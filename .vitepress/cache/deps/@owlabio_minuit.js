import {
  Fragment,
  Text,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  customRef,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  guardReactiveProps,
  h,
  inject,
  isRef,
  markRaw,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeMount,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toRef,
  toValue,
  unref,
  useCssVars,
  useId,
  useSlots,
  vShow,
  warn,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-VJWGEPT5.js";

// node_modules/vue-router/dist/vue-router.mjs
var isBrowser = typeof document !== "undefined";
var assign = Object.assign;
var noop = () => {
};
var isArray = Array.isArray;
function warn2(msg) {
  const args = Array.from(arguments).slice(1);
  console.warn.apply(console, ["[Vue Router warn]: " + msg].concat(args));
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;
}
function isEquivalentArray(a, b) {
  return isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
var NavigationFailureSymbol = Symbol(true ? "navigation failure" : "");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
var matchedRouteKey = Symbol(true ? "router view location matched" : "");
var viewDepthKey = Symbol(true ? "router view depth" : "");
var routerKey = Symbol(true ? "router" : "");
var routeLocationKey = Symbol(true ? "route location" : "");
var routerViewLocationKey = Symbol(true ? "router view location" : "");
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  let hasPrevious = false;
  let previousTo = null;
  const route = computed(() => {
    const to2 = unref(props.to);
    if (!hasPrevious || to2 !== previousTo) {
      if (!isRouteLocation(to2)) {
        if (hasPrevious) {
          warn2(`Invalid value for prop "to" in useLink()
- to:`, to2, `
- previous to:`, previousTo, `
- props:`, props);
        } else {
          warn2(`Invalid value for prop "to" in useLink()
- to:`, to2, `
- props:`, props);
        }
      }
      previousTo = to2;
      hasPrevious = true;
    }
    return router.resolve(to2);
  });
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      const p = router[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop);
      if (props.viewTransition && typeof document !== "undefined" && "startViewTransition" in document) {
        document.startViewTransition(() => p);
      }
      return p;
    }
    return Promise.resolve();
  }
  if (isBrowser) {
    const instance = getCurrentInstance();
    if (instance) {
      const linkContextDevtools = {
        route: route.value,
        isActive: isActive.value,
        isExactActive: isExactActive.value,
        error: null
      };
      instance.__vrl_devtools = instance.__vrl_devtools || [];
      instance.__vrl_devtools.push(linkContextDevtools);
      watchEffect(() => {
        linkContextDevtools.route = route.value;
        linkContextDevtools.isActive = isActive.value;
        linkContextDevtools.isExactActive = isExactActive.value;
        linkContextDevtools.error = isRouteLocation(unref(props.to)) ? null : 'Invalid "to" value';
      }, { flush: "post" });
    }
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
function preferSingleVNode(vnodes) {
  return vnodes.length === 1 ? vnodes[0] : vnodes;
}
var RouterLinkImpl = defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    },
    viewTransition: Boolean
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && preferSingleVNode(slots.default(link));
      return props.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
var getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
var RouterViewImpl = defineComponent({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    warnDeprecatedUsage();
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to2, name], [oldInstance, from, oldName]) => {
      if (to2) {
        to2.instances[name] = instance;
        if (from && from !== to2 && instance && instance === oldInstance) {
          if (!to2.leaveGuards.size) {
            to2.leaveGuards = from.leaveGuards;
          }
          if (!to2.updateGuards.size) {
            to2.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to2 && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from || !isSameRouteRecord(to2, from) || !oldInstance)) {
        (to2.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      if (isBrowser && component.ref) {
        const info = {
          depth: depth.value,
          name: matchedRoute.name,
          path: matchedRoute.path,
          meta: matchedRoute.meta
        };
        const internalInstances = isArray(component.ref) ? component.ref.map((r) => r.i) : [component.ref.i];
        internalInstances.forEach((instance) => {
          instance.__vrv_devtools = info;
        });
      }
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
function warnDeprecatedUsage() {
  const instance = getCurrentInstance();
  const parentName = instance.parent && instance.parent.type.name;
  const parentSubTreeType = instance.parent && instance.parent.subTree && instance.parent.subTree.type;
  if (parentName && (parentName === "KeepAlive" || parentName.includes("Transition")) && typeof parentSubTreeType === "object" && parentSubTreeType.name === "RouterView") {
    const comp = parentName === "KeepAlive" ? "keep-alive" : "transition";
    warn2(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${comp}>
    <component :is="Component" />
  </${comp}>
</router-view>`);
  }
}
function useRouter() {
  return inject(routerKey);
}
function useRoute(_name) {
  return inject(routeLocationKey);
}

// node_modules/@owlabio/minuit/dist/minuit.js
var vS = Object.defineProperty;
var xS = (t10, e, n) => e in t10 ? vS(t10, e, { enumerable: true, configurable: true, writable: true, value: n }) : t10[e] = n;
var ve = (t10, e, n) => xS(t10, typeof e != "symbol" ? e + "" : e, n);
var iv = 0;
var MS = class {
  constructor() {
    ve(this, "subscribe", (e) => (this.subscribers.push(e), () => {
      const n = this.subscribers.indexOf(e);
      this.subscribers.splice(n, 1);
    }));
    ve(this, "publish", (e) => {
      this.subscribers.forEach((n) => n(e));
    });
    ve(this, "addToast", (e) => {
      this.publish(e), this.toasts = [...this.toasts, e];
    });
    ve(this, "create", (e) => {
      var a;
      const { message: n, ...i } = e, s = typeof e.id == "number" || e.id && ((a = e.id) == null ? void 0 : a.length) > 0 ? e.id : iv++, r = this.toasts.find((l) => l.id === s), o = e.dismissible === void 0 ? true : e.dismissible;
      return r ? this.toasts = this.toasts.map((l) => l.id === s ? (this.publish({ ...l, ...e, id: s, title: n }), { ...l, ...e, id: s, title: n, dismissible: o }) : l) : this.addToast({ title: n, dismissible: o, id: s, ...i }), s;
    });
    ve(this, "dismiss", (e) => (e || this.toasts.forEach((n) => {
      this.subscribers.forEach((i) => i({ id: n.id, dismiss: true }));
    }), this.subscribers.forEach((n) => n({ id: e, dismiss: true })), e));
    ve(this, "success", (e, n) => this.create({ ...n, type: "success", message: e }));
    ve(this, "warning", (e, n) => this.create({ ...n, type: "warning", message: e }));
    ve(this, "error", (e, n) => this.create({ ...n, type: "error", message: e }));
    ve(this, "loading", (e, n) => this.create({ ...n, type: "loading", message: e }));
    ve(this, "promise", (e, n) => {
      if (!n) return;
      let i;
      n.loading !== void 0 && (i = this.create({
        ...n,
        promise: e,
        type: "loading",
        message: n.loading,
        description: typeof n.description != "function" ? n.description : void 0
      }));
      const s = e instanceof Promise ? e : e();
      let r = i !== void 0;
      return s.then((o) => {
        if (o && // @ts-expect-error
        typeof o.ok == "boolean" && // @ts-expect-error
        !o.ok) {
          r = false;
          const a = typeof n.error == "function" ? (
            // @ts-expect-error
            n.error(`HTTP error! status: ${response.status}`)
          ) : n.error, l = typeof n.description == "function" ? (
            // @ts-expect-error
            n.description(`HTTP error! status: ${response.status}`)
          ) : n.description;
          this.create({ id: i, type: "error", message: a, description: l });
        } else if (n.success !== void 0) {
          r = false;
          const a = typeof n.success == "function" ? n.success(o) : n.success, l = typeof n.description == "function" ? (
            // @ts-expect-error
            n.description(o)
          ) : n.description;
          this.create({ id: i, type: "success", message: a, description: l });
        }
      }).catch((o) => {
        if (n.error !== void 0) {
          r = false;
          const a = typeof n.error == "function" ? n.error(o) : n.error, l = typeof n.description == "function" ? (
            // @ts-expect-error
            n.description(o)
          ) : n.description;
          this.create({ id: i, type: "error", message: a, description: l });
        }
      }).finally(() => {
        var o;
        r && (this.dismiss(i), i = void 0), (o = n.finally) == null || o.call(n);
      }), i;
    });
    this.subscribers = [], this.toasts = [];
  }
};
var Ns = new MS();
var TS = (t10, e) => {
  const n = (e == null ? void 0 : e.id) || iv++;
  return Ns.create({ ...e, id: n, type: "default", message: t10 }), n;
};
var AS = TS;
var uZ = Object.assign(AS, {
  success: Ns.success,
  warning: Ns.warning,
  error: Ns.error,
  promise: Ns.promise,
  dismiss: Ns.dismiss,
  loading: Ns.loading
});
function _S(t10, e, n) {
  return (e = LS(e)) in t10 ? Object.defineProperty(t10, e, {
    value: n,
    enumerable: true,
    configurable: true,
    writable: true
  }) : t10[e] = n, t10;
}
function fg(t10, e) {
  var n = Object.keys(t10);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t10);
    e && (i = i.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t10, s).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function he(t10) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? fg(Object(n), true).forEach(function(i) {
      _S(t10, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t10, Object.getOwnPropertyDescriptors(n)) : fg(Object(n)).forEach(function(i) {
      Object.defineProperty(t10, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t10;
}
function NS(t10, e) {
  if (typeof t10 != "object" || !t10) return t10;
  var n = t10[Symbol.toPrimitive];
  if (n !== void 0) {
    var i = n.call(t10, e);
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t10);
}
function LS(t10) {
  var e = NS(t10, "string");
  return typeof e == "symbol" ? e : e + "";
}
var hg = () => {
};
var Mp = {};
var sv = {};
var rv = null;
var ov = {
  mark: hg,
  measure: hg
};
try {
  typeof window < "u" && (Mp = window), typeof document < "u" && (sv = document), typeof MutationObserver < "u" && (rv = MutationObserver), typeof performance < "u" && (ov = performance);
} catch {
}
var {
  userAgent: pg = ""
} = Mp.navigator || {};
var Xs = Mp;
var gt = sv;
var mg = rv;
var Vl = ov;
Xs.document;
var ws = !!gt.documentElement && !!gt.head && typeof gt.addEventListener == "function" && typeof gt.createElement == "function";
var av = ~pg.indexOf("MSIE") || ~pg.indexOf("Trident/");
var IS = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/;
var PS = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i;
var lv = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  }
};
var DS = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var cv = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"];
var an = "classic";
var nd = "duotone";
var $S = "sharp";
var RS = "sharp-duotone";
var uv = [an, nd, $S, RS];
var FS = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
};
var VS = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
};
var BS = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}]]);
var zS = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    brands: "fab"
  },
  duotone: {
    solid: "fad",
    regular: "fadr",
    light: "fadl",
    thin: "fadt"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds",
    regular: "fasdr",
    light: "fasdl",
    thin: "fasdt"
  }
};
var jS = ["fak", "fa-kit", "fakd", "fa-kit-duotone"];
var gg = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
};
var HS = ["kit"];
var WS = {
  kit: {
    "fa-kit": "fak"
  }
};
var US = ["fak", "fakd"];
var qS = {
  kit: {
    fak: "fa-kit"
  }
};
var bg = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
};
var Bl = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var KS = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"];
var YS = ["fak", "fa-kit", "fakd", "fa-kit-duotone"];
var GS = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
};
var JS = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  }
};
var XS = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
};
var Zf = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  }
};
var QS = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"];
var eh = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...KS, ...QS];
var ZS = ["solid", "regular", "light", "thin", "duotone", "brands"];
var dv = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var e3 = dv.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
var t3 = [...Object.keys(XS), ...ZS, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", Bl.GROUP, Bl.SWAP_OPACITY, Bl.PRIMARY, Bl.SECONDARY].concat(dv.map((t10) => "".concat(t10, "x"))).concat(e3.map((t10) => "w-".concat(t10)));
var n3 = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
var vs = "___FONT_AWESOME___";
var th = 16;
var fv = "fa";
var hv = "svg-inline--fa";
var Hr = "data-fa-i2svg";
var nh = "data-fa-pseudo-element";
var i3 = "data-fa-pseudo-element-pending";
var Tp = "data-prefix";
var Ap = "data-icon";
var yg = "fontawesome-i2svg";
var s3 = "async";
var r3 = ["HTML", "HEAD", "STYLE", "SCRIPT"];
var pv = (() => {
  try {
    return false;
  } catch {
    return false;
  }
})();
function Tl(t10) {
  return new Proxy(t10, {
    get(e, n) {
      return n in e ? e[n] : e[an];
    }
  });
}
var mv = he({}, lv);
mv[an] = he(he(he(he({}, {
  "fa-duotone": "duotone"
}), lv[an]), gg.kit), gg["kit-duotone"]);
var o3 = Tl(mv);
var ih = he({}, zS);
ih[an] = he(he(he(he({}, {
  duotone: "fad"
}), ih[an]), bg.kit), bg["kit-duotone"]);
var vg = Tl(ih);
var sh = he({}, Zf);
sh[an] = he(he({}, sh[an]), qS.kit);
var _p = Tl(sh);
var rh = he({}, JS);
rh[an] = he(he({}, rh[an]), WS.kit);
Tl(rh);
var a3 = IS;
var gv = "fa-layers-text";
var l3 = PS;
var c3 = he({}, FS);
Tl(c3);
var u3 = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
var Gd = DS;
var d3 = [...HS, ...t3];
var Ta = Xs.FontAwesomeConfig || {};
function f3(t10) {
  var e = gt.querySelector("script[" + t10 + "]");
  if (e)
    return e.getAttribute(t10);
}
function h3(t10) {
  return t10 === "" ? true : t10 === "false" ? false : t10 === "true" ? true : t10;
}
gt && typeof gt.querySelector == "function" && [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach((e) => {
  let [n, i] = e;
  const s = h3(f3(n));
  s != null && (Ta[i] = s);
});
var bv = {
  styleDefault: "solid",
  familyDefault: an,
  cssPrefix: fv,
  replacementClass: hv,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
Ta.familyPrefix && (Ta.cssPrefix = Ta.familyPrefix);
var Ao = he(he({}, bv), Ta);
Ao.autoReplaceSvg || (Ao.observeMutations = false);
var Ne = {};
Object.keys(bv).forEach((t10) => {
  Object.defineProperty(Ne, t10, {
    enumerable: true,
    set: function(e) {
      Ao[t10] = e, Aa.forEach((n) => n(Ne));
    },
    get: function() {
      return Ao[t10];
    }
  });
});
Object.defineProperty(Ne, "familyPrefix", {
  enumerable: true,
  set: function(t10) {
    Ao.cssPrefix = t10, Aa.forEach((e) => e(Ne));
  },
  get: function() {
    return Ao.cssPrefix;
  }
});
Xs.FontAwesomeConfig = Ne;
var Aa = [];
function p3(t10) {
  return Aa.push(t10), () => {
    Aa.splice(Aa.indexOf(t10), 1);
  };
}
var Es = th;
var Li = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function m3(t10) {
  if (!t10 || !ws)
    return;
  const e = gt.createElement("style");
  e.setAttribute("type", "text/css"), e.innerHTML = t10;
  const n = gt.head.childNodes;
  let i = null;
  for (let s = n.length - 1; s > -1; s--) {
    const r = n[s], o = (r.tagName || "").toUpperCase();
    ["STYLE", "LINK"].indexOf(o) > -1 && (i = r);
  }
  return gt.head.insertBefore(e, i), t10;
}
var g3 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function Qa() {
  let t10 = 12, e = "";
  for (; t10-- > 0; )
    e += g3[Math.random() * 62 | 0];
  return e;
}
function Jo(t10) {
  const e = [];
  for (let n = (t10 || []).length >>> 0; n--; )
    e[n] = t10[n];
  return e;
}
function Np(t10) {
  return t10.classList ? Jo(t10.classList) : (t10.getAttribute("class") || "").split(" ").filter((e) => e);
}
function yv(t10) {
  return "".concat(t10).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function b3(t10) {
  return Object.keys(t10 || {}).reduce((e, n) => e + "".concat(n, '="').concat(yv(t10[n]), '" '), "").trim();
}
function id(t10) {
  return Object.keys(t10 || {}).reduce((e, n) => e + "".concat(n, ": ").concat(t10[n].trim(), ";"), "");
}
function Lp(t10) {
  return t10.size !== Li.size || t10.x !== Li.x || t10.y !== Li.y || t10.rotate !== Li.rotate || t10.flipX || t10.flipY;
}
function y3(t10) {
  let {
    transform: e,
    containerWidth: n,
    iconWidth: i
  } = t10;
  const s = {
    transform: "translate(".concat(n / 2, " 256)")
  }, r = "translate(".concat(e.x * 32, ", ").concat(e.y * 32, ") "), o = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") "), a = "rotate(".concat(e.rotate, " 0 0)"), l = {
    transform: "".concat(r, " ").concat(o, " ").concat(a)
  }, c = {
    transform: "translate(".concat(i / 2 * -1, " -256)")
  };
  return {
    outer: s,
    inner: l,
    path: c
  };
}
function v3(t10) {
  let {
    transform: e,
    width: n = th,
    height: i = th,
    startCentered: s = false
  } = t10, r = "";
  return s && av ? r += "translate(".concat(e.x / Es - n / 2, "em, ").concat(e.y / Es - i / 2, "em) ") : s ? r += "translate(calc(-50% + ".concat(e.x / Es, "em), calc(-50% + ").concat(e.y / Es, "em)) ") : r += "translate(".concat(e.x / Es, "em, ").concat(e.y / Es, "em) "), r += "scale(".concat(e.size / Es * (e.flipX ? -1 : 1), ", ").concat(e.size / Es * (e.flipY ? -1 : 1), ") "), r += "rotate(".concat(e.rotate, "deg) "), r;
}
var x3 = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}`;
function vv() {
  const t10 = fv, e = hv, n = Ne.cssPrefix, i = Ne.replacementClass;
  let s = x3;
  if (n !== t10 || i !== e) {
    const r = new RegExp("\\.".concat(t10, "\\-"), "g"), o = new RegExp("\\--".concat(t10, "\\-"), "g"), a = new RegExp("\\.".concat(e), "g");
    s = s.replace(r, ".".concat(n, "-")).replace(o, "--".concat(n, "-")).replace(a, ".".concat(i));
  }
  return s;
}
var xg = false;
function Jd() {
  Ne.autoAddCss && !xg && (m3(vv()), xg = true);
}
var k3 = {
  mixout() {
    return {
      dom: {
        css: vv,
        insertCss: Jd
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        Jd();
      },
      beforeI2svg() {
        Jd();
      }
    };
  }
};
var xs = Xs || {};
xs[vs] || (xs[vs] = {});
xs[vs].styles || (xs[vs].styles = {});
xs[vs].hooks || (xs[vs].hooks = {});
xs[vs].shims || (xs[vs].shims = []);
var Ii = xs[vs];
var xv = [];
var kv = function() {
  gt.removeEventListener("DOMContentLoaded", kv), Vc = 1, xv.map((t10) => t10());
};
var Vc = false;
ws && (Vc = (gt.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(gt.readyState), Vc || gt.addEventListener("DOMContentLoaded", kv));
function S3(t10) {
  ws && (Vc ? setTimeout(t10, 0) : xv.push(t10));
}
function Al(t10) {
  const {
    tag: e,
    attributes: n = {},
    children: i = []
  } = t10;
  return typeof t10 == "string" ? yv(t10) : "<".concat(e, " ").concat(b3(n), ">").concat(i.map(Al).join(""), "</").concat(e, ">");
}
function kg(t10, e, n) {
  if (t10 && t10[e] && t10[e][n])
    return {
      prefix: e,
      iconName: n,
      icon: t10[e][n]
    };
}
var Xd = function(e, n, i, s) {
  var r = Object.keys(e), o = r.length, a = n, l, c, u;
  for (i === void 0 ? (l = 1, u = e[r[0]]) : (l = 0, u = i); l < o; l++)
    c = r[l], u = a(u, e[c], c, e);
  return u;
};
function w3(t10) {
  const e = [];
  let n = 0;
  const i = t10.length;
  for (; n < i; ) {
    const s = t10.charCodeAt(n++);
    if (s >= 55296 && s <= 56319 && n < i) {
      const r = t10.charCodeAt(n++);
      (r & 64512) == 56320 ? e.push(((s & 1023) << 10) + (r & 1023) + 65536) : (e.push(s), n--);
    } else
      e.push(s);
  }
  return e;
}
function oh(t10) {
  const e = w3(t10);
  return e.length === 1 ? e[0].toString(16) : null;
}
function C3(t10, e) {
  const n = t10.length;
  let i = t10.charCodeAt(e), s;
  return i >= 55296 && i <= 56319 && n > e + 1 && (s = t10.charCodeAt(e + 1), s >= 56320 && s <= 57343) ? (i - 55296) * 1024 + s - 56320 + 65536 : i;
}
function Sg(t10) {
  return Object.keys(t10).reduce((e, n) => {
    const i = t10[n];
    return !!i.icon ? e[i.iconName] = i.icon : e[n] = i, e;
  }, {});
}
function ah(t10, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks: i = false
  } = n, s = Sg(e);
  typeof Ii.hooks.addPack == "function" && !i ? Ii.hooks.addPack(t10, Sg(e)) : Ii.styles[t10] = he(he({}, Ii.styles[t10] || {}), s), t10 === "fas" && ah("fa", e);
}
var {
  styles: Za,
  shims: O3
} = Ii;
var Sv = Object.keys(_p);
var E3 = Sv.reduce((t10, e) => (t10[e] = Object.keys(_p[e]), t10), {});
var Ip = null;
var wv = {};
var Cv = {};
var Ov = {};
var Ev = {};
var Mv = {};
function M3(t10) {
  return ~d3.indexOf(t10);
}
function T3(t10, e) {
  const n = e.split("-"), i = n[0], s = n.slice(1).join("-");
  return i === t10 && s !== "" && !M3(s) ? s : null;
}
var Tv = () => {
  const t10 = (i) => Xd(Za, (s, r, o) => (s[o] = Xd(r, i, {}), s), {});
  wv = t10((i, s, r) => (s[3] && (i[s[3]] = r), s[2] && s[2].filter((a) => typeof a == "number").forEach((a) => {
    i[a.toString(16)] = r;
  }), i)), Cv = t10((i, s, r) => (i[r] = r, s[2] && s[2].filter((a) => typeof a == "string").forEach((a) => {
    i[a] = r;
  }), i)), Mv = t10((i, s, r) => {
    const o = s[2];
    return i[r] = r, o.forEach((a) => {
      i[a] = r;
    }), i;
  });
  const e = "far" in Za || Ne.autoFetchSvg, n = Xd(O3, (i, s) => {
    const r = s[0];
    let o = s[1];
    const a = s[2];
    return o === "far" && !e && (o = "fas"), typeof r == "string" && (i.names[r] = {
      prefix: o,
      iconName: a
    }), typeof r == "number" && (i.unicodes[r.toString(16)] = {
      prefix: o,
      iconName: a
    }), i;
  }, {
    names: {},
    unicodes: {}
  });
  Ov = n.names, Ev = n.unicodes, Ip = sd(Ne.styleDefault, {
    family: Ne.familyDefault
  });
};
p3((t10) => {
  Ip = sd(t10.styleDefault, {
    family: Ne.familyDefault
  });
});
Tv();
function Pp(t10, e) {
  return (wv[t10] || {})[e];
}
function A3(t10, e) {
  return (Cv[t10] || {})[e];
}
function Er(t10, e) {
  return (Mv[t10] || {})[e];
}
function Av(t10) {
  return Ov[t10] || {
    prefix: null,
    iconName: null
  };
}
function _3(t10) {
  const e = Ev[t10], n = Pp("fas", t10);
  return e || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function Qs() {
  return Ip;
}
var _v = () => ({
  prefix: null,
  iconName: null,
  rest: []
});
function N3(t10) {
  let e = an;
  const n = Sv.reduce((i, s) => (i[s] = "".concat(Ne.cssPrefix, "-").concat(s), i), {});
  return uv.forEach((i) => {
    (t10.includes(n[i]) || t10.some((s) => E3[i].includes(s))) && (e = i);
  }), e;
}
function sd(t10) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family: n = an
  } = e, i = o3[n][t10];
  if (n === nd && !t10)
    return "fad";
  const s = vg[n][t10] || vg[n][i], r = t10 in Ii.styles ? t10 : null;
  return s || r || null;
}
function L3(t10) {
  let e = [], n = null;
  return t10.forEach((i) => {
    const s = T3(Ne.cssPrefix, i);
    s ? n = s : i && e.push(i);
  }), {
    iconName: n,
    rest: e
  };
}
function wg(t10) {
  return t10.sort().filter((e, n, i) => i.indexOf(e) === n);
}
function rd(t10) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups: n = false
  } = e;
  let i = null;
  const s = eh.concat(YS), r = wg(t10.filter((d) => s.includes(d))), o = wg(t10.filter((d) => !eh.includes(d))), a = r.filter((d) => (i = d, !cv.includes(d))), [l = null] = a, c = N3(r), u = he(he({}, L3(o)), {}, {
    prefix: sd(l, {
      family: c
    })
  });
  return he(he(he({}, u), $3({
    values: t10,
    family: c,
    styles: Za,
    config: Ne,
    canonical: u,
    givenPrefix: i
  })), I3(n, i, u));
}
function I3(t10, e, n) {
  let {
    prefix: i,
    iconName: s
  } = n;
  if (t10 || !i || !s)
    return {
      prefix: i,
      iconName: s
    };
  const r = e === "fa" ? Av(s) : {}, o = Er(i, s);
  return s = r.iconName || o || s, i = r.prefix || i, i === "far" && !Za.far && Za.fas && !Ne.autoFetchSvg && (i = "fas"), {
    prefix: i,
    iconName: s
  };
}
var P3 = uv.filter((t10) => t10 !== an || t10 !== nd);
var D3 = Object.keys(Zf).filter((t10) => t10 !== an).map((t10) => Object.keys(Zf[t10])).flat();
function $3(t10) {
  const {
    values: e,
    family: n,
    canonical: i,
    givenPrefix: s = "",
    styles: r = {},
    config: o = {}
  } = t10, a = n === nd, l = e.includes("fa-duotone") || e.includes("fad"), c = o.familyDefault === "duotone", u = i.prefix === "fad" || i.prefix === "fa-duotone";
  if (!a && (l || c || u) && (i.prefix = "fad"), (e.includes("fa-brands") || e.includes("fab")) && (i.prefix = "fab"), !i.prefix && P3.includes(n) && (Object.keys(r).find((f) => D3.includes(f)) || o.autoFetchSvg)) {
    const f = BS.get(n).defaultShortPrefixId;
    i.prefix = f, i.iconName = Er(i.prefix, i.iconName) || i.iconName;
  }
  return (i.prefix === "fa" || s === "fa") && (i.prefix = Qs() || "fas"), i;
}
var R3 = class {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++)
      n[i] = arguments[i];
    const s = n.reduce(this._pullDefinitions, {});
    Object.keys(s).forEach((r) => {
      this.definitions[r] = he(he({}, this.definitions[r] || {}), s[r]), ah(r, s[r]);
      const o = _p[an][r];
      o && ah(o, s[r]), Tv();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(e, n) {
    const i = n.prefix && n.iconName && n.icon ? {
      0: n
    } : n;
    return Object.keys(i).map((s) => {
      const {
        prefix: r,
        iconName: o,
        icon: a
      } = i[s], l = a[2];
      e[r] || (e[r] = {}), l.length > 0 && l.forEach((c) => {
        typeof c == "string" && (e[r][c] = a);
      }), e[r][o] = a;
    }), e;
  }
};
var Cg = [];
var yo = {};
var wo = {};
var F3 = Object.keys(wo);
function V3(t10, e) {
  let {
    mixoutsTo: n
  } = e;
  return Cg = t10, yo = {}, Object.keys(wo).forEach((i) => {
    F3.indexOf(i) === -1 && delete wo[i];
  }), Cg.forEach((i) => {
    const s = i.mixout ? i.mixout() : {};
    if (Object.keys(s).forEach((r) => {
      typeof s[r] == "function" && (n[r] = s[r]), typeof s[r] == "object" && Object.keys(s[r]).forEach((o) => {
        n[r] || (n[r] = {}), n[r][o] = s[r][o];
      });
    }), i.hooks) {
      const r = i.hooks();
      Object.keys(r).forEach((o) => {
        yo[o] || (yo[o] = []), yo[o].push(r[o]);
      });
    }
    i.provides && i.provides(wo);
  }), n;
}
function lh(t10, e) {
  for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++)
    i[s - 2] = arguments[s];
  return (yo[t10] || []).forEach((o) => {
    e = o.apply(null, [e, ...i]);
  }), e;
}
function Wr(t10) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
    n[i - 1] = arguments[i];
  (yo[t10] || []).forEach((r) => {
    r.apply(null, n);
  });
}
function Zs() {
  const t10 = arguments[0], e = Array.prototype.slice.call(arguments, 1);
  return wo[t10] ? wo[t10].apply(null, e) : void 0;
}
function ch(t10) {
  t10.prefix === "fa" && (t10.prefix = "fas");
  let {
    iconName: e
  } = t10;
  const n = t10.prefix || Qs();
  if (e)
    return e = Er(n, e) || e, kg(Nv.definitions, n, e) || kg(Ii.styles, n, e);
}
var Nv = new R3();
var B3 = () => {
  Ne.autoReplaceSvg = false, Ne.observeMutations = false, Wr("noAuto");
};
var z3 = {
  i2svg: function() {
    let t10 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ws ? (Wr("beforeI2svg", t10), Zs("pseudoElements2svg", t10), Zs("i2svg", t10)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    let t10 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot: e
    } = t10;
    Ne.autoReplaceSvg === false && (Ne.autoReplaceSvg = true), Ne.observeMutations = true, S3(() => {
      H3({
        autoReplaceSvgRoot: e
      }), Wr("watch", t10);
    });
  }
};
var j3 = {
  icon: (t10) => {
    if (t10 === null)
      return null;
    if (typeof t10 == "object" && t10.prefix && t10.iconName)
      return {
        prefix: t10.prefix,
        iconName: Er(t10.prefix, t10.iconName) || t10.iconName
      };
    if (Array.isArray(t10) && t10.length === 2) {
      const e = t10[1].indexOf("fa-") === 0 ? t10[1].slice(3) : t10[1], n = sd(t10[0]);
      return {
        prefix: n,
        iconName: Er(n, e) || e
      };
    }
    if (typeof t10 == "string" && (t10.indexOf("".concat(Ne.cssPrefix, "-")) > -1 || t10.match(a3))) {
      const e = rd(t10.split(" "), {
        skipLookups: true
      });
      return {
        prefix: e.prefix || Qs(),
        iconName: Er(e.prefix, e.iconName) || e.iconName
      };
    }
    if (typeof t10 == "string") {
      const e = Qs();
      return {
        prefix: e,
        iconName: Er(e, t10) || t10
      };
    }
  }
};
var Zn = {
  noAuto: B3,
  config: Ne,
  dom: z3,
  parse: j3,
  library: Nv,
  findIconDefinition: ch,
  toHtml: Al
};
var H3 = function() {
  let t10 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot: e = gt
  } = t10;
  (Object.keys(Ii.styles).length > 0 || Ne.autoFetchSvg) && ws && Ne.autoReplaceSvg && Zn.dom.i2svg({
    node: e
  });
};
function od(t10, e) {
  return Object.defineProperty(t10, "abstract", {
    get: e
  }), Object.defineProperty(t10, "html", {
    get: function() {
      return t10.abstract.map((n) => Al(n));
    }
  }), Object.defineProperty(t10, "node", {
    get: function() {
      if (!ws) return;
      const n = gt.createElement("div");
      return n.innerHTML = t10.html, n.children;
    }
  }), t10;
}
function W3(t10) {
  let {
    children: e,
    main: n,
    mask: i,
    attributes: s,
    styles: r,
    transform: o
  } = t10;
  if (Lp(o) && n.found && !i.found) {
    const {
      width: a,
      height: l
    } = n, c = {
      x: a / l / 2,
      y: 0.5
    };
    s.style = id(he(he({}, r), {}, {
      "transform-origin": "".concat(c.x + o.x / 16, "em ").concat(c.y + o.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: s,
    children: e
  }];
}
function U3(t10) {
  let {
    prefix: e,
    iconName: n,
    children: i,
    attributes: s,
    symbol: r
  } = t10;
  const o = r === true ? "".concat(e, "-").concat(Ne.cssPrefix, "-").concat(n) : r;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: he(he({}, s), {}, {
        id: o
      }),
      children: i
    }]
  }];
}
function Dp(t10) {
  const {
    icons: {
      main: e,
      mask: n
    },
    prefix: i,
    iconName: s,
    transform: r,
    symbol: o,
    title: a,
    maskId: l,
    titleId: c,
    extra: u,
    watchable: d = false
  } = t10, {
    width: f,
    height: h10
  } = n.found ? n : e, p = US.includes(i), g = [Ne.replacementClass, s ? "".concat(Ne.cssPrefix, "-").concat(s) : ""].filter((S) => u.classes.indexOf(S) === -1).filter((S) => S !== "" || !!S).concat(u.classes).join(" ");
  let m = {
    children: [],
    attributes: he(he({}, u.attributes), {}, {
      "data-prefix": i,
      "data-icon": s,
      class: g,
      role: u.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(f, " ").concat(h10)
    })
  };
  const b = p && !~u.classes.indexOf("fa-fw") ? {
    width: "".concat(f / h10 * 16 * 0.0625, "em")
  } : {};
  d && (m.attributes[Hr] = ""), a && (m.children.push({
    tag: "title",
    attributes: {
      id: m.attributes["aria-labelledby"] || "title-".concat(c || Qa())
    },
    children: [a]
  }), delete m.attributes.title);
  const x = he(he({}, m), {}, {
    prefix: i,
    iconName: s,
    main: e,
    mask: n,
    maskId: l,
    transform: r,
    symbol: o,
    styles: he(he({}, b), u.styles)
  }), {
    children: k,
    attributes: v
  } = n.found && e.found ? Zs("generateAbstractMask", x) || {
    children: [],
    attributes: {}
  } : Zs("generateAbstractIcon", x) || {
    children: [],
    attributes: {}
  };
  return x.children = k, x.attributes = v, o ? U3(x) : W3(x);
}
function Og(t10) {
  const {
    content: e,
    width: n,
    height: i,
    transform: s,
    title: r,
    extra: o,
    watchable: a = false
  } = t10, l = he(he(he({}, o.attributes), r ? {
    title: r
  } : {}), {}, {
    class: o.classes.join(" ")
  });
  a && (l[Hr] = "");
  const c = he({}, o.styles);
  Lp(s) && (c.transform = v3({
    transform: s,
    startCentered: true,
    width: n,
    height: i
  }), c["-webkit-transform"] = c.transform);
  const u = id(c);
  u.length > 0 && (l.style = u);
  const d = [];
  return d.push({
    tag: "span",
    attributes: l,
    children: [e]
  }), r && d.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [r]
  }), d;
}
function q3(t10) {
  const {
    content: e,
    title: n,
    extra: i
  } = t10, s = he(he(he({}, i.attributes), n ? {
    title: n
  } : {}), {}, {
    class: i.classes.join(" ")
  }), r = id(i.styles);
  r.length > 0 && (s.style = r);
  const o = [];
  return o.push({
    tag: "span",
    attributes: s,
    children: [e]
  }), n && o.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [n]
  }), o;
}
var {
  styles: Qd
} = Ii;
function uh(t10) {
  const e = t10[0], n = t10[1], [i] = t10.slice(4);
  let s = null;
  return Array.isArray(i) ? s = {
    tag: "g",
    attributes: {
      class: "".concat(Ne.cssPrefix, "-").concat(Gd.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(Ne.cssPrefix, "-").concat(Gd.SECONDARY),
        fill: "currentColor",
        d: i[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(Ne.cssPrefix, "-").concat(Gd.PRIMARY),
        fill: "currentColor",
        d: i[1]
      }
    }]
  } : s = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: i
    }
  }, {
    found: true,
    width: e,
    height: n,
    icon: s
  };
}
var K3 = {
  found: false,
  width: 512,
  height: 512
};
function Y3(t10, e) {
  !pv && !Ne.showMissingIcons && t10 && console.error('Icon with name "'.concat(t10, '" and prefix "').concat(e, '" is missing.'));
}
function dh(t10, e) {
  let n = e;
  return e === "fa" && Ne.styleDefault !== null && (e = Qs()), new Promise((i, s) => {
    if (n === "fa") {
      const r = Av(t10) || {};
      t10 = r.iconName || t10, e = r.prefix || e;
    }
    if (t10 && e && Qd[e] && Qd[e][t10]) {
      const r = Qd[e][t10];
      return i(uh(r));
    }
    Y3(t10, e), i(he(he({}, K3), {}, {
      icon: Ne.showMissingIcons && t10 ? Zs("missingIconAbstract") || {} : {}
    }));
  });
}
var Eg = () => {
};
var fh = Ne.measurePerformance && Vl && Vl.mark && Vl.measure ? Vl : {
  mark: Eg,
  measure: Eg
};
var ma = 'FA "6.7.2"';
var G3 = (t10) => (fh.mark("".concat(ma, " ").concat(t10, " begins")), () => Lv(t10));
var Lv = (t10) => {
  fh.mark("".concat(ma, " ").concat(t10, " ends")), fh.measure("".concat(ma, " ").concat(t10), "".concat(ma, " ").concat(t10, " begins"), "".concat(ma, " ").concat(t10, " ends"));
};
var $p = {
  begin: G3,
  end: Lv
};
var xc = () => {
};
function Mg(t10) {
  return typeof (t10.getAttribute ? t10.getAttribute(Hr) : null) == "string";
}
function J3(t10) {
  const e = t10.getAttribute ? t10.getAttribute(Tp) : null, n = t10.getAttribute ? t10.getAttribute(Ap) : null;
  return e && n;
}
function X3(t10) {
  return t10 && t10.classList && t10.classList.contains && t10.classList.contains(Ne.replacementClass);
}
function Q3() {
  return Ne.autoReplaceSvg === true ? kc.replace : kc[Ne.autoReplaceSvg] || kc.replace;
}
function Z3(t10) {
  return gt.createElementNS("http://www.w3.org/2000/svg", t10);
}
function ew(t10) {
  return gt.createElement(t10);
}
function Iv(t10) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn: n = t10.tag === "svg" ? Z3 : ew
  } = e;
  if (typeof t10 == "string")
    return gt.createTextNode(t10);
  const i = n(t10.tag);
  return Object.keys(t10.attributes || []).forEach(function(r) {
    i.setAttribute(r, t10.attributes[r]);
  }), (t10.children || []).forEach(function(r) {
    i.appendChild(Iv(r, {
      ceFn: n
    }));
  }), i;
}
function tw(t10) {
  let e = " ".concat(t10.outerHTML, " ");
  return e = "".concat(e, "Font Awesome fontawesome.com "), e;
}
var kc = {
  replace: function(t10) {
    const e = t10[0];
    if (e.parentNode)
      if (t10[1].forEach((n) => {
        e.parentNode.insertBefore(Iv(n), e);
      }), e.getAttribute(Hr) === null && Ne.keepOriginalSource) {
        let n = gt.createComment(tw(e));
        e.parentNode.replaceChild(n, e);
      } else
        e.remove();
  },
  nest: function(t10) {
    const e = t10[0], n = t10[1];
    if (~Np(e).indexOf(Ne.replacementClass))
      return kc.replace(t10);
    const i = new RegExp("".concat(Ne.cssPrefix, "-.*"));
    if (delete n[0].attributes.id, n[0].attributes.class) {
      const r = n[0].attributes.class.split(" ").reduce((o, a) => (a === Ne.replacementClass || a.match(i) ? o.toSvg.push(a) : o.toNode.push(a), o), {
        toNode: [],
        toSvg: []
      });
      n[0].attributes.class = r.toSvg.join(" "), r.toNode.length === 0 ? e.removeAttribute("class") : e.setAttribute("class", r.toNode.join(" "));
    }
    const s = n.map((r) => Al(r)).join(`
`);
    e.setAttribute(Hr, ""), e.innerHTML = s;
  }
};
function Tg(t10) {
  t10();
}
function Pv(t10, e) {
  const n = typeof e == "function" ? e : xc;
  if (t10.length === 0)
    n();
  else {
    let i = Tg;
    Ne.mutateApproach === s3 && (i = Xs.requestAnimationFrame || Tg), i(() => {
      const s = Q3(), r = $p.begin("mutate");
      t10.map(s), r(), n();
    });
  }
}
var Rp = false;
function Dv() {
  Rp = true;
}
function hh() {
  Rp = false;
}
var Bc = null;
function Ag(t10) {
  if (!mg || !Ne.observeMutations)
    return;
  const {
    treeCallback: e = xc,
    nodeCallback: n = xc,
    pseudoElementsCallback: i = xc,
    observeMutationsRoot: s = gt
  } = t10;
  Bc = new mg((r) => {
    if (Rp) return;
    const o = Qs();
    Jo(r).forEach((a) => {
      if (a.type === "childList" && a.addedNodes.length > 0 && !Mg(a.addedNodes[0]) && (Ne.searchPseudoElements && i(a.target), e(a.target)), a.type === "attributes" && a.target.parentNode && Ne.searchPseudoElements && i(a.target.parentNode), a.type === "attributes" && Mg(a.target) && ~u3.indexOf(a.attributeName))
        if (a.attributeName === "class" && J3(a.target)) {
          const {
            prefix: l,
            iconName: c
          } = rd(Np(a.target));
          a.target.setAttribute(Tp, l || o), c && a.target.setAttribute(Ap, c);
        } else X3(a.target) && n(a.target);
    });
  }), ws && Bc.observe(s, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function nw() {
  Bc && Bc.disconnect();
}
function iw(t10) {
  const e = t10.getAttribute("style");
  let n = [];
  return e && (n = e.split(";").reduce((i, s) => {
    const r = s.split(":"), o = r[0], a = r.slice(1);
    return o && a.length > 0 && (i[o] = a.join(":").trim()), i;
  }, {})), n;
}
function sw(t10) {
  const e = t10.getAttribute("data-prefix"), n = t10.getAttribute("data-icon"), i = t10.innerText !== void 0 ? t10.innerText.trim() : "";
  let s = rd(Np(t10));
  return s.prefix || (s.prefix = Qs()), e && n && (s.prefix = e, s.iconName = n), s.iconName && s.prefix || (s.prefix && i.length > 0 && (s.iconName = A3(s.prefix, t10.innerText) || Pp(s.prefix, oh(t10.innerText))), !s.iconName && Ne.autoFetchSvg && t10.firstChild && t10.firstChild.nodeType === Node.TEXT_NODE && (s.iconName = t10.firstChild.data)), s;
}
function rw(t10) {
  const e = Jo(t10.attributes).reduce((s, r) => (s.name !== "class" && s.name !== "style" && (s[r.name] = r.value), s), {}), n = t10.getAttribute("title"), i = t10.getAttribute("data-fa-title-id");
  return Ne.autoA11y && (n ? e["aria-labelledby"] = "".concat(Ne.replacementClass, "-title-").concat(i || Qa()) : (e["aria-hidden"] = "true", e.focusable = "false")), e;
}
function ow() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: Li,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function _g(t10) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: true
  };
  const {
    iconName: n,
    prefix: i,
    rest: s
  } = sw(t10), r = rw(t10), o = lh("parseNodeAttributes", {}, t10);
  let a = e.styleParser ? iw(t10) : [];
  return he({
    iconName: n,
    title: t10.getAttribute("title"),
    titleId: t10.getAttribute("data-fa-title-id"),
    prefix: i,
    transform: Li,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: s,
      styles: a,
      attributes: r
    }
  }, o);
}
var {
  styles: aw
} = Ii;
function $v(t10) {
  const e = Ne.autoReplaceSvg === "nest" ? _g(t10, {
    styleParser: false
  }) : _g(t10);
  return ~e.extra.classes.indexOf(gv) ? Zs("generateLayersText", t10, e) : Zs("generateSvgReplacementMutation", t10, e);
}
function lw() {
  return [...jS, ...eh];
}
function Ng(t10) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!ws) return Promise.resolve();
  const n = gt.documentElement.classList, i = (u) => n.add("".concat(yg, "-").concat(u)), s = (u) => n.remove("".concat(yg, "-").concat(u)), r = Ne.autoFetchSvg ? lw() : cv.concat(Object.keys(aw));
  r.includes("fa") || r.push("fa");
  const o = [".".concat(gv, ":not([").concat(Hr, "])")].concat(r.map((u) => ".".concat(u, ":not([").concat(Hr, "])"))).join(", ");
  if (o.length === 0)
    return Promise.resolve();
  let a = [];
  try {
    a = Jo(t10.querySelectorAll(o));
  } catch {
  }
  if (a.length > 0)
    i("pending"), s("complete");
  else
    return Promise.resolve();
  const l = $p.begin("onTree"), c = a.reduce((u, d) => {
    try {
      const f = $v(d);
      f && u.push(f);
    } catch (f) {
      pv || f.name === "MissingIcon" && console.error(f);
    }
    return u;
  }, []);
  return new Promise((u, d) => {
    Promise.all(c).then((f) => {
      Pv(f, () => {
        i("active"), i("complete"), s("pending"), typeof e == "function" && e(), l(), u();
      });
    }).catch((f) => {
      l(), d(f);
    });
  });
}
function cw(t10) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  $v(t10).then((n) => {
    n && Pv([n], e);
  });
}
function uw(t10) {
  return function(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = (e || {}).icon ? e : ch(e || {});
    let {
      mask: s
    } = n;
    return s && (s = (s || {}).icon ? s : ch(s || {})), t10(i, he(he({}, n), {}, {
      mask: s
    }));
  };
}
var dw = function(t10) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: n = Li,
    symbol: i = false,
    mask: s = null,
    maskId: r = null,
    title: o = null,
    titleId: a = null,
    classes: l = [],
    attributes: c = {},
    styles: u = {}
  } = e;
  if (!t10) return;
  const {
    prefix: d,
    iconName: f,
    icon: h10
  } = t10;
  return od(he({
    type: "icon"
  }, t10), () => (Wr("beforeDOMElementCreation", {
    iconDefinition: t10,
    params: e
  }), Ne.autoA11y && (o ? c["aria-labelledby"] = "".concat(Ne.replacementClass, "-title-").concat(a || Qa()) : (c["aria-hidden"] = "true", c.focusable = "false")), Dp({
    icons: {
      main: uh(h10),
      mask: s ? uh(s.icon) : {
        found: false,
        width: null,
        height: null,
        icon: {}
      }
    },
    prefix: d,
    iconName: f,
    transform: he(he({}, Li), n),
    symbol: i,
    title: o,
    maskId: r,
    titleId: a,
    extra: {
      attributes: c,
      styles: u,
      classes: l
    }
  })));
};
var fw = {
  mixout() {
    return {
      icon: uw(dw)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(t10) {
        return t10.treeCallback = Ng, t10.nodeCallback = cw, t10;
      }
    };
  },
  provides(t10) {
    t10.i2svg = function(e) {
      const {
        node: n = gt,
        callback: i = () => {
        }
      } = e;
      return Ng(n, i);
    }, t10.generateSvgReplacementMutation = function(e, n) {
      const {
        iconName: i,
        title: s,
        titleId: r,
        prefix: o,
        transform: a,
        symbol: l,
        mask: c,
        maskId: u,
        extra: d
      } = n;
      return new Promise((f, h10) => {
        Promise.all([dh(i, o), c.iconName ? dh(c.iconName, c.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then((p) => {
          let [g, m] = p;
          f([e, Dp({
            icons: {
              main: g,
              mask: m
            },
            prefix: o,
            iconName: i,
            transform: a,
            symbol: l,
            maskId: u,
            title: s,
            titleId: r,
            extra: d,
            watchable: true
          })]);
        }).catch(h10);
      });
    }, t10.generateAbstractIcon = function(e) {
      let {
        children: n,
        attributes: i,
        main: s,
        transform: r,
        styles: o
      } = e;
      const a = id(o);
      a.length > 0 && (i.style = a);
      let l;
      return Lp(r) && (l = Zs("generateAbstractTransformGrouping", {
        main: s,
        transform: r,
        containerWidth: s.width,
        iconWidth: s.width
      })), n.push(l || s.icon), {
        children: n,
        attributes: i
      };
    };
  }
};
var hw = {
  mixout() {
    return {
      layer(t10) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes: n = []
        } = e;
        return od({
          type: "layer"
        }, () => {
          Wr("beforeDOMElementCreation", {
            assembler: t10,
            params: e
          });
          let i = [];
          return t10((s) => {
            Array.isArray(s) ? s.map((r) => {
              i = i.concat(r.abstract);
            }) : i = i.concat(s.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(Ne.cssPrefix, "-layers"), ...n].join(" ")
            },
            children: i
          }];
        });
      }
    };
  }
};
var pw = {
  mixout() {
    return {
      counter(t10) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title: n = null,
          classes: i = [],
          attributes: s = {},
          styles: r = {}
        } = e;
        return od({
          type: "counter",
          content: t10
        }, () => (Wr("beforeDOMElementCreation", {
          content: t10,
          params: e
        }), q3({
          content: t10.toString(),
          title: n,
          extra: {
            attributes: s,
            styles: r,
            classes: ["".concat(Ne.cssPrefix, "-layers-counter"), ...i]
          }
        })));
      }
    };
  }
};
var mw = {
  mixout() {
    return {
      text(t10) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform: n = Li,
          title: i = null,
          classes: s = [],
          attributes: r = {},
          styles: o = {}
        } = e;
        return od({
          type: "text",
          content: t10
        }, () => (Wr("beforeDOMElementCreation", {
          content: t10,
          params: e
        }), Og({
          content: t10,
          transform: he(he({}, Li), n),
          title: i,
          extra: {
            attributes: r,
            styles: o,
            classes: ["".concat(Ne.cssPrefix, "-layers-text"), ...s]
          }
        })));
      }
    };
  },
  provides(t10) {
    t10.generateLayersText = function(e, n) {
      const {
        title: i,
        transform: s,
        extra: r
      } = n;
      let o = null, a = null;
      if (av) {
        const l = parseInt(getComputedStyle(e).fontSize, 10), c = e.getBoundingClientRect();
        o = c.width / l, a = c.height / l;
      }
      return Ne.autoA11y && !i && (r.attributes["aria-hidden"] = "true"), Promise.resolve([e, Og({
        content: e.innerHTML,
        width: o,
        height: a,
        transform: s,
        title: i,
        extra: r,
        watchable: true
      })]);
    };
  }
};
var gw = new RegExp('"', "ug");
var Lg = [1105920, 1112319];
var Ig = he(he(he(he({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), VS), n3), GS);
var ph = Object.keys(Ig).reduce((t10, e) => (t10[e.toLowerCase()] = Ig[e], t10), {});
var bw = Object.keys(ph).reduce((t10, e) => {
  const n = ph[e];
  return t10[e] = n[900] || [...Object.entries(n)][0][1], t10;
}, {});
function yw(t10) {
  const e = t10.replace(gw, ""), n = C3(e, 0), i = n >= Lg[0] && n <= Lg[1], s = e.length === 2 ? e[0] === e[1] : false;
  return {
    value: oh(s ? e[0] : e),
    isSecondary: i || s
  };
}
function vw(t10, e) {
  const n = t10.replace(/^['"]|['"]$/g, "").toLowerCase(), i = parseInt(e), s = isNaN(i) ? "normal" : i;
  return (ph[n] || {})[s] || bw[n];
}
function Pg(t10, e) {
  const n = "".concat(i3).concat(e.replace(":", "-"));
  return new Promise((i, s) => {
    if (t10.getAttribute(n) !== null)
      return i();
    const o = Jo(t10.children).filter((f) => f.getAttribute(nh) === e)[0], a = Xs.getComputedStyle(t10, e), l = a.getPropertyValue("font-family"), c = l.match(l3), u = a.getPropertyValue("font-weight"), d = a.getPropertyValue("content");
    if (o && !c)
      return t10.removeChild(o), i();
    if (c && d !== "none" && d !== "") {
      const f = a.getPropertyValue("content");
      let h10 = vw(l, u);
      const {
        value: p,
        isSecondary: g
      } = yw(f), m = c[0].startsWith("FontAwesome");
      let b = Pp(h10, p), x = b;
      if (m) {
        const k = _3(p);
        k.iconName && k.prefix && (b = k.iconName, h10 = k.prefix);
      }
      if (b && !g && (!o || o.getAttribute(Tp) !== h10 || o.getAttribute(Ap) !== x)) {
        t10.setAttribute(n, x), o && t10.removeChild(o);
        const k = ow(), {
          extra: v
        } = k;
        v.attributes[nh] = e, dh(b, h10).then((S) => {
          const w = Dp(he(he({}, k), {}, {
            icons: {
              main: S,
              mask: _v()
            },
            prefix: h10,
            iconName: x,
            extra: v,
            watchable: true
          })), E = gt.createElementNS("http://www.w3.org/2000/svg", "svg");
          e === "::before" ? t10.insertBefore(E, t10.firstChild) : t10.appendChild(E), E.outerHTML = w.map((M) => Al(M)).join(`
`), t10.removeAttribute(n), i();
        }).catch(s);
      } else
        i();
    } else
      i();
  });
}
function xw(t10) {
  return Promise.all([Pg(t10, "::before"), Pg(t10, "::after")]);
}
function kw(t10) {
  return t10.parentNode !== document.head && !~r3.indexOf(t10.tagName.toUpperCase()) && !t10.getAttribute(nh) && (!t10.parentNode || t10.parentNode.tagName !== "svg");
}
function Dg(t10) {
  if (ws)
    return new Promise((e, n) => {
      const i = Jo(t10.querySelectorAll("*")).filter(kw).map(xw), s = $p.begin("searchPseudoElements");
      Dv(), Promise.all(i).then(() => {
        s(), hh(), e();
      }).catch(() => {
        s(), hh(), n();
      });
    });
}
var Sw = {
  hooks() {
    return {
      mutationObserverCallbacks(t10) {
        return t10.pseudoElementsCallback = Dg, t10;
      }
    };
  },
  provides(t10) {
    t10.pseudoElements2svg = function(e) {
      const {
        node: n = gt
      } = e;
      Ne.searchPseudoElements && Dg(n);
    };
  }
};
var $g = false;
var ww = {
  mixout() {
    return {
      dom: {
        unwatch() {
          Dv(), $g = true;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        Ag(lh("mutationObserverCallbacks", {}));
      },
      noAuto() {
        nw();
      },
      watch(t10) {
        const {
          observeMutationsRoot: e
        } = t10;
        $g ? hh() : Ag(lh("mutationObserverCallbacks", {
          observeMutationsRoot: e
        }));
      }
    };
  }
};
var Rg = (t10) => {
  let e = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return t10.toLowerCase().split(" ").reduce((n, i) => {
    const s = i.toLowerCase().split("-"), r = s[0];
    let o = s.slice(1).join("-");
    if (r && o === "h")
      return n.flipX = true, n;
    if (r && o === "v")
      return n.flipY = true, n;
    if (o = parseFloat(o), isNaN(o))
      return n;
    switch (r) {
      case "grow":
        n.size = n.size + o;
        break;
      case "shrink":
        n.size = n.size - o;
        break;
      case "left":
        n.x = n.x - o;
        break;
      case "right":
        n.x = n.x + o;
        break;
      case "up":
        n.y = n.y - o;
        break;
      case "down":
        n.y = n.y + o;
        break;
      case "rotate":
        n.rotate = n.rotate + o;
        break;
    }
    return n;
  }, e);
};
var Cw = {
  mixout() {
    return {
      parse: {
        transform: (t10) => Rg(t10)
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(t10, e) {
        const n = e.getAttribute("data-fa-transform");
        return n && (t10.transform = Rg(n)), t10;
      }
    };
  },
  provides(t10) {
    t10.generateAbstractTransformGrouping = function(e) {
      let {
        main: n,
        transform: i,
        containerWidth: s,
        iconWidth: r
      } = e;
      const o = {
        transform: "translate(".concat(s / 2, " 256)")
      }, a = "translate(".concat(i.x * 32, ", ").concat(i.y * 32, ") "), l = "scale(".concat(i.size / 16 * (i.flipX ? -1 : 1), ", ").concat(i.size / 16 * (i.flipY ? -1 : 1), ") "), c = "rotate(".concat(i.rotate, " 0 0)"), u = {
        transform: "".concat(a, " ").concat(l, " ").concat(c)
      }, d = {
        transform: "translate(".concat(r / 2 * -1, " -256)")
      }, f = {
        outer: o,
        inner: u,
        path: d
      };
      return {
        tag: "g",
        attributes: he({}, f.outer),
        children: [{
          tag: "g",
          attributes: he({}, f.inner),
          children: [{
            tag: n.icon.tag,
            children: n.icon.children,
            attributes: he(he({}, n.icon.attributes), f.path)
          }]
        }]
      };
    };
  }
};
var Zd = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function Fg(t10) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return t10.attributes && (t10.attributes.fill || e) && (t10.attributes.fill = "black"), t10;
}
function Ow(t10) {
  return t10.tag === "g" ? t10.children : [t10];
}
var Ew = {
  hooks() {
    return {
      parseNodeAttributes(t10, e) {
        const n = e.getAttribute("data-fa-mask"), i = n ? rd(n.split(" ").map((s) => s.trim())) : _v();
        return i.prefix || (i.prefix = Qs()), t10.mask = i, t10.maskId = e.getAttribute("data-fa-mask-id"), t10;
      }
    };
  },
  provides(t10) {
    t10.generateAbstractMask = function(e) {
      let {
        children: n,
        attributes: i,
        main: s,
        mask: r,
        maskId: o,
        transform: a
      } = e;
      const {
        width: l,
        icon: c
      } = s, {
        width: u,
        icon: d
      } = r, f = y3({
        transform: a,
        containerWidth: u,
        iconWidth: l
      }), h10 = {
        tag: "rect",
        attributes: he(he({}, Zd), {}, {
          fill: "white"
        })
      }, p = c.children ? {
        children: c.children.map(Fg)
      } : {}, g = {
        tag: "g",
        attributes: he({}, f.inner),
        children: [Fg(he({
          tag: c.tag,
          attributes: he(he({}, c.attributes), f.path)
        }, p))]
      }, m = {
        tag: "g",
        attributes: he({}, f.outer),
        children: [g]
      }, b = "mask-".concat(o || Qa()), x = "clip-".concat(o || Qa()), k = {
        tag: "mask",
        attributes: he(he({}, Zd), {}, {
          id: b,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [h10, m]
      }, v = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: x
          },
          children: Ow(d)
        }, k]
      };
      return n.push(v, {
        tag: "rect",
        attributes: he({
          fill: "currentColor",
          "clip-path": "url(#".concat(x, ")"),
          mask: "url(#".concat(b, ")")
        }, Zd)
      }), {
        children: n,
        attributes: i
      };
    };
  }
};
var Mw = {
  provides(t10) {
    let e = false;
    Xs.matchMedia && (e = Xs.matchMedia("(prefers-reduced-motion: reduce)").matches), t10.missingIconAbstract = function() {
      const n = [], i = {
        fill: "currentColor"
      }, s = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      n.push({
        tag: "path",
        attributes: he(he({}, i), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      const r = he(he({}, s), {}, {
        attributeName: "opacity"
      }), o = {
        tag: "circle",
        attributes: he(he({}, i), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return e || o.children.push({
        tag: "animate",
        attributes: he(he({}, s), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: he(he({}, r), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), n.push(o), n.push({
        tag: "path",
        attributes: he(he({}, i), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: e ? [] : [{
          tag: "animate",
          attributes: he(he({}, r), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), e || n.push({
        tag: "path",
        attributes: he(he({}, i), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: he(he({}, r), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: n
      };
    };
  }
};
var Tw = {
  hooks() {
    return {
      parseNodeAttributes(t10, e) {
        const n = e.getAttribute("data-fa-symbol"), i = n === null ? false : n === "" ? true : n;
        return t10.symbol = i, t10;
      }
    };
  }
};
var Aw = [k3, fw, hw, pw, mw, Sw, ww, Cw, Ew, Mw, Tw];
V3(Aw, {
  mixoutsTo: Zn
});
Zn.noAuto;
var Rv = Zn.config;
var _w = Zn.library;
Zn.dom;
var zc = Zn.parse;
Zn.findIconDefinition;
Zn.toHtml;
var Nw = Zn.icon;
Zn.layer;
var Lw = Zn.text;
Zn.counter;
var Iw = {
  prefix: "fas",
  iconName: "trash-can",
  icon: [448, 512, [61460, "trash-alt"], "f2ed", "M135.2 17.7C140.6 6.8 151.7 0 163.8 0L284.2 0c12.1 0 23.2 6.8 28.6 17.7L320 32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l96 0 7.2-14.3zM32 128l384 0 0 320c0 35.3-28.7 64-64 64L96 512c-35.3 0-64-28.7-64-64l0-320zm96 64c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16z"]
};
var Pw = {
  prefix: "fas",
  iconName: "info",
  icon: [192, 512, [], "f129", "M48 80a48 48 0 1 1 96 0A48 48 0 1 1 48 80zM0 224c0-17.7 14.3-32 32-32l64 0c17.7 0 32 14.3 32 32l0 224 32 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 512c-17.7 0-32-14.3-32-32s14.3-32 32-32l32 0 0-192-32 0c-17.7 0-32-14.3-32-32z"]
};
var Dw = {
  prefix: "fas",
  iconName: "arrow-up-long",
  icon: [384, 512, ["long-arrow-up"], "f176", "M214.6 9.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 109.3 160 480c0 17.7 14.3 32 32 32s32-14.3 32-32l0-370.7 73.4 73.4c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-128-128z"]
};
var $w = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
};
var Rw = {
  prefix: "fas",
  iconName: "circle-dot",
  icon: [512, 512, [128280, "dot-circle"], "f192", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-352a96 96 0 1 1 0 192 96 96 0 1 1 0-192z"]
};
var Fw = {
  prefix: "fas",
  iconName: "paintbrush",
  icon: [576, 512, [128396, "paint-brush"], "f1fc", "M339.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L568.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S517.7-4.4 499.1 9.6L262.4 187.2c-24 18-38.2 46.1-38.4 76.1L339.3 367.1zm-19.6 25.4l-116-104.4C143.9 290.3 96 339.6 96 400c0 3.9 .2 7.8 .6 11.6C98.4 429.1 86.4 448 68.8 448L64 448c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"]
};
var Vw = {
  prefix: "fas",
  iconName: "angle-right",
  icon: [320, 512, [8250], "f105", "M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"]
};
var Bw = {
  prefix: "fas",
  iconName: "arrow-up-from-bracket",
  icon: [448, 512, [], "e09a", "M246.6 9.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 109.3 192 320c0 17.7 14.3 32 32 32s32-14.3 32-32l0-210.7 73.4 73.4c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-128-128zM64 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64c0 53 43 96 96 96l256 0c53 0 96-43 96-96l0-64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64c0 17.7-14.3 32-32 32L96 448c-17.7 0-32-14.3-32-32l0-64z"]
};
var zw = {
  prefix: "fas",
  iconName: "folder",
  icon: [512, 512, [128193, 128447, 61716, "folder-blank"], "f07b", "M64 480H448c35.3 0 64-28.7 64-64V160c0-35.3-28.7-64-64-64H288c-10.1 0-19.6-4.7-25.6-12.8L243.2 57.6C231.1 41.5 212.1 32 192 32H64C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64z"]
};
var jw = {
  prefix: "fas",
  iconName: "star",
  icon: [576, 512, [11088, 61446], "f005", "M316.9 18C311.6 7 300.4 0 288.1 0s-23.4 7-28.8 18L195 150.3 51.4 171.5c-12 1.8-22 10.2-25.7 21.7s-.7 24.2 7.9 32.7L137.8 329 113.2 474.7c-2 12 3 24.2 12.9 31.3s23 8 33.8 2.3l128.3-68.5 128.3 68.5c10.8 5.7 23.9 4.9 33.8-2.3s14.9-19.3 12.9-31.3L438.5 329 542.7 225.9c8.6-8.5 11.7-21.2 7.9-32.7s-13.7-19.9-25.7-21.7L381.2 150.3 316.9 18z"]
};
var Hw = {
  prefix: "fas",
  iconName: "rotate-left",
  icon: [512, 512, ["rotate-back", "rotate-backward", "undo-alt"], "f2ea", "M48.5 224L40 224c-13.3 0-24-10.7-24-24L16 72c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2L98.6 96.6c87.6-86.5 228.7-86.2 315.8 1c87.5 87.5 87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3c-62.2-62.2-162.7-62.5-225.3-1L185 183c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8L48.5 224z"]
};
var Ww = {
  prefix: "fas",
  iconName: "arrow-down-long",
  icon: [384, 512, ["long-arrow-down"], "f175", "M169.4 502.6c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 402.7 224 32c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 370.7L86.6 329.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128z"]
};
var Uw = {
  prefix: "fas",
  iconName: "pause",
  icon: [320, 512, [9208], "f04c", "M48 64C21.5 64 0 85.5 0 112L0 400c0 26.5 21.5 48 48 48l32 0c26.5 0 48-21.5 48-48l0-288c0-26.5-21.5-48-48-48L48 64zm192 0c-26.5 0-48 21.5-48 48l0 288c0 26.5 21.5 48 48 48l32 0c26.5 0 48-21.5 48-48l0-288c0-26.5-21.5-48-48-48l-32 0z"]
};
var qw = {
  prefix: "fas",
  iconName: "circle",
  icon: [512, 512, [128308, 128309, 128992, 128993, 128994, 128995, 128996, 9679, 9898, 9899, 11044, 61708, 61915], "f111", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"]
};
var Kw = {
  prefix: "fas",
  iconName: "pen",
  icon: [512, 512, [128394], "f304", "M362.7 19.3L314.3 67.7 444.3 197.7l48.4-48.4c25-25 25-65.5 0-90.5L453.3 19.3c-25-25-65.5-25-90.5 0zm-71 71L58.6 323.5c-10.4 10.4-18 23.3-22.2 37.4L1 481.2C-1.5 489.7 .8 498.8 7 505s15.3 8.5 23.7 6.1l120.3-35.4c14.1-4.2 27-11.8 37.4-22.2L421.7 220.3 291.7 90.3z"]
};
var Yw = {
  prefix: "fas",
  iconName: "arrow-rotate-right",
  icon: [512, 512, [8635, "arrow-right-rotate", "arrow-rotate-forward", "redo"], "f01e", "M386.3 160L336 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l128 0c17.7 0 32-14.3 32-32l0-128c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 51.2L414.4 97.6c-87.5-87.5-229.3-87.5-316.8 0s-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3s163.8-62.5 226.3 0L386.3 160z"]
};
var Gw = {
  prefix: "fas",
  iconName: "arrow-left",
  icon: [448, 512, [8592], "f060", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"]
};
var Jw = {
  prefix: "fas",
  iconName: "arrow-rotate-left",
  icon: [512, 512, [8634, "arrow-left-rotate", "arrow-rotate-back", "arrow-rotate-backward", "undo"], "f0e2", "M125.7 160l50.3 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L48 224c-17.7 0-32-14.3-32-32L16 64c0-17.7 14.3-32 32-32s32 14.3 32 32l0 51.2L97.6 97.6c87.5-87.5 229.3-87.5 316.8 0s87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3s-163.8-62.5-226.3 0L125.7 160z"]
};
var Xw = {
  prefix: "fas",
  iconName: "crop-simple",
  icon: [512, 512, ["crop-alt"], "f565", "M128 32c0-17.7-14.3-32-32-32S64 14.3 64 32l0 32L32 64C14.3 64 0 78.3 0 96s14.3 32 32 32l32 0 0 256c0 35.3 28.7 64 64 64l224 0 0-64-224 0 0-352zM384 480c0 17.7 14.3 32 32 32s32-14.3 32-32l0-32 32 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-32 0 0-256c0-35.3-28.7-64-64-64L160 64l0 64 224 0 0 352z"]
};
var Qw = {
  prefix: "fas",
  iconName: "minus",
  icon: [448, 512, [8211, 8722, 10134, "subtract"], "f068", "M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"]
};
var Zw = {
  prefix: "fas",
  iconName: "power-off",
  icon: [512, 512, [9211], "f011", "M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 224c0 17.7 14.3 32 32 32s32-14.3 32-32l0-224zM143.5 120.6c13.6-11.3 15.4-31.5 4.1-45.1s-31.5-15.4-45.1-4.1C49.7 115.4 16 181.8 16 256c0 132.5 107.5 240 240 240s240-107.5 240-240c0-74.2-33.8-140.6-86.6-184.6c-13.6-11.3-33.8-9.4-45.1 4.1s-9.4 33.8 4.1 45.1c38.9 32.3 63.5 81 63.5 135.4c0 97.2-78.8 176-176 176s-176-78.8-176-176c0-54.4 24.7-103.1 63.5-135.4z"]
};
var eC = {
  prefix: "fas",
  iconName: "closed-captioning",
  icon: [576, 512, [], "f20a", "M0 96C0 60.7 28.7 32 64 32l448 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM200 208c14.2 0 27 6.1 35.8 16c8.8 9.9 24 10.7 33.9 1.9s10.7-24 1.9-33.9c-17.5-19.6-43.1-32-71.5-32c-53 0-96 43-96 96s43 96 96 96c28.4 0 54-12.4 71.5-32c8.8-9.9 8-25-1.9-33.9s-25-8-33.9 1.9c-8.8 9.9-21.6 16-35.8 16c-26.5 0-48-21.5-48-48s21.5-48 48-48zm144 48c0-26.5 21.5-48 48-48c14.2 0 27 6.1 35.8 16c8.8 9.9 24 10.7 33.9 1.9s10.7-24 1.9-33.9c-17.5-19.6-43.1-32-71.5-32c-53 0-96 43-96 96s43 96 96 96c28.4 0 54-12.4 71.5-32c8.8-9.9 8-25-1.9-33.9s-25-8-33.9 1.9c-8.8 9.9-21.6 16-35.8 16c-26.5 0-48-21.5-48-48z"]
};
var tC = {
  prefix: "fas",
  iconName: "house",
  icon: [576, 512, [127968, 63498, 63500, "home", "home-alt", "home-lg-alt"], "f015", "M575.8 255.5c0 18-15 32.1-32 32.1l-32 0 .7 160.2c0 2.7-.2 5.4-.5 8.1l0 16.2c0 22.1-17.9 40-40 40l-16 0c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1L416 512l-24 0c-22.1 0-40-17.9-40-40l0-24 0-64c0-17.7-14.3-32-32-32l-64 0c-17.7 0-32 14.3-32 32l0 64 0 24c0 22.1-17.9 40-40 40l-24 0-31.9 0c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2l-16 0c-22.1 0-40-17.9-40-40l0-112c0-.9 0-1.9 .1-2.8l0-69.7-32 0c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"]
};
var nC = {
  prefix: "fas",
  iconName: "rotate-right",
  icon: [512, 512, ["redo-alt", "rotate-forward"], "f2f9", "M463.5 224l8.5 0c13.3 0 24-10.7 24-24l0-128c0-9.7-5.8-18.5-14.8-22.2s-19.3-1.7-26.2 5.2L413.4 96.6c-87.6-86.5-228.7-86.2-315.8 1c-87.5 87.5-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3c62.2-62.2 162.7-62.5 225.3-1L327 183c-6.9 6.9-8.9 17.2-5.2 26.2s12.5 14.8 22.2 14.8l119.5 0z"]
};
var iC = {
  prefix: "fas",
  iconName: "angle-down",
  icon: [448, 512, [8964], "f107", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"]
};
var sC = {
  prefix: "fas",
  iconName: "inbox",
  icon: [512, 512, [], "f01c", "M121 32C91.6 32 66 52 58.9 80.5L1.9 308.4C.6 313.5 0 318.7 0 323.9L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-92.1c0-5.2-.6-10.4-1.9-15.5l-57-227.9C446 52 420.4 32 391 32L121 32zm0 64l270 0 48 192-51.2 0c-12.1 0-23.2 6.8-28.6 17.7l-14.3 28.6c-5.4 10.8-16.5 17.7-28.6 17.7l-120.4 0c-12.1 0-23.2-6.8-28.6-17.7l-14.3-28.6c-5.4-10.8-16.5-17.7-28.6-17.7L73 288 121 96z"]
};
var rC = {
  prefix: "fas",
  iconName: "play",
  icon: [384, 512, [9654], "f04b", "M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80L0 432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"]
};
var oC = {
  prefix: "fas",
  iconName: "list-ul",
  icon: [512, 512, ["list-dots"], "f0ca", "M64 144a48 48 0 1 0 0-96 48 48 0 1 0 0 96zM192 64c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L192 64zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zM64 464a48 48 0 1 0 0-96 48 48 0 1 0 0 96zm48-208a48 48 0 1 0 -96 0 48 48 0 1 0 96 0z"]
};
var aC = {
  prefix: "fas",
  iconName: "volume-xmark",
  icon: [576, 512, ["volume-mute", "volume-times"], "f6a9", "M301.1 34.8C312.6 40 320 51.4 320 64l0 384c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L131.8 352 64 352c-35.3 0-64-28.7-64-64l0-64c0-35.3 28.7-64 64-64l67.8 0L266.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3zM425 167l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0z"]
};
var lC = {
  prefix: "fas",
  iconName: "plus",
  icon: [448, 512, [10133, 61543, "add"], "2b", "M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 144L48 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0 0 144c0 17.7 14.3 32 32 32s32-14.3 32-32l0-144 144 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-144 0 0-144z"]
};
var cC = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"]
};
var uC = {
  prefix: "fas",
  iconName: "angle-up",
  icon: [448, 512, [8963], "f106", "M201.4 137.4c12.5-12.5 32.8-12.5 45.3 0l160 160c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 205.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l160-160z"]
};
var dC = {
  prefix: "fas",
  iconName: "moon",
  icon: [384, 512, [127769, 9214], "f186", "M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"]
};
var fC = {
  prefix: "fas",
  iconName: "music",
  icon: [512, 512, [127925], "f001", "M499.1 6.3c8.1 6 12.9 15.6 12.9 25.7l0 72 0 264c0 44.2-43 80-96 80s-96-35.8-96-80s43-80 96-80c11.2 0 22 1.6 32 4.6L448 147 192 223.8 192 432c0 44.2-43 80-96 80s-96-35.8-96-80s43-80 96-80c11.2 0 22 1.6 32 4.6L128 200l0-72c0-14.1 9.3-26.6 22.8-30.7l320-96c9.7-2.9 20.2-1.1 28.3 5z"]
};
var hC = {
  prefix: "fas",
  iconName: "check",
  icon: [448, 512, [10003, 10004], "f00c", "M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"]
};
var pC = {
  prefix: "fas",
  iconName: "angle-left",
  icon: [320, 512, [8249], "f104", "M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"]
};
var mC = {
  prefix: "fas",
  iconName: "closed-captioning-slash",
  icon: [640, 512, [], "e135", "M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7l-30-23.5c4.6-8.8 7.2-18.9 7.2-29.6l0-320c0-35.3-28.7-64-64-64L96 32c-6.7 0-13.1 1-19.2 2.9L38.8 5.1zm197.8 155c26.6 1.2 50.4 13.3 67 31.9c6.1 6.8 7.6 16.2 4.7 24.3l-71.6-56.2zm94 73.7c10-42.3 48-73.8 93.4-73.8c28.4 0 54 12.4 71.5 32c8.8 9.9 8 25-1.9 33.9s-25 8-33.9-1.9c-8.8-9.9-21.6-16-35.8-16c-26.5 0-48 21.5-48 48c0 5.4 .9 10.5 2.5 15.4l-47.9-37.6zm89.4 70c1.3 .1 2.7 .2 4.1 .2c14.2 0 27-6.1 35.8-16c8.8-9.9 24-10.7 33.9-1.9s10.7 24 1.9 33.9c-7.8 8.7-17.2 16-27.7 21.4l-47.9-37.6zM32 121.2L32 416c0 35.3 28.7 64 64 64l391.4 0L295 328.4c-16.8 14.7-38.9 23.6-63 23.6c-53 0-96-43-96-96c0-16 3.9-31.1 10.8-44.3L32 121.2zM232 304c8.7 0 16.9-2.3 23.9-6.4l-70-55.1c-1.3 4.3-1.9 8.8-1.9 13.5c0 26.5 21.5 48 48 48z"]
};
var gC = {
  prefix: "fas",
  iconName: "sparkles",
  icon: [512, 512, [10024], "f890", "M327.5 85.2c-4.5 1.7-7.5 6-7.5 10.8s3 9.1 7.5 10.8L384 128l21.2 56.5c1.7 4.5 6 7.5 10.8 7.5s9.1-3 10.8-7.5L448 128l56.5-21.2c4.5-1.7 7.5-6 7.5-10.8s-3-9.1-7.5-10.8L448 64 426.8 7.5C425.1 3 420.8 0 416 0s-9.1 3-10.8 7.5L384 64 327.5 85.2zM205.1 73.3c-2.6-5.7-8.3-9.3-14.5-9.3s-11.9 3.6-14.5 9.3L123.3 187.3 9.3 240C3.6 242.6 0 248.3 0 254.6s3.6 11.9 9.3 14.5l114.1 52.7L176 435.8c2.6 5.7 8.3 9.3 14.5 9.3s11.9-3.6 14.5-9.3l52.7-114.1 114.1-52.7c5.7-2.6 9.3-8.3 9.3-14.5s-3.6-11.9-9.3-14.5L257.8 187.4 205.1 73.3zM384 384l-56.5 21.2c-4.5 1.7-7.5 6-7.5 10.8s3 9.1 7.5 10.8L384 448l21.2 56.5c1.7 4.5 6 7.5 10.8 7.5s9.1-3 10.8-7.5L448 448l56.5-21.2c4.5-1.7 7.5-6 7.5-10.8s-3-9.1-7.5-10.8L448 384l-21.2-56.5c-1.7-4.5-6-7.5-10.8-7.5s-9.1 3-10.8 7.5L384 384z"]
};
var bC = {
  prefix: "fas",
  iconName: "volume",
  icon: [576, 512, [128265, "volume-medium"], "f6a8", "M333.1 34.8C344.6 40 352 51.4 352 64l0 384c0 12.6-7.4 24-18.9 29.2s-25 3.1-34.4-5.3L163.8 352 96 352c-35.3 0-64-28.7-64-64l0-64c0-35.3 28.7-64 64-64l67.8 0L298.7 40.1c9.4-8.4 22.9-10.4 34.4-5.3zm172 72.2c43.2 35.2 70.9 88.9 70.9 149s-27.7 113.8-70.9 149c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C507.3 341.3 528 301.1 528 256s-20.7-85.3-53.2-111.8c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5zm-60.5 74.5C466.1 199.1 480 225.9 480 256s-13.9 56.9-35.4 74.5c-10.3 8.4-25.4 6.8-33.8-3.5s-6.8-25.4 3.5-33.8C425.1 284.4 432 271 432 256s-6.9-28.4-17.7-37.3c-10.3-8.4-11.8-23.5-3.5-33.8s23.5-11.8 33.8-3.5z"]
};
var yC = {
  prefix: "fas",
  iconName: "arrow-down-to-line",
  icon: [384, 512, ["arrow-to-bottom"], "f33d", "M32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l320 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480zM214.6 342.6c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 242.7 160 64c0-17.7 14.3-32 32-32s32 14.3 32 32l0 178.7 73.4-73.4c12.5-12.5 32.8-12.5 45.3 0s12.5 32.8 0 45.3l-128 128z"]
};
var vC = {
  prefix: "fas",
  iconName: "arrow-up-arrow-down",
  icon: [576, 512, ["sort-up-down"], "e099", "M182.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-96 96c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L128 141.3 128 448c0 17.7 14.3 32 32 32s32-14.3 32-32l0-306.7 41.4 41.4c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-96-96zm352 333.3c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L448 370.7 448 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 306.7-41.4-41.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l96 96c12.5 12.5 32.8 12.5 45.3 0l96-96z"]
};
var xC = {
  prefix: "fas",
  iconName: "grip-dots",
  icon: [448, 512, [], "e410", "M336 176a48 48 0 1 0 96 0 48 48 0 1 0 -96 0zm-160 0a48 48 0 1 0 96 0 48 48 0 1 0 -96 0zM64 224a48 48 0 1 0 0-96 48 48 0 1 0 0 96zM336 336a48 48 0 1 0 96 0 48 48 0 1 0 -96 0zM224 384a48 48 0 1 0 0-96 48 48 0 1 0 0 96zM16 336a48 48 0 1 0 96 0 48 48 0 1 0 -96 0z"]
};
var kC = {
  prefix: "far",
  iconName: "file-lines",
  icon: [384, 512, [128441, 128462, 61686, "file-alt", "file-text"], "f15c", "M64 464c-8.8 0-16-7.2-16-16L48 64c0-8.8 7.2-16 16-16l160 0 0 80c0 17.7 14.3 32 32 32l80 0 0 288c0 8.8-7.2 16-16 16L64 464zM64 0C28.7 0 0 28.7 0 64L0 448c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-293.5c0-17-6.7-33.3-18.7-45.3L274.7 18.7C262.7 6.7 246.5 0 229.5 0L64 0zm56 256c-13.3 0-24 10.7-24 24s10.7 24 24 24l144 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-144 0zm0 96c-13.3 0-24 10.7-24 24s10.7 24 24 24l144 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-144 0z"]
};
var SC = {
  prefix: "far",
  iconName: "calendar-days",
  icon: [448, 512, ["calendar-alt"], "f073", "M152 24c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 40L64 64C28.7 64 0 92.7 0 128l0 16 0 48L0 448c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-256 0-48 0-16c0-35.3-28.7-64-64-64l-40 0 0-40c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 40L152 64l0-40zM48 192l80 0 0 56-80 0 0-56zm0 104l80 0 0 64-80 0 0-64zm128 0l96 0 0 64-96 0 0-64zm144 0l80 0 0 64-80 0 0-64zm80-48l-80 0 0-56 80 0 0 56zm0 160l0 40c0 8.8-7.2 16-16 16l-64 0 0-56 80 0zm-128 0l0 56-96 0 0-56 96 0zm-144 0l0 56-64 0c-8.8 0-16-7.2-16-16l0-40 80 0zM272 248l-96 0 0-56 96 0 0 56z"]
};
var wC = {
  prefix: "far",
  iconName: "eye-slash",
  icon: [640, 512, [], "f070", "M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zm151 118.3C226 97.7 269.5 80 320 80c65.2 0 118.8 29.6 159.9 67.7C518.4 183.5 545 226 558.6 256c-12.6 28-36.6 66.8-70.9 100.9l-53.8-42.2c9.1-17.6 14.2-37.5 14.2-58.7c0-70.7-57.3-128-128-128c-32.2 0-61.7 11.9-84.2 31.5l-46.1-36.1zM394.9 284.2l-81.5-63.9c4.2-8.5 6.6-18.2 6.6-28.3c0-5.5-.7-10.9-2-16c.7 0 1.3 0 2 0c44.2 0 80 35.8 80 80c0 9.9-1.8 19.4-5.1 28.2zm9.4 130.3C378.8 425.4 350.7 432 320 432c-65.2 0-118.8-29.6-159.9-67.7C121.6 328.5 95 286 81.4 256c8.3-18.4 21.5-41.5 39.4-64.8L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5l-41.9-33zM192 256c0 70.7 57.3 128 128 128c13.3 0 26.1-2 38.2-5.8L302 334c-23.5-5.4-43.1-21.2-53.7-42.3l-56.1-44.2c-.2 2.8-.3 5.6-.3 8.5z"]
};
var CC = {
  prefix: "far",
  iconName: "image",
  icon: [512, 512, [], "f03e", "M448 80c8.8 0 16 7.2 16 16l0 319.8-5-6.5-136-176c-4.5-5.9-11.6-9.3-19-9.3s-14.4 3.4-19 9.3L202 340.7l-30.5-42.7C167 291.7 159.8 288 152 288s-15 3.7-19.5 10.1l-80 112L48 416.3l0-.3L48 96c0-8.8 7.2-16 16-16l384 0zM64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zm80 192a48 48 0 1 0 0-96 48 48 0 1 0 0 96z"]
};
var OC = {
  prefix: "far",
  iconName: "circle-check",
  icon: [512, 512, [61533, "check-circle"], "f058", "M256 48a208 208 0 1 1 0 416 208 208 0 1 1 0-416zm0 464A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM369 209c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-111 111-47-47c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l64 64c9.4 9.4 24.6 9.4 33.9 0L369 209z"]
};
var EC = {
  prefix: "far",
  iconName: "square",
  icon: [448, 512, [9632, 9723, 9724, 61590], "f0c8", "M384 80c8.8 0 16 7.2 16 16l0 320c0 8.8-7.2 16-16 16L64 432c-8.8 0-16-7.2-16-16L48 96c0-8.8 7.2-16 16-16l320 0zM64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32z"]
};
var MC = {
  prefix: "far",
  iconName: "eye",
  icon: [576, 512, [128065], "f06e", "M288 80c-65.2 0-118.8 29.6-159.9 67.7C89.6 183.5 63 226 49.4 256c13.6 30 40.2 72.5 78.6 108.3C169.2 402.4 222.8 432 288 432s118.8-29.6 159.9-67.7C486.4 328.5 513 286 526.6 256c-13.6-30-40.2-72.5-78.6-108.3C406.8 109.6 353.2 80 288 80zM95.4 112.6C142.5 68.8 207.2 32 288 32s145.5 36.8 192.6 80.6c46.8 43.5 78.1 95.4 93 131.1c3.3 7.9 3.3 16.7 0 24.6c-14.9 35.7-46.2 87.7-93 131.1C433.5 443.2 368.8 480 288 480s-145.5-36.8-192.6-80.6C48.6 356 17.3 304 2.5 268.3c-3.3-7.9-3.3-16.7 0-24.6C17.3 208 48.6 156 95.4 112.6zM288 336c44.2 0 80-35.8 80-80s-35.8-80-80-80c-.7 0-1.3 0-2 0c1.3 5.1 2 10.5 2 16c0 35.3-28.7 64-64 64c-5.5 0-10.9-.7-16-2c0 .7 0 1.3 0 2c0 44.2 35.8 80 80 80zm0-208a128 128 0 1 1 0 256 128 128 0 1 1 0-256z"]
};
var TC = {
  prefix: "far",
  iconName: "file",
  icon: [384, 512, [128196, 128459, 61462], "f15b", "M320 464c8.8 0 16-7.2 16-16l0-288-80 0c-17.7 0-32-14.3-32-32l0-80L64 48c-8.8 0-16 7.2-16 16l0 384c0 8.8 7.2 16 16 16l256 0zM0 64C0 28.7 28.7 0 64 0L229.5 0c17 0 33.3 6.7 45.3 18.7l90.5 90.5c12 12 18.7 28.3 18.7 45.3L384 448c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64z"]
};
var AC = {
  prefix: "far",
  iconName: "clone",
  icon: [512, 512, [], "f24d", "M64 464l224 0c8.8 0 16-7.2 16-16l0-64 48 0 0 64c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 224c0-35.3 28.7-64 64-64l64 0 0 48-64 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16zM224 304l224 0c8.8 0 16-7.2 16-16l0-224c0-8.8-7.2-16-16-16L224 48c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16zm-64-16l0-224c0-35.3 28.7-64 64-64L448 0c35.3 0 64 28.7 64 64l0 224c0 35.3-28.7 64-64 64l-224 0c-35.3 0-64-28.7-64-64z"]
};
var _C = {
  prefix: "far",
  iconName: "text-size",
  icon: [640, 512, [], "f894", "M48 128l0-48 120 0 0 352-48 0c-13.3 0-24 10.7-24 24s10.7 24 24 24l144 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-48 0 0-352 120 0 0 48c0 13.3 10.7 24 24 24s24-10.7 24-24l0-56c0-22.1-17.9-40-40-40L40 32C17.9 32 0 49.9 0 72l0 56c0 13.3 10.7 24 24 24s24-10.7 24-24zM360 296l0-24 96 0 0 160-32 0c-13.3 0-24 10.7-24 24s10.7 24 24 24l112 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-32 0 0-160 88 0 0 24c0 13.3 10.7 24 24 24s24-10.7 24-24l0-32c0-22.1-17.9-40-40-40l-248 0c-22.1 0-40 17.9-40 40l0 32c0 13.3 10.7 24 24 24s24-10.7 24-24z"]
};
var NC = {
  prefix: "far",
  iconName: "circle-notch",
  icon: [512, 512, [], "f1ce", "M215.1 26.3c3.6 12.7-3.7 26-16.5 29.7C111.6 80.9 48 161.1 48 256c0 114.9 93.1 208 208 208s208-93.1 208-208c0-94.9-63.6-175.1-150.6-200c-12.7-3.6-20.1-16.9-16.5-29.7s16.9-20.1 29.7-16.5C433.6 40.5 512 139.1 512 256c0 141.4-114.6 256-256 256S0 397.4 0 256C0 139.1 78.4 40.5 185.4 9.9c12.7-3.6 26 3.7 29.7 16.5z"]
};
var LC = {
  prefix: "far",
  iconName: "film",
  icon: [512, 512, [127902], "f008", "M352 432l-192 0 0-112 0-40 192 0 0 40 0 112zm0-200l-192 0 0-40 0-112 192 0 0 112 0 40zM64 80l48 0 0 88-64 0 0-72c0-8.8 7.2-16 16-16zM48 216l64 0 0 80-64 0 0-80zm64 216l-48 0c-8.8 0-16-7.2-16-16l0-72 64 0 0 88zM400 168l0-88 48 0c8.8 0 16 7.2 16 16l0 72-64 0zm0 48l64 0 0 80-64 0 0-80zm0 128l64 0 0 72c0 8.8-7.2 16-16 16l-48 0 0-88zM448 32L64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64z"]
};
var IC = {
  prefix: "far",
  iconName: "circle-exclamation",
  icon: [512, 512, ["exclamation-circle"], "f06a", "M256 48a208 208 0 1 1 0 416 208 208 0 1 1 0-416zm0 464A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm0-384c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"]
};
var PC = {
  prefix: "far",
  iconName: "sidebar-flip",
  icon: [512, 512, [], "e24f", "M288 80l0 352L64 432c-8.8 0-16-7.2-16-16L48 96c0-8.8 7.2-16 16-16l224 0zM512 96c0-35.3-28.7-64-64-64L64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-320zm-64 24c0 13.3-10.7 24-24 24l-48 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24zm-24 72c13.3 0 24 10.7 24 24s-10.7 24-24 24l-48 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0zm24 120c0 13.3-10.7 24-24 24l-48 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24z"]
};
var DC = {
  prefix: "far",
  iconName: "compress",
  icon: [448, 512, [], "f066", "M160 56c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 88-88 0c-13.3 0-24 10.7-24 24s10.7 24 24 24l112 0c13.3 0 24-10.7 24-24l0-112zM24 320c-13.3 0-24 10.7-24 24s10.7 24 24 24l88 0 0 88c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24L24 320zM336 56c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24l112 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-88 0 0-88zM312 320c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-88 88 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-112 0z"]
};
var $C = {
  prefix: "far",
  iconName: "globe",
  icon: [512, 512, [127760], "f0ac", "M256 464c7.4 0 27-7.2 47.6-48.4c8.8-17.7 16.4-39.2 22-63.6l-139.2 0c5.6 24.4 13.2 45.9 22 63.6C229 456.8 248.6 464 256 464zM178.5 304l155 0c1.6-15.3 2.5-31.4 2.5-48s-.9-32.7-2.5-48l-155 0c-1.6 15.3-2.5 31.4-2.5 48s.9 32.7 2.5 48zm7.9-144l139.2 0c-5.6-24.4-13.2-45.9-22-63.6C283 55.2 263.4 48 256 48s-27 7.2-47.6 48.4c-8.8 17.7-16.4 39.2-22 63.6zm195.3 48c1.5 15.5 2.2 31.6 2.2 48s-.8 32.5-2.2 48l76.7 0c3.6-15.4 5.6-31.5 5.6-48s-1.9-32.6-5.6-48l-76.7 0zm58.8-48c-21.4-41.1-56.1-74.1-98.4-93.4c14.1 25.6 25.3 57.5 32.6 93.4l65.9 0zm-303.3 0c7.3-35.9 18.5-67.7 32.6-93.4c-42.3 19.3-77 52.3-98.4 93.4l65.9 0zM53.6 208c-3.6 15.4-5.6 31.5-5.6 48s1.9 32.6 5.6 48l76.7 0c-1.5-15.5-2.2-31.6-2.2-48s.8-32.5 2.2-48l-76.7 0zM342.1 445.4c42.3-19.3 77-52.3 98.4-93.4l-65.9 0c-7.3 35.9-18.5 67.7-32.6 93.4zm-172.2 0c-14.1-25.6-25.3-57.5-32.6-93.4l-65.9 0c21.4 41.1 56.1 74.1 98.4 93.4zM256 512A256 256 0 1 1 256 0a256 256 0 1 1 0 512z"]
};
var RC = {
  prefix: "far",
  iconName: "underline",
  icon: [448, 512, [], "f0cd", "M16 56c0-13.3 10.7-24 24-24l96 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-24 0 0 144c0 61.9 50.1 112 112 112s112-50.1 112-112l0-144-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l96 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-24 0 0 144c0 88.4-71.6 160-160 160s-160-71.6-160-160L64 80 40 80C26.7 80 16 69.3 16 56zM0 456c0-13.3 10.7-24 24-24l400 0c13.3 0 24 10.7 24 24s-10.7 24-24 24L24 480c-13.3 0-24-10.7-24-24z"]
};
var FC = {
  prefix: "far",
  iconName: "bold",
  icon: [384, 512, [], "f032", "M0 56C0 42.7 10.7 32 24 32l48 0 16 0 124 0c68.5 0 124 55.5 124 124c0 34.7-14.3 66.2-37.3 88.7C339.7 264.9 368 307.1 368 356c0 68.5-55.5 124-124 124L88 480l-16 0-48 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l24 0 0-176L48 80 24 80C10.7 80 0 69.3 0 56zM212 232c42 0 76-34 76-76s-34-76-76-76L96 80l0 152 116 0zM96 280l0 152 148 0c42 0 76-34 76-76s-34-76-76-76l-32 0L96 280z"]
};
var VC = {
  prefix: "far",
  iconName: "subtitles",
  icon: [576, 512, [], "e60f", "M64 80c-8.8 0-16 7.2-16 16l0 320c0 8.8 7.2 16 16 16l448 0c8.8 0 16-7.2 16-16l0-320c0-8.8-7.2-16-16-16L64 80zM0 96C0 60.7 28.7 32 64 32l448 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM120 240l176 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-176 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm256 0l80 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zM120 336l80 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm160 0l176 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-176 0c-13.3 0-24-10.7-24-24s10.7-24 24-24z"]
};
var BC = {
  prefix: "far",
  iconName: "italic",
  icon: [384, 512, [], "f033", "M128 56c0-13.3 10.7-24 24-24l208 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-68.7 0L144.7 432l87.3 0c13.3 0 24 10.7 24 24s-10.7 24-24 24L24 480c-13.3 0-24-10.7-24-24s10.7-24 24-24l68.7 0L239.3 80 152 80c-13.3 0-24-10.7-24-24z"]
};
var zC = {
  prefix: "far",
  iconName: "arrow-up-right-from-square",
  icon: [512, 512, ["external-link"], "f08e", "M304 24c0 13.3 10.7 24 24 24l102.1 0L207 271c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l223-223L464 184c0 13.3 10.7 24 24 24s24-10.7 24-24l0-160c0-13.3-10.7-24-24-24L328 0c-13.3 0-24 10.7-24 24zM72 32C32.2 32 0 64.2 0 104L0 440c0 39.8 32.2 72 72 72l336 0c39.8 0 72-32.2 72-72l0-128c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 128c0 13.3-10.7 24-24 24L72 464c-13.3 0-24-10.7-24-24l0-336c0-13.3 10.7-24 24-24l128 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L72 32z"]
};
var jC = {
  prefix: "far",
  iconName: "align-left",
  icon: [448, 512, [], "f036", "M24 40C10.7 40 0 50.7 0 64S10.7 88 24 88l240 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L24 40zm0 128c-13.3 0-24 10.7-24 24s10.7 24 24 24l400 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L24 168zM0 320c0 13.3 10.7 24 24 24l240 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L24 296c-13.3 0-24 10.7-24 24zM24 424c-13.3 0-24 10.7-24 24s10.7 24 24 24l400 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L24 424z"]
};
var HC = {
  prefix: "far",
  iconName: "circle-info",
  icon: [512, 512, ["info-circle"], "f05a", "M256 48a208 208 0 1 1 0 416 208 208 0 1 1 0-416zm0 464A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336c-13.3 0-24 10.7-24 24s10.7 24 24 24l80 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-8 0 0-88c0-13.3-10.7-24-24-24l-48 0c-13.3 0-24 10.7-24 24s10.7 24 24 24l24 0 0 64-24 0zm40-144a32 32 0 1 0 0-64 32 32 0 1 0 0 64z"]
};
var WC = {
  prefix: "far",
  iconName: "book-font",
  icon: [448, 512, [], "e0bf", "M0 88C0 39.4 39.4 0 88 0L392 0c30.9 0 56 25.1 56 56l0 288c0 22.3-13.1 41.6-32 50.6l0 69.4 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24L80 512c-44.2 0-80-35.8-80-80c0-2.7 .1-5.4 .4-8L0 424 0 88zM80 400c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0 0-64L80 400zM48 358.7c9.8-4.3 20.6-6.7 32-6.7l312 0c4.4 0 8-3.6 8-8l0-288c0-4.4-3.6-8-8-8L88 48C65.9 48 48 65.9 48 88l0 270.7zM261.5 93.3l88 176c5.9 11.9 1.1 26.3-10.7 32.2s-26.3 1.1-32.2-10.7L289.2 256c-.4 0-.8 0-1.2 0l-96 0c-.4 0-.8 0-1.2 0l-17.4 34.8c-5.9 11.9-20.3 16.7-32.2 10.7s-16.7-20.3-10.7-32.2l88-176C222.6 85.1 230.9 80 240 80s17.4 5.1 21.5 13.3zM265.2 208L240 157.7 214.8 208l50.3 0z"]
};
var UC = {
  prefix: "far",
  iconName: "sliders",
  icon: [512, 512, ["sliders-h"], "f1de", "M0 416c0 13.3 10.7 24 24 24l59.7 0c10.2 32.5 40.5 56 76.3 56s66.1-23.5 76.3-56L488 440c13.3 0 24-10.7 24-24s-10.7-24-24-24l-251.7 0c-10.2-32.5-40.5-56-76.3-56s-66.1 23.5-76.3 56L24 392c-13.3 0-24 10.7-24 24zm128 0a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zM320 256a32 32 0 1 1 64 0 32 32 0 1 1 -64 0zm32-80c-35.8 0-66.1 23.5-76.3 56L24 232c-13.3 0-24 10.7-24 24s10.7 24 24 24l251.7 0c10.2 32.5 40.5 56 76.3 56s66.1-23.5 76.3-56l59.7 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-59.7 0c-10.2-32.5-40.5-56-76.3-56zM192 128a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm76.3-56C258.1 39.5 227.8 16 192 16s-66.1 23.5-76.3 56L24 72C10.7 72 0 82.7 0 96s10.7 24 24 24l91.7 0c10.2 32.5 40.5 56 76.3 56s66.1-23.5 76.3-56L488 120c13.3 0 24-10.7 24-24s-10.7-24-24-24L268.3 72z"]
};
var qC = {
  prefix: "far",
  iconName: "align-center",
  icon: [448, 512, [], "f037", "M120 40c-13.3 0-24 10.7-24 24s10.7 24 24 24l208 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L120 40zM24 168c-13.3 0-24 10.7-24 24s10.7 24 24 24l400 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L24 168zM96 320c0 13.3 10.7 24 24 24l208 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-208 0c-13.3 0-24 10.7-24 24zM24 424c-13.3 0-24 10.7-24 24s10.7 24 24 24l400 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L24 424z"]
};
var KC = {
  prefix: "far",
  iconName: "ellipsis",
  icon: [448, 512, ["ellipsis-h"], "f141", "M432 256a48 48 0 1 1 -96 0 48 48 0 1 1 96 0zm-160 0a48 48 0 1 1 -96 0 48 48 0 1 1 96 0zM64 304a48 48 0 1 1 0-96 48 48 0 1 1 0 96z"]
};
var YC = {
  prefix: "far",
  iconName: "inbox",
  icon: [512, 512, [], "f01c", "M48 336l81.2 0 20.9 41.9c6.8 13.6 20.6 22.1 35.8 22.1l140.2 0c15.1 0 29-8.6 35.8-22.1L382.8 336l81.2 0 0 80c0 8.8-7.2 16-16 16L64 432c-8.8 0-16-7.2-16-16l0-80zm406.5-48l-76.6 0c-15.1 0-29 8.6-35.8 22.1L321.2 352l-130.3 0-20.9-41.9c-6.8-13.6-20.6-22.1-35.8-22.1l-76.6 0 49-195.9C108.2 85 114.6 80 122 80L390 80c7.3 0 13.7 5 15.5 12.1l49 195.9zM0 327.9L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-88.1c0-5.2-.6-10.4-1.9-15.5l-58-231.9C445 52 419.4 32 390 32L122 32C92.6 32 67 52 59.9 80.5L1.9 312.4C.6 317.4 0 322.6 0 327.9z"]
};
var GC = {
  prefix: "far",
  iconName: "link",
  icon: [640, 512, [128279, "chain"], "f0c1", "M580.3 267.2c56.2-56.2 56.2-147.3 0-203.5C526.8 10.2 440.9 7.3 383.9 57.2l-6.1 5.4c-10 8.7-11 23.9-2.3 33.9s23.9 11 33.9 2.3l6.1-5.4c38-33.2 95.2-31.3 130.9 4.4c37.4 37.4 37.4 98.1 0 135.6L433.1 346.6c-37.4 37.4-98.2 37.4-135.6 0c-35.7-35.7-37.6-92.9-4.4-130.9l4.7-5.4c8.7-10 7.7-25.1-2.3-33.9s-25.1-7.7-33.9 2.3l-4.7 5.4c-49.8 57-46.9 142.9 6.6 196.4c56.2 56.2 147.3 56.2 203.5 0L580.3 267.2zM59.7 244.8C3.5 301 3.5 392.1 59.7 448.2c53.6 53.6 139.5 56.4 196.5 6.5l6.1-5.4c10-8.7 11-23.9 2.3-33.9s-23.9-11-33.9-2.3l-6.1 5.4c-38 33.2-95.2 31.3-130.9-4.4c-37.4-37.4-37.4-98.1 0-135.6L207 165.4c37.4-37.4 98.1-37.4 135.6 0c35.7 35.7 37.6 92.9 4.4 130.9l-5.4 6.1c-8.7 10-7.7 25.1 2.3 33.9s25.1 7.7 33.9-2.3l5.4-6.1c49.9-57 47-142.9-6.5-196.5c-56.2-56.2-147.3-56.2-203.5 0L59.7 244.8z"]
};
var JC = {
  prefix: "far",
  iconName: "sidebar",
  icon: [512, 512, [], "e24e", "M224 80l0 352 224 0c8.8 0 16-7.2 16-16l0-320c0-8.8-7.2-16-16-16L224 80zM0 96C0 60.7 28.7 32 64 32l384 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zm64 24c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24s-10.7-24-24-24L88 96c-13.3 0-24 10.7-24 24zm24 72c-13.3 0-24 10.7-24 24s10.7 24 24 24l48 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-48 0zM64 312c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-48 0c-13.3 0-24 10.7-24 24z"]
};
var XC = {
  prefix: "far",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M136 32c13.3 0 24 10.7 24 24s-10.7 24-24 24L48 80l0 88c0 13.3-10.7 24-24 24s-24-10.7-24-24L0 56C0 42.7 10.7 32 24 32l112 0zM0 344c0-13.3 10.7-24 24-24s24 10.7 24 24l0 88 88 0c13.3 0 24 10.7 24 24s-10.7 24-24 24L24 480c-13.3 0-24-10.7-24-24L0 344zM424 32c13.3 0 24 10.7 24 24l0 112c0 13.3-10.7 24-24 24s-24-10.7-24-24l0-88-88 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l112 0zM400 344c0-13.3 10.7-24 24-24s24 10.7 24 24l0 112c0 13.3-10.7 24-24 24l-112 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l88 0 0-88z"]
};
var QC = {
  prefix: "far",
  iconName: "highlighter-line",
  icon: [576, 512, [], "e1af", "M169.9 330.6l-38.1 38.1 51.5 51.5 38.1-38.1c9-9 21.2-14.1 33.9-14.1l48 0 16.2-22.5-113-113L184 248.6l0 48c0 12.7-5.1 24.9-14.1 33.9zm178-24.6L502.8 90.2c.8-1.1 1.2-2.4 1.2-3.7c0-1.7-.7-3.3-1.9-4.5L470 49.9c-1.2-1.2-2.8-1.9-4.5-1.9c-1.3 0-2.6 .4-3.7 1.2L246 204.1 347.9 306zM303.4 416l-48 0-43.7 43.7c-10.7 10.7-26 14.1-39.5 10.1l-32.8 32.8c-6 6-14.1 9.4-22.6 9.4L32 512c-17.7 0-32-14.3-32-32l0-4.7c0-8.5 3.4-16.6 9.4-22.6l72.8-72.8c-4-13.6-.6-28.8 10.1-39.5L136 296.6l0-48c0-15.5 7.4-30 20-39L433.8 10.2C443 3.6 454.1 0 465.5 0c14.4 0 28.2 5.7 38.4 15.9l32.2 32.2c10.2 10.2 15.9 24 15.9 38.4c0 11.4-3.6 22.5-10.2 31.7L342.4 396c-9 12.6-23.5 20-39 20zm-190.7 1.3L65.9 464l44.1 0 24.7-24.7-22.1-22.1zM248 464l304 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-304 0c-13.3 0-24-10.7-24-24s10.7-24 24-24z"]
};
var ZC = {
  prefix: "far",
  iconName: "sun-bright",
  icon: [512, 512, ["sun-alt"], "e28f", "M280 24l0 64c0 13.3-10.7 24-24 24s-24-10.7-24-24l0-64c0-13.3 10.7-24 24-24s24 10.7 24 24zm157 84.9l-45.3 45.3c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9L403.1 75c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9zM108.9 75l45.3 45.3c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0L75 108.9c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0zM24 232l64 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-64 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm400 0l64 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-64 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zM154.2 391.8L108.9 437c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l45.3-45.3c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9zm237.6-33.9L437 403.1c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-45.3-45.3c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0zM280 424l0 64c0 13.3-10.7 24-24 24s-24-10.7-24-24l0-64c0-13.3 10.7-24 24-24s24 10.7 24 24zm40-168a64 64 0 1 0 -128 0 64 64 0 1 0 128 0zm-176 0a112 112 0 1 1 224 0 112 112 0 1 1 -224 0z"]
};
var eO = {
  prefix: "far",
  iconName: "triangle-exclamation",
  icon: [512, 512, [9888, "exclamation-triangle", "warning"], "f071", "M248.4 84.3c1.6-2.7 4.5-4.3 7.6-4.3s6 1.6 7.6 4.3L461.9 410c1.4 2.3 2.1 4.9 2.1 7.5c0 8-6.5 14.5-14.5 14.5l-387 0c-8 0-14.5-6.5-14.5-14.5c0-2.7 .7-5.3 2.1-7.5L248.4 84.3zm-41-25L9.1 385c-6 9.8-9.1 21-9.1 32.5C0 452 28 480 62.5 480l387 0c34.5 0 62.5-28 62.5-62.5c0-11.5-3.2-22.7-9.1-32.5L304.6 59.3C294.3 42.4 275.9 32 256 32s-38.3 10.4-48.6 27.3zM288 368a32 32 0 1 0 -64 0 32 32 0 1 0 64 0zm-8-184c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 96c0 13.3 10.7 24 24 24s24-10.7 24-24l0-96z"]
};
var tO = {
  prefix: "far",
  iconName: "align-right",
  icon: [448, 512, [], "f038", "M424 40c13.3 0 24 10.7 24 24s-10.7 24-24 24L184 88c-13.3 0-24-10.7-24-24s10.7-24 24-24l240 0zm0 128c13.3 0 24 10.7 24 24s-10.7 24-24 24L24 216c-13.3 0-24-10.7-24-24s10.7-24 24-24l400 0zm24 152c0 13.3-10.7 24-24 24l-240 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l240 0c13.3 0 24 10.7 24 24zM424 424c13.3 0 24 10.7 24 24s-10.7 24-24 24L24 472c-13.3 0-24-10.7-24-24s10.7-24 24-24l400 0z"]
};
var nO = Object.freeze(Object.defineProperty({
  __proto__: null,
  faAlignCenter: qC,
  faAlignLeft: jC,
  faAlignRight: tO,
  faAngleDown: iC,
  faAngleLeft: pC,
  faAngleRight: Vw,
  faAngleUp: uC,
  faArrowDownLong: Ww,
  faArrowDownToLine: yC,
  faArrowLeft: Gw,
  faArrowRotateLeft: Jw,
  faArrowRotateRight: Yw,
  faArrowUpArrowDown: vC,
  faArrowUpFromBracket: Bw,
  faArrowUpLong: Dw,
  faArrowUpRightFromSquare: zC,
  faBars: $w,
  faBold: FC,
  faBookFont: WC,
  faCalendarDays: SC,
  faCheck: hC,
  faCircle: qw,
  faCircleCheck: OC,
  faCircleDot: Rw,
  faCircleExclamation: IC,
  faCircleInfo: HC,
  faCircleNotch: NC,
  faClone: AC,
  faClosedCaptioning: eC,
  faClosedCaptioningSlash: mC,
  faCompress: DC,
  faCropSimple: Xw,
  faEllipsis: KC,
  faExpand: XC,
  faEye: MC,
  faEyeSlash: wC,
  faFile: TC,
  faFileLines: kC,
  faFilm: LC,
  faFolder: zw,
  faGlobe: $C,
  faGripDots: xC,
  faHighlighterLine: QC,
  faHouse: tC,
  faImage: CC,
  faInbox: YC,
  faInboxSolid: sC,
  faInfo: Pw,
  faItalic: BC,
  faLink: GC,
  faListUl: oC,
  faMinus: Qw,
  faMoon: dC,
  faMusic: fC,
  faPaintbrush: Fw,
  faPause: Uw,
  faPen: Kw,
  faPlay: rC,
  faPlus: lC,
  faPowerOff: Zw,
  faRotateLeft: Hw,
  faRotateRight: nC,
  faSidebar: JC,
  faSidebarFlip: PC,
  faSliders: UC,
  faSparkles: gC,
  faSquare: EC,
  faStar: jw,
  faSubtitles: VC,
  faSunBright: ZC,
  faTextSize: _C,
  faTrashCan: Iw,
  faTriangleExclamation: eO,
  faUnderline: RC,
  faVolume: bC,
  faVolumeXmark: aC,
  faXmark: cC
}, Symbol.toStringTag, { value: "Module" }));
function Vg(t10, e) {
  var n = Object.keys(t10);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t10);
    e && (i = i.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t10, s).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function pi(t10) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Vg(Object(n), true).forEach(function(i) {
      On(t10, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t10, Object.getOwnPropertyDescriptors(n)) : Vg(Object(n)).forEach(function(i) {
      Object.defineProperty(t10, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t10;
}
function iO(t10, e) {
  if (typeof t10 != "object" || !t10) return t10;
  var n = t10[Symbol.toPrimitive];
  if (n !== void 0) {
    var i = n.call(t10, e);
    if (typeof i != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t10);
}
function sO(t10) {
  var e = iO(t10, "string");
  return typeof e == "symbol" ? e : e + "";
}
function jc(t10) {
  "@babel/helpers - typeof";
  return jc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, jc(t10);
}
function On(t10, e, n) {
  return e = sO(e), e in t10 ? Object.defineProperty(t10, e, {
    value: n,
    enumerable: true,
    configurable: true,
    writable: true
  }) : t10[e] = n, t10;
}
function rO(t10, e) {
  if (t10 == null) return {};
  var n = {};
  for (var i in t10)
    if (Object.prototype.hasOwnProperty.call(t10, i)) {
      if (e.indexOf(i) >= 0) continue;
      n[i] = t10[i];
    }
  return n;
}
function oO(t10, e) {
  if (t10 == null) return {};
  var n = rO(t10, e), i, s;
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t10);
    for (s = 0; s < r.length; s++)
      i = r[s], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(t10, i) && (n[i] = t10[i]);
  }
  return n;
}
function mh(t10) {
  return aO(t10) || lO(t10) || cO(t10) || uO();
}
function aO(t10) {
  if (Array.isArray(t10)) return gh(t10);
}
function lO(t10) {
  if (typeof Symbol < "u" && t10[Symbol.iterator] != null || t10["@@iterator"] != null) return Array.from(t10);
}
function cO(t10, e) {
  if (t10) {
    if (typeof t10 == "string") return gh(t10, e);
    var n = Object.prototype.toString.call(t10).slice(8, -1);
    if (n === "Object" && t10.constructor && (n = t10.constructor.name), n === "Map" || n === "Set") return Array.from(t10);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return gh(t10, e);
  }
}
function gh(t10, e) {
  (e == null || e > t10.length) && (e = t10.length);
  for (var n = 0, i = new Array(e); n < e; n++) i[n] = t10[n];
  return i;
}
function uO() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var dO = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var Fv = { exports: {} };
(function(t10) {
  (function(e) {
    var n = function(b, x, k) {
      if (!c(x) || d(x) || f(x) || h10(x) || l(x))
        return x;
      var v, S = 0, w = 0;
      if (u(x))
        for (v = [], w = x.length; S < w; S++)
          v.push(n(b, x[S], k));
      else {
        v = {};
        for (var E in x)
          Object.prototype.hasOwnProperty.call(x, E) && (v[b(E, k)] = n(b, x[E], k));
      }
      return v;
    }, i = function(b, x) {
      x = x || {};
      var k = x.separator || "_", v = x.split || /(?=[A-Z])/;
      return b.split(v).join(k);
    }, s = function(b) {
      return p(b) ? b : (b = b.replace(/[\-_\s]+(.)?/g, function(x, k) {
        return k ? k.toUpperCase() : "";
      }), b.substr(0, 1).toLowerCase() + b.substr(1));
    }, r = function(b) {
      var x = s(b);
      return x.substr(0, 1).toUpperCase() + x.substr(1);
    }, o = function(b, x) {
      return i(b, x).toLowerCase();
    }, a = Object.prototype.toString, l = function(b) {
      return typeof b == "function";
    }, c = function(b) {
      return b === Object(b);
    }, u = function(b) {
      return a.call(b) == "[object Array]";
    }, d = function(b) {
      return a.call(b) == "[object Date]";
    }, f = function(b) {
      return a.call(b) == "[object RegExp]";
    }, h10 = function(b) {
      return a.call(b) == "[object Boolean]";
    }, p = function(b) {
      return b = b - 0, b === b;
    }, g = function(b, x) {
      var k = x && "process" in x ? x.process : x;
      return typeof k != "function" ? b : function(v, S) {
        return k(v, b, S);
      };
    }, m = {
      camelize: s,
      decamelize: o,
      pascalize: r,
      depascalize: o,
      camelizeKeys: function(b, x) {
        return n(g(s, x), b);
      },
      decamelizeKeys: function(b, x) {
        return n(g(o, x), b, x);
      },
      pascalizeKeys: function(b, x) {
        return n(g(r, x), b);
      },
      depascalizeKeys: function() {
        return this.decamelizeKeys.apply(this, arguments);
      }
    };
    t10.exports ? t10.exports = m : e.humps = m;
  })(dO);
})(Fv);
var fO = Fv.exports;
var hO = ["class", "style"];
function pO(t10) {
  return t10.split(";").map(function(e) {
    return e.trim();
  }).filter(function(e) {
    return e;
  }).reduce(function(e, n) {
    var i = n.indexOf(":"), s = fO.camelize(n.slice(0, i)), r = n.slice(i + 1).trim();
    return e[s] = r, e;
  }, {});
}
function mO(t10) {
  return t10.split(/\s+/).reduce(function(e, n) {
    return e[n] = true, e;
  }, {});
}
function Fp(t10) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof t10 == "string")
    return t10;
  var i = (t10.children || []).map(function(l) {
    return Fp(l);
  }), s = Object.keys(t10.attributes || {}).reduce(function(l, c) {
    var u = t10.attributes[c];
    switch (c) {
      case "class":
        l.class = mO(u);
        break;
      case "style":
        l.style = pO(u);
        break;
      default:
        l.attrs[c] = u;
    }
    return l;
  }, {
    attrs: {},
    class: {},
    style: {}
  });
  n.class;
  var r = n.style, o = r === void 0 ? {} : r, a = oO(n, hO);
  return h(t10.tag, pi(pi(pi({}, e), {}, {
    class: s.class,
    style: pi(pi({}, s.style), o)
  }, s.attrs), a), i);
}
var Vv = false;
try {
  Vv = false;
} catch {
}
function gO() {
  if (!Vv && console && typeof console.error == "function") {
    var t10;
    (t10 = console).error.apply(t10, arguments);
  }
}
function _a(t10, e) {
  return Array.isArray(e) && e.length > 0 || !Array.isArray(e) && e ? On({}, t10, e) : {};
}
function bO(t10) {
  var e, n = (e = {
    "fa-spin": t10.spin,
    "fa-pulse": t10.pulse,
    "fa-fw": t10.fixedWidth,
    "fa-border": t10.border,
    "fa-li": t10.listItem,
    "fa-inverse": t10.inverse,
    "fa-flip": t10.flip === true,
    "fa-flip-horizontal": t10.flip === "horizontal" || t10.flip === "both",
    "fa-flip-vertical": t10.flip === "vertical" || t10.flip === "both"
  }, On(On(On(On(On(On(On(On(On(On(e, "fa-".concat(t10.size), t10.size !== null), "fa-rotate-".concat(t10.rotation), t10.rotation !== null), "fa-pull-".concat(t10.pull), t10.pull !== null), "fa-swap-opacity", t10.swapOpacity), "fa-bounce", t10.bounce), "fa-shake", t10.shake), "fa-beat", t10.beat), "fa-fade", t10.fade), "fa-beat-fade", t10.beatFade), "fa-flash", t10.flash), On(On(e, "fa-spin-pulse", t10.spinPulse), "fa-spin-reverse", t10.spinReverse));
  return Object.keys(n).map(function(i) {
    return n[i] ? i : null;
  }).filter(function(i) {
    return i;
  });
}
function Bg(t10) {
  if (t10 && jc(t10) === "object" && t10.prefix && t10.iconName && t10.icon)
    return t10;
  if (zc.icon)
    return zc.icon(t10);
  if (t10 === null)
    return null;
  if (jc(t10) === "object" && t10.prefix && t10.iconName)
    return t10;
  if (Array.isArray(t10) && t10.length === 2)
    return {
      prefix: t10[0],
      iconName: t10[1]
    };
  if (typeof t10 == "string")
    return {
      prefix: "fas",
      iconName: t10
    };
}
var yO = defineComponent({
  name: "FontAwesomeIcon",
  props: {
    border: {
      type: Boolean,
      default: false
    },
    fixedWidth: {
      type: Boolean,
      default: false
    },
    flip: {
      type: [Boolean, String],
      default: false,
      validator: function(e) {
        return [true, false, "horizontal", "vertical", "both"].indexOf(e) > -1;
      }
    },
    icon: {
      type: [Object, Array, String],
      required: true
    },
    mask: {
      type: [Object, Array, String],
      default: null
    },
    maskId: {
      type: String,
      default: null
    },
    listItem: {
      type: Boolean,
      default: false
    },
    pull: {
      type: String,
      default: null,
      validator: function(e) {
        return ["right", "left"].indexOf(e) > -1;
      }
    },
    pulse: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: [String, Number],
      default: null,
      validator: function(e) {
        return [90, 180, 270].indexOf(Number.parseInt(e, 10)) > -1;
      }
    },
    swapOpacity: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: null,
      validator: function(e) {
        return ["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"].indexOf(e) > -1;
      }
    },
    spin: {
      type: Boolean,
      default: false
    },
    transform: {
      type: [String, Object],
      default: null
    },
    symbol: {
      type: [Boolean, String],
      default: false
    },
    title: {
      type: String,
      default: null
    },
    titleId: {
      type: String,
      default: null
    },
    inverse: {
      type: Boolean,
      default: false
    },
    bounce: {
      type: Boolean,
      default: false
    },
    shake: {
      type: Boolean,
      default: false
    },
    beat: {
      type: Boolean,
      default: false
    },
    fade: {
      type: Boolean,
      default: false
    },
    beatFade: {
      type: Boolean,
      default: false
    },
    flash: {
      type: Boolean,
      default: false
    },
    spinPulse: {
      type: Boolean,
      default: false
    },
    spinReverse: {
      type: Boolean,
      default: false
    }
  },
  setup: function(e, n) {
    var i = n.attrs, s = computed(function() {
      return Bg(e.icon);
    }), r = computed(function() {
      return _a("classes", bO(e));
    }), o = computed(function() {
      return _a("transform", typeof e.transform == "string" ? zc.transform(e.transform) : e.transform);
    }), a = computed(function() {
      return _a("mask", Bg(e.mask));
    }), l = computed(function() {
      return Nw(s.value, pi(pi(pi(pi({}, r.value), o.value), a.value), {}, {
        symbol: e.symbol,
        title: e.title,
        titleId: e.titleId,
        maskId: e.maskId
      }));
    });
    watch(l, function(u) {
      if (!u)
        return gO("Could not find one or more icon(s)", s.value, a.value);
    }, {
      immediate: true
    });
    var c = computed(function() {
      return l.value ? Fp(l.value.abstract[0], {}, i) : null;
    });
    return function() {
      return c.value;
    };
  }
});
defineComponent({
  name: "FontAwesomeLayers",
  props: {
    fixedWidth: {
      type: Boolean,
      default: false
    }
  },
  setup: function(e, n) {
    var i = n.slots, s = Rv.familyPrefix, r = computed(function() {
      return ["".concat(s, "-layers")].concat(mh(e.fixedWidth ? ["".concat(s, "-fw")] : []));
    });
    return function() {
      return h("div", {
        class: r.value
      }, i.default ? i.default() : []);
    };
  }
});
defineComponent({
  name: "FontAwesomeLayersText",
  props: {
    value: {
      type: [String, Number],
      default: ""
    },
    transform: {
      type: [String, Object],
      default: null
    },
    counter: {
      type: Boolean,
      default: false
    },
    position: {
      type: String,
      default: null,
      validator: function(e) {
        return ["bottom-left", "bottom-right", "top-left", "top-right"].indexOf(e) > -1;
      }
    }
  },
  setup: function(e, n) {
    var i = n.attrs, s = Rv.familyPrefix, r = computed(function() {
      return _a("classes", [].concat(mh(e.counter ? ["".concat(s, "-layers-counter")] : []), mh(e.position ? ["".concat(s, "-layers-").concat(e.position)] : [])));
    }), o = computed(function() {
      return _a("transform", typeof e.transform == "string" ? zc.transform(e.transform) : e.transform);
    }), a = computed(function() {
      var c = Lw(e.value.toString(), pi(pi({}, o.value), r.value)), u = c.abstract;
      return e.counter && (u[0].attributes.class = u[0].attributes.class.replace("fa-layers-text", "")), u[0];
    }), l = computed(function() {
      return Fp(a.value, {}, i);
    });
    return function() {
      return l.value;
    };
  }
});
var Me = (t10, e) => {
  const n = t10.__vccOpts || t10;
  for (const [i, s] of e)
    n[i] = s;
  return n;
};
var vO = Object.assign({ name: "mn-icon" }, {
  __name: "icon",
  props: {
    icon: {
      type: String,
      required: true
    },
    color: {
      type: String,
      validator: (t10) => ["neutral", "accent", "success", "warning", "danger"].includes(t10)
    },
    label: String,
    mirror: Boolean
  },
  setup(t10) {
    const e = t10, n = computed(() => e.icon.split(" ").length > 1 && ["fas", "far", "fab", "fal", "fat", "fad", "fass", "fasr", "fasl", "fast", "fasd"].includes(e.icon.split(" ")[0]) ? e.icon.split(" ")[0] : "fas"), i = computed(() => e.icon.split(" ").length > 1 ? e.icon.split(" ")[1] : e.icon);
    return (s, r) => (openBlock(), createBlock(unref(yO), {
      class: normalizeClass(["fa-fw mn-icon", [t10.color, { "-mirror": t10.mirror }]]),
      icon: [n.value, i.value],
      title: t10.label || null
    }, null, 8, ["class", "icon", "title"]));
  }
});
var ft = Me(vO, [["__scopeId", "data-v-e67a44ed"]]);
function Ie(t10) {
  return typeof t10 != "string" ? t10 : t10.charAt(0).toUpperCase() + t10.slice(1);
}
function xO(t10) {
  return typeof t10 != "string" ? t10 : t10.split(" ").map((i) => i.charAt(0).toUpperCase()).slice(0, 3).join("");
}
function Na(t10) {
  const e = ["bytes", "KB", "MB", "GB", "TB"], n = Math.floor(Math.log(t10) / Math.log(1e3));
  return `${(t10 / Math.pow(1e3, n)).toFixed(n < 2 ? 0 : n < 3 ? 1 : 2)} ${e[n]}`;
}
var kO = ["type", "aria-labelledby", "aria-busy", "title", "disabled"];
var SO = {
  class: "mn-button-loader",
  "aria-hidden": "true"
};
var wO = ["id"];
var CO = { key: 0 };
var OO = {
  key: 0,
  class: "mn-button-label",
  "aria-hidden": "true"
};
var EO = Object.assign({ name: "mn-button" }, {
  __name: "button",
  props: {
    label: {
      type: [String, Number],
      required: true
    },
    type: {
      type: String,
      default: "button",
      validator: (t10) => ["button", "submit", "reset"].includes(String(t10))
    },
    variant: {
      type: String,
      default: "full",
      validator: (t10) => ["full", "muted", "border", "text"].includes(String(t10))
    },
    color: {
      type: String,
      default: "accent",
      validator: (t10) => ["accent", "neutral", "danger"].includes(String(t10))
    },
    icon: String,
    mirror: Boolean,
    inline: Boolean,
    fluid: Boolean,
    wide: Boolean,
    pill: Boolean,
    pending: Boolean,
    disabled: Boolean,
    labelless: Boolean
  },
  setup(t10) {
    const e = useId();
    return (n, i) => (openBlock(), createElementBlock("button", {
      class: normalizeClass(["mn-button", [
        t10.variant,
        t10.color,
        { "-wide": t10.wide, "-pill": t10.pill, "-pending": t10.pending, "-labelless": t10.labelless && t10.icon, "-inline": t10.inline, "-fluid": t10.fluid, "-wrapper": !!n.$slots.default }
      ]]),
      type: t10.type,
      "aria-labelledby": n.$slots.default ? null : unref(e),
      "aria-busy": t10.pending || null,
      title: t10.labelless && t10.icon && unref(Ie)(t10.label) || null,
      disabled: t10.disabled || t10.pending
    }, [
      withDirectives(createBaseVNode("span", SO, [
        createVNode(ft, {
          icon: "far circle-notch",
          spin: ""
        })
      ], 512), [
        [vShow, t10.pending]
      ]),
      renderSlot(n.$slots, "default", {}, () => [
        createBaseVNode("span", {
          id: unref(e),
          hidden: ""
        }, toDisplayString(t10.label), 9, wO),
        renderSlot(n.$slots, "start", {}, () => [
          t10.icon ? (openBlock(), createElementBlock("span", CO, [
            createVNode(ft, {
              class: "mn-button-icon",
              "aria-hidden": "true",
              icon: t10.icon,
              mirror: t10.mirror
            }, null, 8, ["icon", "mirror"])
          ])) : createCommentVNode("", true)
        ]),
        !t10.labelless || t10.labelless && !t10.icon && !n.$slots.start ? (openBlock(), createElementBlock("span", OO, toDisplayString(t10.inline ? t10.label : unref(Ie)(t10.label)), 1)) : createCommentVNode("", true)
      ])
    ], 10, kO));
  }
});
var me = Me(EO, [["__scopeId", "data-v-641d1165"]]);
var MO = ["href", "aria-labelledby", "title"];
var TO = ["id"];
var AO = { key: 0 };
var _O = {
  key: 1,
  class: "mn-link-label",
  "aria-hidden": "true"
};
var NO = ["id"];
var LO = { key: 0 };
var IO = {
  key: 0,
  class: "mn-link-label",
  "aria-hidden": "true"
};
var PO = Object.assign({ name: "mn-link" }, {
  __name: "link",
  props: {
    label: {
      type: [String, Number],
      required: true
    },
    path: {
      type: String,
      required: true
    },
    variant: {
      type: String,
      default: "full",
      validator: (t10) => ["full", "muted", "border", "text"].includes(String(t10))
    },
    color: {
      type: String,
      default: "accent",
      validator: (t10) => ["accent", "neutral", "danger"].includes(String(t10))
    },
    icon: String,
    mirror: Boolean,
    inline: Boolean,
    wide: Boolean,
    pill: Boolean,
    external: Boolean,
    labelless: Boolean,
    fluid: Boolean
  },
  setup(t10) {
    const e = useRoute(), n = t10, i = useId(), s = computed(() => n.path === "/" ? e.path === n.path : e.path.startsWith(n.path));
    return (r, o) => {
      const a = resolveComponent("router-link");
      return t10.path.startsWith("/") ? (openBlock(), createBlock(a, {
        key: 1,
        type: "link",
        class: normalizeClass(["mn-link", [
          t10.variant,
          t10.color,
          { "-wide": t10.wide, "-pill": t10.pill, "-labelless": t10.labelless && t10.icon, "-inline": t10.inline, "-fluid": t10.fluid, "-wrapper": !!r.$slots.default, "-active": s.value }
        ]]),
        to: t10.path,
        "aria-labelledby": r.$slots.default ? null : unref(i),
        title: t10.labelless && t10.icon && unref(Ie)(t10.label) || null
      }, {
        default: withCtx(() => [
          renderSlot(r.$slots, "default", {}, () => [
            createBaseVNode("span", {
              id: `${unref(i)}`,
              hidden: ""
            }, toDisplayString(t10.label), 9, NO),
            renderSlot(r.$slots, "start", {}, () => [
              t10.icon ? (openBlock(), createElementBlock("span", LO, [
                createVNode(ft, {
                  class: "mn-link-icon",
                  "aria-hidden": "true",
                  icon: t10.icon,
                  mirror: t10.mirror
                }, null, 8, ["icon", "mirror"])
              ])) : createCommentVNode("", true)
            ], true),
            !t10.labelless || t10.labelless && !t10.icon && !r.$slots.start ? (openBlock(), createElementBlock("span", IO, toDisplayString(t10.inline ? t10.label : unref(Ie)(t10.label)), 1)) : createCommentVNode("", true)
          ], true)
        ]),
        _: 3
      }, 8, ["class", "to", "aria-labelledby", "title"])) : (openBlock(), createElementBlock("a", {
        key: 0,
        type: "link",
        class: normalizeClass(["mn-link", [
          t10.variant,
          t10.color,
          { "-wide": t10.wide, "-pill": t10.pill, "-labelless": t10.labelless && t10.icon, "-inline": t10.inline, "-fluid": t10.fluid, "-wrapper": !!r.$slots.default }
        ]]),
        href: t10.path,
        "aria-labelledby": r.$slots.default ? null : unref(i),
        title: t10.labelless && t10.icon && unref(Ie)(t10.label) || null
      }, [
        renderSlot(r.$slots, "default", {}, () => [
          createBaseVNode("span", {
            id: unref(i),
            hidden: ""
          }, toDisplayString(t10.label), 9, TO),
          t10.external ? createCommentVNode("", true) : renderSlot(r.$slots, "start", { key: 0 }, () => [
            t10.icon ? (openBlock(), createElementBlock("span", AO, [
              createVNode(ft, {
                class: "mn-link-icon",
                "aria-hidden": "true",
                icon: t10.icon,
                mirror: t10.mirror
              }, null, 8, ["icon", "mirror"])
            ])) : createCommentVNode("", true)
          ], true),
          t10.external || !t10.labelless || t10.labelless && !t10.icon && !r.$slots.start ? (openBlock(), createElementBlock("span", _O, toDisplayString(t10.inline ? t10.label : unref(Ie)(t10.label)), 1)) : createCommentVNode("", true),
          t10.external ? (openBlock(), createBlock(ft, {
            key: 2,
            class: "mn-link-icon",
            "aria-hidden": "true",
            icon: "far arrow-up-right-from-square",
            mirror: ""
          })) : createCommentVNode("", true)
        ], true)
      ], 10, MO));
    };
  }
});
var ds = Me(PO, [["__scopeId", "data-v-8bff38c4"]]);
function Hc(t10) {
  const e = Math.floor(t10 / 3600), n = Math.floor((t10 - e * 3600) / 60), i = Math.floor(t10 - e * 3600 - n * 60);
  return `${e ? `${e.toString().padStart(2, "0")}:` : ""}${n ? `${n.toString().padStart(2, "0")}:` : "00:"}${i.toString().padStart(2, "0")}`;
}
function hn(t10) {
  return typeof t10 == "function";
}
function Bv(t10) {
  return t10 == null;
}
var er = (t10) => t10 !== null && !!t10 && typeof t10 == "object" && !Array.isArray(t10);
function Vp(t10) {
  return Number(t10) >= 0;
}
function DO(t10) {
  const e = parseFloat(t10);
  return isNaN(e) ? t10 : e;
}
function $O(t10) {
  return typeof t10 == "object" && t10 !== null;
}
function RO(t10) {
  return t10 == null ? t10 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(t10);
}
function zg(t10) {
  if (!$O(t10) || RO(t10) !== "[object Object]")
    return false;
  if (Object.getPrototypeOf(t10) === null)
    return true;
  let e = t10;
  for (; Object.getPrototypeOf(e) !== null; )
    e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t10) === e;
}
function el(t10, e) {
  return Object.keys(e).forEach((n) => {
    if (zg(e[n]) && zg(t10[n])) {
      t10[n] || (t10[n] = {}), el(t10[n], e[n]);
      return;
    }
    t10[n] = e[n];
  }), t10;
}
function ga(t10) {
  const e = t10.split(".");
  if (!e.length)
    return "";
  let n = String(e[0]);
  for (let i = 1; i < e.length; i++) {
    if (Vp(e[i])) {
      n += `[${e[i]}]`;
      continue;
    }
    n += `.${e[i]}`;
  }
  return n;
}
var zv = {};
function vt(t10, e) {
  VO(t10, e), zv[t10] = e;
}
function FO(t10) {
  return zv[t10];
}
function VO(t10, e) {
  if (!hn(e))
    throw new Error(`Extension Error: The validator '${t10}' must be a function.`);
}
function jg(t10, e, n) {
  typeof n.value == "object" && (n.value = ct(n.value)), !n.enumerable || n.get || n.set || !n.configurable || !n.writable || e === "__proto__" ? Object.defineProperty(t10, e, n) : t10[e] = n.value;
}
function ct(t10) {
  if (typeof t10 != "object") return t10;
  var e = 0, n, i, s, r = Object.prototype.toString.call(t10);
  if (r === "[object Object]" ? s = Object.create(t10.__proto__ || null) : r === "[object Array]" ? s = Array(t10.length) : r === "[object Set]" ? (s = /* @__PURE__ */ new Set(), t10.forEach(function(o) {
    s.add(ct(o));
  })) : r === "[object Map]" ? (s = /* @__PURE__ */ new Map(), t10.forEach(function(o, a) {
    s.set(ct(a), ct(o));
  })) : r === "[object Date]" ? s = /* @__PURE__ */ new Date(+t10) : r === "[object RegExp]" ? s = new RegExp(t10.source, t10.flags) : r === "[object DataView]" ? s = new t10.constructor(ct(t10.buffer)) : r === "[object ArrayBuffer]" ? s = t10.slice(0) : r.slice(-6) === "Array]" && (s = new t10.constructor(t10)), s) {
    for (i = Object.getOwnPropertySymbols(t10); e < i.length; e++)
      jg(s, i[e], Object.getOwnPropertyDescriptor(t10, i[e]));
    for (e = 0, i = Object.getOwnPropertyNames(t10); e < i.length; e++)
      Object.hasOwnProperty.call(s, n = i[e]) && s[n] === t10[n] || jg(s, n, Object.getOwnPropertyDescriptor(t10, n));
  }
  return s || t10;
}
var ad = Symbol("vee-validate-form");
var BO = Symbol("vee-validate-form-context");
var zO = Symbol("vee-validate-field-instance");
var Hg = Symbol("Default empty value");
var jv = typeof window < "u";
function bh(t10) {
  return hn(t10) && !!t10.__locatorRef;
}
function gi(t10) {
  return !!t10 && hn(t10.parse) && t10.__type === "VVTypedSchema";
}
function Wc(t10) {
  return !!t10 && hn(t10.validate);
}
function Hv(t10) {
  return t10 === "checkbox" || t10 === "radio";
}
function jO(t10) {
  return er(t10) || Array.isArray(t10);
}
function HO(t10) {
  return Array.isArray(t10) ? t10.length === 0 : er(t10) && Object.keys(t10).length === 0;
}
function ld(t10) {
  return /^\[.+\]$/i.test(t10);
}
function WO(t10) {
  return Wv(t10) && t10.multiple;
}
function Wv(t10) {
  return t10.tagName === "SELECT";
}
function UO(t10) {
  return Uv(t10) && t10.target && "submit" in t10.target;
}
function Uv(t10) {
  return t10 ? !!(typeof Event < "u" && hn(Event) && t10 instanceof Event || t10 && t10.srcElement) : false;
}
function gn(t10, e) {
  if (t10 === e)
    return true;
  if (t10 && e && typeof t10 == "object" && typeof e == "object") {
    if (t10.constructor !== e.constructor)
      return false;
    var n, i, s;
    if (Array.isArray(t10)) {
      if (n = t10.length, n != e.length)
        return false;
      for (i = n; i-- !== 0; )
        if (!gn(t10[i], e[i]))
          return false;
      return true;
    }
    if (t10 instanceof Map && e instanceof Map) {
      if (t10.size !== e.size)
        return false;
      for (i of t10.entries())
        if (!e.has(i[0]))
          return false;
      for (i of t10.entries())
        if (!gn(i[1], e.get(i[0])))
          return false;
      return true;
    }
    if (Ug(t10) && Ug(e))
      return !(t10.size !== e.size || t10.name !== e.name || t10.lastModified !== e.lastModified || t10.type !== e.type);
    if (t10 instanceof Set && e instanceof Set) {
      if (t10.size !== e.size)
        return false;
      for (i of t10.entries())
        if (!e.has(i[0]))
          return false;
      return true;
    }
    if (ArrayBuffer.isView(t10) && ArrayBuffer.isView(e)) {
      if (n = t10.length, n != e.length)
        return false;
      for (i = n; i-- !== 0; )
        if (t10[i] !== e[i])
          return false;
      return true;
    }
    if (t10.constructor === RegExp)
      return t10.source === e.source && t10.flags === e.flags;
    if (t10.valueOf !== Object.prototype.valueOf)
      return t10.valueOf() === e.valueOf();
    if (t10.toString !== Object.prototype.toString)
      return t10.toString() === e.toString();
    if (s = Object.keys(t10), n = s.length - Wg(t10, s), n !== Object.keys(e).length - Wg(e, Object.keys(e)))
      return false;
    for (i = n; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(e, s[i]))
        return false;
    for (i = n; i-- !== 0; ) {
      var r = s[i];
      if (!gn(t10[r], e[r]))
        return false;
    }
    return true;
  }
  return t10 !== t10 && e !== e;
}
function Wg(t10, e) {
  let n = 0;
  for (let s = e.length; s-- !== 0; ) {
    var i = e[s];
    t10[i] === void 0 && n++;
  }
  return n;
}
function Ug(t10) {
  return jv ? t10 instanceof File : false;
}
function Bp(t10) {
  return ld(t10) ? t10.replace(/\[|\]/gi, "") : t10;
}
function _n(t10, e, n) {
  return t10 ? ld(e) ? t10[Bp(e)] : (e || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((s, r) => jO(s) && r in s ? s[r] : n, t10) : n;
}
function Ei(t10, e, n) {
  if (ld(e)) {
    t10[Bp(e)] = n;
    return;
  }
  const i = e.split(/\.|\[(\d+)\]/).filter(Boolean);
  let s = t10;
  for (let r = 0; r < i.length; r++) {
    if (r === i.length - 1) {
      s[i[r]] = n;
      return;
    }
    (!(i[r] in s) || Bv(s[i[r]])) && (s[i[r]] = Vp(i[r + 1]) ? [] : {}), s = s[i[r]];
  }
}
function ef(t10, e) {
  if (Array.isArray(t10) && Vp(e)) {
    t10.splice(Number(e), 1);
    return;
  }
  er(t10) && delete t10[e];
}
function qg(t10, e) {
  if (ld(e)) {
    delete t10[Bp(e)];
    return;
  }
  const n = e.split(/\.|\[(\d+)\]/).filter(Boolean);
  let i = t10;
  for (let r = 0; r < n.length; r++) {
    if (r === n.length - 1) {
      ef(i, n[r]);
      break;
    }
    if (!(n[r] in i) || Bv(i[n[r]]))
      break;
    i = i[n[r]];
  }
  const s = n.map((r, o) => _n(t10, n.slice(0, o).join(".")));
  for (let r = s.length - 1; r >= 0; r--)
    if (HO(s[r])) {
      if (r === 0) {
        ef(t10, n[0]);
        continue;
      }
      ef(s[r - 1], n[r - 1]);
    }
}
function Mn(t10) {
  return Object.keys(t10);
}
function zp(t10, e = void 0) {
  const n = getCurrentInstance();
  return (n == null ? void 0 : n.provides[t10]) || inject(t10, e);
}
function qO(t10) {
  warn(`[vee-validate]: ${t10}`);
}
function Kg(t10, e, n) {
  if (Array.isArray(t10)) {
    const i = [...t10], s = i.findIndex((r) => gn(r, e));
    return s >= 0 ? i.splice(s, 1) : i.push(e), i;
  }
  return gn(t10, e) ? n : e;
}
function KO(t10, e) {
  let n, i;
  return function(...s) {
    const r = this;
    return n || (n = true, setTimeout(() => n = false, e), i = t10.apply(r, s)), i;
  };
}
function Yg(t10, e = 0) {
  let n = null, i = [];
  return function(...s) {
    return n && clearTimeout(n), n = setTimeout(() => {
      const r = t10(...s);
      i.forEach((o) => o(r)), i = [];
    }, e), new Promise((r) => i.push(r));
  };
}
function YO(t10, e) {
  return er(e) && e.number ? DO(t10) : t10;
}
function yh(t10, e) {
  let n;
  return async function(...s) {
    const r = t10(...s);
    n = r;
    const o = await r;
    return r !== n ? o : (n = void 0, e(o, s));
  };
}
function vh(t10) {
  return Array.isArray(t10) ? t10 : t10 ? [t10] : [];
}
function zl(t10, e) {
  const n = {};
  for (const i in t10)
    e.includes(i) || (n[i] = t10[i]);
  return n;
}
function GO(t10) {
  let e = null, n = [];
  return function(...i) {
    const s = nextTick(() => {
      if (e !== s)
        return;
      const r = t10(...i);
      n.forEach((o) => o(r)), n = [], e = null;
    });
    return e = s, new Promise((r) => n.push(r));
  };
}
function tf(t10) {
  if (qv(t10))
    return t10._value;
}
function qv(t10) {
  return "_value" in t10;
}
function JO(t10) {
  return t10.type === "number" || t10.type === "range" ? Number.isNaN(t10.valueAsNumber) ? t10.value : t10.valueAsNumber : t10.value;
}
function Uc(t10) {
  if (!Uv(t10))
    return t10;
  const e = t10.target;
  if (Hv(e.type) && qv(e))
    return tf(e);
  if (e.type === "file" && e.files) {
    const n = Array.from(e.files);
    return e.multiple ? n : n[0];
  }
  if (WO(e))
    return Array.from(e.options).filter((n) => n.selected && !n.disabled).map(tf);
  if (Wv(e)) {
    const n = Array.from(e.options).find((i) => i.selected);
    return n ? tf(n) : e.value;
  }
  return JO(e);
}
function Kv(t10) {
  const e = {};
  return Object.defineProperty(e, "_$$isNormalized", {
    value: true,
    writable: false,
    enumerable: false,
    configurable: false
  }), t10 ? er(t10) && t10._$$isNormalized ? t10 : er(t10) ? Object.keys(t10).reduce((n, i) => {
    const s = XO(t10[i]);
    return t10[i] !== false && (n[i] = Gg(s)), n;
  }, e) : typeof t10 != "string" ? e : t10.split("|").reduce((n, i) => {
    const s = QO(i);
    return s.name && (n[s.name] = Gg(s.params)), n;
  }, e) : e;
}
function XO(t10) {
  return t10 === true ? [] : Array.isArray(t10) || er(t10) ? t10 : [t10];
}
function Gg(t10) {
  const e = (n) => typeof n == "string" && n[0] === "@" ? ZO(n.slice(1)) : n;
  return Array.isArray(t10) ? t10.map(e) : t10 instanceof RegExp ? [t10] : Object.keys(t10).reduce((n, i) => (n[i] = e(t10[i]), n), {});
}
var QO = (t10) => {
  let e = [];
  const n = t10.split(":")[0];
  return t10.includes(":") && (e = t10.split(":").slice(1).join(":").split(",")), { name: n, params: e };
};
function ZO(t10) {
  const e = (n) => {
    var i;
    return (i = _n(n, t10)) !== null && i !== void 0 ? i : n[t10];
  };
  return e.__locatorRef = t10, e;
}
function eE(t10) {
  return Array.isArray(t10) ? t10.filter(bh) : Mn(t10).filter((e) => bh(t10[e])).map((e) => t10[e]);
}
var tE = {
  generateMessage: ({ field: t10 }) => `${t10} is not valid.`,
  bails: true,
  validateOnBlur: true,
  validateOnChange: true,
  validateOnInput: false,
  validateOnModelUpdate: true
};
var nE = Object.assign({}, tE);
var ba = () => nE;
async function Yv(t10, e, n = {}) {
  const i = n == null ? void 0 : n.bails, s = {
    name: (n == null ? void 0 : n.name) || "{field}",
    rules: e,
    label: n == null ? void 0 : n.label,
    bails: i ?? true,
    formData: (n == null ? void 0 : n.values) || {}
  }, r = await iE(s, t10);
  return Object.assign(Object.assign({}, r), { valid: !r.errors.length });
}
async function iE(t10, e) {
  const n = t10.rules;
  if (gi(n) || Wc(n))
    return rE(e, Object.assign(Object.assign({}, t10), { rules: n }));
  if (hn(n) || Array.isArray(n)) {
    const a = {
      field: t10.label || t10.name,
      name: t10.name,
      label: t10.label,
      form: t10.formData,
      value: e
    }, l = Array.isArray(n) ? n : [n], c = l.length, u = [];
    for (let d = 0; d < c; d++) {
      const f = l[d], h10 = await f(e, a);
      if (!(typeof h10 != "string" && !Array.isArray(h10) && h10)) {
        if (Array.isArray(h10))
          u.push(...h10);
        else {
          const g = typeof h10 == "string" ? h10 : Jv(a);
          u.push(g);
        }
        if (t10.bails)
          return {
            errors: u
          };
      }
    }
    return {
      errors: u
    };
  }
  const i = Object.assign(Object.assign({}, t10), { rules: Kv(n) }), s = [], r = Object.keys(i.rules), o = r.length;
  for (let a = 0; a < o; a++) {
    const l = r[a], c = await oE(i, e, {
      name: l,
      params: i.rules[l]
    });
    if (c.error && (s.push(c.error), t10.bails))
      return {
        errors: s
      };
  }
  return {
    errors: s
  };
}
function sE(t10) {
  return !!t10 && t10.name === "ValidationError";
}
function Gv(t10) {
  return {
    __type: "VVTypedSchema",
    async parse(n, i) {
      var s;
      try {
        return {
          output: await t10.validate(n, { abortEarly: false, context: (i == null ? void 0 : i.formData) || {} }),
          errors: []
        };
      } catch (r) {
        if (!sE(r))
          throw r;
        if (!(!((s = r.inner) === null || s === void 0) && s.length) && r.errors.length)
          return { errors: [{ path: r.path, errors: r.errors }] };
        const o = r.inner.reduce((a, l) => {
          const c = l.path || "";
          return a[c] || (a[c] = { errors: [], path: c }), a[c].errors.push(...l.errors), a;
        }, {});
        return { errors: Object.values(o) };
      }
    }
  };
}
async function rE(t10, e) {
  const i = await (gi(e.rules) ? e.rules : Gv(e.rules)).parse(t10, { formData: e.formData }), s = [];
  for (const r of i.errors)
    r.errors.length && s.push(...r.errors);
  return {
    value: i.value,
    errors: s
  };
}
async function oE(t10, e, n) {
  const i = FO(n.name);
  if (!i)
    throw new Error(`No such validator '${n.name}' exists.`);
  const s = aE(n.params, t10.formData), r = {
    field: t10.label || t10.name,
    name: t10.name,
    label: t10.label,
    value: e,
    form: t10.formData,
    rule: Object.assign(Object.assign({}, n), { params: s })
  }, o = await i(e, s, r);
  return typeof o == "string" ? {
    error: o
  } : {
    error: o ? void 0 : Jv(r)
  };
}
function Jv(t10) {
  const e = ba().generateMessage;
  return e ? e(t10) : "Field is invalid";
}
function aE(t10, e) {
  const n = (i) => bh(i) ? i(e) : i;
  return Array.isArray(t10) ? t10.map(n) : Object.keys(t10).reduce((i, s) => (i[s] = n(t10[s]), i), {});
}
async function lE(t10, e) {
  const i = await (gi(t10) ? t10 : Gv(t10)).parse(ct(e), { formData: ct(e) }), s = {}, r = {};
  for (const o of i.errors) {
    const a = o.errors, l = (o.path || "").replace(/\["(\d+)"\]/g, (c, u) => `[${u}]`);
    s[l] = { valid: !a.length, errors: a }, a.length && (r[l] = a[0]);
  }
  return {
    valid: !i.errors.length,
    results: s,
    errors: r,
    values: i.value,
    source: "schema"
  };
}
async function cE(t10, e, n) {
  const s = Mn(t10).map(async (c) => {
    var u, d, f;
    const h10 = (u = n == null ? void 0 : n.names) === null || u === void 0 ? void 0 : u[c], p = await Yv(_n(e, c), t10[c], {
      name: (h10 == null ? void 0 : h10.name) || c,
      label: h10 == null ? void 0 : h10.label,
      values: e,
      bails: (f = (d = n == null ? void 0 : n.bailsMap) === null || d === void 0 ? void 0 : d[c]) !== null && f !== void 0 ? f : true
    });
    return Object.assign(Object.assign({}, p), { path: c });
  });
  let r = true;
  const o = await Promise.all(s), a = {}, l = {};
  for (const c of o)
    a[c.path] = {
      valid: c.valid,
      errors: c.errors
    }, c.valid || (r = false, l[c.path] = c.errors[0]);
  return {
    valid: r,
    results: a,
    errors: l,
    source: "schema"
  };
}
var Jg = 0;
function uE(t10, e) {
  const { value: n, initialValue: i, setInitialValue: s } = dE(t10, e.modelValue, e.form);
  if (!e.form) {
    let f = function(h10) {
      var p;
      "value" in h10 && (n.value = h10.value), "errors" in h10 && c(h10.errors), "touched" in h10 && (d.touched = (p = h10.touched) !== null && p !== void 0 ? p : d.touched), "initialValue" in h10 && s(h10.initialValue);
    };
    const { errors: l, setErrors: c } = pE(), u = Jg >= Number.MAX_SAFE_INTEGER ? 0 : ++Jg, d = hE(n, i, l, e.schema);
    return {
      id: u,
      path: t10,
      value: n,
      initialValue: i,
      meta: d,
      flags: { pendingUnmount: { [u]: false }, pendingReset: false },
      errors: l,
      setState: f
    };
  }
  const r = e.form.createPathState(t10, {
    bails: e.bails,
    label: e.label,
    type: e.type,
    validate: e.validate,
    schema: e.schema
  }), o = computed(() => r.errors);
  function a(l) {
    var c, u, d;
    "value" in l && (n.value = l.value), "errors" in l && ((c = e.form) === null || c === void 0 || c.setFieldError(unref(t10), l.errors)), "touched" in l && ((u = e.form) === null || u === void 0 || u.setFieldTouched(unref(t10), (d = l.touched) !== null && d !== void 0 ? d : false)), "initialValue" in l && s(l.initialValue);
  }
  return {
    id: Array.isArray(r.id) ? r.id[r.id.length - 1] : r.id,
    path: t10,
    value: n,
    errors: o,
    meta: r,
    initialValue: i,
    flags: r.__flags,
    setState: a
  };
}
function dE(t10, e, n) {
  const i = ref(unref(e));
  function s() {
    return n ? _n(n.initialValues.value, unref(t10), unref(i)) : unref(i);
  }
  function r(c) {
    if (!n) {
      i.value = c;
      return;
    }
    n.setFieldInitialValue(unref(t10), c, true);
  }
  const o = computed(s);
  if (!n)
    return {
      value: ref(s()),
      initialValue: o,
      setInitialValue: r
    };
  const a = fE(e, n, o, t10);
  return n.stageInitialValue(unref(t10), a, true), {
    value: computed({
      get() {
        return _n(n.values, unref(t10));
      },
      set(c) {
        n.setFieldValue(unref(t10), c, false);
      }
    }),
    initialValue: o,
    setInitialValue: r
  };
}
function fE(t10, e, n, i) {
  return isRef(t10) ? unref(t10) : t10 !== void 0 ? t10 : _n(e.values, unref(i), unref(n));
}
function hE(t10, e, n, i) {
  const s = computed(() => {
    var o, a, l;
    return (l = (a = (o = toValue(i)) === null || o === void 0 ? void 0 : o.describe) === null || a === void 0 ? void 0 : a.call(o).required) !== null && l !== void 0 ? l : false;
  }), r = reactive({
    touched: false,
    pending: false,
    valid: true,
    required: s,
    validated: !!unref(n).length,
    initialValue: computed(() => unref(e)),
    dirty: computed(() => !gn(unref(t10), unref(e)))
  });
  return watch(n, (o) => {
    r.valid = !o.length;
  }, {
    immediate: true,
    flush: "sync"
  }), r;
}
function pE() {
  const t10 = ref([]);
  return {
    errors: t10,
    setErrors: (e) => {
      t10.value = vh(e);
    }
  };
}
var La = {};
var Ia = {};
var Pa = "vee-validate-inspector";
var Tn = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
var Dt = null;
var cs;
async function Xv(t10) {
  if (true) {
    if (!jv)
      return;
    (await import("./index-IdtPmXeP-TBKPDV2A.js")).setupDevtoolsPlugin({
      id: "vee-validate-devtools-plugin",
      label: "VeeValidate Plugin",
      packageName: "vee-validate",
      homepage: "https://vee-validate.logaretm.com/v4",
      app: t10,
      logo: "https://vee-validate.logaretm.com/v4/logo.png"
    }, (n) => {
      cs = n, n.addInspector({
        id: Pa,
        icon: "rule",
        label: "vee-validate",
        noSelectionText: "Select a vee-validate node to inspect",
        actions: [
          {
            icon: "done_outline",
            tooltip: "Validate selected item",
            action: async () => {
              if (!Dt) {
                console.error("There is not a valid selected vee-validate node or component");
                return;
              }
              if (Dt.type === "field") {
                await Dt.field.validate();
                return;
              }
              if (Dt.type === "form") {
                await Dt.form.validate();
                return;
              }
              Dt.type === "pathState" && await Dt.form.validateField(Dt.state.path);
            }
          },
          {
            icon: "delete_sweep",
            tooltip: "Clear validation state of the selected item",
            action: () => {
              if (!Dt) {
                console.error("There is not a valid selected vee-validate node or component");
                return;
              }
              if (Dt.type === "field") {
                Dt.field.resetField();
                return;
              }
              Dt.type === "form" && Dt.form.resetForm(), Dt.type === "pathState" && Dt.form.resetField(Dt.state.path);
            }
          }
        ]
      }), n.on.getInspectorTree((i) => {
        if (i.inspectorId !== Pa)
          return;
        const s = Object.values(La), r = Object.values(Ia);
        i.rootNodes = [
          ...s.map(bE),
          ...r.map((o) => vE(o))
        ];
      }), n.on.getInspectorState((i) => {
        if (i.inspectorId !== Pa)
          return;
        const { form: s, field: r, state: o, type: a } = xE(i.nodeId);
        if (n.unhighlightElement(), s && a === "form") {
          i.state = kE(s), Dt = { type: "form", form: s }, n.highlightElement(s._vm);
          return;
        }
        if (o && a === "pathState" && s) {
          i.state = Xg(o), Dt = { type: "pathState", state: o, form: s };
          return;
        }
        if (r && a === "field") {
          i.state = Xg({
            errors: r.errors.value,
            dirty: r.meta.dirty,
            valid: r.meta.valid,
            touched: r.meta.touched,
            value: r.value.value,
            initialValue: r.meta.initialValue
          }), Dt = { field: r, type: "field" }, n.highlightElement(r._vm);
          return;
        }
        Dt = null, n.unhighlightElement();
      });
    });
  }
}
var _o = KO(() => {
  setTimeout(async () => {
    await nextTick(), cs == null || cs.sendInspectorState(Pa), cs == null || cs.sendInspectorTree(Pa);
  }, 100);
}, 100);
function mE(t10) {
  const e = getCurrentInstance();
  if (!cs) {
    const n = e == null ? void 0 : e.appContext.app;
    if (!n)
      return;
    Xv(n);
  }
  La[t10.formId] = Object.assign({}, t10), La[t10.formId]._vm = e, onUnmounted(() => {
    delete La[t10.formId], _o();
  }), _o();
}
function gE(t10) {
  const e = getCurrentInstance();
  if (!cs) {
    const n = e == null ? void 0 : e.appContext.app;
    if (!n)
      return;
    Xv(n);
  }
  Ia[t10.id] = Object.assign({}, t10), Ia[t10.id]._vm = e, onUnmounted(() => {
    delete Ia[t10.id], _o();
  }), _o();
}
function bE(t10) {
  const { textColor: e, bgColor: n } = Zv(t10.meta.value.valid), i = {};
  Object.values(t10.getAllPathStates()).forEach((o) => {
    Ei(i, toValue(o.path), yE(o, t10));
  });
  function s(o, a = []) {
    const l = [...a].pop();
    return "id" in o ? Object.assign(Object.assign({}, o), { label: l || o.label }) : er(o) ? {
      id: `${a.join(".")}`,
      label: l || "",
      children: Object.keys(o).map((c) => s(o[c], [...a, c]))
    } : Array.isArray(o) ? {
      id: `${a.join(".")}`,
      label: `${l}[]`,
      children: o.map((c, u) => s(c, [...a, String(u)]))
    } : { id: "", label: "", children: [] };
  }
  const { children: r } = s(i);
  return {
    id: jp(t10),
    label: t10.name,
    children: r,
    tags: [
      {
        label: "Form",
        textColor: e,
        backgroundColor: n
      },
      {
        label: `${t10.getAllPathStates().length} fields`,
        textColor: Tn.white,
        backgroundColor: Tn.unknown
      }
    ]
  };
}
function yE(t10, e) {
  return {
    id: jp(e, t10),
    label: toValue(t10.path),
    tags: Qv(t10.multiple, t10.fieldsCount, t10.type, t10.valid, e)
  };
}
function vE(t10, e) {
  return {
    id: jp(e, t10),
    label: unref(t10.name),
    tags: Qv(false, 1, t10.type, t10.meta.valid, e)
  };
}
function Qv(t10, e, n, i, s) {
  const { textColor: r, bgColor: o } = Zv(i);
  return [
    t10 ? void 0 : {
      label: "Field",
      textColor: r,
      backgroundColor: o
    },
    s ? void 0 : {
      label: "Standalone",
      textColor: Tn.black,
      backgroundColor: Tn.gray
    },
    n === "checkbox" ? {
      label: "Checkbox",
      textColor: Tn.white,
      backgroundColor: Tn.blue
    } : void 0,
    n === "radio" ? {
      label: "Radio",
      textColor: Tn.white,
      backgroundColor: Tn.purple
    } : void 0,
    t10 ? {
      label: "Multiple",
      textColor: Tn.black,
      backgroundColor: Tn.orange
    } : void 0
  ].filter(Boolean);
}
function jp(t10, e) {
  const n = e ? "path" in e ? "pathState" : "field" : "form", i = e ? "path" in e ? e == null ? void 0 : e.path : toValue(e == null ? void 0 : e.name) : "", s = { f: t10 == null ? void 0 : t10.formId, ff: (e == null ? void 0 : e.id) || i, type: n };
  return btoa(encodeURIComponent(JSON.stringify(s)));
}
function xE(t10) {
  try {
    const e = JSON.parse(decodeURIComponent(atob(t10))), n = La[e.f];
    if (!n && e.ff) {
      const s = Ia[e.ff];
      return s ? {
        type: e.type,
        field: s
      } : {};
    }
    if (!n)
      return {};
    const i = n.getPathState(e.ff);
    return {
      type: e.type,
      form: n,
      state: i
    };
  } catch {
  }
  return {};
}
function Xg(t10) {
  return {
    "Field state": [
      { key: "errors", value: t10.errors },
      {
        key: "initialValue",
        value: t10.initialValue
      },
      {
        key: "currentValue",
        value: t10.value
      },
      {
        key: "touched",
        value: t10.touched
      },
      {
        key: "dirty",
        value: t10.dirty
      },
      {
        key: "valid",
        value: t10.valid
      }
    ]
  };
}
function kE(t10) {
  const { errorBag: e, meta: n, values: i, isSubmitting: s, isValidating: r, submitCount: o } = t10;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: o.value
      },
      {
        key: "isSubmitting",
        value: s.value
      },
      {
        key: "isValidating",
        value: r.value
      },
      {
        key: "touched",
        value: n.value.touched
      },
      {
        key: "dirty",
        value: n.value.dirty
      },
      {
        key: "valid",
        value: n.value.valid
      },
      {
        key: "initialValues",
        value: n.value.initialValues
      },
      {
        key: "currentValues",
        value: i
      },
      {
        key: "errors",
        value: Mn(e.value).reduce((a, l) => {
          var c;
          const u = (c = e.value[l]) === null || c === void 0 ? void 0 : c[0];
          return u && (a[l] = u), a;
        }, {})
      }
    ]
  };
}
function Zv(t10) {
  return {
    bgColor: t10 ? Tn.success : Tn.error,
    textColor: t10 ? Tn.black : Tn.white
  };
}
function Sn(t10, e, n) {
  return Hv(n == null ? void 0 : n.type) ? wE(t10, e, n) : e2(t10, e, n);
}
function e2(t10, e, n) {
  const { initialValue: i, validateOnMount: s, bails: r, type: o, checkedValue: a, label: l, validateOnValueUpdate: c, uncheckedValue: u, controlled: d, keepValueOnUnmount: f, syncVModel: h10, form: p } = SE(n), g = d ? zp(ad) : void 0, m = p || g, b = computed(() => ga(toValue(t10))), x = computed(() => {
    if (toValue(m == null ? void 0 : m.schema))
      return;
    const K = unref(e);
    return Wc(K) || gi(K) || hn(K) || Array.isArray(K) ? K : Kv(K);
  }), k = !hn(x.value) && gi(toValue(e)), { id: v, value: S, initialValue: w, meta: E, setState: M, errors: N, flags: V } = uE(b, {
    modelValue: i,
    form: m,
    bails: r,
    label: l,
    type: o,
    validate: x.value ? C : void 0,
    schema: k ? e : void 0
  }), Y = computed(() => N.value[0]);
  h10 && CE({
    value: S,
    prop: h10,
    handleChange: O,
    shouldValidate: () => c && !V.pendingReset
  });
  const F = (L, K = false) => {
    E.touched = true, K && z();
  };
  async function re(L) {
    var K, B;
    if (m != null && m.validateSchema) {
      const { results: X } = await m.validateSchema(L);
      return (K = X[toValue(b)]) !== null && K !== void 0 ? K : { valid: true, errors: [] };
    }
    return x.value ? Yv(S.value, x.value, {
      name: toValue(b),
      label: toValue(l),
      values: (B = m == null ? void 0 : m.values) !== null && B !== void 0 ? B : {},
      bails: r
    }) : { valid: true, errors: [] };
  }
  const z = yh(async () => (E.pending = true, E.validated = true, re("validated-only")), (L) => (V.pendingUnmount[xe.id] || (M({ errors: L.errors }), E.pending = false, E.valid = L.valid), L)), W = yh(async () => re("silent"), (L) => (E.valid = L.valid, L));
  function C(L) {
    return (L == null ? void 0 : L.mode) === "silent" ? W() : z();
  }
  function O(L, K = true) {
    const B = Uc(L);
    Q(B, K);
  }
  onMounted(() => {
    if (s)
      return z();
    (!m || !m.validateSchema) && W();
  });
  function _(L) {
    E.touched = L;
  }
  function T(L) {
    var K;
    const B = L && "value" in L ? L.value : w.value;
    M({
      value: ct(B),
      initialValue: ct(B),
      touched: (K = L == null ? void 0 : L.touched) !== null && K !== void 0 ? K : false,
      errors: (L == null ? void 0 : L.errors) || []
    }), E.pending = false, E.validated = false, W();
  }
  const H = getCurrentInstance();
  function Q(L, K = true) {
    S.value = H && h10 ? YO(L, H.props.modelModifiers) : L, (K ? z : W)();
  }
  function ae(L) {
    M({ errors: Array.isArray(L) ? L : [L] });
  }
  const pe = computed({
    get() {
      return S.value;
    },
    set(L) {
      Q(L, c);
    }
  }), xe = {
    id: v,
    name: b,
    label: l,
    value: pe,
    meta: E,
    errors: N,
    errorMessage: Y,
    type: o,
    checkedValue: a,
    uncheckedValue: u,
    bails: r,
    keepValueOnUnmount: f,
    resetField: T,
    handleReset: () => T(),
    validate: C,
    handleChange: O,
    handleBlur: F,
    setState: M,
    setTouched: _,
    setErrors: ae,
    setValue: Q
  };
  if (provide(zO, xe), isRef(e) && typeof unref(e) != "function" && watch(e, (L, K) => {
    gn(L, K) || (E.validated ? z() : W());
  }, {
    deep: true
  }), xe._vm = getCurrentInstance(), watch(() => Object.assign(Object.assign({ errors: N.value }, E), { value: S.value }), _o, {
    deep: true
  }), m || gE(xe), !m)
    return xe;
  const Te = computed(() => {
    const L = x.value;
    return !L || hn(L) || Wc(L) || gi(L) || Array.isArray(L) ? {} : Object.keys(L).reduce((K, B) => {
      const X = eE(L[B]).map((be) => be.__locatorRef).reduce((be, Ce) => {
        const Oe = _n(m.values, Ce) || m.values[Ce];
        return Oe !== void 0 && (be[Ce] = Oe), be;
      }, {});
      return Object.assign(K, X), K;
    }, {});
  });
  return watch(Te, (L, K) => {
    if (!Object.keys(L).length)
      return;
    !gn(L, K) && (E.validated ? z() : W());
  }), onBeforeUnmount(() => {
    var L;
    const K = (L = toValue(xe.keepValueOnUnmount)) !== null && L !== void 0 ? L : toValue(m.keepValuesOnUnmount), B = toValue(b);
    if (K || !m || V.pendingUnmount[xe.id]) {
      m == null || m.removePathState(B, v);
      return;
    }
    V.pendingUnmount[xe.id] = true;
    const X = m.getPathState(B);
    if (Array.isArray(X == null ? void 0 : X.id) && (X != null && X.multiple) ? X != null && X.id.includes(xe.id) : (X == null ? void 0 : X.id) === xe.id) {
      if (X != null && X.multiple && Array.isArray(X.value)) {
        const Ce = X.value.findIndex((Oe) => gn(Oe, toValue(xe.checkedValue)));
        if (Ce > -1) {
          const Oe = [...X.value];
          Oe.splice(Ce, 1), m.setFieldValue(B, Oe);
        }
        Array.isArray(X.id) && X.id.splice(X.id.indexOf(xe.id), 1);
      } else
        m.unsetPathValue(toValue(b));
      m.removePathState(B, v);
    }
  }), xe;
}
function SE(t10) {
  const e = () => ({
    initialValue: void 0,
    validateOnMount: false,
    bails: true,
    label: void 0,
    validateOnValueUpdate: true,
    keepValueOnUnmount: void 0,
    syncVModel: false,
    controlled: true
  }), n = !!(t10 != null && t10.syncVModel), i = typeof (t10 == null ? void 0 : t10.syncVModel) == "string" ? t10.syncVModel : (t10 == null ? void 0 : t10.modelPropName) || "modelValue", s = n && !("initialValue" in (t10 || {})) ? xh(getCurrentInstance(), i) : t10 == null ? void 0 : t10.initialValue;
  if (!t10)
    return Object.assign(Object.assign({}, e()), { initialValue: s });
  const r = "valueProp" in t10 ? t10.valueProp : t10.checkedValue, o = "standalone" in t10 ? !t10.standalone : t10.controlled, a = (t10 == null ? void 0 : t10.modelPropName) || (t10 == null ? void 0 : t10.syncVModel) || false;
  return Object.assign(Object.assign(Object.assign({}, e()), t10 || {}), {
    initialValue: s,
    controlled: o ?? true,
    checkedValue: r,
    syncVModel: a
  });
}
function wE(t10, e, n) {
  const i = n != null && n.standalone ? void 0 : zp(ad), s = n == null ? void 0 : n.checkedValue, r = n == null ? void 0 : n.uncheckedValue;
  function o(a) {
    const l = a.handleChange, c = computed(() => {
      const d = toValue(a.value), f = toValue(s);
      return Array.isArray(d) ? d.findIndex((h10) => gn(h10, f)) >= 0 : gn(f, d);
    });
    function u(d, f = true) {
      var h10, p;
      if (c.value === ((h10 = d == null ? void 0 : d.target) === null || h10 === void 0 ? void 0 : h10.checked)) {
        f && a.validate();
        return;
      }
      const g = toValue(t10), m = i == null ? void 0 : i.getPathState(g), b = Uc(d);
      let x = (p = toValue(s)) !== null && p !== void 0 ? p : b;
      i && (m != null && m.multiple) && m.type === "checkbox" ? x = Kg(_n(i.values, g) || [], x, void 0) : (n == null ? void 0 : n.type) === "checkbox" && (x = Kg(toValue(a.value), x, toValue(r))), l(x, f);
    }
    return Object.assign(Object.assign({}, a), {
      checked: c,
      checkedValue: s,
      uncheckedValue: r,
      handleChange: u
    });
  }
  return o(e2(t10, e, n));
}
function CE({ prop: t10, value: e, handleChange: n, shouldValidate: i }) {
  const s = getCurrentInstance();
  if (!s || !t10) {
    console.warn("Failed to setup model events because `useField` was not called in setup.");
    return;
  }
  const r = typeof t10 == "string" ? t10 : "modelValue", o = `update:${r}`;
  r in s.props && (watch(e, (a) => {
    gn(a, xh(s, r)) || s.emit(o, a);
  }), watch(() => xh(s, r), (a) => {
    if (a === Hg && e.value === void 0)
      return;
    const l = a === Hg ? void 0 : a;
    gn(l, e.value) || n(l, i());
  }));
}
function xh(t10, e) {
  if (t10)
    return t10.props[e];
}
var OE = 0;
var jl = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];
function t2(t10) {
  const e = (t10 == null ? void 0 : t10.initialValues) || {}, n = Object.assign({}, toValue(e)), i = unref(t10 == null ? void 0 : t10.validationSchema);
  return i && gi(i) && hn(i.cast) ? ct(i.cast(n) || {}) : ct(n);
}
function EE(t10) {
  var e;
  const n = OE++, i = (t10 == null ? void 0 : t10.name) || "Form";
  let s = 0;
  const r = ref(false), o = ref(false), a = ref(0), l = [], c = reactive(t2(t10)), u = ref([]), d = ref({}), f = ref({}), h10 = GO(() => {
    f.value = u.value.reduce((U, q) => (U[ga(toValue(q.path))] = q, U), {});
  });
  function p(U, q) {
    const se = O(U);
    if (!se) {
      typeof U == "string" && (d.value[ga(U)] = vh(q));
      return;
    }
    if (typeof U == "string") {
      const R = ga(U);
      d.value[R] && delete d.value[R];
    }
    se.errors = vh(q), se.valid = !se.errors.length;
  }
  function g(U) {
    Mn(U).forEach((q) => {
      p(q, U[q]);
    });
  }
  t10 != null && t10.initialErrors && g(t10.initialErrors);
  const m = computed(() => {
    const U = u.value.reduce((q, se) => (se.errors.length && (q[toValue(se.path)] = se.errors), q), {});
    return Object.assign(Object.assign({}, d.value), U);
  }), b = computed(() => Mn(m.value).reduce((U, q) => {
    const se = m.value[q];
    return se != null && se.length && (U[q] = se[0]), U;
  }, {})), x = computed(() => u.value.reduce((U, q) => (U[toValue(q.path)] = { name: toValue(q.path) || "", label: q.label || "" }, U), {})), k = computed(() => u.value.reduce((U, q) => {
    var se;
    return U[toValue(q.path)] = (se = q.bails) !== null && se !== void 0 ? se : true, U;
  }, {})), v = Object.assign({}, (t10 == null ? void 0 : t10.initialErrors) || {}), S = (e = t10 == null ? void 0 : t10.keepValuesOnUnmount) !== null && e !== void 0 ? e : false, { initialValues: w, originalInitialValues: E, setInitialValues: M } = TE(u, c, t10), N = ME(u, c, E, b), V = computed(() => u.value.reduce((U, q) => {
    const se = _n(c, toValue(q.path));
    return Ei(U, toValue(q.path), se), U;
  }, {})), Y = t10 == null ? void 0 : t10.validationSchema;
  function F(U, q) {
    var se, R;
    const ie = computed(() => _n(w.value, toValue(U))), de = f.value[toValue(U)], ye = (q == null ? void 0 : q.type) === "checkbox" || (q == null ? void 0 : q.type) === "radio";
    if (de && ye) {
      de.multiple = true;
      const en = s++;
      return Array.isArray(de.id) ? de.id.push(en) : de.id = [de.id, en], de.fieldsCount++, de.__flags.pendingUnmount[en] = false, de;
    }
    const _e = computed(() => _n(c, toValue(U))), Ge = toValue(U), rt = T.findIndex((en) => en === Ge);
    rt !== -1 && T.splice(rt, 1);
    const nt = computed(() => {
      var en, Si, wi, ia;
      const pr = toValue(Y);
      if (gi(pr))
        return (Si = (en = pr.describe) === null || en === void 0 ? void 0 : en.call(pr, toValue(U)).required) !== null && Si !== void 0 ? Si : false;
      const Os = toValue(q == null ? void 0 : q.schema);
      return gi(Os) && (ia = (wi = Os.describe) === null || wi === void 0 ? void 0 : wi.call(Os).required) !== null && ia !== void 0 ? ia : false;
    }), Bt = s++, Ot = reactive({
      id: Bt,
      path: U,
      touched: false,
      pending: false,
      valid: true,
      validated: !!(!((se = v[Ge]) === null || se === void 0) && se.length),
      required: nt,
      initialValue: ie,
      errors: shallowRef([]),
      bails: (R = q == null ? void 0 : q.bails) !== null && R !== void 0 ? R : false,
      label: q == null ? void 0 : q.label,
      type: (q == null ? void 0 : q.type) || "default",
      value: _e,
      multiple: false,
      __flags: {
        pendingUnmount: { [Bt]: false },
        pendingReset: false
      },
      fieldsCount: 1,
      validate: q == null ? void 0 : q.validate,
      dirty: computed(() => !gn(unref(_e), unref(ie)))
    });
    return u.value.push(Ot), f.value[Ge] = Ot, h10(), b.value[Ge] && !v[Ge] && nextTick(() => {
      I(Ge, { mode: "silent" });
    }), isRef(U) && watch(U, (en) => {
      h10();
      const Si = ct(_e.value);
      f.value[en] = Ot, nextTick(() => {
        Ei(c, en, Si);
      });
    }), Ot;
  }
  const re = Yg(Ze, 5), z = Yg(Ze, 5), W = yh(async (U) => await (U === "silent" ? re() : z()), (U, [q]) => {
    const se = Mn(K.errorBag.value), ie = [
      .../* @__PURE__ */ new Set([...Mn(U.results), ...u.value.map((de) => de.path), ...se])
    ].sort().reduce((de, ye) => {
      var _e;
      const Ge = ye, rt = O(Ge) || _(Ge), nt = ((_e = U.results[Ge]) === null || _e === void 0 ? void 0 : _e.errors) || [], Bt = toValue(rt == null ? void 0 : rt.path) || Ge, Ot = AE({ errors: nt, valid: !nt.length }, de.results[Bt]);
      return de.results[Bt] = Ot, Ot.valid || (de.errors[Bt] = Ot.errors[0]), rt && d.value[Bt] && delete d.value[Bt], rt ? (rt.valid = Ot.valid, q === "silent" || q === "validated-only" && !rt.validated || p(rt, Ot.errors), de) : (p(Bt, nt), de);
    }, {
      valid: U.valid,
      results: {},
      errors: {},
      source: U.source
    });
    return U.values && (ie.values = U.values, ie.source = U.source), Mn(ie.results).forEach((de) => {
      var ye;
      const _e = O(de);
      _e && q !== "silent" && (q === "validated-only" && !_e.validated || p(_e, (ye = ie.results[de]) === null || ye === void 0 ? void 0 : ye.errors));
    }), ie;
  });
  function C(U) {
    u.value.forEach(U);
  }
  function O(U) {
    const q = typeof U == "string" ? ga(U) : U;
    return typeof q == "string" ? f.value[q] : q;
  }
  function _(U) {
    return u.value.filter((se) => U.startsWith(toValue(se.path))).reduce((se, R) => se ? R.path.length > se.path.length ? R : se : R, void 0);
  }
  let T = [], H;
  function Q(U) {
    return T.push(U), H || (H = nextTick(() => {
      [...T].sort().reverse().forEach((se) => {
        qg(c, se);
      }), T = [], H = null;
    })), H;
  }
  function ae(U) {
    return function(se, R) {
      return function(de) {
        return de instanceof Event && (de.preventDefault(), de.stopPropagation()), C((ye) => ye.touched = true), r.value = true, a.value++, un().then((ye) => {
          const _e = ct(c);
          if (ye.valid && typeof se == "function") {
            const Ge = ct(V.value);
            let rt = U ? Ge : _e;
            return ye.values && (rt = ye.source === "schema" ? ye.values : Object.assign({}, rt, ye.values)), se(rt, {
              evt: de,
              controlledValues: Ge,
              setErrors: g,
              setFieldError: p,
              setTouched: xt,
              setFieldTouched: Oe,
              setValues: be,
              setFieldValue: B,
              resetForm: Pt,
              resetField: Ct
            });
          }
          !ye.valid && typeof R == "function" && R({
            values: _e,
            evt: de,
            errors: ye.errors,
            results: ye.results
          });
        }).then((ye) => (r.value = false, ye), (ye) => {
          throw r.value = false, ye;
        });
      };
    };
  }
  const xe = ae(false);
  xe.withControlled = ae(true);
  function Te(U, q) {
    const se = u.value.findIndex((ie) => ie.path === U && (Array.isArray(ie.id) ? ie.id.includes(q) : ie.id === q)), R = u.value[se];
    if (!(se === -1 || !R)) {
      if (nextTick(() => {
        I(U, { mode: "silent", warn: false });
      }), R.multiple && R.fieldsCount && R.fieldsCount--, Array.isArray(R.id)) {
        const ie = R.id.indexOf(q);
        ie >= 0 && R.id.splice(ie, 1), delete R.__flags.pendingUnmount[q];
      }
      (!R.multiple || R.fieldsCount <= 0) && (u.value.splice(se, 1), $(U), h10(), delete f.value[U]);
    }
  }
  function L(U) {
    Mn(f.value).forEach((q) => {
      q.startsWith(U) && delete f.value[q];
    }), u.value = u.value.filter((q) => !q.path.startsWith(U)), nextTick(() => {
      h10();
    });
  }
  const K = {
    name: i,
    formId: n,
    values: c,
    controlledValues: V,
    errorBag: m,
    errors: b,
    schema: Y,
    submitCount: a,
    meta: N,
    isSubmitting: r,
    isValidating: o,
    fieldArrays: l,
    keepValuesOnUnmount: S,
    validateSchema: unref(Y) ? W : void 0,
    validate: un,
    setFieldError: p,
    validateField: I,
    setFieldValue: B,
    setValues: be,
    setErrors: g,
    setFieldTouched: Oe,
    setTouched: xt,
    resetForm: Pt,
    resetField: Ct,
    handleSubmit: xe,
    useFieldModel: Z,
    defineInputBinds: ue,
    defineComponentBinds: Xe,
    defineField: Ye,
    stageInitialValue: ne,
    unsetInitialValue: $,
    setFieldInitialValue: Se,
    createPathState: F,
    getPathState: O,
    unsetPathValue: Q,
    removePathState: Te,
    initialValues: w,
    getAllPathStates: () => u.value,
    destroyPath: L,
    isFieldTouched: Ue,
    isFieldDirty: J,
    isFieldValid: Fe
  };
  function B(U, q, se = true) {
    const R = ct(q), ie = typeof U == "string" ? U : U.path;
    O(ie) || F(ie), Ei(c, ie, R), se && I(ie);
  }
  function X(U, q = true) {
    Mn(c).forEach((se) => {
      delete c[se];
    }), Mn(U).forEach((se) => {
      B(se, U[se], false);
    }), q && un();
  }
  function be(U, q = true) {
    el(c, U), l.forEach((se) => se && se.reset()), q && un();
  }
  function Ce(U, q) {
    const se = O(toValue(U)) || F(U);
    return computed({
      get() {
        return se.value;
      },
      set(R) {
        var ie;
        const de = toValue(U);
        B(de, R, (ie = toValue(q)) !== null && ie !== void 0 ? ie : false);
      }
    });
  }
  function Oe(U, q) {
    const se = O(U);
    se && (se.touched = q);
  }
  function Ue(U) {
    const q = O(U);
    return q ? q.touched : u.value.filter((se) => se.path.startsWith(U)).some((se) => se.touched);
  }
  function J(U) {
    const q = O(U);
    return q ? q.dirty : u.value.filter((se) => se.path.startsWith(U)).some((se) => se.dirty);
  }
  function Fe(U) {
    const q = O(U);
    return q ? q.valid : u.value.filter((se) => se.path.startsWith(U)).every((se) => se.valid);
  }
  function xt(U) {
    if (typeof U == "boolean") {
      C((q) => {
        q.touched = U;
      });
      return;
    }
    Mn(U).forEach((q) => {
      Oe(q, !!U[q]);
    });
  }
  function Ct(U, q) {
    var se;
    const R = q && "value" in q ? q.value : _n(w.value, U), ie = O(U);
    ie && (ie.__flags.pendingReset = true), Se(U, ct(R), true), B(U, R, false), Oe(U, (se = q == null ? void 0 : q.touched) !== null && se !== void 0 ? se : false), p(U, (q == null ? void 0 : q.errors) || []), nextTick(() => {
      ie && (ie.__flags.pendingReset = false);
    });
  }
  function Pt(U, q) {
    let se = ct(U != null && U.values ? U.values : E.value);
    se = q != null && q.force ? se : el(E.value, se), se = gi(Y) && hn(Y.cast) ? Y.cast(se) : se, M(se, { force: q == null ? void 0 : q.force }), C((R) => {
      var ie;
      R.__flags.pendingReset = true, R.validated = false, R.touched = ((ie = U == null ? void 0 : U.touched) === null || ie === void 0 ? void 0 : ie[toValue(R.path)]) || false, B(toValue(R.path), _n(se, toValue(R.path)), false), p(toValue(R.path), void 0);
    }), q != null && q.force ? X(se, false) : be(se, false), g((U == null ? void 0 : U.errors) || {}), a.value = (U == null ? void 0 : U.submitCount) || 0, nextTick(() => {
      un({ mode: "silent" }), C((R) => {
        R.__flags.pendingReset = false;
      });
    });
  }
  async function un(U) {
    const q = (U == null ? void 0 : U.mode) || "force";
    if (q === "force" && C((ye) => ye.validated = true), K.validateSchema)
      return K.validateSchema(q);
    o.value = true;
    const se = await Promise.all(u.value.map((ye) => ye.validate ? ye.validate(U).then((_e) => ({
      key: toValue(ye.path),
      valid: _e.valid,
      errors: _e.errors,
      value: _e.value
    })) : Promise.resolve({
      key: toValue(ye.path),
      valid: true,
      errors: [],
      value: void 0
    })));
    o.value = false;
    const R = {}, ie = {}, de = {};
    for (const ye of se)
      R[ye.key] = {
        valid: ye.valid,
        errors: ye.errors
      }, ye.value && Ei(de, ye.key, ye.value), ye.errors.length && (ie[ye.key] = ye.errors[0]);
    return {
      valid: se.every((ye) => ye.valid),
      results: R,
      errors: ie,
      values: de,
      source: "fields"
    };
  }
  async function I(U, q) {
    var se;
    const R = O(U);
    if (R && (q == null ? void 0 : q.mode) !== "silent" && (R.validated = true), Y) {
      const { results: de } = await W((q == null ? void 0 : q.mode) || "validated-only");
      return de[U] || { errors: [], valid: true };
    }
    return R != null && R.validate ? R.validate(q) : (!R && ((se = q == null ? void 0 : q.warn) !== null && se !== void 0 ? se : true) && true && warn(`field with path ${U} was not found`), Promise.resolve({ errors: [], valid: true }));
  }
  function $(U) {
    qg(w.value, U);
  }
  function ne(U, q, se = false) {
    Se(U, q), Ei(c, U, q), se && !(t10 != null && t10.initialValues) && Ei(E.value, U, ct(q));
  }
  function Se(U, q, se = false) {
    Ei(w.value, U, ct(q)), se && Ei(E.value, U, ct(q));
  }
  async function Ze() {
    const U = unref(Y);
    if (!U)
      return { valid: true, results: {}, errors: {}, source: "none" };
    o.value = true;
    const q = Wc(U) || gi(U) ? await lE(U, c) : await cE(U, c, {
      names: x.value,
      bailsMap: k.value
    });
    return o.value = false, q;
  }
  const Qe = xe((U, { evt: q }) => {
    UO(q) && q.target.submit();
  });
  onMounted(() => {
    if (t10 != null && t10.initialErrors && g(t10.initialErrors), t10 != null && t10.initialTouched && xt(t10.initialTouched), t10 != null && t10.validateOnMount) {
      un();
      return;
    }
    K.validateSchema && K.validateSchema("silent");
  }), isRef(Y) && watch(Y, () => {
    var U;
    (U = K.validateSchema) === null || U === void 0 || U.call(K, "validated-only");
  }), provide(ad, K), mE(K), watch(() => Object.assign(Object.assign({ errors: m.value }, N.value), { values: c, isSubmitting: r.value, isValidating: o.value, submitCount: a.value }), _o, {
    deep: true
  });
  function Ye(U, q) {
    const se = hn(q) || q == null ? void 0 : q.label, R = O(toValue(U)) || F(U, { label: se }), ie = () => hn(q) ? q(zl(R, jl)) : q || {};
    function de() {
      var nt;
      R.touched = true, ((nt = ie().validateOnBlur) !== null && nt !== void 0 ? nt : ba().validateOnBlur) && I(toValue(R.path));
    }
    function ye() {
      var nt;
      ((nt = ie().validateOnInput) !== null && nt !== void 0 ? nt : ba().validateOnInput) && nextTick(() => {
        I(toValue(R.path));
      });
    }
    function _e() {
      var nt;
      ((nt = ie().validateOnChange) !== null && nt !== void 0 ? nt : ba().validateOnChange) && nextTick(() => {
        I(toValue(R.path));
      });
    }
    const Ge = computed(() => {
      const nt = {
        onChange: _e,
        onInput: ye,
        onBlur: de
      };
      return hn(q) ? Object.assign(Object.assign({}, nt), q(zl(R, jl)).props || {}) : q != null && q.props ? Object.assign(Object.assign({}, nt), q.props(zl(R, jl))) : nt;
    });
    return [Ce(U, () => {
      var nt, Bt, Ot;
      return (Ot = (nt = ie().validateOnModelUpdate) !== null && nt !== void 0 ? nt : (Bt = ba()) === null || Bt === void 0 ? void 0 : Bt.validateOnModelUpdate) !== null && Ot !== void 0 ? Ot : true;
    }), Ge];
  }
  function Z(U) {
    return Array.isArray(U) ? U.map((q) => Ce(q, true)) : Ce(U);
  }
  function ue(U, q) {
    const [se, R] = Ye(U, q);
    function ie() {
      R.value.onBlur();
    }
    function de(_e) {
      const Ge = Uc(_e);
      B(toValue(U), Ge, false), R.value.onInput();
    }
    function ye(_e) {
      const Ge = Uc(_e);
      B(toValue(U), Ge, false), R.value.onChange();
    }
    return computed(() => Object.assign(Object.assign({}, R.value), {
      onBlur: ie,
      onInput: de,
      onChange: ye,
      value: se.value
    }));
  }
  function Xe(U, q) {
    const [se, R] = Ye(U, q), ie = O(toValue(U));
    function de(ye) {
      se.value = ye;
    }
    return computed(() => {
      const ye = hn(q) ? q(zl(ie, jl)) : q || {};
      return Object.assign({ [ye.model || "modelValue"]: se.value, [`onUpdate:${ye.model || "modelValue"}`]: de }, R.value);
    });
  }
  const ht = Object.assign(Object.assign({}, K), { values: readonly(c), handleReset: () => Pt(), submitForm: Qe });
  return provide(BO, ht), ht;
}
function ME(t10, e, n, i) {
  const s = {
    touched: "some",
    pending: "some",
    valid: "every"
  }, r = computed(() => !gn(e, unref(n)));
  function o() {
    const l = t10.value;
    return Mn(s).reduce((c, u) => {
      const d = s[u];
      return c[u] = l[d]((f) => f[u]), c;
    }, {});
  }
  const a = reactive(o());
  return watchEffect(() => {
    const l = o();
    a.touched = l.touched, a.valid = l.valid, a.pending = l.pending;
  }), computed(() => Object.assign(Object.assign({ initialValues: unref(n) }, a), { valid: a.valid && !Mn(i.value).length, dirty: r.value }));
}
function TE(t10, e, n) {
  const i = t2(n), s = ref(i), r = ref(ct(i));
  function o(a, l) {
    l != null && l.force ? (s.value = ct(a), r.value = ct(a)) : (s.value = el(ct(s.value) || {}, ct(a)), r.value = el(ct(r.value) || {}, ct(a))), l != null && l.updateFields && t10.value.forEach((c) => {
      if (c.touched)
        return;
      const d = _n(s.value, toValue(c.path));
      Ei(e, toValue(c.path), ct(d));
    });
  }
  return {
    initialValues: s,
    originalInitialValues: r,
    setInitialValues: o
  };
}
function AE(t10, e) {
  return e ? {
    valid: t10.valid && e.valid,
    errors: [...t10.errors, ...e.errors]
  } : t10;
}
function _E() {
  const t10 = zp(ad);
  return t10 || qO("No vee-validate <Form /> or `useForm` was detected in the component tree"), computed(() => (t10 == null ? void 0 : t10.values) || {});
}
var NE = "";
var LE = "";
var IE = "";
var PE = "";
var DE = "";
var $E = "";
var RE = "";
var FE = "";
var VE = "عربي";
var BE = "";
var zE = "";
var jE = "";
var HE = "";
var WE = "";
var UE = "";
var qE = "";
var KE = "";
var YE = "";
var GE = "";
var JE = "english";
var XE = "";
var QE = "";
var ZE = "";
var eM = "";
var tM = "";
var nM = "";
var iM = "";
var sM = "";
var rM = "";
var oM = "";
var aM = "";
var lM = "";
var cM = "";
var uM = "";
var dM = "";
var fM = "";
var hM = "";
var pM = "";
var mM = "";
var gM = "";
var bM = "";
var yM = "";
var vM = "";
var xM = "";
var kM = "";
var SM = "ar expand sidebar";
var wM = "";
var CM = "";
var OM = "";
var EM = "";
var MM = "français";
var TM = "";
var AM = "";
var _M = "";
var NM = "";
var LM = "";
var IM = "";
var PM = "";
var DM = "";
var $M = "";
var RM = "";
var FM = "";
var VM = "";
var BM = "";
var zM = "";
var jM = "اللغة";
var HM = "";
var WM = "";
var UM = "";
var qM = "";
var KM = "";
var YM = "";
var GM = "";
var JM = "";
var XM = "";
var QM = "";
var ZM = "";
var eT = "";
var tT = "";
var nT = "";
var iT = "";
var sT = "";
var rT = "";
var oT = "";
var aT = "";
var lT = "";
var cT = "";
var uT = "لكل صفحة";
var dT = "";
var fT = "";
var hT = "";
var pT = "";
var mT = "";
var gT = "";
var bT = "";
var yT = "";
var vT = "";
var xT = "";
var kT = "";
var ST = "";
var wT = "";
var CT = "";
var OT = "";
var ET = "";
var MT = "";
var TT = "";
var AT = "";
var _T = "";
var NT = "";
var LT = "";
var IT = "";
var PT = "";
var DT = "";
var $T = "";
var RT = "";
var FT = "تبديل الوضع المظلم";
var VT = "تبديل وضع الضوء";
var BT = "";
var zT = "";
var jT = "";
var HT = "";
var WT = "";
var UT = "";
var qT = {
  URL: NE,
  accent: LE,
  actions: IE,
  addOne: PE,
  alignCenter: DE,
  alignEnd: $E,
  alignStart: RE,
  altText: FE,
  ar: VE,
  cancel: BE,
  characters: zE,
  close: jE,
  closeMainSidebar: HE,
  closeSecondarySidebar: WE,
  collapseSidebar: UE,
  color: qE,
  column: KE,
  columns: YE,
  empty: GE,
  en: JE,
  errAlpha: XE,
  errAlphaNum: QE,
  errAlphaNumDash: ZE,
  errColor: eM,
  errConfirm: tM,
  errEmail: nM,
  errMax: iM,
  errMaxChar: sM,
  errMaxDate: rM,
  errMaxOpt: oM,
  errMaxTime: aM,
  errMin: lM,
  errMinChar: cM,
  errMinDate: uM,
  errMinOpt: dM,
  errMinTime: fM,
  errNumber: hM,
  errPassword: pM,
  errRegex: mM,
  errRequired: gM,
  errSize: bM,
  errType: yM,
  errUrl: vM,
  es: xM,
  exitFullscreen: kM,
  expandSidebar: SM,
  filters: wM,
  filtersMenu: CM,
  firstPage: OM,
  formHasErrors: EM,
  fr: MM,
  fullscreen: TM,
  hidePassword: AM,
  highlight: _M,
  home: NM,
  insertAudio: LM,
  insertImage: IM,
  insertLink: PM,
  insertList: DM,
  insertMedia: $M,
  insertTitle: RM,
  insertVideo: FM,
  itemsPerPage: VM,
  lastPage: BM,
  lightbox: zM,
  locale: jM,
  mainContent: HM,
  mainSidebar: WM,
  makeBold: UM,
  makeItalic: qM,
  mute: KM,
  neutral: YM,
  nextPage: GM,
  nextSlide: JM,
  noresult: XM,
  notifications: QM,
  of: ZM,
  off: eT,
  open: tT,
  openContextmenu: nT,
  openMainSidebar: iT,
  openSecondarySidebar: sT,
  optional: rT,
  outOf: oT,
  page: aT,
  pagination: lT,
  pause: cT,
  perPage: uT,
  play: dT,
  previousPage: fT,
  previousSlide: hT,
  radius: pT,
  redo: mT,
  remove: gT,
  removeOne: bT,
  result: yT,
  results: vT,
  search: xT,
  searchPlaceholder: kT,
  secondarySidebar: ST,
  seek: wT,
  selectAllRows: CT,
  selectRow: OT,
  sharp: ET,
  shortcuts: MT,
  showDetails: TT,
  showPassword: AT,
  signOut: _T,
  slide: NT,
  soft: LT,
  sortAscending: IT,
  sortAscendingU: PT,
  sortDescending: DT,
  style: $T,
  subtitles: RT,
  toggleDark: FT,
  toggleLight: VT,
  toolbar: BT,
  underline: zT,
  undo: jT,
  unmute: HT,
  upload: WT,
  uploadedFiles: UT
};
var KT = "URL";
var YT = "accent";
var GT = "actions";
var JT = "add one";
var XT = "align center";
var QT = "align end";
var ZT = "align start";
var eA = "alt text";
var tA = "عربي";
var nA = "cancel";
var iA = "characters";
var sA = "close";
var rA = "close main sidebar";
var oA = "close secondary sidebar";
var aA = "collapse sidebar";
var lA = "color";
var cA = "column";
var uA = "columns";
var dA = "no item selected";
var fA = "english";
var hA = "you can only use letters";
var pA = "you can only use letters and digits";
var mA = "you can only use letters, digits and dashes";
var gA = "you should provide a valid hexadecimal color, starting with a #";
var bA = "the values don't match";
var yA = "you should provide a valid email";
var vA = "the maximum value is";
var xA = "you can only use";
var kA = "the date can only be until";
var SA = "you can only pick";
var wA = "the time can only be until";
var CA = "the minimum value is";
var OA = "you should use at least";
var EA = "the date should be at least";
var MA = "you should pick at least";
var TA = "the time should be at least";
var AA = "you can only use digits";
var _A = "you should use at least 1 uppercase, 1 lowercase, 1 digit and 1 special character";
var NA = "the format is invalid";
var LA = "this field is required";
var IA = "the maximum size is";
var PA = "you can only pick";
var DA = "you should provide a valid URL";
var $A = "español";
var RA = "exit fullscreen";
var FA = "expand sidebar";
var VA = "filter";
var BA = "filter list";
var zA = "first page";
var jA = "The form contains errors:";
var HA = "français";
var WA = "fullscreen";
var UA = "hide password";
var qA = "highlight";
var KA = "home";
var YA = "insert audio";
var GA = "insert image";
var JA = "insert link";
var XA = "insert list";
var QA = "insert media";
var ZA = "insert title";
var e_ = "insert video";
var t_ = "items per page";
var n_ = "last page";
var i_ = "lightbox";
var s_ = "choose app language";
var r_ = "main content";
var o_ = "main sidebar";
var a_ = "make bold";
var l_ = "make italic";
var c_ = "mute";
var u_ = "neutral";
var d_ = "next page";
var f_ = "next slide";
var h_ = "no result found";
var p_ = "notifications (Alt + N)";
var m_ = "of";
var g_ = "off";
var b_ = "open";
var y_ = "open contextual menu with Alt + C";
var v_ = "open main sidebar";
var x_ = "open secondary sidebar";
var k_ = "optional";
var S_ = "out of";
var w_ = "page";
var C_ = "pagination";
var O_ = "pause";
var E_ = "per page";
var M_ = "play";
var T_ = "previous page";
var A_ = "previous slide";
var __ = "radius";
var N_ = "redo";
var L_ = "remove";
var I_ = "remove one";
var P_ = "result found";
var D_ = "results found";
var $_ = "search";
var R_ = "Search...";
var F_ = "secondary sidebar";
var V_ = "seek";
var B_ = "select all rows";
var z_ = "select row";
var j_ = "sharp";
var H_ = "shortcuts";
var W_ = "show details";
var U_ = "show password";
var q_ = "sign out";
var K_ = "slide";
var Y_ = "soft";
var G_ = "sort by ascending order (currently descending)";
var J_ = "sort by ascending order (currently unsorted)";
var X_ = "sort by descending order (currently ascending)";
var Q_ = "choose app style";
var Z_ = "subtitles";
var eN = "toggle dark mode";
var tN = "toggle light mode";
var nN = "toolbar";
var iN = "underline";
var sN = "undo";
var rN = "unmute";
var oN = "upload";
var aN = "uploaded files";
var lN = {
  URL: KT,
  accent: YT,
  actions: GT,
  addOne: JT,
  alignCenter: XT,
  alignEnd: QT,
  alignStart: ZT,
  altText: eA,
  ar: tA,
  cancel: nA,
  characters: iA,
  close: sA,
  closeMainSidebar: rA,
  closeSecondarySidebar: oA,
  collapseSidebar: aA,
  color: lA,
  column: cA,
  columns: uA,
  empty: dA,
  en: fA,
  errAlpha: hA,
  errAlphaNum: pA,
  errAlphaNumDash: mA,
  errColor: gA,
  errConfirm: bA,
  errEmail: yA,
  errMax: vA,
  errMaxChar: xA,
  errMaxDate: kA,
  errMaxOpt: SA,
  errMaxTime: wA,
  errMin: CA,
  errMinChar: OA,
  errMinDate: EA,
  errMinOpt: MA,
  errMinTime: TA,
  errNumber: AA,
  errPassword: _A,
  errRegex: NA,
  errRequired: LA,
  errSize: IA,
  errType: PA,
  errUrl: DA,
  es: $A,
  exitFullscreen: RA,
  expandSidebar: FA,
  filters: VA,
  filtersMenu: BA,
  firstPage: zA,
  formHasErrors: jA,
  fr: HA,
  fullscreen: WA,
  hidePassword: UA,
  highlight: qA,
  home: KA,
  insertAudio: YA,
  insertImage: GA,
  insertLink: JA,
  insertList: XA,
  insertMedia: QA,
  insertTitle: ZA,
  insertVideo: e_,
  itemsPerPage: t_,
  lastPage: n_,
  lightbox: i_,
  locale: s_,
  mainContent: r_,
  mainSidebar: o_,
  makeBold: a_,
  makeItalic: l_,
  mute: c_,
  neutral: u_,
  nextPage: d_,
  nextSlide: f_,
  noresult: h_,
  notifications: p_,
  of: m_,
  off: g_,
  open: b_,
  openContextmenu: y_,
  openMainSidebar: v_,
  openSecondarySidebar: x_,
  optional: k_,
  outOf: S_,
  page: w_,
  pagination: C_,
  pause: O_,
  perPage: E_,
  play: M_,
  previousPage: T_,
  previousSlide: A_,
  radius: __,
  redo: N_,
  remove: L_,
  removeOne: I_,
  result: P_,
  results: D_,
  search: $_,
  searchPlaceholder: R_,
  secondarySidebar: F_,
  seek: V_,
  selectAllRows: B_,
  selectRow: z_,
  sharp: j_,
  shortcuts: H_,
  showDetails: W_,
  showPassword: U_,
  signOut: q_,
  slide: K_,
  soft: Y_,
  sortAscending: G_,
  sortAscendingU: J_,
  sortDescending: X_,
  style: Q_,
  subtitles: Z_,
  toggleDark: eN,
  toggleLight: tN,
  toolbar: nN,
  underline: iN,
  undo: sN,
  unmute: rN,
  upload: oN,
  uploadedFiles: aN
};
var cN = "URL";
var uN = "acento";
var dN = "acciones";
var fN = "agregar uno";
var hN = "centrar";
var pN = "alinear al final";
var mN = "alinear al principio";
var gN = "texto alternativo";
var bN = "عربي";
var yN = "cancelar";
var vN = "caracteres";
var xN = "cerrar";
var kN = "cerrar barra lateral principal";
var SN = "cerrar barra lateral secundaria";
var wN = "colapsar barra lateral";
var CN = "color";
var ON = "columna";
var EN = "columnas";
var MN = "ningún elemento seleccionado";
var TN = "english";
var AN = "solo puedes usar letras";
var _N = "solo puedes usar letras y números";
var NN = "solo puedes usar letras, números y guiones";
var LN = "debes proporcionar un color hexadecimal válido, comenzando con un #";
var IN = "los valores no coinciden";
var PN = "debes proporcionar un correo electrónico válido";
var DN = "el valor máximo es";
var $N = "solo puedes usar";
var RN = "la fecha solo puede ser hasta";
var FN = "solo puedes elegir";
var VN = "la hora solo puede ser hasta";
var BN = "el valor mínimo es";
var zN = "debes usar al menos";
var jN = "la fecha debe ser al menos";
var HN = "debes elegir al menos";
var WN = "la hora debe ser al menos";
var UN = "solo puedes usar números";
var qN = "debes usar al menos 1 mayúscula, 1 minúscula, 1 número y 1 carácter especial";
var KN = "el formato es inválido";
var YN = "este campo es obligatorio";
var GN = "el tamaño máximo es";
var JN = "solo puedes elegir";
var XN = "debes proporcionar una URL válida";
var QN = "español";
var ZN = "salir de pantalla completa";
var e8 = "expandir barra lateral";
var t8 = "filtro";
var n8 = "lista de filtros";
var i8 = "primera página";
var s8 = "El formulario contiene errores :";
var r8 = "français";
var o8 = "pantalla completa";
var a8 = "ocultar contraseña";
var l8 = "resaltar";
var c8 = "inicio";
var u8 = "insertar audio";
var d8 = "insertar imagen";
var f8 = "insertar enlace";
var h8 = "insertar lista";
var p8 = "insertar medios";
var m8 = "insertar título";
var g8 = "insertar video";
var b8 = "elementos por página";
var y8 = "última página";
var v8 = "lightbox";
var x8 = "elegir idioma de la aplicación";
var k8 = "contenido principal";
var S8 = "barra lateral principal";
var w8 = "poner en negrita";
var C8 = "poner en cursiva";
var O8 = "silenciar";
var E8 = "neutral";
var M8 = "página siguiente";
var T8 = "diapositiva siguiente";
var A8 = "no se encontraron resultados";
var _8 = "notificaciones (Alt + N)";
var N8 = "de";
var L8 = "apagado";
var I8 = "abrir";
var P8 = "abrir menú contextual con Alt + C";
var D8 = "abrir barra lateral principal";
var $8 = "abrir barra lateral secundaria";
var R8 = "opcional";
var F8 = "de un total de";
var V8 = "página";
var B8 = "paginación";
var z8 = "pausar";
var j8 = "por página";
var H8 = "reproducir";
var W8 = "página anterior";
var U8 = "diapositiva anterior";
var q8 = "radio";
var K8 = "rehacer";
var Y8 = "eliminar";
var G8 = "eliminar uno";
var J8 = "resultado encontrado";
var X8 = "resultados encontrados";
var Q8 = "buscar";
var Z8 = "Buscar...";
var e5 = "barra lateral secundaria";
var t5 = "buscar";
var n5 = "seleccionar todas las filas";
var i5 = "seleccionar fila";
var s5 = "filo";
var r5 = "accesos directos";
var o5 = "mostrar detalles";
var a5 = "mostrar contraseña";
var l5 = "cerrar sesión";
var c5 = "diapositiva";
var u5 = "suave";
var d5 = "ordenar en orden ascendente (actualmente descendente)";
var f5 = "ordenar en orden ascendente (actualmente sin ordenar)";
var h5 = "ordenar en orden descendente (actualmente ascendente)";
var p5 = "elegir estilo de la aplicación";
var m5 = "subtítulos";
var g5 = "activar modo oscuro";
var b5 = "activar modo claro";
var y5 = "barra de herramientas";
var v5 = "subrayar";
var x5 = "deshacer";
var k5 = "desilenciar";
var S5 = "subir";
var w5 = "archivos subidos";
var C5 = {
  URL: cN,
  accent: uN,
  actions: dN,
  addOne: fN,
  alignCenter: hN,
  alignEnd: pN,
  alignStart: mN,
  altText: gN,
  ar: bN,
  cancel: yN,
  characters: vN,
  close: xN,
  closeMainSidebar: kN,
  closeSecondarySidebar: SN,
  collapseSidebar: wN,
  color: CN,
  column: ON,
  columns: EN,
  empty: MN,
  en: TN,
  errAlpha: AN,
  errAlphaNum: _N,
  errAlphaNumDash: NN,
  errColor: LN,
  errConfirm: IN,
  errEmail: PN,
  errMax: DN,
  errMaxChar: $N,
  errMaxDate: RN,
  errMaxOpt: FN,
  errMaxTime: VN,
  errMin: BN,
  errMinChar: zN,
  errMinDate: jN,
  errMinOpt: HN,
  errMinTime: WN,
  errNumber: UN,
  errPassword: qN,
  errRegex: KN,
  errRequired: YN,
  errSize: GN,
  errType: JN,
  errUrl: XN,
  es: QN,
  exitFullscreen: ZN,
  expandSidebar: e8,
  filters: t8,
  filtersMenu: n8,
  firstPage: i8,
  formHasErrors: s8,
  fr: r8,
  fullscreen: o8,
  hidePassword: a8,
  highlight: l8,
  home: c8,
  insertAudio: u8,
  insertImage: d8,
  insertLink: f8,
  insertList: h8,
  insertMedia: p8,
  insertTitle: m8,
  insertVideo: g8,
  itemsPerPage: b8,
  lastPage: y8,
  lightbox: v8,
  locale: x8,
  mainContent: k8,
  mainSidebar: S8,
  makeBold: w8,
  makeItalic: C8,
  mute: O8,
  neutral: E8,
  nextPage: M8,
  nextSlide: T8,
  noresult: A8,
  notifications: _8,
  of: N8,
  off: L8,
  open: I8,
  openContextmenu: P8,
  openMainSidebar: D8,
  openSecondarySidebar: $8,
  optional: R8,
  outOf: F8,
  page: V8,
  pagination: B8,
  pause: z8,
  perPage: j8,
  play: H8,
  previousPage: W8,
  previousSlide: U8,
  radius: q8,
  redo: K8,
  remove: Y8,
  removeOne: G8,
  result: J8,
  results: X8,
  search: Q8,
  searchPlaceholder: Z8,
  secondarySidebar: e5,
  seek: t5,
  selectAllRows: n5,
  selectRow: i5,
  sharp: s5,
  shortcuts: r5,
  showDetails: o5,
  showPassword: a5,
  signOut: l5,
  slide: c5,
  soft: u5,
  sortAscending: d5,
  sortAscendingU: f5,
  sortDescending: h5,
  style: p5,
  subtitles: m5,
  toggleDark: g5,
  toggleLight: b5,
  toolbar: y5,
  underline: v5,
  undo: x5,
  unmute: k5,
  upload: S5,
  uploadedFiles: w5
};
var O5 = "URL";
var E5 = "accent";
var M5 = "actions";
var T5 = "ajouter";
var A5 = "aligner au centre";
var _5 = "aligner à la fin";
var N5 = "aligner au début";
var L5 = "texte alternatif";
var I5 = "عربي";
var P5 = "annuler";
var D5 = "caractères";
var $5 = "fermer";
var R5 = "fermer la barre latérale principale";
var F5 = "fermer la barre latérale secondaire";
var V5 = "réduire la barre latérale";
var B5 = "accent";
var z5 = "colonne";
var j5 = "colonnes";
var H5 = "aucun élément sélectionné";
var W5 = "english";
var U5 = "vous ne pouvez utiliser que des lettres";
var q5 = "vous ne pouvez utiliser que des lettres et des chiffres";
var K5 = "vous ne pouvez utiliser que des lettres, des chiffres et des tirets";
var Y5 = "vous devez fournir une couleur valide, commençant par #";
var G5 = "les valeurs ne correspondent pas";
var J5 = "vous devez fournir une adresse e-mail valide";
var X5 = "la valeur maximale est";
var Q5 = "vous ne pouvez utiliser que";
var Z5 = "la date ne peut être que jusqu'au";
var eL = "vous ne pouvez en choisir que";
var tL = "l'heure ne peut être que jusqu'à";
var nL = "la valeur minimale est";
var iL = "vous devez utiliser au moins";
var sL = "la date doit être après le";
var rL = "vous devez en choisir au moins";
var oL = "l'heure doit être après";
var aL = "vous ne pouvez utiliser que des chiffres";
var lL = "le mot de passe doit contenir au moins une lettre majuscule, une lettre minuscule, un chiffre et un caractère spécial";
var cL = "le format est incorrect";
var uL = "ce champ est obligatoire";
var dL = "la taille ne doit pas dépasser";
var fL = "vous ne pouvez choisir que des";
var hL = "vous devez fournir une URL valide";
var pL = "español";
var mL = "quitter le plein écran";
var gL = "développer la barre latérale";
var bL = "filtrer";
var yL = "liste des filtres";
var vL = "première page";
var xL = "Le formulaire contient des erreurs :";
var kL = "français";
var SL = "plein écran";
var wL = "masquer le mot de passe";
var CL = "surligner";
var OL = "accueil";
var EL = "insérer un audio";
var ML = "insérer une image";
var TL = "insérer un lien";
var AL = "insérer une liste";
var _L = "insérer le média";
var NL = "insérer un titre";
var LL = "insérer une vidéo";
var IL = "éléments par page";
var PL = "dernière page";
var DL = "diaporama";
var $L = "choisir la langue de l'app";
var RL = "contenu principal";
var FL = "barre latérale principale";
var VL = "mettre en gras";
var BL = "mettre en italique";
var zL = "désactiver le son";
var jL = "neutre";
var HL = "page suivante";
var WL = "diapositive suivante";
var UL = "aucun résultat trouvé";
var qL = "notifications (Alt + N)";
var KL = "sur";
var YL = "désactivé";
var GL = "ouvrir";
var JL = "ouvrir le menu contextuel avec Alt + C";
var XL = "ouvrir la barre latérale principale";
var QL = "ouvrir la barre latérale secondaire";
var ZL = "optionnel";
var e6 = "sur";
var t6 = "page";
var n6 = "pagination";
var i6 = "pause";
var s6 = "par page";
var r6 = "lecture";
var o6 = "page précédente";
var a6 = "diapositive précédente";
var l6 = "radius";
var c6 = "refaire";
var u6 = "enlever";
var d6 = "enlever";
var f6 = "résultat trouvé";
var h6 = "résultats trouvés";
var p6 = "recherche";
var m6 = "Rechercher...";
var g6 = "barre latérale secondaire";
var b6 = "aller à";
var y6 = "sélectionner toutes les lignes";
var v6 = "sélectionner la ligne";
var x6 = "brut";
var k6 = "raccourcis";
var S6 = "afficher les détails";
var w6 = "afficher le mot de passe";
var C6 = "se déconnecter";
var O6 = "diapositive";
var E6 = "doux";
var M6 = "tri par ordre croissant (actuellement décroissant)";
var T6 = "tri par ordre croissant (actuellement non trié)";
var A6 = "tri par ordre décroissant (actuellement croissant)";
var _6 = "choisir le design de l'app";
var N6 = "sous-titres";
var L6 = "activer le mode sombre";
var I6 = "activer le mode clair";
var P6 = "barre d'outils";
var D6 = "souligner";
var $6 = "annuler";
var R6 = "activer le son";
var F6 = "parcourir";
var V6 = "fichiers téléchargés";
var B6 = {
  URL: O5,
  accent: E5,
  actions: M5,
  addOne: T5,
  alignCenter: A5,
  alignEnd: _5,
  alignStart: N5,
  altText: L5,
  ar: I5,
  cancel: P5,
  characters: D5,
  close: $5,
  closeMainSidebar: R5,
  closeSecondarySidebar: F5,
  collapseSidebar: V5,
  color: B5,
  column: z5,
  columns: j5,
  empty: H5,
  en: W5,
  errAlpha: U5,
  errAlphaNum: q5,
  errAlphaNumDash: K5,
  errColor: Y5,
  errConfirm: G5,
  errEmail: J5,
  errMax: X5,
  errMaxChar: Q5,
  errMaxDate: Z5,
  errMaxOpt: eL,
  errMaxTime: tL,
  errMin: nL,
  errMinChar: iL,
  errMinDate: sL,
  errMinOpt: rL,
  errMinTime: oL,
  errNumber: aL,
  errPassword: lL,
  errRegex: cL,
  errRequired: uL,
  errSize: dL,
  errType: fL,
  errUrl: hL,
  es: pL,
  exitFullscreen: mL,
  expandSidebar: gL,
  filters: bL,
  filtersMenu: yL,
  firstPage: vL,
  formHasErrors: xL,
  fr: kL,
  fullscreen: SL,
  hidePassword: wL,
  highlight: CL,
  home: OL,
  insertAudio: EL,
  insertImage: ML,
  insertLink: TL,
  insertList: AL,
  insertMedia: _L,
  insertTitle: NL,
  insertVideo: LL,
  itemsPerPage: IL,
  lastPage: PL,
  lightbox: DL,
  locale: $L,
  mainContent: RL,
  mainSidebar: FL,
  makeBold: VL,
  makeItalic: BL,
  mute: zL,
  neutral: jL,
  nextPage: HL,
  nextSlide: WL,
  noresult: UL,
  notifications: qL,
  of: KL,
  off: YL,
  open: GL,
  openContextmenu: JL,
  openMainSidebar: XL,
  openSecondarySidebar: QL,
  optional: ZL,
  outOf: e6,
  page: t6,
  pagination: n6,
  pause: i6,
  perPage: s6,
  play: r6,
  previousPage: o6,
  previousSlide: a6,
  radius: l6,
  redo: c6,
  remove: u6,
  removeOne: d6,
  result: f6,
  results: h6,
  search: p6,
  searchPlaceholder: m6,
  secondarySidebar: g6,
  seek: b6,
  selectAllRows: y6,
  selectRow: v6,
  sharp: x6,
  shortcuts: k6,
  showDetails: S6,
  showPassword: w6,
  signOut: C6,
  slide: O6,
  soft: E6,
  sortAscending: M6,
  sortAscendingU: T6,
  sortDescending: A6,
  style: _6,
  subtitles: N6,
  toggleDark: L6,
  toggleLight: I6,
  toolbar: P6,
  underline: D6,
  undo: $6,
  unmute: R6,
  upload: F6,
  uploadedFiles: V6
};
var at = {
  ar: qT,
  en: lN,
  es: C5,
  fr: B6
};
var st = ref("en");
if (typeof window < "u") {
  z6 = new MutationObserver(function(t10) {
    t10.forEach(function(e) {
      e.type === "attributes" && e.attributeName === "lang" && (st.value = document.documentElement.getAttribute("lang").split("-")[0]);
    });
  });
  z6.observe(document.documentElement, {
    attributes: true
  });
}
var z6;
function j6(t10) {
  return !!(t10 == null || !String(t10).trim().length || Array.isArray(t10) && t10.length === 0);
}
vt("required", (t10) => {
  var e;
  return !t10 || j6(t10) ? (e = at[st.value]) == null ? void 0 : e.errRequired : true;
});
vt("confirm", (t10, [e]) => {
  var n;
  return t10 !== e ? (n = at[st.value]) == null ? void 0 : n.errConfirm : true;
});
vt("minchar", (t10, [e]) => {
  var n, i;
  return (t10 == null ? void 0 : t10.length) < Number(e) ? `${(n = at[st.value]) == null ? void 0 : n.errMinChar} ${e} ${(i = at[st.value]) == null ? void 0 : i.characters}` : true;
});
vt("maxchar", (t10, [e]) => {
  var n, i;
  return (t10 == null ? void 0 : t10.length) > Number(e) ? `${(n = at[st.value]) == null ? void 0 : n.errMaxChar} ${e} ${(i = at[st.value]) == null ? void 0 : i.characters}` : true;
});
vt("minopt", (t10, [e]) => {
  var n;
  return (t10 == null ? void 0 : t10.length) < Number(e) ? `${(n = at[st.value]) == null ? void 0 : n.errMinOpt} ${e}` : true;
});
vt("maxopt", (t10, [e]) => {
  var n;
  return (t10 == null ? void 0 : t10.length) > Number(e) ? `${(n = at[st.value]) == null ? void 0 : n.errMaxOpt} ${e}` : true;
});
vt("size", (t10, [e]) => {
  var i;
  const n = `${(i = at[st.value]) == null ? void 0 : i.errSize} ${e}KB`;
  return Array.isArray(t10) ? t10.every((s) => s.size <= Number(e) * 1024) ? true : n : t10.size > Number(e) * 1024 ? n : true;
});
vt("mime", (t10, [e]) => {
  var r;
  e || (e = []);
  const n = e.split(",").map((o) => o.trim()), i = n.map((o) => {
    let a = o;
    return /\+(.+)?/.test(o) && (a = o.replace(/\+(.+)?/, "(\\+$1)?")), new RegExp(a.replace("*", ".+"), "i");
  }), s = `${(r = at[st.value]) == null ? void 0 : r.errType} ${n.join(", ")}`;
  return Array.isArray(t10) ? t10.every((o) => i.some((a) => a.test(o.type))) ? true : s : i.some((o) => o.test(t10.type)) ? true : s;
});
vt("ext", (t10, [e]) => {
  var r;
  e || (e = []);
  const n = e.split(",").map((o) => o.trim()), i = new RegExp(`\\.(${n.join("|")})$`, "i"), s = `${(r = at[st.value]) == null ? void 0 : r.errType} ${n.join(", ")}`;
  return Array.isArray(t10) ? t10.every((o) => i.test(o.name)) ? true : s : i.test(t10 == null ? void 0 : t10.name) ? true : s;
});
vt("min", (t10, [e]) => {
  var n;
  return t10 < Number(e) ? `${(n = at[st.value]) == null ? void 0 : n.errMin} ${e}` : true;
});
vt("max", (t10, [e]) => {
  var n;
  return t10 > Number(e) ? `${(n = at[st.value]) == null ? void 0 : n.errMax} ${e}` : true;
});
vt("mindate", (t10, [e]) => {
  var n;
  return t10 < e ? `${(n = at[st.value]) == null ? void 0 : n.errMinDate} ${Intl.DateTimeFormat(st.value, { dateStyle: "medium" }).format(new Date(e))}` : true;
});
vt("maxdate", (t10, [e]) => {
  var n;
  return t10 > e ? `${(n = at[st.value]) == null ? void 0 : n.errMaxDate} ${Intl.DateTimeFormat(st.value, { dateStyle: "medium" }).format(new Date(e))}` : true;
});
vt("mintime", (t10, [e]) => {
  var i;
  const n = `${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}T${e}`;
  return t10 < e ? `${(i = at[st.value]) == null ? void 0 : i.errMinTime} ${Intl.DateTimeFormat(st.value, { timeStyle: "short" }).format(new Date(n))}` : true;
});
vt("maxtime", (t10, [e]) => {
  var i;
  const n = `${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}T${e}`;
  return t10 > e ? `${(i = at[st.value]) == null ? void 0 : i.errMaxTime} ${Intl.DateTimeFormat(st.value, { timeStyle: "short" }).format(new Date(n))}` : true;
});
vt("regex", (t10, [e]) => {
  var n;
  return e.test(t10) ? true : (n = at[st.value]) == null ? void 0 : n.errRegex;
});
vt("alpha", (t10) => {
  var e;
  return /^[A-Z]*$/i.test(t10) ? true : (e = at[st.value]) == null ? void 0 : e.errAlpha;
});
vt("alphanum", (t10) => {
  var e;
  return /^[0-9A-Z]*$/i.test(t10) ? true : (e = at[st.value]) == null ? void 0 : e.errAlphaNum;
});
vt("alphanumdash", (t10) => {
  var e;
  return /^[0-9A-Z_-]*$/i.test(t10) ? true : (e = at[st.value]) == null ? void 0 : e.errAlphaNumDash;
});
vt("alphapw", (t10) => {
  var e;
  return /^(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^\w\d\s:])$/.test(t10) ? true : (e = at[st.value]) == null ? void 0 : e.errPassword;
});
vt("number", (t10) => {
  var e;
  return /^[0-9]*$/.test(t10) ? true : (e = at[st.value]) == null ? void 0 : e.errNumber;
});
vt("email", (t10) => {
  var e;
  return /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i.test(t10) ? true : (e = at[st.value]) == null ? void 0 : e.errEmail;
});
vt("url", (t10) => {
  var e;
  return /^(https?|ftp):\/\/[^\s\/$.?#].[^\s]*$/.test(t10) ? true : (e = at[st.value]) == null ? void 0 : e.errUrl;
});
vt("color", (t10) => {
  var e;
  return /^#[0-9A-F]{6}$/i.test(t10) ? true : (e = at[st.value]) == null ? void 0 : e.errColor;
});
var H6 = { class: "mn-error" };
var W6 = Object.assign({ name: "mn-error" }, {
  __name: "error",
  props: {
    message: {
      type: String,
      required: true
    }
  },
  setup(t10) {
    return (e, n) => (openBlock(), createElementBlock("div", H6, [
      createVNode(ft, {
        icon: "far circle-exclamation",
        color: "danger"
      }),
      createBaseVNode("span", null, toDisplayString(unref(Ie)(t10.message)), 1)
    ]));
  }
});
var $n = Me(W6, [["__scopeId", "data-v-69ab9891"]]);
var U6 = { class: "mn-hint" };
var q6 = Object.assign({ name: "mn-hint" }, {
  __name: "hint",
  props: {
    label: {
      type: String,
      required: true
    }
  },
  setup(t10) {
    return (e, n) => (openBlock(), createElementBlock("span", U6, toDisplayString(unref(Ie)(t10.label)), 1));
  }
});
var ln = Me(q6, [["__scopeId", "data-v-78219155"]]);
var qc = Math.min;
var Pr = Math.max;
var Kc = Math.round;
var Hl = Math.floor;
var Bi = (t10) => ({
  x: t10,
  y: t10
});
var K6 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var Y6 = {
  start: "end",
  end: "start"
};
function Qg(t10, e, n) {
  return Pr(t10, qc(e, n));
}
function cd(t10, e) {
  return typeof t10 == "function" ? t10(e) : t10;
}
function Ur(t10) {
  return t10.split("-")[0];
}
function ud(t10) {
  return t10.split("-")[1];
}
function n2(t10) {
  return t10 === "x" ? "y" : "x";
}
function i2(t10) {
  return t10 === "y" ? "height" : "width";
}
function No(t10) {
  return ["top", "bottom"].includes(Ur(t10)) ? "y" : "x";
}
function s2(t10) {
  return n2(No(t10));
}
function G6(t10, e, n) {
  n === void 0 && (n = false);
  const i = ud(t10), s = s2(t10), r = i2(s);
  let o = s === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return e.reference[r] > e.floating[r] && (o = Yc(o)), [o, Yc(o)];
}
function J6(t10) {
  const e = Yc(t10);
  return [kh(t10), e, kh(e)];
}
function kh(t10) {
  return t10.replace(/start|end/g, (e) => Y6[e]);
}
function X6(t10, e, n) {
  const i = ["left", "right"], s = ["right", "left"], r = ["top", "bottom"], o = ["bottom", "top"];
  switch (t10) {
    case "top":
    case "bottom":
      return n ? e ? s : i : e ? i : s;
    case "left":
    case "right":
      return e ? r : o;
    default:
      return [];
  }
}
function Q6(t10, e, n, i) {
  const s = ud(t10);
  let r = X6(Ur(t10), n === "start", i);
  return s && (r = r.map((o) => o + "-" + s), e && (r = r.concat(r.map(kh)))), r;
}
function Yc(t10) {
  return t10.replace(/left|right|bottom|top/g, (e) => K6[e]);
}
function Z6(t10) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t10
  };
}
function eI(t10) {
  return typeof t10 != "number" ? Z6(t10) : {
    top: t10,
    right: t10,
    bottom: t10,
    left: t10
  };
}
function Gc(t10) {
  const {
    x: e,
    y: n,
    width: i,
    height: s
  } = t10;
  return {
    width: i,
    height: s,
    top: n,
    left: e,
    right: e + i,
    bottom: n + s,
    x: e,
    y: n
  };
}
function Zg(t10, e, n) {
  let {
    reference: i,
    floating: s
  } = t10;
  const r = No(e), o = s2(e), a = i2(o), l = Ur(e), c = r === "y", u = i.x + i.width / 2 - s.width / 2, d = i.y + i.height / 2 - s.height / 2, f = i[a] / 2 - s[a] / 2;
  let h10;
  switch (l) {
    case "top":
      h10 = {
        x: u,
        y: i.y - s.height
      };
      break;
    case "bottom":
      h10 = {
        x: u,
        y: i.y + i.height
      };
      break;
    case "right":
      h10 = {
        x: i.x + i.width,
        y: d
      };
      break;
    case "left":
      h10 = {
        x: i.x - s.width,
        y: d
      };
      break;
    default:
      h10 = {
        x: i.x,
        y: i.y
      };
  }
  switch (ud(e)) {
    case "start":
      h10[o] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      h10[o] += f * (n && c ? -1 : 1);
      break;
  }
  return h10;
}
var tI = async (t10, e, n) => {
  const {
    placement: i = "bottom",
    strategy: s = "absolute",
    middleware: r = [],
    platform: o
  } = n, a = r.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let c = await o.getElementRects({
    reference: t10,
    floating: e,
    strategy: s
  }), {
    x: u,
    y: d
  } = Zg(c, i, l), f = i, h10 = {}, p = 0;
  for (let g = 0; g < a.length; g++) {
    const {
      name: m,
      fn: b
    } = a[g], {
      x,
      y: k,
      data: v,
      reset: S
    } = await b({
      x: u,
      y: d,
      initialPlacement: i,
      placement: f,
      strategy: s,
      middlewareData: h10,
      rects: c,
      platform: o,
      elements: {
        reference: t10,
        floating: e
      }
    });
    u = x ?? u, d = k ?? d, h10 = {
      ...h10,
      [m]: {
        ...h10[m],
        ...v
      }
    }, S && p <= 50 && (p++, typeof S == "object" && (S.placement && (f = S.placement), S.rects && (c = S.rects === true ? await o.getElementRects({
      reference: t10,
      floating: e,
      strategy: s
    }) : S.rects), {
      x: u,
      y: d
    } = Zg(c, f, l)), g = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: s,
    middlewareData: h10
  };
};
async function r2(t10, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: i,
    y: s,
    platform: r,
    rects: o,
    elements: a,
    strategy: l
  } = t10, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = false,
    padding: h10 = 0
  } = cd(e, t10), p = eI(h10), m = a[f ? d === "floating" ? "reference" : "floating" : d], b = Gc(await r.getClippingRect({
    element: (n = await (r.isElement == null ? void 0 : r.isElement(m))) == null || n ? m : m.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), x = d === "floating" ? {
    x: i,
    y: s,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, k = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(a.floating)), v = await (r.isElement == null ? void 0 : r.isElement(k)) ? await (r.getScale == null ? void 0 : r.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = Gc(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: x,
    offsetParent: k,
    strategy: l
  }) : x);
  return {
    top: (b.top - S.top + p.top) / v.y,
    bottom: (S.bottom - b.bottom + p.bottom) / v.y,
    left: (b.left - S.left + p.left) / v.x,
    right: (S.right - b.right + p.right) / v.x
  };
}
var nI = function(t10) {
  return t10 === void 0 && (t10 = {}), {
    name: "flip",
    options: t10,
    async fn(e) {
      var n, i;
      const {
        placement: s,
        middlewareData: r,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: u = true,
        crossAxis: d = true,
        fallbackPlacements: f,
        fallbackStrategy: h10 = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: g = true,
        ...m
      } = cd(t10, e);
      if ((n = r.arrow) != null && n.alignmentOffset)
        return {};
      const b = Ur(s), x = No(a), k = Ur(a) === a, v = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), S = f || (k || !g ? [Yc(a)] : J6(a)), w = p !== "none";
      !f && w && S.push(...Q6(a, g, p, v));
      const E = [a, ...S], M = await r2(e, m), N = [];
      let V = ((i = r.flip) == null ? void 0 : i.overflows) || [];
      if (u && N.push(M[b]), d) {
        const z = G6(s, o, v);
        N.push(M[z[0]], M[z[1]]);
      }
      if (V = [...V, {
        placement: s,
        overflows: N
      }], !N.every((z) => z <= 0)) {
        var Y, F;
        const z = (((Y = r.flip) == null ? void 0 : Y.index) || 0) + 1, W = E[z];
        if (W)
          return {
            data: {
              index: z,
              overflows: V
            },
            reset: {
              placement: W
            }
          };
        let C = (F = V.filter((O) => O.overflows[0] <= 0).sort((O, _) => O.overflows[1] - _.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!C)
          switch (h10) {
            case "bestFit": {
              var re;
              const O = (re = V.filter((_) => {
                if (w) {
                  const T = No(_.placement);
                  return T === x || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  T === "y";
                }
                return true;
              }).map((_) => [_.placement, _.overflows.filter((T) => T > 0).reduce((T, H) => T + H, 0)]).sort((_, T) => _[1] - T[1])[0]) == null ? void 0 : re[0];
              O && (C = O);
              break;
            }
            case "initialPlacement":
              C = a;
              break;
          }
        if (s !== C)
          return {
            reset: {
              placement: C
            }
          };
      }
      return {};
    }
  };
};
async function iI(t10, e) {
  const {
    placement: n,
    platform: i,
    elements: s
  } = t10, r = await (i.isRTL == null ? void 0 : i.isRTL(s.floating)), o = Ur(n), a = ud(n), l = No(n) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = r && l ? -1 : 1, d = cd(e, t10);
  let {
    mainAxis: f,
    crossAxis: h10,
    alignmentAxis: p
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return a && typeof p == "number" && (h10 = a === "end" ? p * -1 : p), l ? {
    x: h10 * u,
    y: f * c
  } : {
    x: f * c,
    y: h10 * u
  };
}
var sI = function(t10) {
  return t10 === void 0 && (t10 = 0), {
    name: "offset",
    options: t10,
    async fn(e) {
      var n, i;
      const {
        x: s,
        y: r,
        placement: o,
        middlewareData: a
      } = e, l = await iI(e, t10);
      return o === ((n = a.offset) == null ? void 0 : n.placement) && (i = a.arrow) != null && i.alignmentOffset ? {} : {
        x: s + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
};
var rI = function(t10) {
  return t10 === void 0 && (t10 = {}), {
    name: "shift",
    options: t10,
    async fn(e) {
      const {
        x: n,
        y: i,
        placement: s
      } = e, {
        mainAxis: r = true,
        crossAxis: o = false,
        limiter: a = {
          fn: (m) => {
            let {
              x: b,
              y: x
            } = m;
            return {
              x: b,
              y: x
            };
          }
        },
        ...l
      } = cd(t10, e), c = {
        x: n,
        y: i
      }, u = await r2(e, l), d = No(Ur(s)), f = n2(d);
      let h10 = c[f], p = c[d];
      if (r) {
        const m = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", x = h10 + u[m], k = h10 - u[b];
        h10 = Qg(x, h10, k);
      }
      if (o) {
        const m = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", x = p + u[m], k = p - u[b];
        p = Qg(x, p, k);
      }
      const g = a.fn({
        ...e,
        [f]: h10,
        [d]: p
      });
      return {
        ...g,
        data: {
          x: g.x - n,
          y: g.y - i,
          enabled: {
            [f]: r,
            [d]: o
          }
        }
      };
    }
  };
};
function dd() {
  return typeof window < "u";
}
function io(t10) {
  return Hp(t10) ? (t10.nodeName || "").toLowerCase() : "#document";
}
function Kn(t10) {
  var e;
  return (t10 == null || (e = t10.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Ji(t10) {
  var e;
  return (e = (Hp(t10) ? t10.ownerDocument : t10.document) || window.document) == null ? void 0 : e.documentElement;
}
function Hp(t10) {
  return dd() ? t10 instanceof Node || t10 instanceof Kn(t10).Node : false;
}
function bi(t10) {
  return dd() ? t10 instanceof Element || t10 instanceof Kn(t10).Element : false;
}
function qi(t10) {
  return dd() ? t10 instanceof HTMLElement || t10 instanceof Kn(t10).HTMLElement : false;
}
function e0(t10) {
  return !dd() || typeof ShadowRoot > "u" ? false : t10 instanceof ShadowRoot || t10 instanceof Kn(t10).ShadowRoot;
}
function _l(t10) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: i,
    display: s
  } = yi(t10);
  return /auto|scroll|overlay|hidden|clip/.test(e + i + n) && !["inline", "contents"].includes(s);
}
function oI(t10) {
  return ["table", "td", "th"].includes(io(t10));
}
function fd(t10) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t10.matches(e);
    } catch {
      return false;
    }
  });
}
function Wp(t10) {
  const e = Up(), n = bi(t10) ? yi(t10) : t10;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((i) => n[i] ? n[i] !== "none" : false) || (n.containerType ? n.containerType !== "normal" : false) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : false) || !e && (n.filter ? n.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((i) => (n.willChange || "").includes(i)) || ["paint", "layout", "strict", "content"].some((i) => (n.contain || "").includes(i));
}
function aI(t10) {
  let e = tr(t10);
  for (; qi(e) && !Lo(e); ) {
    if (Wp(e))
      return e;
    if (fd(e))
      return null;
    e = tr(e);
  }
  return null;
}
function Up() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function Lo(t10) {
  return ["html", "body", "#document"].includes(io(t10));
}
function yi(t10) {
  return Kn(t10).getComputedStyle(t10);
}
function hd(t10) {
  return bi(t10) ? {
    scrollLeft: t10.scrollLeft,
    scrollTop: t10.scrollTop
  } : {
    scrollLeft: t10.scrollX,
    scrollTop: t10.scrollY
  };
}
function tr(t10) {
  if (io(t10) === "html")
    return t10;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t10.assignedSlot || // DOM Element detected.
    t10.parentNode || // ShadowRoot detected.
    e0(t10) && t10.host || // Fallback.
    Ji(t10)
  );
  return e0(e) ? e.host : e;
}
function o2(t10) {
  const e = tr(t10);
  return Lo(e) ? t10.ownerDocument ? t10.ownerDocument.body : t10.body : qi(e) && _l(e) ? e : o2(e);
}
function tl(t10, e, n) {
  var i;
  e === void 0 && (e = []), n === void 0 && (n = true);
  const s = o2(t10), r = s === ((i = t10.ownerDocument) == null ? void 0 : i.body), o = Kn(s);
  if (r) {
    const a = Sh(o);
    return e.concat(o, o.visualViewport || [], _l(s) ? s : [], a && n ? tl(a) : []);
  }
  return e.concat(s, tl(s, [], n));
}
function Sh(t10) {
  return t10.parent && Object.getPrototypeOf(t10.parent) ? t10.frameElement : null;
}
function a2(t10) {
  const e = yi(t10);
  let n = parseFloat(e.width) || 0, i = parseFloat(e.height) || 0;
  const s = qi(t10), r = s ? t10.offsetWidth : n, o = s ? t10.offsetHeight : i, a = Kc(n) !== r || Kc(i) !== o;
  return a && (n = r, i = o), {
    width: n,
    height: i,
    $: a
  };
}
function qp(t10) {
  return bi(t10) ? t10 : t10.contextElement;
}
function Co(t10) {
  const e = qp(t10);
  if (!qi(e))
    return Bi(1);
  const n = e.getBoundingClientRect(), {
    width: i,
    height: s,
    $: r
  } = a2(e);
  let o = (r ? Kc(n.width) : n.width) / i, a = (r ? Kc(n.height) : n.height) / s;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
var lI = Bi(0);
function l2(t10) {
  const e = Kn(t10);
  return !Up() || !e.visualViewport ? lI : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function cI(t10, e, n) {
  return e === void 0 && (e = false), !n || e && n !== Kn(t10) ? false : e;
}
function qr(t10, e, n, i) {
  e === void 0 && (e = false), n === void 0 && (n = false);
  const s = t10.getBoundingClientRect(), r = qp(t10);
  let o = Bi(1);
  e && (i ? bi(i) && (o = Co(i)) : o = Co(t10));
  const a = cI(r, n, i) ? l2(r) : Bi(0);
  let l = (s.left + a.x) / o.x, c = (s.top + a.y) / o.y, u = s.width / o.x, d = s.height / o.y;
  if (r) {
    const f = Kn(r), h10 = i && bi(i) ? Kn(i) : i;
    let p = f, g = Sh(p);
    for (; g && i && h10 !== p; ) {
      const m = Co(g), b = g.getBoundingClientRect(), x = yi(g), k = b.left + (g.clientLeft + parseFloat(x.paddingLeft)) * m.x, v = b.top + (g.clientTop + parseFloat(x.paddingTop)) * m.y;
      l *= m.x, c *= m.y, u *= m.x, d *= m.y, l += k, c += v, p = Kn(g), g = Sh(p);
    }
  }
  return Gc({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
function Kp(t10, e) {
  const n = hd(t10).scrollLeft;
  return e ? e.left + n : qr(Ji(t10)).left + n;
}
function c2(t10, e, n) {
  n === void 0 && (n = false);
  const i = t10.getBoundingClientRect(), s = i.left + e.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    Kp(t10, i)
  )), r = i.top + e.scrollTop;
  return {
    x: s,
    y: r
  };
}
function uI(t10) {
  let {
    elements: e,
    rect: n,
    offsetParent: i,
    strategy: s
  } = t10;
  const r = s === "fixed", o = Ji(i), a = e ? fd(e.floating) : false;
  if (i === o || a && r)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = Bi(1);
  const u = Bi(0), d = qi(i);
  if ((d || !d && !r) && ((io(i) !== "body" || _l(o)) && (l = hd(i)), qi(i))) {
    const h10 = qr(i);
    c = Co(i), u.x = h10.x + i.clientLeft, u.y = h10.y + i.clientTop;
  }
  const f = o && !d && !r ? c2(o, l, true) : Bi(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + f.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + f.y
  };
}
function dI(t10) {
  return Array.from(t10.getClientRects());
}
function fI(t10) {
  const e = Ji(t10), n = hd(t10), i = t10.ownerDocument.body, s = Pr(e.scrollWidth, e.clientWidth, i.scrollWidth, i.clientWidth), r = Pr(e.scrollHeight, e.clientHeight, i.scrollHeight, i.clientHeight);
  let o = -n.scrollLeft + Kp(t10);
  const a = -n.scrollTop;
  return yi(i).direction === "rtl" && (o += Pr(e.clientWidth, i.clientWidth) - s), {
    width: s,
    height: r,
    x: o,
    y: a
  };
}
function hI(t10, e) {
  const n = Kn(t10), i = Ji(t10), s = n.visualViewport;
  let r = i.clientWidth, o = i.clientHeight, a = 0, l = 0;
  if (s) {
    r = s.width, o = s.height;
    const c = Up();
    (!c || c && e === "fixed") && (a = s.offsetLeft, l = s.offsetTop);
  }
  return {
    width: r,
    height: o,
    x: a,
    y: l
  };
}
function pI(t10, e) {
  const n = qr(t10, true, e === "fixed"), i = n.top + t10.clientTop, s = n.left + t10.clientLeft, r = qi(t10) ? Co(t10) : Bi(1), o = t10.clientWidth * r.x, a = t10.clientHeight * r.y, l = s * r.x, c = i * r.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function t0(t10, e, n) {
  let i;
  if (e === "viewport")
    i = hI(t10, n);
  else if (e === "document")
    i = fI(Ji(t10));
  else if (bi(e))
    i = pI(e, n);
  else {
    const s = l2(t10);
    i = {
      x: e.x - s.x,
      y: e.y - s.y,
      width: e.width,
      height: e.height
    };
  }
  return Gc(i);
}
function u2(t10, e) {
  const n = tr(t10);
  return n === e || !bi(n) || Lo(n) ? false : yi(n).position === "fixed" || u2(n, e);
}
function mI(t10, e) {
  const n = e.get(t10);
  if (n)
    return n;
  let i = tl(t10, [], false).filter((a) => bi(a) && io(a) !== "body"), s = null;
  const r = yi(t10).position === "fixed";
  let o = r ? tr(t10) : t10;
  for (; bi(o) && !Lo(o); ) {
    const a = yi(o), l = Wp(o);
    !l && a.position === "fixed" && (s = null), (r ? !l && !s : !l && a.position === "static" && !!s && ["absolute", "fixed"].includes(s.position) || _l(o) && !l && u2(t10, o)) ? i = i.filter((u) => u !== o) : s = a, o = tr(o);
  }
  return e.set(t10, i), i;
}
function gI(t10) {
  let {
    element: e,
    boundary: n,
    rootBoundary: i,
    strategy: s
  } = t10;
  const o = [...n === "clippingAncestors" ? fd(e) ? [] : mI(e, this._c) : [].concat(n), i], a = o[0], l = o.reduce((c, u) => {
    const d = t0(e, u, s);
    return c.top = Pr(d.top, c.top), c.right = qc(d.right, c.right), c.bottom = qc(d.bottom, c.bottom), c.left = Pr(d.left, c.left), c;
  }, t0(e, a, s));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function bI(t10) {
  const {
    width: e,
    height: n
  } = a2(t10);
  return {
    width: e,
    height: n
  };
}
function yI(t10, e, n) {
  const i = qi(e), s = Ji(e), r = n === "fixed", o = qr(t10, true, r, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Bi(0);
  if (i || !i && !r)
    if ((io(e) !== "body" || _l(s)) && (a = hd(e)), i) {
      const f = qr(e, true, r, e);
      l.x = f.x + e.clientLeft, l.y = f.y + e.clientTop;
    } else s && (l.x = Kp(s));
  const c = s && !i && !r ? c2(s, a) : Bi(0), u = o.left + a.scrollLeft - l.x - c.x, d = o.top + a.scrollTop - l.y - c.y;
  return {
    x: u,
    y: d,
    width: o.width,
    height: o.height
  };
}
function nf(t10) {
  return yi(t10).position === "static";
}
function n0(t10, e) {
  if (!qi(t10) || yi(t10).position === "fixed")
    return null;
  if (e)
    return e(t10);
  let n = t10.offsetParent;
  return Ji(t10) === n && (n = n.ownerDocument.body), n;
}
function d2(t10, e) {
  const n = Kn(t10);
  if (fd(t10))
    return n;
  if (!qi(t10)) {
    let s = tr(t10);
    for (; s && !Lo(s); ) {
      if (bi(s) && !nf(s))
        return s;
      s = tr(s);
    }
    return n;
  }
  let i = n0(t10, e);
  for (; i && oI(i) && nf(i); )
    i = n0(i, e);
  return i && Lo(i) && nf(i) && !Wp(i) ? n : i || aI(t10) || n;
}
var vI = async function(t10) {
  const e = this.getOffsetParent || d2, n = this.getDimensions, i = await n(t10.floating);
  return {
    reference: yI(t10.reference, await e(t10.floating), t10.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
};
function xI(t10) {
  return yi(t10).direction === "rtl";
}
var kI = {
  convertOffsetParentRelativeRectToViewportRelativeRect: uI,
  getDocumentElement: Ji,
  getClippingRect: gI,
  getOffsetParent: d2,
  getElementRects: vI,
  getClientRects: dI,
  getDimensions: bI,
  getScale: Co,
  isElement: bi,
  isRTL: xI
};
function f2(t10, e) {
  return t10.x === e.x && t10.y === e.y && t10.width === e.width && t10.height === e.height;
}
function SI(t10, e) {
  let n = null, i;
  const s = Ji(t10);
  function r() {
    var a;
    clearTimeout(i), (a = n) == null || a.disconnect(), n = null;
  }
  function o(a, l) {
    a === void 0 && (a = false), l === void 0 && (l = 1), r();
    const c = t10.getBoundingClientRect(), {
      left: u,
      top: d,
      width: f,
      height: h10
    } = c;
    if (a || e(), !f || !h10)
      return;
    const p = Hl(d), g = Hl(s.clientWidth - (u + f)), m = Hl(s.clientHeight - (d + h10)), b = Hl(u), k = {
      rootMargin: -p + "px " + -g + "px " + -m + "px " + -b + "px",
      threshold: Pr(0, qc(1, l)) || 1
    };
    let v = true;
    function S(w) {
      const E = w[0].intersectionRatio;
      if (E !== l) {
        if (!v)
          return o();
        E ? o(false, E) : i = setTimeout(() => {
          o(false, 1e-7);
        }, 1e3);
      }
      E === 1 && !f2(c, t10.getBoundingClientRect()) && o(), v = false;
    }
    try {
      n = new IntersectionObserver(S, {
        ...k,
        // Handle <iframe>s
        root: s.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(S, k);
    }
    n.observe(t10);
  }
  return o(true), r;
}
function pd(t10, e, n, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: s = true,
    ancestorResize: r = true,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = false
  } = i, c = qp(t10), u = s || r ? [...c ? tl(c) : [], ...tl(e)] : [];
  u.forEach((b) => {
    s && b.addEventListener("scroll", n, {
      passive: true
    }), r && b.addEventListener("resize", n);
  });
  const d = c && a ? SI(c, n) : null;
  let f = -1, h10 = null;
  o && (h10 = new ResizeObserver((b) => {
    let [x] = b;
    x && x.target === c && h10 && (h10.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var k;
      (k = h10) == null || k.observe(e);
    })), n();
  }), c && !l && h10.observe(c), h10.observe(e));
  let p, g = l ? qr(t10) : null;
  l && m();
  function m() {
    const b = qr(t10);
    g && !f2(g, b) && n(), g = b, p = requestAnimationFrame(m);
  }
  return n(), () => {
    var b;
    u.forEach((x) => {
      s && x.removeEventListener("scroll", n), r && x.removeEventListener("resize", n);
    }), d == null || d(), (b = h10) == null || b.disconnect(), h10 = null, l && cancelAnimationFrame(p);
  };
}
var md = sI;
var gd = rI;
var bd = nI;
var wI = (t10, e, n) => {
  const i = /* @__PURE__ */ new Map(), s = {
    platform: kI,
    ...n
  }, r = {
    ...s.platform,
    _c: i
  };
  return tI(t10, e, {
    ...s,
    platform: r
  });
};
function CI(t10) {
  return t10 != null && typeof t10 == "object" && "$el" in t10;
}
function i0(t10) {
  if (CI(t10)) {
    const e = t10.$el;
    return Hp(e) && io(e) === "#comment" ? null : e;
  }
  return t10;
}
function ra(t10) {
  return typeof t10 == "function" ? t10() : unref(t10);
}
function h2(t10) {
  return typeof window > "u" ? 1 : (t10.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function s0(t10, e) {
  const n = h2(t10);
  return Math.round(e * n) / n;
}
function yd(t10, e, n) {
  n === void 0 && (n = {});
  const i = n.whileElementsMounted, s = computed(() => {
    var E;
    return (E = ra(n.open)) != null ? E : true;
  }), r = computed(() => ra(n.middleware)), o = computed(() => {
    var E;
    return (E = ra(n.placement)) != null ? E : "bottom";
  }), a = computed(() => {
    var E;
    return (E = ra(n.strategy)) != null ? E : "absolute";
  }), l = computed(() => {
    var E;
    return (E = ra(n.transform)) != null ? E : true;
  }), c = computed(() => i0(t10.value)), u = computed(() => i0(e.value)), d = ref(0), f = ref(0), h10 = ref(a.value), p = ref(o.value), g = shallowRef({}), m = ref(false), b = computed(() => {
    const E = {
      position: h10.value,
      left: "0",
      top: "0"
    };
    if (!u.value)
      return E;
    const M = s0(u.value, d.value), N = s0(u.value, f.value);
    return l.value ? {
      ...E,
      transform: "translate(" + M + "px, " + N + "px)",
      ...h2(u.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: h10.value,
      left: M + "px",
      top: N + "px"
    };
  });
  let x;
  function k() {
    if (c.value == null || u.value == null)
      return;
    const E = s.value;
    wI(c.value, u.value, {
      middleware: r.value,
      placement: o.value,
      strategy: a.value
    }).then((M) => {
      d.value = M.x, f.value = M.y, h10.value = M.strategy, p.value = M.placement, g.value = M.middlewareData, m.value = E !== false;
    });
  }
  function v() {
    typeof x == "function" && (x(), x = void 0);
  }
  function S() {
    if (v(), i === void 0) {
      k();
      return;
    }
    if (c.value != null && u.value != null) {
      x = i(c.value, u.value, k);
      return;
    }
  }
  function w() {
    s.value || (m.value = false);
  }
  return watch([r, o, a, s], k, {
    flush: "sync"
  }), watch([c, u], S, {
    flush: "sync"
  }), watch(s, w, {
    flush: "sync"
  }), getCurrentScope() && onScopeDispose(v), {
    x: shallowReadonly(d),
    y: shallowReadonly(f),
    strategy: shallowReadonly(h10),
    placement: shallowReadonly(p),
    middlewareData: shallowReadonly(g),
    isPositioned: shallowReadonly(m),
    floatingStyles: b,
    update: k
  };
}
var OI = ["id"];
var EI = ["id"];
var MI = Object.assign({ name: "mn-tooltip" }, {
  __name: "tooltip",
  props: {
    placement: {
      type: String,
      default: "start-center",
      validator: (t10) => ["start-center", "center-end", "end-center", "center-start"].includes(String(t10))
    },
    action: {
      type: String,
      default: "hover",
      validator: (t10) => ["click", "hover"].includes(String(t10))
    }
  },
  setup(t10) {
    const e = t10, n = useId(), i = ref(false), s = ref(null), r = ref(null), o = computed(() => e.placement === "start-center" ? "top" : e.placement === "center-end" ? "right" : e.placement === "end-center" ? "bottom" : e.placement === "center-start" ? "left" : "top"), { floatingStyles: a } = yd(s, r, {
      whileElementsMounted: pd,
      placement: o.value,
      middleware: [md(8), bd(), gd({ padding: 8 })]
    });
    function l(u) {
      if (!i.value) return;
      const d = u.target;
      d.closest(`#${n}-container`) || d.closest(`#${n}-tooltip`) || (i.value = false);
    }
    function c(u) {
      if (u.code === "Escape") {
        u.preventDefault(), i.value = false;
        return;
      }
      i.value = !i.value;
    }
    return onMounted(() => {
      window.addEventListener("click", l);
    }), onUnmounted(() => {
      window.removeEventListener("click", l);
    }), (u, d) => (openBlock(), createElementBlock("div", {
      ref_key: "triggerRef",
      ref: s,
      tabindex: "0",
      class: normalizeClass([t10.action, "mn-tooltip"]),
      id: `${unref(n)}-container`,
      onClick: c
    }, [
      renderSlot(u.$slots, "trigger", {}, void 0, true),
      createBaseVNode("div", {
        ref_key: "tooltipRef",
        ref: r,
        class: normalizeClass(["mn-tooltip-content", { "-hidden": !i.value }]),
        id: `${unref(n)}-tooltip`,
        style: normalizeStyle(unref(a))
      }, [
        renderSlot(u.$slots, "default", {}, void 0, true)
      ], 14, EI)
    ], 10, OI));
  }
});
var TI = Me(MI, [["__scopeId", "data-v-a7a6d9a4"]]);
var AI = { class: "mn-label" };
var _I = Object.assign({ name: "mn-label" }, {
  __name: "label",
  props: {
    label: {
      type: String,
      required: true
    },
    tooltip: String
  },
  setup(t10) {
    return (e, n) => (openBlock(), createElementBlock("label", AI, [
      createBaseVNode("span", null, toDisplayString(unref(Ie)(t10.label)), 1),
      t10.tooltip ? (openBlock(), createBlock(TI, { key: 0 }, {
        trigger: withCtx(() => [
          createVNode(ft, {
            class: "mn-label-tooltip-icon",
            icon: "far circle-info"
          })
        ]),
        default: withCtx(() => [
          createBaseVNode("span", null, toDisplayString(t10.tooltip), 1)
        ]),
        _: 1
      })) : createCommentVNode("", true)
    ]));
  }
});
var Ft = Me(_I, [["__scopeId", "data-v-997c7536"]]);
var NI = ["title"];
var LI = ["id", "min", "max", "step", "name", "disabled", "value", "aria-describedby", "aria-required"];
var II = ["id", "value"];
var PI = Object.assign({ name: "mn-range" }, {
  __name: "range",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: Number,
      default: 0
    },
    step: {
      type: Number,
      default: 1
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    hint: String,
    tooltip: String,
    compact: Boolean,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = e, i = t10, s = useId(), r = ref(null), o = ref(null), a = toRef(i, "name"), l = toRef(i, "rules"), { value: c, errors: u, handleChange: d, meta: f } = Sn(a, l, {
      initialValue: i.min,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    });
    function h10(p) {
      let g = (p.target.value - i.min) * 100 / (i.max - i.min);
      o.value = p.target.value, p.target.style.backgroundSize = g + "% 100%", n("update:modelValue", Number(p.target.value)), n("input", p, Number(p.target.value)), n("change", p, Number(p.target.value)), d(Number(p.target.value));
    }
    return watch(
      () => c.value,
      (p) => {
        let g = (p - i.min) * 100 / (i.max - i.min) || 0;
        r.value.style.backgroundSize = g + "% 100%";
      }
    ), (p, g) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-range", { "-hidden": t10.hidden, "-disabled": t10.disabled, "-compact": t10.compact }]),
      title: t10.labelless ? t10.label : null
    }, [
      createVNode(Ft, {
        class: normalizeClass(["mn-range-label", { invisible: t10.labelless }]),
        label: t10.label,
        tooltip: t10.tooltip,
        for: unref(s)
      }, null, 8, ["class", "label", "tooltip", "for"]),
      createBaseVNode("div", {
        class: normalizeClass(["mn-range-shell", { "-invalid": unref(u).length }])
      }, [
        createBaseVNode("input", {
          ref_key: "inputRef",
          ref: r,
          type: "range",
          class: "mn-range-input",
          id: unref(s),
          min: t10.min,
          max: t10.max,
          step: t10.step,
          name: t10.name,
          disabled: t10.disabled,
          value: unref(c),
          "aria-describedby": `${unref(s)}-error ${unref(s)}-hint`,
          "aria-required": t10.rules.includes("required") || null,
          onInput: h10,
          onChange: h10
        }, null, 40, LI),
        t10.compact ? createCommentVNode("", true) : (openBlock(), createElementBlock("output", {
          key: 0,
          ref_key: "outputRef",
          ref: o,
          id: `${unref(s)}-output`,
          class: "mn-range-value",
          "aria-hidden": "true",
          value: unref(c) || t10.min
        }, null, 8, II))
      ], 2),
      unref(u).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(u), (m) => (openBlock(), createBlock($n, {
        key: m,
        id: `${unref(s)}-error`,
        message: m
      }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
      t10.hint ? (openBlock(), createBlock(ln, {
        key: 1,
        id: `${unref(s)}-hint`,
        class: "mn-range-hint",
        label: t10.hint
      }, null, 8, ["id", "label"])) : createCommentVNode("", true)
    ], 10, NI));
  }
});
var p2 = Me(PI, [["__scopeId", "data-v-9eb32bfb"]]);
var DI = ["aria-details"];
var $I = ["src"];
var RI = ["src"];
var FI = ["src"];
var VI = ["hidden"];
var BI = { class: "mn-audio-controls" };
var zI = { class: "mn-audio-duration" };
var jI = ["id"];
var HI = Object.assign({ name: "mn-audio" }, {
  __name: "audio",
  props: {
    file: Object,
    src: String,
    title: String,
    cover: String,
    caption: String,
    titleless: Boolean,
    captionless: Boolean,
    card: Boolean
  },
  setup(t10) {
    const e = inject("minuit"), n = t10, i = useId(), s = ref(null), r = ref(false), o = ref(0), a = ref(0);
    function l() {
      var h10, p, g;
      (p = (h10 = n.file) == null ? void 0 : h10.original) != null && p.url || n.src ? o.value = Math.round((g = s.value) == null ? void 0 : g.duration) : o.value = 0;
    }
    function c() {
      r.value ? s.value.pause() : s.value.play(), r.value = !r.value;
    }
    function u() {
      s.value.currentTime = a.value;
    }
    function d() {
      a.value = Math.round(s.value.currentTime * 2) / 2;
    }
    function f() {
      r.value = false;
    }
    return (h10, p) => {
      var g, m, b, x, k, v, S, w, E, M, N, V, Y, F, re, z;
      return openBlock(), createElementBlock("figure", {
        class: "mn-audio",
        "aria-details": (g = t10.file) != null && g.caption || t10.caption ? `${unref(i)}` : null
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["mn-audio-player", { "-card": t10.card, "-titleless": t10.titleless, "-coverless": !((m = t10.file) != null && m.cover) && !t10.cover }]),
          style: normalizeStyle(t10.cover || (b = t10.file) != null && b.cover ? `--url: url(${t10.cover || t10.file.cover})` : null)
        }, [
          createBaseVNode("audio", {
            ref_key: "audioRef",
            ref: s,
            preload: "metadata",
            hidden: "",
            src: ((k = (x = t10.file) == null ? void 0 : x.original) == null ? void 0 : k.url) || t10.src,
            onLoadedmetadata: l,
            onTimeupdate: d,
            onEnded: f
          }, [
            renderSlot(h10.$slots, "default", {}, void 0, true),
            createBaseVNode("source", {
              src: ((S = (v = t10.file) == null ? void 0 : v.original) == null ? void 0 : S.url) || t10.src,
              type: "audio/mp3"
            }, null, 8, RI)
          ], 40, $I),
          (w = t10.file) != null && w.cover || t10.cover ? (openBlock(), createElementBlock("img", {
            key: 0,
            class: "mn-audio-cover",
            src: ((E = t10.file) == null ? void 0 : E.cover) || t10.cover,
            alt: "",
            loading: "lazy"
          }, null, 8, FI)) : createCommentVNode("", true),
          createBaseVNode("span", {
            class: "mn-audio-title",
            hidden: t10.titleless
          }, toDisplayString(unref(Ie)(((M = t10.file) == null ? void 0 : M.name) || t10.title)), 9, VI),
          createBaseVNode("ul", BI, [
            createBaseVNode("li", null, [
              createVNode(me, {
                class: normalizeClass(["mn-audio-button", { "-paused": !r.value }]),
                label: r.value ? unref(e).t("pause") : unref(e).t("play"),
                icon: r.value ? "pause" : "play",
                disabled: !((V = (N = t10.file) == null ? void 0 : N.original) != null && V.url) && !t10.src,
                color: "neutral",
                labelless: "",
                onClick: c
              }, null, 8, ["class", "label", "icon", "disabled"])
            ]),
            createBaseVNode("li", null, [
              createVNode(p2, {
                class: "mn-audio-range",
                label: unref(e).t("seek"),
                compact: "",
                labelless: "",
                modelValue: a.value,
                "onUpdate:modelValue": p[0] || (p[0] = (W) => a.value = W),
                disabled: !((F = (Y = t10.file) == null ? void 0 : Y.original) != null && F.url) && !t10.src,
                max: o.value,
                step: 0.5,
                onInput: u
              }, null, 8, ["label", "modelValue", "disabled", "max"])
            ]),
            createBaseVNode("li", null, [
              createBaseVNode("span", zI, toDisplayString(unref(Hc)(a.value)) + " / " + toDisplayString(unref(Hc)(o.value)), 1)
            ])
          ])
        ], 6),
        !t10.captionless && ((re = t10.file) != null && re.caption || t10.caption) ? (openBlock(), createElementBlock("figcaption", {
          key: 0,
          id: `${unref(i)}`,
          class: "mn-audio-caption"
        }, toDisplayString(unref(Ie)(((z = t10.file) == null ? void 0 : z.caption) || t10.caption)), 9, jI)) : createCommentVNode("", true)
      ], 8, DI);
    };
  }
});
var dZ = Me(HI, [["__scopeId", "data-v-6b97b2d5"]]);
var WI = {
  class: "mn-avatar-label",
  "aria-hidden": "true"
};
var UI = ["src"];
var qI = Object.assign({ name: "mn-avatar" }, {
  __name: "avatar",
  props: {
    label: {
      type: String,
      required: true
    },
    size: {
      type: String,
      default: "medium",
      validator: (t10) => ["small", "medium", "large"].includes(String(t10))
    },
    src: String,
    circle: Boolean
  },
  setup(t10) {
    return (e, n) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-avatar", [t10.size, { "-circle": t10.circle }]])
    }, [
      createBaseVNode("span", WI, toDisplayString(unref(xO)(t10.label)), 1),
      t10.src ? (openBlock(), createElementBlock("img", {
        key: 0,
        class: "mn-avatar-image",
        src: t10.src,
        alt: ""
      }, null, 8, UI)) : createCommentVNode("", true)
    ], 2));
  }
});
var KI = Me(qI, [["__scopeId", "data-v-94ff7b3d"]]);
var YI = ["aria-labelledby"];
var GI = ["id"];
var JI = { class: "mn-breadcrumbs-list" };
var XI = { class: "mn-breadcrumbs-item" };
var QI = Object.assign({ name: "mn-breadcrumbs" }, {
  __name: "breadcrumbs",
  props: {
    label: {
      type: String,
      required: true
    },
    links: {
      type: Array
    }
  },
  setup(t10) {
    const e = inject("minuit"), n = t10, i = useRoute(), s = ref([]), r = useId();
    return watch(
      () => n.links,
      () => {
        if (s.value = [], n.links)
          n.links.forEach((o) => {
            s.value.push({
              path: o.path,
              label: o.label,
              current: false
            });
          });
        else {
          const o = i.fullPath.split("/").filter((l) => l !== ""), a = ref("");
          o.forEach((l) => {
            a.value += `/${l}`, s.value.push({
              path: a.value,
              label: l.split("?")[0],
              current: false
            });
          });
        }
        return s.value[s.value.length - 1].current = true, s.value;
      },
      { immediate: true, deep: true }
    ), (o, a) => (openBlock(), createElementBlock("nav", {
      class: "mn-breadcrumbs",
      "aria-labelledby": `${unref(r)}`
    }, [
      createBaseVNode("span", {
        id: `${unref(r)}`,
        hidden: ""
      }, toDisplayString(t10.label), 9, GI),
      createBaseVNode("ol", JI, [
        createBaseVNode("li", XI, [
          createVNode(ds, {
            class: "mn-breadcrumbs-link",
            variant: "text",
            color: "neutral",
            path: "/",
            label: unref(e).t("home"),
            icon: "house",
            labelless: ""
          }, null, 8, ["label"])
        ]),
        s.value.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(s.value, (l) => (openBlock(), createElementBlock("li", {
          class: "mn-breadcrumbs-item",
          key: `${unref(r)}-${l.path}`
        }, [
          createVNode(ft, {
            icon: "angle-right",
            class: "mn-breadcrumbs-divider",
            color: "neutral",
            mirror: ""
          }),
          createVNode(ds, {
            class: "mn-breadcrumbs-link",
            variant: "text",
            color: "neutral",
            path: l.path,
            label: l.label,
            "aria-current": l.current ? "page" : null
          }, null, 8, ["path", "label", "aria-current"])
        ]))), 128)) : createCommentVNode("", true)
      ])
    ], 8, YI));
  }
});
var fZ = Me(QI, [["__scopeId", "data-v-519f2756"]]);
var ZI = { class: "mn-code" };
var eP = Object.assign({ name: "mn-code" }, {
  __name: "code",
  setup(t10) {
    return (e, n) => (openBlock(), createElementBlock("code", ZI, [
      renderSlot(e.$slots, "default", {}, void 0, true)
    ]));
  }
});
var hZ = Me(eP, [["__scopeId", "data-v-eec30b1d"]]);
var tP = {
  key: 0,
  class: "mn-divider-label"
};
var nP = {
  key: 1,
  class: "mn-divider-line"
};
var iP = Object.assign({ name: "mn-divider" }, {
  __name: "divider",
  props: {
    label: String,
    align: {
      type: String,
      default: "center",
      validator: (t10) => ["start", "center", "end"].includes(String(t10))
    },
    vertical: Boolean
  },
  setup(t10) {
    return (e, n) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-divider", [t10.align, { "-labelless": !t10.label, "-vertical": t10.vertical }]]),
      role: "separator"
    }, [
      n[0] || (n[0] = createBaseVNode("div", { class: "mn-divider-line" }, null, -1)),
      t10.label ? (openBlock(), createElementBlock("span", tP, toDisplayString(t10.label), 1)) : createCommentVNode("", true),
      t10.label ? (openBlock(), createElementBlock("div", nP)) : createCommentVNode("", true)
    ], 2));
  }
});
var pZ = Me(iP, [["__scopeId", "data-v-9bd9eda2"]]);
var sP = { class: "mn-empty" };
var rP = ["src"];
var oP = Object.assign({ name: "mn-empty" }, {
  __name: "empty",
  props: {
    label: {
      type: String,
      required: true
    },
    src: String
  },
  setup(t10) {
    return (e, n) => (openBlock(), createElementBlock("div", sP, [
      t10.src ? (openBlock(), createElementBlock("img", {
        key: 0,
        src: t10.src,
        alt: ""
      }, null, 8, rP)) : createCommentVNode("", true),
      createBaseVNode("span", null, toDisplayString(unref(Ie)(t10.label)), 1),
      renderSlot(e.$slots, "default", {}, void 0, true)
    ]));
  }
});
var mZ = Me(oP, [["__scopeId", "data-v-ac233db1"]]);
var aP = Object.assign({ name: "mn-text" }, {
  __name: "text",
  props: {
    size: {
      type: String,
      validator: (t10) => ["small", "medium", "large"].includes(String(t10))
    },
    align: {
      type: String,
      validator: (t10) => ["start", "center", "end"].includes(String(t10))
    },
    lines: {
      type: Number,
      default: null
    },
    muted: Boolean,
    bold: Boolean,
    italic: Boolean,
    balanced: Boolean
  },
  setup(t10) {
    return useCssVars((e) => ({
      c67f2c14: t10.lines
    })), (e, n) => (openBlock(), createElementBlock("p", {
      class: normalizeClass(["mn-text", [t10.size, t10.align, { "-ellipsis": t10.lines, "-muted": t10.muted, "-bold": t10.bold, "-italic": t10.italic, "-balanced": t10.balanced }]])
    }, [
      renderSlot(e.$slots, "default", {}, void 0, true)
    ], 2));
  }
});
var ui = Me(aP, [["__scopeId", "data-v-fff84995"]]);
var lP = {
  class: "mn-feedback-body",
  role: "status",
  "aria-live": "polite",
  "aria-atomic": "true"
};
var cP = { class: "mn-feedback-content" };
var uP = Object.assign({ name: "mn-feedback" }, {
  __name: "feedback",
  props: {
    message: {
      type: String,
      required: true
    },
    type: {
      type: String,
      validator: (t10) => ["success", "warning", "danger"].includes(String(t10))
    },
    icon: String,
    description: String,
    wide: Boolean,
    closable: Boolean
  },
  emits: ["close"],
  setup(t10, { emit: e }) {
    const n = e, i = inject("minuit"), s = t10, r = ref(null);
    function o() {
      switch (s.type) {
        case "success":
          return "far circle-check";
        case "warning":
          return "far triangle-exclamation";
        case "danger":
          return "far circle-exclamation";
        default:
          return s.icon || "sparkles";
      }
    }
    function a() {
      r.value.remove(), n("close");
    }
    return (l, c) => (openBlock(), createElementBlock("div", {
      ref_key: "feedbackRef",
      ref: r,
      class: normalizeClass(["mn-feedback", [t10.type, { "-wide": t10.wide }]])
    }, [
      createBaseVNode("div", lP, [
        createVNode(ft, {
          class: "mn-feedback-icon",
          color: t10.type || "accent",
          label: t10.type,
          icon: o()
        }, null, 8, ["color", "label", "icon"]),
        createBaseVNode("div", cP, [
          createVNode(ui, { class: "mn-feedback-title" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(Ie)(t10.message)), 1)
            ]),
            _: 1
          }),
          t10.description ? (openBlock(), createBlock(ui, {
            key: 0,
            class: "mn-feedback-description",
            muted: ""
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(Ie)(t10.description)), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true)
        ]),
        t10.closable ? (openBlock(), createBlock(me, {
          key: 0,
          class: "mn-feedback-close",
          variant: "text",
          color: "neutral",
          label: unref(i).t("close"),
          icon: "xmark",
          labelless: "",
          onClick: a
        }, null, 8, ["label"])) : createCommentVNode("", true)
      ])
    ], 2));
  }
});
var gZ = Me(uP, [["__scopeId", "data-v-ea6e84ef"]]);
var dP = ["aria-details"];
var fP = { class: "mn-image-picture" };
var hP = ["srcset"];
var pP = ["srcset"];
var mP = ["srcset"];
var gP = ["src", "alt", "loading"];
var bP = ["id"];
var yP = Object.assign({ name: "mn-image" }, {
  __name: "image",
  props: {
    file: Object,
    src: String,
    alt: String,
    caption: String,
    width: {
      type: String,
      default: "100%"
    },
    height: {
      type: String,
      default: "auto"
    },
    ratio: String,
    captionless: Boolean,
    fluid: Boolean,
    lazy: Boolean
  },
  setup(t10) {
    useCssVars((n) => ({
      "3b6dc02c": t10.width,
      "187b4b81": t10.height,
      "3b23e271": t10.ratio
    }));
    const e = useId();
    return (n, i) => {
      var s, r, o, a, l, c;
      return openBlock(), createElementBlock("figure", {
        class: normalizeClass(["mn-image", { "-fluid": t10.fluid }]),
        "aria-details": !t10.captionless && ((s = t10.file) != null && s.caption) || t10.caption ? `${unref(e)}` : null
      }, [
        createBaseVNode("picture", fP, [
          renderSlot(n.$slots, "default", {}, () => {
            var u, d, f, h10, p, g, m, b, x, k, v, S;
            return [
              (u = t10.file) != null && u.sources ? (openBlock(), createElementBlock("source", {
                key: 0,
                srcset: (h10 = (f = (d = t10.file) == null ? void 0 : d.sources) == null ? void 0 : f.thumbnail) == null ? void 0 : h10.url,
                media: "(max-width: 250px)"
              }, null, 8, hP)) : createCommentVNode("", true),
              (p = t10.file) != null && p.sources ? (openBlock(), createElementBlock("source", {
                key: 1,
                srcset: (b = (m = (g = t10.file) == null ? void 0 : g.sources) == null ? void 0 : m.mobile) == null ? void 0 : b.url,
                media: "(max-width: 1023px)"
              }, null, 8, pP)) : createCommentVNode("", true),
              (x = t10.file) != null && x.sources ? (openBlock(), createElementBlock("source", {
                key: 2,
                srcset: (S = (v = (k = t10.file) == null ? void 0 : k.sources) == null ? void 0 : v.desktop) == null ? void 0 : S.url,
                media: "(min-width: 1024px)"
              }, null, 8, mP)) : createCommentVNode("", true)
            ];
          }, true),
          createBaseVNode("img", {
            src: ((o = (r = t10.file) == null ? void 0 : r.original) == null ? void 0 : o.url) || t10.src,
            alt: ((a = t10.file) == null ? void 0 : a.alt) || t10.alt || "",
            loading: t10.lazy ? "lazy" : "eager"
          }, null, 8, gP)
        ]),
        !t10.captionless && ((l = t10.file) != null && l.caption || t10.caption) ? (openBlock(), createElementBlock("figcaption", {
          key: 0,
          id: `${unref(e)}`,
          class: normalizeClass(["mn-image-caption", { invisible: t10.fluid }])
        }, toDisplayString(unref(Ie)(((c = t10.file) == null ? void 0 : c.caption) || t10.caption)), 11, bP)) : createCommentVNode("", true)
      ], 10, dP);
    };
  }
});
var r0 = Me(yP, [["__scopeId", "data-v-f0a43428"]]);
var vP = { class: "mn-loader" };
var xP = Object.assign({ name: "mn-loader" }, {
  __name: "loader",
  props: {
    label: {
      type: String,
      required: true
    },
    labelless: Boolean
  },
  setup(t10) {
    return (e, n) => (openBlock(), createElementBlock("div", vP, [
      createVNode(ft, {
        class: "mn-loader-icon",
        color: "accent",
        icon: "far circle-notch",
        label: t10.labelless ? t10.label : null,
        spin: ""
      }, null, 8, ["label"]),
      createBaseVNode("span", {
        class: normalizeClass(["mn-loader-label", { invisible: t10.labelless }])
      }, toDisplayString(unref(Ie)(t10.label)), 3)
    ]));
  }
});
var bZ = Me(xP, [["__scopeId", "data-v-0999dac6"]]);
var kP = ["aria-labelledby"];
var SP = ["id"];
var wP = { class: "mn-pagination-list" };
var CP = ["id"];
var OP = { "aria-hidden": "true" };
var EP = ["id"];
var MP = ["id"];
var TP = ["id"];
var AP = ["id"];
var _P = ["id"];
var NP = ["id"];
var LP = ["id"];
var IP = { "aria-hidden": "true" };
var PP = ["id"];
var DP = Object.assign({ name: "mn-pagination" }, {
  __name: "pagination",
  props: {
    label: {
      type: String,
      required: true
    },
    total: {
      type: Number,
      required: true
    },
    current: {
      type: Number,
      default: 1
    }
  },
  emits: ["navigate"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = e, s = useId();
    return (r, o) => (openBlock(), createElementBlock("nav", {
      class: "mn-pagination",
      "aria-labelledby": `${unref(s)}`
    }, [
      createBaseVNode("span", {
        id: `${unref(s)}`,
        hidden: ""
      }, toDisplayString(t10.label), 9, SP),
      createBaseVNode("ul", wP, [
        createBaseVNode("li", null, [
          createVNode(me, {
            class: "mn-pagination-previous",
            label: unref(n).t("previousPage"),
            icon: "angle-left",
            variant: "text",
            labelless: "",
            mirror: "",
            color: "neutral",
            disabled: t10.current === 1,
            onClick: o[0] || (o[0] = (a) => i("navigate", t10.current - 1))
          }, null, 8, ["label", "disabled"])
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("span", {
            id: `${unref(s)}-first`,
            hidden: ""
          }, toDisplayString(`${unref(n).t("firstPage")} (1)`), 9, CP),
          createVNode(me, {
            color: "neutral",
            variant: "text",
            label: 1,
            "aria-labelledby": `${unref(s)}-first`,
            "aria-current": t10.current === 1 ? "page" : null,
            "aria-pressed": t10.current === 1 ? "true" : null,
            onClick: o[1] || (o[1] = (a) => i("navigate", 1))
          }, null, 8, ["aria-labelledby", "aria-current", "aria-pressed"])
        ]),
        withDirectives(createBaseVNode("li", OP, o[11] || (o[11] = [
          createBaseVNode("span", null, "...", -1)
        ]), 512), [
          [vShow, t10.total > 5 && t10.current > 3]
        ]),
        t10.total > 2 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          withDirectives(createBaseVNode("li", null, [
            createBaseVNode("span", {
              id: `${unref(s)}-minus-3`,
              hidden: ""
            }, toDisplayString(unref(n).t("page")) + " " + toDisplayString(t10.current - 3), 9, EP),
            createVNode(me, {
              variant: "text",
              color: "neutral",
              label: t10.current - 3,
              "aria-labelledby": `${unref(s)}-minus-3`,
              onClick: o[2] || (o[2] = (a) => i("navigate", t10.current - 3))
            }, null, 8, ["label", "aria-labelledby"])
          ], 512), [
            [vShow, t10.current >= t10.total && t10.current > 4]
          ]),
          withDirectives(createBaseVNode("li", null, [
            createBaseVNode("span", {
              id: `${unref(s)}-minus-2`,
              hidden: ""
            }, toDisplayString(unref(n).t("page")) + " " + toDisplayString(t10.current - 2), 9, MP),
            createVNode(me, {
              variant: "text",
              color: "neutral",
              label: t10.current - 2,
              "aria-labelledby": `${unref(s)}-minus-2`,
              onClick: o[3] || (o[3] = (a) => i("navigate", t10.current - 2))
            }, null, 8, ["label", "aria-labelledby"])
          ], 512), [
            [vShow, t10.current >= t10.total - 1 && t10.current > 3]
          ]),
          withDirectives(createBaseVNode("li", null, [
            createBaseVNode("span", {
              id: `${unref(s)}-minus-1`,
              hidden: ""
            }, toDisplayString(unref(n).t("page")) + " " + toDisplayString(t10.current - 1), 9, TP),
            createVNode(me, {
              variant: "text",
              color: "neutral",
              label: t10.current - 1,
              "aria-labelledby": `${unref(s)}-minus-1`,
              onClick: o[4] || (o[4] = (a) => i("navigate", t10.current - 1))
            }, null, 8, ["label", "aria-labelledby"])
          ], 512), [
            [vShow, t10.current <= t10.total && t10.current > 2]
          ]),
          withDirectives(createBaseVNode("li", null, [
            createBaseVNode("span", {
              id: `${unref(s)}-current`,
              hidden: ""
            }, toDisplayString(unref(n).t("page")) + " " + toDisplayString(t10.current), 9, AP),
            createVNode(me, {
              variant: "text",
              color: "neutral",
              label: t10.current,
              "aria-labelledby": `${unref(s)}-current`,
              "aria-current": "page",
              "aria-pressed": "true",
              onClick: o[5] || (o[5] = (a) => i("navigate", t10.current))
            }, null, 8, ["label", "aria-labelledby"])
          ], 512), [
            [vShow, t10.current > 1 && t10.current < t10.total]
          ]),
          withDirectives(createBaseVNode("li", null, [
            createBaseVNode("span", {
              id: `${unref(s)}-plus-1`,
              hidden: ""
            }, toDisplayString(unref(n).t("page")) + " " + toDisplayString(t10.current + 1), 9, _P),
            createVNode(me, {
              variant: "text",
              color: "neutral",
              label: t10.current + 1,
              "aria-labelledby": `${unref(s)}-plus-1`,
              onClick: o[6] || (o[6] = (a) => i("navigate", t10.current + 1))
            }, null, 8, ["label", "aria-labelledby"])
          ], 512), [
            [vShow, t10.current < t10.total - 1]
          ]),
          withDirectives(createBaseVNode("li", null, [
            createBaseVNode("span", {
              id: `${unref(s)}-plus-2`,
              hidden: ""
            }, toDisplayString(unref(n).t("page")) + " " + toDisplayString(t10.current + 2), 9, NP),
            createVNode(me, {
              variant: "text",
              color: "neutral",
              label: t10.current + 2,
              "aria-labelledby": `${unref(s)}-plus-2`,
              onClick: o[7] || (o[7] = (a) => i("navigate", t10.current + 2))
            }, null, 8, ["label", "aria-labelledby"])
          ], 512), [
            [vShow, t10.current < 3 && t10.current + 2 < t10.total]
          ]),
          withDirectives(createBaseVNode("li", null, [
            createBaseVNode("span", {
              id: `${unref(s)}-plus-3`,
              hidden: ""
            }, toDisplayString(unref(n).t("page")) + " " + toDisplayString(t10.current + 3), 9, LP),
            createVNode(me, {
              variant: "text",
              color: "neutral",
              label: t10.current + 3,
              "aria-labelledby": `${unref(s)}-plus-3`,
              onClick: o[8] || (o[8] = (a) => i("navigate", t10.current + 3))
            }, null, 8, ["label", "aria-labelledby"])
          ], 512), [
            [vShow, t10.current < 2 && t10.current + 3 < t10.total]
          ])
        ], 64)) : createCommentVNode("", true),
        withDirectives(createBaseVNode("li", IP, o[12] || (o[12] = [
          createBaseVNode("span", null, "...", -1)
        ]), 512), [
          [vShow, t10.total > 5 && t10.current < t10.total - 2]
        ]),
        createBaseVNode("li", null, [
          createBaseVNode("span", {
            id: `${unref(s)}-last`,
            hidden: ""
          }, toDisplayString(`${unref(n).t("lastPage")} (${t10.total})`), 9, PP),
          withDirectives(createVNode(me, {
            color: "neutral",
            variant: "text",
            label: t10.total,
            "aria-labelledby": `${unref(s)}-last`,
            "aria-current": t10.current === t10.total ? "page" : null,
            "aria-pressed": t10.current === t10.total ? "true" : null,
            onClick: o[9] || (o[9] = (a) => i("navigate", t10.total))
          }, null, 8, ["label", "aria-labelledby", "aria-current", "aria-pressed"]), [
            [vShow, t10.total > 1]
          ])
        ]),
        createBaseVNode("li", null, [
          createVNode(me, {
            class: "mn-pagination-next",
            label: unref(n).t("nextPage"),
            icon: "angle-right",
            variant: "text",
            labelless: "",
            mirror: "",
            color: "neutral",
            disabled: t10.current === t10.total,
            onClick: o[10] || (o[10] = (a) => i("navigate", t10.current + 1))
          }, null, 8, ["label", "disabled"])
        ])
      ])
    ], 8, kP));
  }
});
var $P = Me(DP, [["__scopeId", "data-v-cf4b5ac7"]]);
var RP = { class: "mn-progress" };
var FP = ["id"];
var VP = ["role", "aria-labelledby", "aria-valuemax", "aria-valuenow", "low", "high", "title"];
var BP = Object.assign({ name: "mn-progress" }, {
  __name: "progress",
  props: {
    label: {
      type: String,
      required: true
    },
    current: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    meter: Boolean,
    reversed: Boolean,
    labelless: Boolean
  },
  setup(t10) {
    useCssVars((r) => ({
      bfb158ae: i.value,
      e190d4c8: t10.max
    }));
    const e = t10, n = useId(), i = computed(() => e.current <= e.max ? e.current : e.max), s = computed(() => ({
      "-low": e.meter && e.current * 100 / e.max < 33,
      "-medium": e.meter && e.current * 100 / e.max >= 33 && e.current * 100 / e.max < 66,
      "-high": e.meter && e.current * 100 / e.max >= 66,
      "-complete": e.meter && e.current >= e.max
    }));
    return (r, o) => (openBlock(), createElementBlock("div", RP, [
      createVNode(Ft, {
        id: unref(n),
        class: normalizeClass({ invisible: t10.labelless }),
        label: t10.label
      }, null, 8, ["id", "class", "label"]),
      createBaseVNode("span", {
        id: `${unref(n)}-value`,
        hidden: ""
      }, toDisplayString(`${t10.current} / ${t10.max}`), 9, FP),
      createBaseVNode("div", {
        class: "mn-progress-bar",
        role: t10.meter ? "meter" : "progressbar",
        "aria-labelledby": `${unref(n)} ${unref(n)}-value`,
        "aria-valuemin": 0,
        "aria-valuemax": t10.max,
        "aria-valuenow": i.value,
        low: e.meter ? 33 * t10.max / 100 : null,
        high: e.meter ? 66 * t10.max / 100 : null,
        title: `${t10.current} / ${t10.max}`
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["mn-progress-fill", [s.value, { "-reversed": t10.reversed }]])
        }, null, 2)
      ], 8, VP)
    ]));
  }
});
var yZ = Me(BP, [["__scopeId", "data-v-9924f9eb"]]);
var zP = { class: "mn-tag-label" };
var jP = Object.assign({ name: "mn-tag" }, {
  __name: "tag",
  props: {
    label: {
      type: String,
      required: true
    },
    color: {
      type: String,
      validator: (t10) => [
        "red",
        "orange",
        "amber",
        "yellow",
        "lime",
        "green",
        "emerald",
        "teal",
        "cyan",
        "sky",
        "blue",
        "indigo",
        "violet",
        "purple",
        "fuchsia",
        "pink",
        "rose"
      ].includes(String(t10))
    },
    removable: Boolean
  },
  emits: ["remove"],
  setup(t10, { emit: e }) {
    useCssVars((o) => ({
      "13c6cd10": r.value.light.background,
      "66bb2514": r.value.light.border,
      "83a3ee12": r.value.light.text,
      "0be6c3f4": r.value.dark.background,
      "363d35f2": r.value.dark.border,
      "50ce7f1a": r.value.dark.text
    }));
    const n = inject("minuit"), i = e, s = t10, r = computed(() => ({
      light: {
        background: s.color ? `var(--${s.color}-50)` : "var(--bg-neutral-subtle)",
        border: s.color ? `var(--${s.color}-200)` : "var(--border-neutral-muted)",
        text: s.color ? `var(--${s.color}-700)` : "var(--text-neutral-muted)"
      },
      dark: {
        background: s.color ? `var(--${s.color}-950)` : "var(--bg-neutral-muted)",
        border: s.color ? `var(--${s.color}-800)` : "var(--border-neutral-muted)",
        text: s.color ? `var(--${s.color}-300)` : "var(--text-neutral-muted)"
      }
    }));
    return (o, a) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-tag", [{ "-removable": t10.removable }]])
    }, [
      createBaseVNode("span", zP, toDisplayString(unref(Ie)(t10.label)), 1),
      t10.removable ? (openBlock(), createBlock(me, {
        key: 0,
        class: "mn-tag-button",
        variant: "text",
        color: "neutral",
        fluid: "",
        label: unref(n).t("remove"),
        icon: "xmark",
        labelless: "",
        onClick: a[0] || (a[0] = (l) => i("remove"))
      }, null, 8, ["label"])) : createCommentVNode("", true)
    ], 2));
  }
});
var HP = Me(jP, [["__scopeId", "data-v-ccf5c1e9"]]);
var WP = ["title"];
var UP = ["id"];
var qP = { class: "mn-thumbnail-file" };
var KP = ["src"];
var YP = ["src"];
var GP = ["src"];
var JP = ["src"];
var XP = {
  key: 4,
  class: "mn-thumbnail-file-misc"
};
var QP = {
  key: 0,
  class: "mn-thumbnail-footer",
  "aria-hidden": "true"
};
var ZP = { class: "mn-thumbnail-name" };
var eD = { class: "mn-thumbnail-size" };
var tD = Object.assign({ name: "mn-thumbnail" }, {
  __name: "thumbnail",
  props: {
    file: {
      type: Object,
      required: true
    },
    size: {
      type: String,
      default: "medium",
      validator: (t10) => ["small", "medium", "large"].includes(String(t10))
    },
    footer: Boolean,
    removable: Boolean
  },
  emits: ["remove"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = e, s = t10, r = useId(), o = computed(() => {
      var a, l, c, u, d, f;
      return (c = (l = (a = s.file) == null ? void 0 : a.sources) == null ? void 0 : l.thumbnail) != null && c.url ? s.file.sources.thumbnail.url : (d = (u = s.file) == null ? void 0 : u.original) != null && d.url ? s.file.original.url : (f = s.file) != null && f.src || typeof s.file.src == "string" ? s.file.src : s.file instanceof Blob ? URL.createObjectURL(s.file) : null;
    });
    return (a, l) => {
      var c, u, d, f, h10, p, g, m, b, x;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["mn-thumbnail", [t10.size, { "-footerless": !t10.footer }]]),
        title: `${t10.file.name} ${unref(Na)(t10.file.size)}`
      }, [
        createBaseVNode("span", {
          id: unref(r),
          class: "invisible"
        }, toDisplayString(t10.file.type) + ", " + toDisplayString(t10.file.name) + ", " + toDisplayString(unref(Na)(t10.file.size)), 9, UP),
        createBaseVNode("div", qP, [
          (c = t10.file.mimetype) != null && c.includes("image") || (u = t10.file.type) != null && u.includes("image") ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: o.value,
            alt: ""
          }, null, 8, KP)) : (d = t10.file.mimetype) != null && d.includes("video") || (f = t10.file.type) != null && f.includes("video") ? (openBlock(), createElementBlock("video", {
            key: 1,
            src: o.value,
            alt: "",
            controls: ""
          }, null, 8, YP)) : (h10 = t10.file.mimetype) != null && h10.includes("autio") || (p = t10.file.type) != null && p.includes("audio") ? (openBlock(), createElementBlock("audio", {
            key: 2,
            src: o.value,
            alt: "",
            controls: ""
          }, null, 8, GP)) : t10.file.mimetype === "application/pdf" || t10.file.type === "application/pdf" ? (openBlock(), createElementBlock("embed", {
            key: 3,
            src: o.value,
            alt: ""
          }, null, 8, JP)) : (openBlock(), createElementBlock("div", XP, [
            (g = t10.file.mimetype) != null && g.includes("font") || (m = t10.file.type) != null && m.includes("font") ? (openBlock(), createBlock(ft, {
              key: 0,
              icon: "far book-font",
              color: "neutral",
              mirror: ""
            })) : t10.file.mimetype === "text/vtt" || t10.file.type === "text/vtt" ? (openBlock(), createBlock(ft, {
              key: 1,
              icon: "far subtitles",
              color: "neutral",
              mirror: ""
            })) : (b = t10.file.mimetype) != null && b.includes("text") || (x = t10.file.type) != null && x.includes("text") ? (openBlock(), createBlock(ft, {
              key: 2,
              icon: "far file-lines",
              color: "neutral",
              mirror: ""
            })) : (openBlock(), createBlock(ft, {
              key: 3,
              icon: "far file",
              color: "neutral",
              mirror: ""
            }))
          ]))
        ]),
        t10.footer ? (openBlock(), createElementBlock("div", QP, [
          createBaseVNode("span", ZP, toDisplayString(t10.file.name), 1),
          createBaseVNode("span", eD, toDisplayString(unref(Na)(t10.file.size)), 1)
        ])) : createCommentVNode("", true),
        t10.removable ? (openBlock(), createBlock(me, {
          key: 1,
          variant: "muted",
          color: "neutral",
          label: unref(n).t("remove"),
          labelless: "",
          icon: "xmark",
          onClick: l[0] || (l[0] = (k) => i("remove"))
        }, null, 8, ["label"])) : createCommentVNode("", true)
      ], 10, WP);
    };
  }
});
var nD = Me(tD, [["__scopeId", "data-v-d11cfadb"]]);
var iD = Object.assign({ name: "mn-title" }, {
  __name: "title",
  props: {
    tag: {
      type: String,
      required: true,
      validator: (t10) => ["h1", "h2", "h3", "h4", "h5", "h6"].includes(String(t10))
    },
    align: {
      type: String,
      validator: (t10) => ["start", "center", "end"].includes(String(t10))
    },
    lines: {
      type: Number,
      default: null
    }
  },
  setup(t10) {
    return useCssVars((e) => ({
      "6923d916": t10.lines
    })), (e, n) => (openBlock(), createBlock(resolveDynamicComponent(t10.tag), {
      class: normalizeClass(["mn-title", [t10.align, { "-ellipsis": t10.lines }]])
    }, {
      default: withCtx(() => [
        renderSlot(e.$slots, "default", {}, void 0, true)
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var o0 = Me(iD, [["__scopeId", "data-v-67bef644"]]);
var sD = ["id", "aria-labelledby"];
var rD = Object.assign({ name: "mn-menu" }, {
  __name: "menu",
  props: {
    label: {
      type: String,
      required: true
    },
    variant: {
      type: String,
      default: "full",
      validator: (t10) => ["full", "muted", "border", "text"].includes(String(t10))
    },
    color: {
      type: String,
      default: "accent",
      validator: (t10) => ["accent", "neutral", "danger"].includes(String(t10))
    },
    placement: {
      type: String,
      default: "end-start",
      validator: (t10) => ["start-start", "start-end", "end-start", "end-end"].includes(String(t10))
    },
    icon: String,
    autoclose: Boolean,
    mirror: Boolean,
    inline: Boolean,
    wide: Boolean,
    pill: Boolean,
    disabled: Boolean,
    labelless: Boolean,
    fluid: Boolean
  },
  setup(t10) {
    const e = t10, n = useId(), i = ref(false), s = ref(null), r = ref(null), o = ref(null), a = computed(
      () => Array.from(document.querySelectorAll(`#${n}-menu :is([role="menuitemradio"], [role="menuitem"], [role="menuitemcheckbox"])`))
    ), l = computed(() => e.placement === "start-start" ? "top-start" : e.placement === "start-end" ? "top-end" : e.placement === "end-start" ? "bottom-start" : e.placement === "end-end" ? "bottom-end" : "bottom-start"), { floatingStyles: c } = yd(s, r, {
      whileElementsMounted: pd,
      placement: l.value,
      middleware: [md(8), bd(), gd({ padding: 8 })]
    });
    function u(g) {
      if (!i.value) return;
      const m = g.target, b = document.getElementById(`${n}-button`);
      m === b || m.closest(`#${n}-button`) || m.closest(`#${n}-menu`) && !e.autoclose || (i.value = false);
    }
    function d() {
      i.value = !i.value;
    }
    function f(g) {
      e.disabled || ((g.code === "Enter" || g.code === "Space" || g.code === "ArrowDown") && (g.preventDefault(), d(), nextTick(() => {
        if (r.value.focus({ preventScroll: true }), o.value === null) p("first");
        else {
          const m = a.value[o.value];
          m && m.scrollIntoView({ block: "nearest" });
        }
      })), g.code === "ArrowUp" && (g.preventDefault(), d(), nextTick(() => {
        if (r.value.focus({ preventScroll: true }), o.value === null) p("last");
        else {
          const m = a.value[o.value];
          m && m.scrollIntoView({ block: "nearest" });
        }
      })));
    }
    function h10(g) {
      if (!(g.metaKey || g.ctrlKey)) {
        if (g.code === "Escape" && (g.preventDefault(), d(), nextTick(() => document.getElementById(`${n}-button`).focus({ preventScroll: true }))), g.code === "Enter" || g.code === "Space") {
          g.stopPropagation();
          const m = a.value[o.value];
          m && m.click(), e.autoclose && d();
        }
        (g.code === "Home" || g.code === "PageUp") && (g.preventDefault(), g.stopPropagation(), p("first")), g.code === "ArrowUp" && (g.preventDefault(), g.stopPropagation(), p("previous")), g.code === "ArrowDown" && (g.preventDefault(), g.stopPropagation(), p("next")), (g.code === "End" || g.code === "PageDown") && (g.preventDefault(), g.stopPropagation(), p("last")), g.code === "Tab" && (g.preventDefault(), g.stopPropagation(), d(), nextTick(() => document.getElementById(`${n}-button`).focus({ preventScroll: true })));
      }
    }
    function p(g) {
      i.value && (g === "first" && (o.value = 0), g === "previous" && (o.value === 0 ? o.value = a.value.length - 1 : o.value--), g === "next" && (o.value === a.value.length - 1 ? o.value = 0 : o.value++), g === "last" && (o.value = a.value.length - 1), nextTick(() => {
        const m = a.value[o.value];
        m && m.scrollIntoView({ block: "nearest" }), m && m.focus();
      }));
    }
    return onMounted(() => {
      window.addEventListener("click", u);
    }), onUnmounted(() => {
      window.removeEventListener("click", u);
    }), (g, m) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-menu", { "-wide": t10.wide }])
    }, [
      createVNode(me, {
        ref_key: "buttonRef",
        ref: s,
        id: `${unref(n)}-button`,
        label: t10.label,
        variant: t10.variant,
        color: t10.color,
        fluid: t10.fluid,
        icon: t10.icon,
        mirror: t10.mirror,
        inline: t10.inline,
        wide: t10.wide,
        pill: t10.pill,
        disabled: t10.disabled,
        labelless: t10.labelless,
        "aria-expanded": i.value,
        "aria-haspopup": "menu",
        onClick: d,
        onKeydown: f
      }, null, 8, ["id", "label", "variant", "color", "fluid", "icon", "mirror", "inline", "wide", "pill", "disabled", "labelless", "aria-expanded"]),
      createBaseVNode("div", {
        ref_key: "menuRef",
        ref: r,
        class: normalizeClass(["mn-menu-content", [t10.placement, { "-hidden": !i.value }]]),
        role: "menu",
        tabindex: "0",
        id: `${unref(n)}-menu`,
        "aria-labelledby": `${unref(n)}-button`,
        style: normalizeStyle(unref(c)),
        onKeydown: h10
      }, [
        renderSlot(g.$slots, "default")
      ], 46, sD)
    ], 2));
  }
});
var Yp = Me(rD, [["__scopeId", "data-v-78cf3c63"]]);
var oD = ["aria-details"];
var aD = { class: "mn-video-player" };
var lD = ["autoplay", "loop", "muted", "playsinline", "poster"];
var cD = ["src"];
var uD = ["src", "srclang", "label"];
var dD = ["src", "srclang", "label"];
var fD = {
  class: "mn-video-title",
  "data-theme": "dark"
};
var hD = { class: "mn-video-controls-track" };
var pD = ["id"];
var mD = { class: "mn-video-subtitles" };
var gD = ["id"];
var bD = Object.assign({ name: "mn-video" }, {
  __name: "video",
  props: {
    file: Object,
    subtitles: Array,
    src: String,
    title: String,
    cover: String,
    caption: String,
    captionless: Boolean,
    autoplay: Boolean,
    loop: Boolean
  },
  setup(t10) {
    const e = useId(), n = inject("minuit"), i = t10, s = ref(null), r = ref(null), o = ref(false), a = ref(false), l = ref(false), c = ref(false), u = ref(null), d = ref(0), f = ref(0);
    function h10() {
      var S, w, E;
      (w = (S = i.file) == null ? void 0 : S.original) != null && w.url || i.src ? d.value = Math.round((E = r.value) == null ? void 0 : E.duration) : d.value = 0;
    }
    function p() {
      o.value ? r.value.pause() : r.value.play(), o.value = !o.value;
    }
    function g() {
      r.value.muted = !r.value.muted, a.value = r.value.muted;
    }
    function m(S) {
      if (S === "off") {
        for (const w of r.value.textTracks) w.mode = "hidden";
        u.value = null;
      } else
        for (const [w, E] of Object.entries(r.value.textTracks))
          Number(w) === S ? (E.mode = "showing", u.value = E.language) : E.mode = "hidden";
      c.value = false;
    }
    function b() {
      l.value ? document.exitFullscreen() : s.value.requestFullscreen();
    }
    function x() {
      r.value.currentTime = f.value;
    }
    function k() {
      var S;
      f.value = Math.round(((S = r.value) == null ? void 0 : S.currentTime) * 2) / 2;
    }
    function v() {
      o.value = false;
    }
    return onMounted(() => {
      document.addEventListener("fullscreenchange", () => l.value = !l.value);
    }), onUnmounted(() => {
      document.removeEventListener("fullscreenchange", () => l.value = !l.value);
    }), (S, w) => {
      var E, M, N, V, Y, F, re, z, W, C, O, _, T, H, Q, ae, pe, xe, Te, L, K, B;
      return openBlock(), createElementBlock("figure", {
        ref_key: "containerRef",
        ref: s,
        class: "mn-video",
        "aria-details": (E = t10.file) != null && E.caption || t10.caption ? `${unref(e)}` : null
      }, [
        createBaseVNode("div", aD, [
          createBaseVNode("video", {
            ref_key: "videoRef",
            ref: r,
            autoplay: t10.autoplay,
            loop: t10.loop,
            muted: t10.autoplay,
            playsinline: t10.autoplay,
            preload: "metadata",
            poster: ((M = t10.file) == null ? void 0 : M.cover) || t10.cover || null,
            class: normalizeClass({ "-fullscreen": l.value }),
            onLoadedmetadata: h10,
            onTimeupdate: k,
            onEnded: v,
            onClick: p
          }, [
            renderSlot(S.$slots, "default", {}, void 0, true),
            createBaseVNode("source", {
              src: ((V = (N = t10.file) == null ? void 0 : N.original) == null ? void 0 : V.url) || t10.src,
              type: "video/mp4"
            }, null, 8, cD),
            (F = (Y = t10.file) == null ? void 0 : Y.subtitles) != null && F.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList((re = t10.file) == null ? void 0 : re.subtitles, (X) => (openBlock(), createElementBlock("track", {
              key: X.code,
              src: X.url,
              kind: "subtitles",
              srclang: X.code,
              label: X.label
            }, null, 8, uD))), 128)) : (z = t10.subtitles) != null && z.length ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(t10.subtitles, (X) => (openBlock(), createElementBlock("track", {
              key: X.code,
              src: X.url,
              kind: "subtitles",
              srclang: X.code,
              label: X.label
            }, null, 8, dD))), 128)) : createCommentVNode("", true)
          ], 42, lD),
          createBaseVNode("span", fD, toDisplayString(unref(Ie)(((W = t10.file) == null ? void 0 : W.name) || t10.title)), 1),
          createBaseVNode("ul", {
            class: normalizeClass(["mn-video-controls", { "-fullscreen": l.value }]),
            "data-theme": "dark"
          }, [
            createBaseVNode("li", hD, [
              createVNode(p2, {
                label: unref(n).t("seek"),
                compact: "",
                labelless: "",
                modelValue: f.value,
                "onUpdate:modelValue": w[0] || (w[0] = (X) => f.value = X),
                disabled: !((O = (C = t10.file) == null ? void 0 : C.original) != null && O.url) && !t10.src,
                max: d.value,
                step: 0.5,
                onInput: x,
                "aria-describedby": `${unref(e)}-time`
              }, null, 8, ["label", "modelValue", "disabled", "max", "aria-describedby"])
            ]),
            createBaseVNode("li", null, [
              createVNode(me, {
                label: o.value ? unref(n).t("pause") : unref(n).t("play"),
                icon: o.value ? "pause" : "play",
                disabled: !((T = (_ = t10.file) == null ? void 0 : _.original) != null && T.url) && !t10.src,
                variant: "text",
                color: "neutral",
                labelless: "",
                onClick: p
              }, null, 8, ["label", "icon", "disabled"])
            ]),
            createBaseVNode("li", null, [
              createVNode(me, {
                label: a.value ? unref(n).t("unmute") : unref(n).t("mute"),
                icon: a.value ? "volume-xmark" : "volume",
                disabled: !((Q = (H = t10.file) == null ? void 0 : H.original) != null && Q.url) && !t10.src,
                variant: "text",
                color: "neutral",
                labelless: "",
                onClick: g
              }, null, 8, ["label", "icon", "disabled"])
            ]),
            createBaseVNode("li", null, [
              createBaseVNode("span", {
                id: `${unref(e)}-time`,
                class: "mn-video-duration"
              }, toDisplayString(unref(Hc)(f.value)) + " / " + toDisplayString(unref(Hc)(d.value)), 9, pD)
            ]),
            createBaseVNode("li", mD, [
              createVNode(Yp, {
                label: unref(n).t("subtitles"),
                icon: u.value ? "closed-captioning" : "closed-captioning-slash",
                disabled: !((pe = (ae = t10.file) == null ? void 0 : ae.original) != null && pe.url) && !t10.src || !((Te = (xe = t10.file) == null ? void 0 : xe.subtitles) != null && Te.length) && !((L = t10.subtitles) != null && L.length),
                placement: "start-end",
                variant: "text",
                color: "neutral",
                labelless: ""
              }, {
                default: withCtx(() => {
                  var X, be, Ce, Oe;
                  return [
                    createVNode(me, {
                      label: unref(n).t("off"),
                      variant: "text",
                      color: u.value ? "neutral" : "accent",
                      role: "menuitemradio",
                      onClick: w[1] || (w[1] = (Ue) => m("off")),
                      "aria-checked": !u.value
                    }, null, 8, ["label", "color", "aria-checked"]),
                    (be = (X = t10.file) == null ? void 0 : X.subtitles) != null && be.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList((Ce = t10.file) == null ? void 0 : Ce.subtitles, (Ue, J) => (openBlock(), createBlock(me, {
                      key: Ue.label,
                      label: Ue.label,
                      variant: "text",
                      color: u.value === Ue.code ? "accent" : "neutral",
                      role: "menuitemradio",
                      onClick: (Fe) => m(J),
                      "aria-checked": u.value === Ue.code
                    }, null, 8, ["label", "color", "onClick", "aria-checked"]))), 128)) : (Oe = t10.subtitles) != null && Oe.length ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(t10.subtitles, (Ue, J) => (openBlock(), createBlock(me, {
                      key: Ue.label,
                      label: Ue.label,
                      variant: "text",
                      color: u.value === Ue.code ? "accent" : "neutral",
                      role: "menuitemradio",
                      onClick: (Fe) => m(J),
                      "aria-checked": u.value === Ue.code
                    }, null, 8, ["label", "color", "onClick", "aria-checked"]))), 128)) : createCommentVNode("", true)
                  ];
                }),
                _: 1
              }, 8, ["label", "icon", "disabled"])
            ]),
            createBaseVNode("li", null, [
              createVNode(me, {
                label: l.value ? unref(n).t("exitFullscreen") : unref(n).t("fullscreen"),
                icon: l.value ? "far compress" : "far expand",
                disabled: !t10.src,
                variant: "text",
                color: "neutral",
                labelless: "",
                onClick: b
              }, null, 8, ["label", "icon", "disabled"])
            ])
          ], 2)
        ]),
        !t10.captionless && ((K = t10.file) != null && K.caption || t10.caption) ? (openBlock(), createElementBlock("figcaption", {
          key: 0,
          id: `${unref(e)}`,
          class: "mn-video-caption"
        }, toDisplayString(unref(Ie)(((B = t10.file) == null ? void 0 : B.caption) || t10.caption)), 9, gD)) : createCommentVNode("", true)
      ], 8, oD);
    };
  }
});
var vZ = Me(bD, [["__scopeId", "data-v-8d7b5e21"]]);
function Io(t10, e, n) {
  const i = [];
  return Array.isArray(t10) ? t10.forEach((s) => {
    n ? n.push(s) : s && i.push(s), s && s[e] && i.push(...Io(s[e], e, i));
  }) : (n ? n.push(t10) : t10 && i.push(t10), t10 && t10[e] && i.push(...Io(t10[e], e, i))), i;
}
var yD = ["title"];
var vD = ["id", "value", "checked", "indeterminate", "disabled", "name", "aria-describedby", "aria-required"];
var xD = Object.assign({ name: "mn-checkbox" }, {
  __name: "checkbox",
  props: {
    label: {
      type: [String, Number],
      required: true
    },
    modelValue: {
      type: [String, Number, Array, Object, Boolean],
      default: null
    },
    groupValue: [String, Number, Object],
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    compareKey: {
      type: String,
      default: "_id"
    },
    hint: String,
    tooltip: String,
    indeterminate: Boolean,
    control: Boolean,
    toggle: Boolean,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = e, i = t10, s = useId(), r = ref(null), o = toRef(i, "name"), a = toRef(i, "rules"), { value: l, errors: c, handleChange: u, meta: d } = Sn(o, a, {
      initialValue: i.groupValue || i.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    });
    function f(h10) {
      i.groupValue ? (h10.type === "input" && n("input", h10, i.groupValue, h10.target.checked), h10.type === "change" && n("change", h10, i.groupValue, h10.target.checked)) : (l.value !== void 0 && n("update:modelValue", h10.target.checked), h10.type === "input" && n("input", h10, h10.target.checked), h10.type === "change" && (n("change", h10, h10.target.checked), u(h10.target.checked)));
    }
    return watch(
      () => i.indeterminate,
      (h10) => {
        r.value && (r.value.indeterminate = h10);
      },
      { immediate: true }
    ), (h10, p) => {
      var g;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["mn-checkbox", { "-labelless": t10.labelless, "-hidden": t10.hidden, "-disabled": t10.disabled, "-toggle": t10.toggle }]),
        title: t10.labelless ? t10.label : null
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["mn-checkbox-button", { "-invalid": unref(c).length }])
        }, [
          createBaseVNode("input", {
            ref_key: "checkboxRef",
            ref: r,
            class: "mn-checkbox-input",
            type: "checkbox",
            id: unref(s),
            value: t10.control ? t10.modelValue : unref(l),
            checked: t10.control ? t10.modelValue : t10.groupValue ? (g = t10.modelValue) == null ? void 0 : g.map((m) => typeof m == "object" ? m == null ? void 0 : m[t10.compareKey] : m).includes(t10.groupValue) : unref(l),
            indeterminate: t10.indeterminate,
            disabled: t10.disabled,
            name: t10.name,
            "aria-describedby": `${unref(s)}-error ${unref(s)}-hint`,
            "aria-required": t10.rules.includes("required") || null,
            onInput: f,
            onChange: f
          }, null, 40, vD),
          !t10.toggle && !t10.indeterminate ? (openBlock(), createBlock(ft, {
            key: 0,
            class: "mn-checkbox-checked",
            icon: "check"
          })) : createCommentVNode("", true),
          t10.toggle ? createCommentVNode("", true) : (openBlock(), createBlock(ft, {
            key: 1,
            class: "mn-checkbox-indeterminate",
            icon: "minus"
          }))
        ], 2),
        createVNode(Ft, {
          class: normalizeClass(["mn-checkbox-label", { invisible: t10.labelless }]),
          label: unref(Ie)(t10.label),
          tooltip: t10.tooltip,
          for: unref(s)
        }, null, 8, ["class", "label", "tooltip", "for"]),
        unref(c).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(c), (m) => (openBlock(), createBlock($n, {
          key: m,
          id: `${unref(s)}-error`,
          message: m
        }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
        t10.hint ? (openBlock(), createBlock(ln, {
          key: 1,
          id: `${unref(s)}-hint`,
          class: "mn-checkbox-hint",
          label: t10.hint
        }, null, 8, ["id", "label"])) : createCommentVNode("", true)
      ], 10, yD);
    };
  }
});
var Jc = Me(xD, [["__scopeId", "data-v-323dc82f"]]);
var kD = ["id", "aria-describedby", "title", "name"];
var SD = Object.assign({ name: "mn-checkbox-group" }, {
  __name: "checkbox-group",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: Array,
      default: () => []
    },
    options: {
      type: [Array, Object],
      default: () => []
    },
    entry: {
      type: String,
      default: "children"
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    compareKey: {
      type: String,
      default: "_id"
    },
    hint: String,
    tooltip: String,
    hintKey: String,
    control: String,
    toggle: Boolean,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean,
    formatIn: {
      type: Function,
      default: (t10) => t10
    },
    formatOut: {
      type: Function,
      default: (t10) => t10
    }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = e, i = t10, s = useId(), r = ref(false), o = computed(() => Io(i.options, i.entry)), a = toRef(i, "name"), l = toRef(i, "rules"), { value: c, errors: u, handleChange: d, meta: f } = Sn(a, l, {
      initialValue: i.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    });
    function h10(g, m) {
      m ? (r.value = true, c.value = o.value.map((b) => i.formatOut(b))) : String(r.value) === "indeterminate" ? (r.value = true, c.value = o.value.map((b) => i.formatOut(b))) : (r.value = false, c.value = []), n("update:modelValue", c.value), g.type === "input" && (n("input", g, c.value), d(c.value)), g.type === "change" && (n("change", g, c.value), d(c.value));
    }
    function p(g, m, b) {
      b && !c.value.includes(m) && (c.value = [...c.value, m]), !b && c.value.includes(m) && (c.value = [...c.value].filter((x) => x !== m)), n("update:modelValue", c.value), g.type === "input" && (n("input", g, c.value, b ? m : null), d(c.value)), g.type === "change" && (n("change", g, c.value, b ? m : null), d(c.value));
    }
    return watch(
      () => c.value,
      (g) => {
        r.value = (g == null ? void 0 : g.length) === o.value.length ? true : (g == null ? void 0 : g.length) === 0 || !g ? false : "indeterminate";
      },
      { immediate: true, deep: true }
    ), (g, m) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-checkbox-group", { "-hidden": t10.hidden }]),
      role: "group",
      id: unref(s),
      "aria-describedby": `${unref(s)}-error ${unref(s)}-hint`,
      title: t10.labelless ? t10.label : null,
      name: t10.name
    }, [
      createVNode(Ft, {
        class: normalizeClass(["mn-checkbox-group-label", { invisible: t10.labelless }]),
        label: t10.label,
        tooltip: t10.tooltip,
        for: unref(s)
      }, null, 8, ["class", "label", "tooltip", "for"]),
      createBaseVNode("div", {
        class: normalizeClass(["mn-checkbox-group-list", { "-invalid": unref(u).length }])
      }, [
        t10.control ? (openBlock(), createBlock(Jc, {
          key: 0,
          class: "mn-checkbox-group-control",
          label: t10.control,
          toggle: t10.toggle,
          disabled: t10.disabled,
          modelValue: r.value,
          indeterminate: String(r.value) === "indeterminate",
          form: `${unref(s)}-form`,
          control: "",
          onInput: h10,
          onChange: h10
        }, null, 8, ["label", "toggle", "disabled", "modelValue", "indeterminate", "form"])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(o.value, (b) => (openBlock(), createBlock(Jc, {
          class: "mn-checkbox-group-option",
          key: `${unref(s)}-${JSON.stringify(b)}`,
          label: t10.formatIn(b),
          groupValue: typeof b == "object" ? b == null ? void 0 : b[t10.compareKey] : b,
          compareKey: t10.compareKey,
          form: `${unref(s)}-form`,
          toggle: t10.toggle,
          disabled: t10.disabled,
          modelValue: unref(c),
          hint: b == null ? void 0 : b[t10.hintKey],
          onInput: p,
          onChange: p
        }, null, 8, ["label", "groupValue", "compareKey", "form", "toggle", "disabled", "modelValue", "hint"]))), 128))
      ], 2),
      unref(u).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(u), (b) => (openBlock(), createBlock($n, {
        key: b,
        id: `${unref(s)}-error`,
        message: b
      }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
      t10.hint ? (openBlock(), createBlock(ln, {
        key: 1,
        id: `${unref(s)}-hint`,
        class: "mn-checkbox-group-hint",
        label: t10.hint
      }, null, 8, ["id", "label"])) : createCommentVNode("", true)
    ], 10, kD));
  }
});
var xZ = Me(SD, [["__scopeId", "data-v-8199ac18"]]);
function ai(t10) {
  return getComputedStyle(document.body).getPropertyValue(t10);
}
var wD = ["title"];
var CD = ["value", "disabled"];
var OD = ["value", "id", "disabled", "placeholder", "name", "aria-describedby", "aria-required"];
var ED = Object.assign({ name: "mn-color" }, {
  __name: "color",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: String,
      default: null
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    hint: String,
    placeholder: String,
    tooltip: String,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    useCssVars((h10) => ({
      "702c9a62": unref(l)
    }));
    const n = e, i = t10, s = useId(), r = ref(ai("--border-accent")), o = toRef(i, "name"), a = toRef(i, "rules"), { value: l, errors: c, handleChange: u, meta: d } = Sn(o, a, {
      initialValue: i.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    });
    function f(h10) {
      l.value !== void 0 && n("update:modelValue", h10.target.value), h10.type === "input" && n("input", h10, h10.target.value), h10.type === "change" && (n("change", h10, h10.target.value), u(h10.target.value));
    }
    return (h10, p) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-color", { "-hidden": t10.hidden, "-disabled": t10.disabled }]),
      title: t10.labelless ? t10.label : null
    }, [
      createVNode(Ft, {
        class: normalizeClass(["mn-color-label", { invisible: t10.labelless }]),
        label: t10.label,
        tooltip: t10.tooltip,
        for: unref(s)
      }, null, 8, ["class", "label", "tooltip", "for"]),
      createBaseVNode("div", {
        class: normalizeClass(["mn-color-shell", { "-invalid": unref(c).length }])
      }, [
        createBaseVNode("input", {
          tabindex: "-1",
          class: "mn-color-input-color",
          type: "color",
          value: unref(l) || r.value,
          "aria-hidden": true,
          disabled: t10.disabled,
          onInput: f,
          onChange: f
        }, null, 40, CD),
        createBaseVNode("input", {
          class: "mn-color-input-field",
          type: "text",
          value: unref(l),
          id: unref(s),
          disabled: t10.disabled,
          placeholder: t10.placeholder,
          name: t10.name,
          "aria-describedby": `${unref(s)}-error ${unref(s)}-hint`,
          "aria-required": t10.rules.includes("required") || null,
          onInput: f,
          onChange: f
        }, null, 40, OD)
      ], 2),
      unref(c).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(c), (g) => (openBlock(), createBlock($n, {
        key: g,
        id: `${unref(s)}-error`,
        message: g
      }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
      t10.hint ? (openBlock(), createBlock(ln, {
        key: 1,
        id: `${unref(s)}-hint`,
        class: "mn-color-hint",
        label: t10.hint
      }, null, 8, ["id", "label"])) : createCommentVNode("", true)
    ], 10, wD));
  }
});
var kZ = Me(ED, [["__scopeId", "data-v-683475a9"]]);
function Gt(t10) {
  this.content = t10;
}
Gt.prototype = {
  constructor: Gt,
  find: function(t10) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t10) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t10) {
    var e = this.find(t10);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t10, e, n) {
    var i = n && n != t10 ? this.remove(n) : this, s = i.find(t10), r = i.content.slice();
    return s == -1 ? r.push(n || t10, e) : (r[s + 1] = e, n && (r[s] = n)), new Gt(r);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t10) {
    var e = this.find(t10);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new Gt(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t10, e) {
    return new Gt([t10, e].concat(this.remove(t10).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t10, e) {
    var n = this.remove(t10).content.slice();
    return n.push(t10, e), new Gt(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t10, e, n) {
    var i = this.remove(e), s = i.content.slice(), r = i.find(t10);
    return s.splice(r == -1 ? s.length : r, 0, e, n), new Gt(s);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t10) {
    for (var e = 0; e < this.content.length; e += 2)
      t10(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t10) {
    return t10 = Gt.from(t10), t10.size ? new Gt(t10.content.concat(this.subtract(t10).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t10) {
    return t10 = Gt.from(t10), t10.size ? new Gt(this.subtract(t10).content.concat(t10.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t10) {
    var e = this;
    t10 = Gt.from(t10);
    for (var n = 0; n < t10.content.length; n += 2)
      e = e.remove(t10.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t10 = {};
    return this.forEach(function(e, n) {
      t10[e] = n;
    }), t10;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Gt.from = function(t10) {
  if (t10 instanceof Gt) return t10;
  var e = [];
  if (t10) for (var n in t10) e.push(n, t10[n]);
  return new Gt(e);
};
function m2(t10, e, n) {
  for (let i = 0; ; i++) {
    if (i == t10.childCount || i == e.childCount)
      return t10.childCount == e.childCount ? null : n;
    let s = t10.child(i), r = e.child(i);
    if (s == r) {
      n += s.nodeSize;
      continue;
    }
    if (!s.sameMarkup(r))
      return n;
    if (s.isText && s.text != r.text) {
      for (let o = 0; s.text[o] == r.text[o]; o++)
        n++;
      return n;
    }
    if (s.content.size || r.content.size) {
      let o = m2(s.content, r.content, n + 1);
      if (o != null)
        return o;
    }
    n += s.nodeSize;
  }
}
function g2(t10, e, n, i) {
  for (let s = t10.childCount, r = e.childCount; ; ) {
    if (s == 0 || r == 0)
      return s == r ? null : { a: n, b: i };
    let o = t10.child(--s), a = e.child(--r), l = o.nodeSize;
    if (o == a) {
      n -= l, i -= l;
      continue;
    }
    if (!o.sameMarkup(a))
      return { a: n, b: i };
    if (o.isText && o.text != a.text) {
      let c = 0, u = Math.min(o.text.length, a.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, n--, i--;
      return { a: n, b: i };
    }
    if (o.content.size || a.content.size) {
      let c = g2(o.content, a.content, n - 1, i - 1);
      if (c)
        return c;
    }
    n -= l, i -= l;
  }
}
var ce = class _ce {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let i = 0; i < e.length; i++)
        this.size += e[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, i, s = 0, r) {
    for (let o = 0, a = 0; a < n; o++) {
      let l = this.content[o], c = a + l.nodeSize;
      if (c > e && i(l, s + a, r || null, o) !== false && l.content.size) {
        let u = a + 1;
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), i, s + u);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, i, s) {
    let r = "", o = true;
    return this.nodesBetween(e, n, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? s ? typeof s == "function" ? s(a) : s : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && i && (o ? o = false : r += i), r += c;
    }, 0), r;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, i = e.firstChild, s = this.content.slice(), r = 0;
    for (n.isText && n.sameMarkup(i) && (s[s.length - 1] = n.withText(n.text + i.text), r = 1); r < e.content.length; r++)
      s.push(e.content[r]);
    return new _ce(s, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let i = [], s = 0;
    if (n > e)
      for (let r = 0, o = 0; o < n; r++) {
        let a = this.content[r], l = o + a.nodeSize;
        l > e && ((o < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, n - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, n - o - 1))), i.push(a), s += a.nodeSize), o = l;
      }
    return new _ce(i, s);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? _ce.empty : e == 0 && n == this.content.length ? this : new _ce(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let i = this.content[e];
    if (i == n)
      return this;
    let s = this.content.slice(), r = this.size + n.nodeSize - i.nodeSize;
    return s[e] = n, new _ce(s, r);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new _ce([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new _ce(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return false;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, i = 0; n < this.content.length; n++) {
      let s = this.content[n];
      e(s, i, n), i += s.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return m2(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, i = e.size) {
    return g2(this, e, n, i);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e, n = -1) {
    if (e == 0)
      return Wl(0, e);
    if (e == this.size)
      return Wl(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let i = 0, s = 0; ; i++) {
      let r = this.child(i), o = s + r.nodeSize;
      if (o >= e)
        return o == e || n > 0 ? Wl(i + 1, o) : Wl(i, s);
      s = o;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return _ce.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _ce(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return _ce.empty;
    let n, i = 0;
    for (let s = 0; s < e.length; s++) {
      let r = e[s];
      i += r.nodeSize, s && r.isText && e[s - 1].sameMarkup(r) ? (n || (n = e.slice(0, s)), n[n.length - 1] = r.withText(n[n.length - 1].text + r.text)) : n && n.push(r);
    }
    return new _ce(n || e, i);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return _ce.empty;
    if (e instanceof _ce)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new _ce([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
ce.empty = new ce([], 0);
var sf = { index: 0, offset: 0 };
function Wl(t10, e) {
  return sf.index = t10, sf.offset = e, sf;
}
function Xc(t10, e) {
  if (t10 === e)
    return true;
  if (!(t10 && typeof t10 == "object") || !(e && typeof e == "object"))
    return false;
  let n = Array.isArray(t10);
  if (Array.isArray(e) != n)
    return false;
  if (n) {
    if (t10.length != e.length)
      return false;
    for (let i = 0; i < t10.length; i++)
      if (!Xc(t10[i], e[i]))
        return false;
  } else {
    for (let i in t10)
      if (!(i in e) || !Xc(t10[i], e[i]))
        return false;
    for (let i in e)
      if (!(i in t10))
        return false;
  }
  return true;
}
var dt = class wh {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, i = false;
    for (let s = 0; s < e.length; s++) {
      let r = e[s];
      if (this.eq(r))
        return e;
      if (this.type.excludes(r.type))
        n || (n = e.slice(0, s));
      else {
        if (r.type.excludes(this.type))
          return e;
        !i && r.type.rank > this.type.rank && (n || (n = e.slice(0, s)), n.push(this), i = true), n && n.push(r);
      }
    }
    return n || (n = e.slice()), i || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && Xc(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let i = e.marks[n.type];
    if (!i)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let s = i.create(n.attrs);
    return i.checkAttrs(s.attrs), s;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return true;
    if (e.length != n.length)
      return false;
    for (let i = 0; i < e.length; i++)
      if (!e[i].eq(n[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return wh.none;
    if (e instanceof wh)
      return [e];
    let n = e.slice();
    return n.sort((i, s) => i.type.rank - s.type.rank), n;
  }
};
dt.none = [];
var Qc = class extends Error {
};
var ke = class _ke {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, i) {
    this.content = e, this.openStart = n, this.openEnd = i;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let i = y2(this.content, e + this.openStart, n);
    return i && new _ke(i, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new _ke(b2(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return _ke.empty;
    let i = n.openStart || 0, s = n.openEnd || 0;
    if (typeof i != "number" || typeof s != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _ke(ce.fromJSON(e, n.content), i, s);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = true) {
    let i = 0, s = 0;
    for (let r = e.firstChild; r && !r.isLeaf && (n || !r.type.spec.isolating); r = r.firstChild)
      i++;
    for (let r = e.lastChild; r && !r.isLeaf && (n || !r.type.spec.isolating); r = r.lastChild)
      s++;
    return new _ke(e, i, s);
  }
};
ke.empty = new ke(ce.empty, 0, 0);
function b2(t10, e, n) {
  let { index: i, offset: s } = t10.findIndex(e), r = t10.maybeChild(i), { index: o, offset: a } = t10.findIndex(n);
  if (s == e || r.isText) {
    if (a != n && !t10.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return t10.cut(0, e).append(t10.cut(n));
  }
  if (i != o)
    throw new RangeError("Removing non-flat range");
  return t10.replaceChild(i, r.copy(b2(r.content, e - s - 1, n - s - 1)));
}
function y2(t10, e, n, i) {
  let { index: s, offset: r } = t10.findIndex(e), o = t10.maybeChild(s);
  if (r == e || o.isText)
    return t10.cut(0, e).append(n).append(t10.cut(e));
  let a = y2(o.content, e - r - 1, n);
  return a && t10.replaceChild(s, o.copy(a));
}
function MD(t10, e, n) {
  if (n.openStart > t10.depth)
    throw new Qc("Inserted content deeper than insertion position");
  if (t10.depth - n.openStart != e.depth - n.openEnd)
    throw new Qc("Inconsistent open depths");
  return v2(t10, e, n, 0);
}
function v2(t10, e, n, i) {
  let s = t10.index(i), r = t10.node(i);
  if (s == e.index(i) && i < t10.depth - n.openStart) {
    let o = v2(t10, e, n, i + 1);
    return r.copy(r.content.replaceChild(s, o));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t10.depth == i && e.depth == i) {
      let o = t10.parent, a = o.content;
      return $r(o, a.cut(0, t10.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: o, end: a } = TD(n, t10);
      return $r(r, k2(t10, o, a, e, i));
    }
  else return $r(r, Zc(t10, e, i));
}
function x2(t10, e) {
  if (!e.type.compatibleContent(t10.type))
    throw new Qc("Cannot join " + e.type.name + " onto " + t10.type.name);
}
function Ch(t10, e, n) {
  let i = t10.node(n);
  return x2(i, e.node(n)), i;
}
function Dr(t10, e) {
  let n = e.length - 1;
  n >= 0 && t10.isText && t10.sameMarkup(e[n]) ? e[n] = t10.withText(e[n].text + t10.text) : e.push(t10);
}
function Da(t10, e, n, i) {
  let s = (e || t10).node(n), r = 0, o = e ? e.index(n) : s.childCount;
  t10 && (r = t10.index(n), t10.depth > n ? r++ : t10.textOffset && (Dr(t10.nodeAfter, i), r++));
  for (let a = r; a < o; a++)
    Dr(s.child(a), i);
  e && e.depth == n && e.textOffset && Dr(e.nodeBefore, i);
}
function $r(t10, e) {
  return t10.type.checkContent(e), t10.copy(e);
}
function k2(t10, e, n, i, s) {
  let r = t10.depth > s && Ch(t10, e, s + 1), o = i.depth > s && Ch(n, i, s + 1), a = [];
  return Da(null, t10, s, a), r && o && e.index(s) == n.index(s) ? (x2(r, o), Dr($r(r, k2(t10, e, n, i, s + 1)), a)) : (r && Dr($r(r, Zc(t10, e, s + 1)), a), Da(e, n, s, a), o && Dr($r(o, Zc(n, i, s + 1)), a)), Da(i, null, s, a), new ce(a);
}
function Zc(t10, e, n) {
  let i = [];
  if (Da(null, t10, n, i), t10.depth > n) {
    let s = Ch(t10, e, n + 1);
    Dr($r(s, Zc(t10, e, n + 1)), i);
  }
  return Da(e, null, n, i), new ce(i);
}
function TD(t10, e) {
  let n = e.depth - t10.openStart, s = e.node(n).copy(t10.content);
  for (let r = n - 1; r >= 0; r--)
    s = e.node(r).copy(ce.from(s));
  return {
    start: s.resolveNoCache(t10.openStart + n),
    end: s.resolveNoCache(s.content.size - t10.openEnd - n)
  };
}
var nl = class _nl {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.pos = e, this.path = n, this.parentOffset = i, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let i = this.pos - this.path[this.path.length - 1], s = e.child(n);
    return i ? e.child(n).cut(i) : s;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let i = this.path[n * 3], s = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let r = 0; r < e; r++)
      s += i.child(r).nodeSize;
    return s;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return dt.none;
    if (this.textOffset)
      return e.child(n).marks;
    let i = e.maybeChild(n - 1), s = e.maybeChild(n);
    if (!i) {
      let a = i;
      i = s, s = a;
    }
    let r = i.marks;
    for (var o = 0; o < r.length; o++)
      r[o].type.spec.inclusive === false && (!s || !r[o].isInSet(s.marks)) && (r = r[o--].removeFromSet(r));
    return r;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let i = n.marks, s = e.parent.maybeChild(e.index());
    for (var r = 0; r < i.length; r++)
      i[r].type.spec.inclusive === false && (!s || !i[r].isInSet(s.marks)) && (i = i[r--].removeFromSet(i));
    return i;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let i = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); i >= 0; i--)
      if (e.pos <= this.end(i) && (!n || n(this.node(i))))
        return new eu(this, e, i);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let i = [], s = 0, r = n;
    for (let o = e; ; ) {
      let { index: a, offset: l } = o.content.findIndex(r), c = r - l;
      if (i.push(o, a, s + l), !c || (o = o.child(a), o.isText))
        break;
      r = c - 1, s += l + 1;
    }
    return new _nl(n, i, r);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let i = a0.get(e);
    if (i)
      for (let r = 0; r < i.elts.length; r++) {
        let o = i.elts[r];
        if (o.pos == n)
          return o;
      }
    else
      a0.set(e, i = new AD());
    let s = i.elts[i.i] = _nl.resolve(e, n);
    return i.i = (i.i + 1) % _D, s;
  }
};
var AD = class {
  constructor() {
    this.elts = [], this.i = 0;
  }
};
var _D = 12;
var a0 = /* @__PURE__ */ new WeakMap();
var eu = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, i) {
    this.$from = e, this.$to = n, this.depth = i;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var ND = /* @__PURE__ */ Object.create(null);
var Hs = class Oh {
  /**
  @internal
  */
  constructor(e, n, i, s = dt.none) {
    this.type = e, this.attrs = n, this.marks = s, this.content = i || ce.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, i, s = 0) {
    this.content.nodesBetween(e, n, i, s, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, n, i, s) {
    return this.content.textBetween(e, n, i, s);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, i) {
    return this.type == e && Xc(this.attrs, n || e.defaultAttrs || ND) && dt.sameSet(this.marks, i || dt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Oh(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Oh(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, i = false) {
    if (e == n)
      return ke.empty;
    let s = this.resolve(e), r = this.resolve(n), o = i ? 0 : s.sharedDepth(n), a = s.start(o), c = s.node(o).content.cut(s.pos - a, r.pos - a);
    return new ke(c, s.depth - o, r.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, i) {
    return MD(this.resolve(e), this.resolve(n), i);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: i, offset: s } = n.content.findIndex(e);
      if (n = n.maybeChild(i), !n)
        return null;
      if (s == e || n.isText)
        return n;
      e -= s + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: i } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: i };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: i } = this.content.findIndex(e);
    if (i < e)
      return { node: this.content.child(n), index: n, offset: i };
    let s = this.content.child(n - 1);
    return { node: s, index: n - 1, offset: i - s.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return nl.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return nl.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, i) {
    let s = false;
    return n > e && this.nodesBetween(e, n, (r) => (i.isInSet(r.marks) && (s = true), !s)), s;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), S2(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, i = ce.empty, s = 0, r = i.childCount) {
    let o = this.contentMatchAt(e).matchFragment(i, s, r), a = o && o.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return false;
    for (let l = s; l < r; l++)
      if (!this.type.allowsMarks(i.child(l).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, i, s) {
    if (s && !this.type.allowsMarks(s))
      return false;
    let r = this.contentMatchAt(e).matchType(i), o = r && r.matchFragment(this.content, n);
    return o ? o.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = dt.none;
    for (let n = 0; n < this.marks.length; n++) {
      let i = this.marks[n];
      i.type.checkAttrs(i.attrs), e = i.addToSet(e);
    }
    if (!dt.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let i;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      i = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, i);
    }
    let s = ce.fromJSON(e, n.content), r = e.nodeType(n.type).create(n.attrs, s, i);
    return r.type.checkAttrs(r.attrs), r;
  }
};
Hs.prototype.text = void 0;
var tu = class _tu extends Hs {
  /**
  @internal
  */
  constructor(e, n, i, s) {
    if (super(e, n, null, s), !i)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = i;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : S2(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new _tu(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new _tu(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
};
function S2(t10, e) {
  for (let n = t10.length - 1; n >= 0; n--)
    e = t10[n].type.name + "(" + e + ")";
  return e;
}
var Kr = class _Kr {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let i = new LD(e, n);
    if (i.next == null)
      return _Kr.empty;
    let s = w2(i);
    i.next && i.err("Unexpected trailing text");
    let r = VD(FD(s));
    return BD(r, i), r;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, i = e.childCount) {
    let s = this;
    for (let r = n; s && r < i; r++)
      s = s.matchType(e.child(r).type);
    return s;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let i = 0; i < e.next.length; i++)
        if (this.next[n].type == e.next[i].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = false, i = 0) {
    let s = [this];
    function r(o, a) {
      let l = o.matchFragment(e, i);
      if (l && (!n || l.validEnd))
        return ce.from(a.map((c) => c.createAndFill()));
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: d } = o.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && s.indexOf(d) == -1) {
          s.push(d);
          let f = r(d, a.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return r(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == e)
        return this.wrapCache[i + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), i = [{ match: this, type: null, via: null }];
    for (; i.length; ) {
      let s = i.shift(), r = s.match;
      if (r.matchType(e)) {
        let o = [];
        for (let a = s; a.type; a = a.via)
          o.push(a.type);
        return o.reverse();
      }
      for (let o = 0; o < r.next.length; o++) {
        let { type: a, next: l } = r.next[o];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!s.type || l.validEnd) && (i.push({ match: a.contentMatch, type: a, via: s }), n[a.name] = true);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(i) {
      e.push(i);
      for (let s = 0; s < i.next.length; s++)
        e.indexOf(i.next[s].next) == -1 && n(i.next[s].next);
    }
    return n(this), e.map((i, s) => {
      let r = s + (i.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < i.next.length; o++)
        r += (o ? ", " : "") + i.next[o].type.name + "->" + e.indexOf(i.next[o].next);
      return r;
    }).join(`
`);
  }
};
Kr.empty = new Kr(true);
var LD = class {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || true);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
};
function w2(t10) {
  let e = [];
  do
    e.push(ID(t10));
  while (t10.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function ID(t10) {
  let e = [];
  do
    e.push(PD(t10));
  while (t10.next && t10.next != ")" && t10.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function PD(t10) {
  let e = RD(t10);
  for (; ; )
    if (t10.eat("+"))
      e = { type: "plus", expr: e };
    else if (t10.eat("*"))
      e = { type: "star", expr: e };
    else if (t10.eat("?"))
      e = { type: "opt", expr: e };
    else if (t10.eat("{"))
      e = DD(t10, e);
    else
      break;
  return e;
}
function l0(t10) {
  /\D/.test(t10.next) && t10.err("Expected number, got '" + t10.next + "'");
  let e = Number(t10.next);
  return t10.pos++, e;
}
function DD(t10, e) {
  let n = l0(t10), i = n;
  return t10.eat(",") && (t10.next != "}" ? i = l0(t10) : i = -1), t10.eat("}") || t10.err("Unclosed braced range"), { type: "range", min: n, max: i, expr: e };
}
function $D(t10, e) {
  let n = t10.nodeTypes, i = n[e];
  if (i)
    return [i];
  let s = [];
  for (let r in n) {
    let o = n[r];
    o.isInGroup(e) && s.push(o);
  }
  return s.length == 0 && t10.err("No node type or group '" + e + "' found"), s;
}
function RD(t10) {
  if (t10.eat("(")) {
    let e = w2(t10);
    return t10.eat(")") || t10.err("Missing closing paren"), e;
  } else if (/\W/.test(t10.next))
    t10.err("Unexpected token '" + t10.next + "'");
  else {
    let e = $D(t10, t10.next).map((n) => (t10.inline == null ? t10.inline = n.isInline : t10.inline != n.isInline && t10.err("Mixing inline and block content"), { type: "name", value: n }));
    return t10.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function FD(t10) {
  let e = [[]];
  return s(r(t10, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function i(o, a, l) {
    let c = { term: l, to: a };
    return e[o].push(c), c;
  }
  function s(o, a) {
    o.forEach((l) => l.to = a);
  }
  function r(o, a) {
    if (o.type == "choice")
      return o.exprs.reduce((l, c) => l.concat(r(c, a)), []);
    if (o.type == "seq")
      for (let l = 0; ; l++) {
        let c = r(o.exprs[l], a);
        if (l == o.exprs.length - 1)
          return c;
        s(c, a = n());
      }
    else if (o.type == "star") {
      let l = n();
      return i(a, l), s(r(o.expr, l), l), [i(l)];
    } else if (o.type == "plus") {
      let l = n();
      return s(r(o.expr, a), l), s(r(o.expr, l), l), [i(l)];
    } else {
      if (o.type == "opt")
        return [i(a)].concat(r(o.expr, a));
      if (o.type == "range") {
        let l = a;
        for (let c = 0; c < o.min; c++) {
          let u = n();
          s(r(o.expr, l), u), l = u;
        }
        if (o.max == -1)
          s(r(o.expr, l), l);
        else
          for (let c = o.min; c < o.max; c++) {
            let u = n();
            i(l, u), s(r(o.expr, l), u), l = u;
          }
        return [i(l)];
      } else {
        if (o.type == "name")
          return [i(a, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function C2(t10, e) {
  return e - t10;
}
function c0(t10, e) {
  let n = [];
  return i(e), n.sort(C2);
  function i(s) {
    let r = t10[s];
    if (r.length == 1 && !r[0].term)
      return i(r[0].to);
    n.push(s);
    for (let o = 0; o < r.length; o++) {
      let { term: a, to: l } = r[o];
      !a && n.indexOf(l) == -1 && i(l);
    }
  }
}
function VD(t10) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(c0(t10, 0));
  function n(i) {
    let s = [];
    i.forEach((o) => {
      t10[o].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let c;
        for (let u = 0; u < s.length; u++)
          s[u][0] == a && (c = s[u][1]);
        c0(t10, l).forEach((u) => {
          c || s.push([a, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let r = e[i.join(",")] = new Kr(i.indexOf(t10.length - 1) > -1);
    for (let o = 0; o < s.length; o++) {
      let a = s[o][1].sort(C2);
      r.next.push({ type: s[o][0], next: e[a.join(",")] || n(a) });
    }
    return r;
  }
}
function BD(t10, e) {
  for (let n = 0, i = [t10]; n < i.length; n++) {
    let s = i[n], r = !s.validEnd, o = [];
    for (let a = 0; a < s.next.length; a++) {
      let { type: l, next: c } = s.next[a];
      o.push(l.name), r && !(l.isText || l.hasRequiredAttrs()) && (r = false), i.indexOf(c) == -1 && i.push(c);
    }
    r && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function O2(t10) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t10) {
    let i = t10[n];
    if (!i.hasDefault)
      return null;
    e[n] = i.default;
  }
  return e;
}
function E2(t10, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let i in t10) {
    let s = e && e[i];
    if (s === void 0) {
      let r = t10[i];
      if (r.hasDefault)
        s = r.default;
      else
        throw new RangeError("No value supplied for attribute " + i);
    }
    n[i] = s;
  }
  return n;
}
function M2(t10, e, n, i) {
  for (let s in e)
    if (!(s in t10))
      throw new RangeError(`Unsupported attribute ${s} for ${n} of type ${s}`);
  for (let s in t10) {
    let r = t10[s];
    r.validate && r.validate(e[s]);
  }
}
function T2(t10, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let i in e)
      n[i] = new jD(t10, i, e[i]);
  return n;
}
var u0 = class A2 {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.name = e, this.schema = n, this.spec = i, this.markSet = null, this.groups = i.group ? i.group.split(" ") : [], this.attrs = T2(e, i.attrs), this.defaultAttrs = O2(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(i.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Kr.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : E2(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, i) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Hs(this, this.computeAttrs(e), ce.from(n), dt.setFrom(i));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, i) {
    return n = ce.from(n), this.checkContent(n), new Hs(this, this.computeAttrs(e), n, dt.setFrom(i));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, i) {
    if (e = this.computeAttrs(e), n = ce.from(n), n.size) {
      let o = this.contentMatch.fillBefore(n);
      if (!o)
        return null;
      n = o.append(n);
    }
    let s = this.contentMatch.matchFragment(n), r = s && s.fillBefore(ce.empty, true);
    return r ? new Hs(this, e, n.append(r), dt.setFrom(i)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return false;
    for (let i = 0; i < e.childCount; i++)
      if (!this.allowsMarks(e.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    M2(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return true;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let i = 0; i < e.length; i++)
      this.allowsMarkType(e[i].type) ? n && n.push(e[i]) : n || (n = e.slice(0, i));
    return n ? n.length ? n : dt.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let i = /* @__PURE__ */ Object.create(null);
    e.forEach((r, o) => i[r] = new A2(r, n, o));
    let s = n.spec.topNode || "doc";
    if (!i[s])
      throw new RangeError("Schema is missing its top node type ('" + s + "')");
    if (!i.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let r in i.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return i;
  }
};
function zD(t10, e, n) {
  let i = n.split("|");
  return (s) => {
    let r = s === null ? "null" : typeof s;
    if (i.indexOf(r) < 0)
      throw new RangeError(`Expected value of type ${i} for attribute ${e} on type ${t10}, got ${r}`);
  };
}
var jD = class {
  constructor(e, n, i) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(i, "default"), this.default = i.default, this.validate = typeof i.validate == "string" ? zD(e, n, i.validate) : i.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var vd = class _vd {
  /**
  @internal
  */
  constructor(e, n, i, s) {
    this.name = e, this.rank = n, this.schema = i, this.spec = s, this.attrs = T2(e, s.attrs), this.excluded = null;
    let r = O2(this.attrs);
    this.instance = r ? new dt(this, r) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new dt(this, E2(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let i = /* @__PURE__ */ Object.create(null), s = 0;
    return e.forEach((r, o) => i[r] = new _vd(r, s++, n, o)), i;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    M2(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
};
var _2 = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let s in e)
      n[s] = e[s];
    n.nodes = Gt.from(e.nodes), n.marks = Gt.from(e.marks || {}), this.nodes = u0.compile(this.spec.nodes, this), this.marks = vd.compile(this.spec.marks, this);
    let i = /* @__PURE__ */ Object.create(null);
    for (let s in this.nodes) {
      if (s in this.marks)
        throw new RangeError(s + " can not be both a node and a mark");
      let r = this.nodes[s], o = r.spec.content || "", a = r.spec.marks;
      if (r.contentMatch = i[o] || (i[o] = Kr.parse(o, this.nodes)), r.inlineContent = r.contentMatch.inlineContent, r.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!r.isInline || !r.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = r;
      }
      r.markSet = a == "_" ? null : a ? d0(this, a.split(" ")) : a == "" || !r.inlineContent ? [] : null;
    }
    for (let s in this.marks) {
      let r = this.marks[s], o = r.spec.excludes;
      r.excluded = o == null ? [r] : o == "" ? [] : d0(this, o.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, i, s) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof u0) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, i, s);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let i = this.nodes.text;
    return new tu(i, i.defaultAttrs, e, dt.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return Hs.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return dt.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
};
function d0(t10, e) {
  let n = [];
  for (let i = 0; i < e.length; i++) {
    let s = e[i], r = t10.marks[s], o = r;
    if (r)
      n.push(r);
    else
      for (let a in t10.marks) {
        let l = t10.marks[a];
        (s == "_" || l.spec.group && l.spec.group.split(" ").indexOf(s) > -1) && n.push(o = l);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[i] + "'");
  }
  return n;
}
function HD(t10) {
  return t10.tag != null;
}
function WD(t10) {
  return t10.style != null;
}
var Ws = class _Ws {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let i = this.matchedStyles = [];
    n.forEach((s) => {
      if (HD(s))
        this.tags.push(s);
      else if (WD(s)) {
        let r = /[^=]*/.exec(s.style)[0];
        i.indexOf(r) < 0 && i.push(r), this.styles.push(s);
      }
    }), this.normalizeLists = !this.tags.some((s) => {
      if (!/^(ul|ol)\b/.test(s.tag) || !s.node)
        return false;
      let r = e.nodes[s.node];
      return r.contentMatch.matchType(r);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let i = new h0(this, n, false);
    return i.addAll(e, dt.none, n.from, n.to), i.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let i = new h0(this, n, true);
    return i.addAll(e, dt.none, n.from, n.to), ke.maxOpen(i.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, i) {
    for (let s = i ? this.tags.indexOf(i) + 1 : 0; s < this.tags.length; s++) {
      let r = this.tags[s];
      if (KD(e, r.tag) && (r.namespace === void 0 || e.namespaceURI == r.namespace) && (!r.context || n.matchesContext(r.context))) {
        if (r.getAttrs) {
          let o = r.getAttrs(e);
          if (o === false)
            continue;
          r.attrs = o || void 0;
        }
        return r;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, i, s) {
    for (let r = s ? this.styles.indexOf(s) + 1 : 0; r < this.styles.length; r++) {
      let o = this.styles[r], a = o.style;
      if (!(a.indexOf(e) != 0 || o.context && !i.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (o.getAttrs) {
          let l = o.getAttrs(n);
          if (l === false)
            continue;
          o.attrs = l || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function i(s) {
      let r = s.priority == null ? 50 : s.priority, o = 0;
      for (; o < n.length; o++) {
        let a = n[o];
        if ((a.priority == null ? 50 : a.priority) < r)
          break;
      }
      n.splice(o, 0, s);
    }
    for (let s in e.marks) {
      let r = e.marks[s].spec.parseDOM;
      r && r.forEach((o) => {
        i(o = p0(o)), o.mark || o.ignore || o.clearMark || (o.mark = s);
      });
    }
    for (let s in e.nodes) {
      let r = e.nodes[s].spec.parseDOM;
      r && r.forEach((o) => {
        i(o = p0(o)), o.node || o.ignore || o.mark || (o.node = s);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new _Ws(e, _Ws.schemaRules(e)));
  }
};
var N2 = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var UD = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var L2 = { ol: true, ul: true };
var il = 1;
var Eh = 2;
var Sc = 4;
function f0(t10, e, n) {
  return e != null ? (e ? il : 0) | (e === "full" ? Eh : 0) : t10 && t10.whitespace == "pre" ? il | Eh : n & -5;
}
var Ul = class {
  constructor(e, n, i, s, r, o) {
    this.type = e, this.attrs = n, this.marks = i, this.solid = s, this.options = o, this.content = [], this.activeMarks = dt.none, this.match = r || (o & Sc ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(ce.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let i = this.type.contentMatch, s;
        return (s = i.findWrapping(e.type)) ? (this.match = i, s) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & il)) {
      let i = this.content[this.content.length - 1], s;
      if (i && i.isText && (s = /[ \t\r\n\u000c]+$/.exec(i.text))) {
        let r = i;
        i.text.length == s[0].length ? this.content.pop() : this.content[this.content.length - 1] = r.withText(r.text.slice(0, r.text.length - s[0].length));
      }
    }
    let n = ce.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(ce.empty, true))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !N2.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
};
var h0 = class {
  constructor(e, n, i) {
    this.parser = e, this.options = n, this.isOpen = i, this.open = 0, this.localPreserveWS = false;
    let s = n.topNode, r, o = f0(null, n.preserveWhitespace, 0) | (i ? Sc : 0);
    s ? r = new Ul(s.type, s.attrs, dt.none, true, n.topMatch || s.type.contentMatch, o) : i ? r = new Ul(null, null, dt.none, true, null, o) : r = new Ul(e.schema.topNodeType, null, dt.none, true, null, o), this.nodes = [r], this.find = n.findPositions, this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let i = e.nodeValue, s = this.top, r = s.options & Eh ? "full" : this.localPreserveWS || (s.options & il) > 0;
    if (r === "full" || s.inlineContext(e) || /[^ \t\r\n\u000c]/.test(i)) {
      if (r)
        r !== "full" ? i = i.replace(/\r?\n|\r/g, " ") : i = i.replace(/\r\n?/g, `
`);
      else if (i = i.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(i) && this.open == this.nodes.length - 1) {
        let o = s.content[s.content.length - 1], a = e.previousSibling;
        (!o || a && a.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (i = i.slice(1));
      }
      i && this.insertNode(this.parser.schema.text(i), n), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, i) {
    let s = this.localPreserveWS, r = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = true);
    let o = e.nodeName.toLowerCase(), a;
    L2.hasOwnProperty(o) && this.parser.normalizeLists && qD(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, i));
    e: if (l ? l.ignore : UD.hasOwnProperty(o))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
      let c, u = this.needsBlock;
      if (N2.hasOwnProperty(o))
        r.content.length && r.content[0].isInline && this.open && (this.open--, r = this.top), c = true, r.type || (this.needsBlock = true);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        break e;
      }
      let d = l && l.skip ? n : this.readStyles(e, n);
      d && this.addAll(e, d), c && this.sync(r), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, n);
      c && this.addElementByRule(e, l, c, l.consuming === false ? a : void 0);
    }
    this.localPreserveWS = s;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let i = e.style;
    if (i && i.length)
      for (let s = 0; s < this.parser.matchedStyles.length; s++) {
        let r = this.parser.matchedStyles[s], o = i.getPropertyValue(r);
        if (o)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(r, o, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? n = n.filter((c) => !l.clearMark(c)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === false)
              a = l;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, i, s) {
    let r, o;
    if (n.node)
      if (o = this.parser.schema.nodes[n.node], o.isLeaf)
        this.insertNode(o.create(n.attrs), i) || this.leafFallback(e, i);
      else {
        let l = this.enter(o, n.attrs || null, i, n.preserveWhitespace);
        l && (r = true, i = l);
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      i = i.concat(l.create(n.attrs));
    }
    let a = this.top;
    if (o && o.isLeaf)
      this.findInside(e);
    else if (s)
      this.addElement(e, i, s);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, i));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, true), this.addAll(l, i), this.findAround(e, l, false);
    }
    r && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, i, s) {
    let r = i || 0;
    for (let o = i ? e.childNodes[i] : e.firstChild, a = s == null ? null : e.childNodes[s]; o != a; o = o.nextSibling, ++r)
      this.findAtPoint(e, r), this.addDOM(o, n);
    this.findAtPoint(e, r);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n) {
    let i, s;
    for (let r = this.open; r >= 0; r--) {
      let o = this.nodes[r], a = o.findWrapping(e);
      if (a && (!i || i.length > a.length) && (i = a, s = o, !a.length) || o.solid)
        break;
    }
    if (!i)
      return null;
    this.sync(s);
    for (let r = 0; r < i.length; r++)
      n = this.enterInner(i[r], null, n, false);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let s = this.textblockFromContext();
      s && (n = this.enterInner(s, null, n));
    }
    let i = this.findPlace(e, n);
    if (i) {
      this.closeExtra();
      let s = this.top;
      s.match && (s.match = s.match.matchType(e.type));
      let r = dt.none;
      for (let o of i.concat(e.marks))
        (s.type ? s.type.allowsMarkType(o.type) : m0(o.type, e.type)) && (r = o.addToSet(r));
      return s.content.push(e.mark(r)), true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, i, s) {
    let r = this.findPlace(e.create(n), i);
    return r && (r = this.enterInner(e, n, i, true, s)), r;
  }
  // Open a node of the given type
  enterInner(e, n, i, s = false, r) {
    this.closeExtra();
    let o = this.top;
    o.match = o.match && o.match.matchType(e);
    let a = f0(e, r, o.options);
    o.options & Sc && o.content.length == 0 && (a |= Sc);
    let l = dt.none;
    return i = i.filter((c) => (o.type ? o.type.allowsMarkType(c.type) : m0(c.type, e)) ? (l = c.addToSet(l), false) : true), this.nodes.push(new Ul(e, n, l, s, null, a)), this.open++, i;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = false) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e)
        return this.open = n, true;
      this.localPreserveWS && (this.nodes[n].options |= il);
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let i = this.nodes[n].content;
      for (let s = i.length - 1; s >= 0; s--)
        e += i[s].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].node == e && this.find[i].offset == n && (this.find[i].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, i) {
    if (e != n && this.find)
      for (let s = 0; s < this.find.length; s++)
        this.find[s].pos == null && e.nodeType == 1 && e.contains(this.find[s].node) && n.compareDocumentPosition(this.find[s].node) & (i ? 2 : 4) && (this.find[s].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), i = this.options.context, s = !this.isOpen && (!i || i.parent.type == this.nodes[0].type), r = -(i ? i.depth + 1 : 0) + (s ? 0 : 1), o = (a, l) => {
      for (; a >= 0; a--) {
        let c = n[a];
        if (c == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= r; l--)
            if (o(a - 1, l))
              return true;
          return false;
        } else {
          let u = l > 0 || l == 0 && s ? this.nodes[l].type : i && l >= r ? i.node(l - r).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return false;
          l--;
        }
      }
      return true;
    };
    return o(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let i = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (i && i.isTextblock && i.defaultAttrs)
          return i;
      }
    for (let n in this.parser.schema.nodes) {
      let i = this.parser.schema.nodes[n];
      if (i.isTextblock && i.defaultAttrs)
        return i;
    }
  }
};
function qD(t10) {
  for (let e = t10.firstChild, n = null; e; e = e.nextSibling) {
    let i = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    i && L2.hasOwnProperty(i) && n ? (n.appendChild(e), e = n) : i == "li" ? n = e : i && (n = null);
  }
}
function KD(t10, e) {
  return (t10.matches || t10.msMatchesSelector || t10.webkitMatchesSelector || t10.mozMatchesSelector).call(t10, e);
}
function p0(t10) {
  let e = {};
  for (let n in t10)
    e[n] = t10[n];
  return e;
}
function m0(t10, e) {
  let n = e.schema.nodes;
  for (let i in n) {
    let s = n[i];
    if (!s.allowsMarkType(t10))
      continue;
    let r = [], o = (a) => {
      r.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: c, next: u } = a.edge(l);
        if (c == e || r.indexOf(u) < 0 && o(u))
          return true;
      }
    };
    if (o(s.contentMatch))
      return true;
  }
}
var so = class _so {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, i) {
    i || (i = rf(n).createDocumentFragment());
    let s = i, r = [];
    return e.forEach((o) => {
      if (r.length || o.marks.length) {
        let a = 0, l = 0;
        for (; a < r.length && l < o.marks.length; ) {
          let c = o.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(r[a][0]) || c.type.spec.spanning === false)
            break;
          a++, l++;
        }
        for (; a < r.length; )
          s = r.pop()[1];
        for (; l < o.marks.length; ) {
          let c = o.marks[l++], u = this.serializeMark(c, o.isInline, n);
          u && (r.push([c, s]), s.appendChild(u.dom), s = u.contentDOM || u.dom);
        }
      }
      s.appendChild(this.serializeNodeInner(o, n));
    }), i;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: i, contentDOM: s } = wc(rf(n), this.nodes[e.type.name](e), null, e.attrs);
    if (s) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, s);
    }
    return i;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let i = this.serializeNodeInner(e, n);
    for (let s = e.marks.length - 1; s >= 0; s--) {
      let r = this.serializeMark(e.marks[s], e.isInline, n);
      r && ((r.contentDOM || r.dom).appendChild(i), i = r.dom);
    }
    return i;
  }
  /**
  @internal
  */
  serializeMark(e, n, i = {}) {
    let s = this.marks[e.type.name];
    return s && wc(rf(i), s(e, n), null, e.attrs);
  }
  static renderSpec(e, n, i = null, s) {
    return wc(e, n, i, s);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new _so(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = g0(e.nodes);
    return n.text || (n.text = (i) => i.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return g0(e.marks);
  }
};
function g0(t10) {
  let e = {};
  for (let n in t10) {
    let i = t10[n].spec.toDOM;
    i && (e[n] = i);
  }
  return e;
}
function rf(t10) {
  return t10.document || window.document;
}
var b0 = /* @__PURE__ */ new WeakMap();
function YD(t10) {
  let e = b0.get(t10);
  return e === void 0 && b0.set(t10, e = GD(t10)), e;
}
function GD(t10) {
  let e = null;
  function n(i) {
    if (i && typeof i == "object")
      if (Array.isArray(i))
        if (typeof i[0] == "string")
          e || (e = []), e.push(i);
        else
          for (let s = 0; s < i.length; s++)
            n(i[s]);
      else
        for (let s in i)
          n(i[s]);
  }
  return n(t10), e;
}
function wc(t10, e, n, i) {
  if (typeof e == "string")
    return { dom: t10.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let s = e[0], r;
  if (typeof s != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (i && (r = YD(i)) && r.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let o = s.indexOf(" ");
  o > 0 && (n = s.slice(0, o), s = s.slice(o + 1));
  let a, l = n ? t10.createElementNS(n, s) : t10.createElement(s), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let d in c)
      if (c[d] != null) {
        let f = d.indexOf(" ");
        f > 0 ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), c[d]) : l.setAttribute(d, c[d]);
      }
  }
  for (let d = u; d < e.length; d++) {
    let f = e[d];
    if (f === 0) {
      if (d < e.length - 1 || d > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: h10, contentDOM: p } = wc(t10, f, n, i);
      if (l.appendChild(h10), p) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = p;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
var I2 = 65535;
var P2 = Math.pow(2, 16);
function JD(t10, e) {
  return t10 + e * P2;
}
function y0(t10) {
  return t10 & I2;
}
function XD(t10) {
  return (t10 - (t10 & I2)) / P2;
}
var D2 = 1;
var $2 = 2;
var Cc = 4;
var R2 = 8;
var Mh = class {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.pos = e, this.delInfo = n, this.recover = i;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & R2) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (D2 | Cc)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & ($2 | Cc)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Cc) > 0;
  }
};
var Hn = class _Hn {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = false) {
    if (this.ranges = e, this.inverted = n, !e.length && _Hn.empty)
      return _Hn.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, i = y0(e);
    if (!this.inverted)
      for (let s = 0; s < i; s++)
        n += this.ranges[s * 3 + 2] - this.ranges[s * 3 + 1];
    return this.ranges[i * 3] + n + XD(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, false);
  }
  map(e, n = 1) {
    return this._map(e, n, true);
  }
  /**
  @internal
  */
  _map(e, n, i) {
    let s = 0, r = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? s : 0);
      if (l > e)
        break;
      let c = this.ranges[a + r], u = this.ranges[a + o], d = l + c;
      if (e <= d) {
        let f = c ? e == l ? -1 : e == d ? 1 : n : n, h10 = l + s + (f < 0 ? 0 : u);
        if (i)
          return h10;
        let p = e == (n < 0 ? l : d) ? null : JD(a / 3, e - l), g = e == l ? $2 : e == d ? D2 : Cc;
        return (n < 0 ? e != l : e != d) && (g |= R2), new Mh(h10, g, p);
      }
      s += u - c;
    }
    return i ? e + s : new Mh(e + s, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let i = 0, s = y0(n), r = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let c = this.ranges[a + r], u = l + c;
      if (e <= u && a == s * 3)
        return true;
      i += this.ranges[a + o] - c;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2;
    for (let s = 0, r = 0; s < this.ranges.length; s += 3) {
      let o = this.ranges[s], a = o - (this.inverted ? r : 0), l = o + (this.inverted ? 0 : r), c = this.ranges[s + n], u = this.ranges[s + i];
      e(a, a + c, l, l + u), r += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _Hn(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? _Hn.empty : new _Hn(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
};
Hn.empty = new Hn([]);
var sl = class _sl {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, n, i = 0, s = e ? e.length : 0) {
    this.mirror = n, this.from = i, this.to = s, this._maps = e || [], this.ownData = !(e || n);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new _sl(this._maps, this.mirror, e, n);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = true), this.to = this._maps.push(e), n != null && this.setMirror(this._maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, i = this._maps.length; n < e._maps.length; n++) {
      let s = e.getMirror(n);
      this.appendMap(e._maps[n], s != null && s < n ? i + s : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, i = this._maps.length + e._maps.length; n >= 0; n--) {
      let s = e.getMirror(n);
      this.appendMap(e._maps[n].invert(), s != null && s > n ? i - s - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new _sl();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, true);
    for (let i = this.from; i < this.to; i++)
      e = this._maps[i].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, false);
  }
  /**
  @internal
  */
  _map(e, n, i) {
    let s = 0;
    for (let r = this.from; r < this.to; r++) {
      let o = this._maps[r], a = o.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(r);
        if (l != null && l > r && l < this.to) {
          r = l, e = this._maps[l].recover(a.recover);
          continue;
        }
      }
      s |= a.delInfo, e = a.pos;
    }
    return i ? e : new Mh(e, s, null);
  }
};
var of = /* @__PURE__ */ Object.create(null);
var cn = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Hn.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let i = of[n.stepType];
    if (!i)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return i.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in of)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return of[e] = n, n.prototype.jsonID = e, n;
  }
};
var Rt = class _Rt {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new _Rt(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new _Rt(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, i, s) {
    try {
      return _Rt.ok(e.replace(n, i, s));
    } catch (r) {
      if (r instanceof Qc)
        return _Rt.fail(r.message);
      throw r;
    }
  }
};
function Gp(t10, e, n) {
  let i = [];
  for (let s = 0; s < t10.childCount; s++) {
    let r = t10.child(s);
    r.content.size && (r = r.copy(Gp(r.content, e, r))), r.isInline && (r = e(r, n, s)), i.push(r);
  }
  return ce.fromArray(i);
}
var Rs = class _Rs extends cn {
  /**
  Create a mark step.
  */
  constructor(e, n, i) {
    super(), this.from = e, this.to = n, this.mark = i;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), i = e.resolve(this.from), s = i.node(i.sharedDepth(this.to)), r = new ke(Gp(n.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), s), n.openStart, n.openEnd);
    return Rt.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Pi(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return n.deleted && i.deleted || n.pos >= i.pos ? null : new _Rs(n.pos, i.pos, this.mark);
  }
  merge(e) {
    return e instanceof _Rs && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new _Rs(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _Rs(n.from, n.to, e.markFromJSON(n.mark));
  }
};
cn.jsonID("addMark", Rs);
var Pi = class _Pi extends cn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, i) {
    super(), this.from = e, this.to = n, this.mark = i;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), i = new ke(Gp(n.content, (s) => s.mark(this.mark.removeFromSet(s.marks)), e), n.openStart, n.openEnd);
    return Rt.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new Rs(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return n.deleted && i.deleted || n.pos >= i.pos ? null : new _Pi(n.pos, i.pos, this.mark);
  }
  merge(e) {
    return e instanceof _Pi && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new _Pi(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _Pi(n.from, n.to, e.markFromJSON(n.mark));
  }
};
cn.jsonID("removeMark", Pi);
var Fs = class _Fs extends cn {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Rt.fail("No node at mark step's position");
    let i = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return Rt.fromReplace(e, this.pos, this.pos + 1, new ke(ce.from(i), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let i = this.mark.addToSet(n.marks);
      if (i.length == n.marks.length) {
        for (let s = 0; s < n.marks.length; s++)
          if (!n.marks[s].isInSet(i))
            return new _Fs(this.pos, n.marks[s]);
        return new _Fs(this.pos, this.mark);
      }
    }
    return new Po(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new _Fs(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _Fs(n.pos, e.markFromJSON(n.mark));
  }
};
cn.jsonID("addNodeMark", Fs);
var Po = class _Po extends cn {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Rt.fail("No node at mark step's position");
    let i = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return Rt.fromReplace(e, this.pos, this.pos + 1, new ke(ce.from(i), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new Fs(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new _Po(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _Po(n.pos, e.markFromJSON(n.mark));
  }
};
cn.jsonID("removeNodeMark", Po);
var Wt = class _Wt extends cn {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, i, s = false) {
    super(), this.from = e, this.to = n, this.slice = i, this.structure = s;
  }
  apply(e) {
    return this.structure && Th(e, this.from, this.to) ? Rt.fail("Structure replace would overwrite content") : Rt.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Hn([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new _Wt(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1);
    return n.deletedAcross && i.deletedAcross ? null : new _Wt(n.pos, Math.max(n.pos, i.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof _Wt) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? ke.empty : new ke(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new _Wt(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? ke.empty : new ke(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new _Wt(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _Wt(n.from, n.to, ke.fromJSON(e, n.slice), !!n.structure);
  }
};
cn.jsonID("replace", Wt);
var Ut = class _Ut extends cn {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, i, s, r, o, a = false) {
    super(), this.from = e, this.to = n, this.gapFrom = i, this.gapTo = s, this.slice = r, this.insert = o, this.structure = a;
  }
  apply(e) {
    if (this.structure && (Th(e, this.from, this.gapFrom) || Th(e, this.gapTo, this.to)))
      return Rt.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return Rt.fail("Gap is not a flat range");
    let i = this.slice.insertAt(this.insert, n.content);
    return i ? Rt.fromReplace(e, this.from, this.to, i) : Rt.fail("Content does not fit in gap");
  }
  getMap() {
    return new Hn([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new _Ut(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), i = e.mapResult(this.to, -1), s = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), r = this.to == this.gapTo ? i.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && i.deletedAcross || s < n.pos || r > i.pos ? null : new _Ut(n.pos, i.pos, s, r, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = true), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _Ut(n.from, n.to, n.gapFrom, n.gapTo, ke.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
};
cn.jsonID("replaceAround", Ut);
function Th(t10, e, n) {
  let i = t10.resolve(e), s = n - e, r = i.depth;
  for (; s > 0 && r > 0 && i.indexAfter(r) == i.node(r).childCount; )
    r--, s--;
  if (s > 0) {
    let o = i.node(r).maybeChild(i.indexAfter(r));
    for (; s > 0; ) {
      if (!o || o.isLeaf)
        return true;
      o = o.firstChild, s--;
    }
  }
  return false;
}
function QD(t10, e, n, i) {
  let s = [], r = [], o, a;
  t10.doc.nodesBetween(e, n, (l, c, u) => {
    if (!l.isInline)
      return;
    let d = l.marks;
    if (!i.isInSet(d) && u.type.allowsMarkType(i.type)) {
      let f = Math.max(c, e), h10 = Math.min(c + l.nodeSize, n), p = i.addToSet(d);
      for (let g = 0; g < d.length; g++)
        d[g].isInSet(p) || (o && o.to == f && o.mark.eq(d[g]) ? o.to = h10 : s.push(o = new Pi(f, h10, d[g])));
      a && a.to == f ? a.to = h10 : r.push(a = new Rs(f, h10, i));
    }
  }), s.forEach((l) => t10.step(l)), r.forEach((l) => t10.step(l));
}
function ZD(t10, e, n, i) {
  let s = [], r = 0;
  t10.doc.nodesBetween(e, n, (o, a) => {
    if (!o.isInline)
      return;
    r++;
    let l = null;
    if (i instanceof vd) {
      let c = o.marks, u;
      for (; u = i.isInSet(c); )
        (l || (l = [])).push(u), c = u.removeFromSet(c);
    } else i ? i.isInSet(o.marks) && (l = [i]) : l = o.marks;
    if (l && l.length) {
      let c = Math.min(a + o.nodeSize, n);
      for (let u = 0; u < l.length; u++) {
        let d = l[u], f;
        for (let h10 = 0; h10 < s.length; h10++) {
          let p = s[h10];
          p.step == r - 1 && d.eq(s[h10].style) && (f = p);
        }
        f ? (f.to = c, f.step = r) : s.push({ style: d, from: Math.max(a, e), to: c, step: r });
      }
    }
  }), s.forEach((o) => t10.step(new Pi(o.from, o.to, o.style)));
}
function Jp(t10, e, n, i = n.contentMatch, s = true) {
  let r = t10.doc.nodeAt(e), o = [], a = e + 1;
  for (let l = 0; l < r.childCount; l++) {
    let c = r.child(l), u = a + c.nodeSize, d = i.matchType(c.type);
    if (!d)
      o.push(new Wt(a, u, ke.empty));
    else {
      i = d;
      for (let f = 0; f < c.marks.length; f++)
        n.allowsMarkType(c.marks[f].type) || t10.step(new Pi(a, u, c.marks[f]));
      if (s && c.isText && n.whitespace != "pre") {
        let f, h10 = /\r?\n|\r/g, p;
        for (; f = h10.exec(c.text); )
          p || (p = new ke(ce.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), o.push(new Wt(a + f.index, a + f.index + f[0].length, p));
      }
    }
    a = u;
  }
  if (!i.validEnd) {
    let l = i.fillBefore(ce.empty, true);
    t10.replace(a, a, new ke(l, 0, 0));
  }
  for (let l = o.length - 1; l >= 0; l--)
    t10.step(o[l]);
}
function e$(t10, e, n) {
  return (e == 0 || t10.canReplace(e, t10.childCount)) && (n == t10.childCount || t10.canReplace(0, n));
}
function Xo(t10) {
  let n = t10.parent.content.cutByIndex(t10.startIndex, t10.endIndex);
  for (let i = t10.depth; ; --i) {
    let s = t10.$from.node(i), r = t10.$from.index(i), o = t10.$to.indexAfter(i);
    if (i < t10.depth && s.canReplace(r, o, n))
      return i;
    if (i == 0 || s.type.spec.isolating || !e$(s, r, o))
      break;
  }
  return null;
}
function t$(t10, e, n) {
  let { $from: i, $to: s, depth: r } = e, o = i.before(r + 1), a = s.after(r + 1), l = o, c = a, u = ce.empty, d = 0;
  for (let p = r, g = false; p > n; p--)
    g || i.index(p) > 0 ? (g = true, u = ce.from(i.node(p).copy(u)), d++) : l--;
  let f = ce.empty, h10 = 0;
  for (let p = r, g = false; p > n; p--)
    g || s.after(p + 1) < s.end(p) ? (g = true, f = ce.from(s.node(p).copy(f)), h10++) : c++;
  t10.step(new Ut(l, c, o, a, new ke(u.append(f), d, h10), u.size - d, true));
}
function Xp(t10, e, n = null, i = t10) {
  let s = n$(t10, e), r = s && i$(i, e);
  return r ? s.map(v0).concat({ type: e, attrs: n }).concat(r.map(v0)) : null;
}
function v0(t10) {
  return { type: t10, attrs: null };
}
function n$(t10, e) {
  let { parent: n, startIndex: i, endIndex: s } = t10, r = n.contentMatchAt(i).findWrapping(e);
  if (!r)
    return null;
  let o = r.length ? r[0] : e;
  return n.canReplaceWith(i, s, o) ? r : null;
}
function i$(t10, e) {
  let { parent: n, startIndex: i, endIndex: s } = t10, r = n.child(i), o = e.contentMatch.findWrapping(r.type);
  if (!o)
    return null;
  let l = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let c = i; l && c < s; c++)
    l = l.matchType(n.child(c).type);
  return !l || !l.validEnd ? null : o;
}
function s$(t10, e, n) {
  let i = ce.empty;
  for (let o = n.length - 1; o >= 0; o--) {
    if (i.size) {
      let a = n[o].type.contentMatch.matchFragment(i);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    i = ce.from(n[o].type.create(n[o].attrs, i));
  }
  let s = e.start, r = e.end;
  t10.step(new Ut(s, r, s, r, new ke(i, 0, 0), n.length, true));
}
function r$(t10, e, n, i, s) {
  if (!i.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let r = t10.steps.length;
  t10.doc.nodesBetween(e, n, (o, a) => {
    let l = typeof s == "function" ? s(o) : s;
    if (o.isTextblock && !o.hasMarkup(i, l) && o$(t10.doc, t10.mapping.slice(r).map(a), i)) {
      let c = null;
      if (i.schema.linebreakReplacement) {
        let h10 = i.whitespace == "pre", p = !!i.contentMatch.matchType(i.schema.linebreakReplacement);
        h10 && !p ? c = false : !h10 && p && (c = true);
      }
      c === false && V2(t10, o, a, r), Jp(t10, t10.mapping.slice(r).map(a, 1), i, void 0, c === null);
      let u = t10.mapping.slice(r), d = u.map(a, 1), f = u.map(a + o.nodeSize, 1);
      return t10.step(new Ut(d, f, d + 1, f - 1, new ke(ce.from(i.create(l, null, o.marks)), 0, 0), 1, true)), c === true && F2(t10, o, a, r), false;
    }
  });
}
function F2(t10, e, n, i) {
  e.forEach((s, r) => {
    if (s.isText) {
      let o, a = /\r?\n|\r/g;
      for (; o = a.exec(s.text); ) {
        let l = t10.mapping.slice(i).map(n + 1 + r + o.index);
        t10.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function V2(t10, e, n, i) {
  e.forEach((s, r) => {
    if (s.type == s.type.schema.linebreakReplacement) {
      let o = t10.mapping.slice(i).map(n + 1 + r);
      t10.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function o$(t10, e, n) {
  let i = t10.resolve(e), s = i.index();
  return i.parent.canReplaceWith(s, s + 1, n);
}
function a$(t10, e, n, i, s) {
  let r = t10.doc.nodeAt(e);
  if (!r)
    throw new RangeError("No node at given position");
  n || (n = r.type);
  let o = n.create(i, null, s || r.marks);
  if (r.isLeaf)
    return t10.replaceWith(e, e + r.nodeSize, o);
  if (!n.validContent(r.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t10.step(new Ut(e, e + r.nodeSize, e + 1, e + r.nodeSize - 1, new ke(ce.from(o), 0, 0), 1, true));
}
function bs(t10, e, n = 1, i) {
  let s = t10.resolve(e), r = s.depth - n, o = i && i[i.length - 1] || s.parent;
  if (r < 0 || s.parent.type.spec.isolating || !s.parent.canReplace(s.index(), s.parent.childCount) || !o.type.validContent(s.parent.content.cutByIndex(s.index(), s.parent.childCount)))
    return false;
  for (let c = s.depth - 1, u = n - 2; c > r; c--, u--) {
    let d = s.node(c), f = s.index(c);
    if (d.type.spec.isolating)
      return false;
    let h10 = d.content.cutByIndex(f, d.childCount), p = i && i[u + 1];
    p && (h10 = h10.replaceChild(0, p.type.create(p.attrs)));
    let g = i && i[u] || d;
    if (!d.canReplace(f + 1, d.childCount) || !g.type.validContent(h10))
      return false;
  }
  let a = s.indexAfter(r), l = i && i[0];
  return s.node(r).canReplaceWith(a, a, l ? l.type : s.node(r + 1).type);
}
function l$(t10, e, n = 1, i) {
  let s = t10.doc.resolve(e), r = ce.empty, o = ce.empty;
  for (let a = s.depth, l = s.depth - n, c = n - 1; a > l; a--, c--) {
    r = ce.from(s.node(a).copy(r));
    let u = i && i[c];
    o = ce.from(u ? u.type.create(u.attrs, o) : s.node(a).copy(o));
  }
  t10.step(new Wt(e, e, new ke(r.append(o), n, n), true));
}
function or(t10, e) {
  let n = t10.resolve(e), i = n.index();
  return B2(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(i, i + 1);
}
function c$(t10, e) {
  e.content.size || t10.type.compatibleContent(e.type);
  let n = t10.contentMatchAt(t10.childCount), { linebreakReplacement: i } = t10.type.schema;
  for (let s = 0; s < e.childCount; s++) {
    let r = e.child(s), o = r.type == i ? t10.type.schema.nodes.text : r.type;
    if (n = n.matchType(o), !n || !t10.type.allowsMarks(r.marks))
      return false;
  }
  return n.validEnd;
}
function B2(t10, e) {
  return !!(t10 && e && !t10.isLeaf && c$(t10, e));
}
function xd(t10, e, n = -1) {
  let i = t10.resolve(e);
  for (let s = i.depth; ; s--) {
    let r, o, a = i.index(s);
    if (s == i.depth ? (r = i.nodeBefore, o = i.nodeAfter) : n > 0 ? (r = i.node(s + 1), a++, o = i.node(s).maybeChild(a)) : (r = i.node(s).maybeChild(a - 1), o = i.node(s + 1)), r && !r.isTextblock && B2(r, o) && i.node(s).canReplace(a, a + 1))
      return e;
    if (s == 0)
      break;
    e = n < 0 ? i.before(s) : i.after(s);
  }
}
function u$(t10, e, n) {
  let i = null, { linebreakReplacement: s } = t10.doc.type.schema, r = t10.doc.resolve(e - n), o = r.node().type;
  if (s && o.inlineContent) {
    let u = o.whitespace == "pre", d = !!o.contentMatch.matchType(s);
    u && !d ? i = false : !u && d && (i = true);
  }
  let a = t10.steps.length;
  if (i === false) {
    let u = t10.doc.resolve(e + n);
    V2(t10, u.node(), u.before(), a);
  }
  o.inlineContent && Jp(t10, e + n - 1, o, r.node().contentMatchAt(r.index()), i == null);
  let l = t10.mapping.slice(a), c = l.map(e - n);
  if (t10.step(new Wt(c, l.map(e + n, -1), ke.empty, true)), i === true) {
    let u = t10.doc.resolve(c);
    F2(t10, u.node(), u.before(), t10.steps.length);
  }
  return t10;
}
function d$(t10, e, n) {
  let i = t10.resolve(e);
  if (i.parent.canReplaceWith(i.index(), i.index(), n))
    return e;
  if (i.parentOffset == 0)
    for (let s = i.depth - 1; s >= 0; s--) {
      let r = i.index(s);
      if (i.node(s).canReplaceWith(r, r, n))
        return i.before(s + 1);
      if (r > 0)
        return null;
    }
  if (i.parentOffset == i.parent.content.size)
    for (let s = i.depth - 1; s >= 0; s--) {
      let r = i.indexAfter(s);
      if (i.node(s).canReplaceWith(r, r, n))
        return i.after(s + 1);
      if (r < i.node(s).childCount)
        return null;
    }
  return null;
}
function z2(t10, e, n) {
  let i = t10.resolve(e);
  if (!n.content.size)
    return e;
  let s = n.content;
  for (let r = 0; r < n.openStart; r++)
    s = s.firstChild.content;
  for (let r = 1; r <= (n.openStart == 0 && n.size ? 2 : 1); r++)
    for (let o = i.depth; o >= 0; o--) {
      let a = o == i.depth ? 0 : i.pos <= (i.start(o + 1) + i.end(o + 1)) / 2 ? -1 : 1, l = i.index(o) + (a > 0 ? 1 : 0), c = i.node(o), u = false;
      if (r == 1)
        u = c.canReplace(l, l, s);
      else {
        let d = c.contentMatchAt(l).findWrapping(s.firstChild.type);
        u = d && c.canReplaceWith(l, l, d[0]);
      }
      if (u)
        return a == 0 ? i.pos : a < 0 ? i.before(o + 1) : i.after(o + 1);
    }
  return null;
}
function kd(t10, e, n = e, i = ke.empty) {
  if (e == n && !i.size)
    return null;
  let s = t10.resolve(e), r = t10.resolve(n);
  return j2(s, r, i) ? new Wt(e, n, i) : new f$(s, r, i).fit();
}
function j2(t10, e, n) {
  return !n.openStart && !n.openEnd && t10.start() == e.start() && t10.parent.canReplace(t10.index(), e.index(), n.content);
}
var f$ = class {
  constructor(e, n, i) {
    this.$from = e, this.$to = n, this.unplaced = i, this.frontier = [], this.placed = ce.empty;
    for (let s = 0; s <= e.depth; s++) {
      let r = e.node(s);
      this.frontier.push({
        type: r.type,
        match: r.contentMatchAt(e.indexAfter(s))
      });
    }
    for (let s = e.depth; s > 0; s--)
      this.placed = ce.from(e.node(s).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, i = this.$from, s = this.close(e < 0 ? this.$to : i.doc.resolve(e));
    if (!s)
      return null;
    let r = this.placed, o = i.depth, a = s.depth;
    for (; o && a && r.childCount == 1; )
      r = r.firstChild.content, o--, a--;
    let l = new ke(r, o, a);
    return e > -1 ? new Ut(i.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || i.pos != this.$to.pos ? new Wt(i.pos, s.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, i = 0, s = this.unplaced.openEnd; i < e; i++) {
      let r = n.firstChild;
      if (n.childCount > 1 && (s = 0), r.type.spec.isolating && s <= i) {
        e = i;
        break;
      }
      n = r.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let i = n == 1 ? e : this.unplaced.openStart; i >= 0; i--) {
        let s, r = null;
        i ? (r = af(this.unplaced.content, i - 1).firstChild, s = r.content) : s = this.unplaced.content;
        let o = s.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a], u, d = null;
          if (n == 1 && (o ? c.matchType(o.type) || (d = c.fillBefore(ce.from(o), false)) : r && l.compatibleContent(r.type)))
            return { sliceDepth: i, frontierDepth: a, parent: r, inject: d };
          if (n == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: i, frontierDepth: a, parent: r, wrap: u };
          if (r && c.matchType(r.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: i } = this.unplaced, s = af(e, n);
    return !s.childCount || s.firstChild.isLeaf ? false : (this.unplaced = new ke(e, n + 1, Math.max(i, s.size + n >= e.size - i ? n + 1 : 0)), true);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: i } = this.unplaced, s = af(e, n);
    if (s.childCount <= 1 && n > 0) {
      let r = e.size - n <= n + s.size;
      this.unplaced = new ke(ya(e, n - 1, 1), n - 1, r ? n - 1 : i);
    } else
      this.unplaced = new ke(ya(e, n, 1), n, i);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: i, inject: s, wrap: r }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (r)
      for (let g = 0; g < r.length; g++)
        this.openFrontierNode(r[g]);
    let o = this.unplaced, a = i ? i.content : o.content, l = o.openStart - e, c = 0, u = [], { match: d, type: f } = this.frontier[n];
    if (s) {
      for (let g = 0; g < s.childCount; g++)
        u.push(s.child(g));
      d = d.matchFragment(s);
    }
    let h10 = a.size + e - (o.content.size - o.openEnd);
    for (; c < a.childCount; ) {
      let g = a.child(c), m = d.matchType(g.type);
      if (!m)
        break;
      c++, (c > 1 || l == 0 || g.content.size) && (d = m, u.push(H2(g.mark(f.allowedMarks(g.marks)), c == 1 ? l : 0, c == a.childCount ? h10 : -1)));
    }
    let p = c == a.childCount;
    p || (h10 = -1), this.placed = va(this.placed, n, ce.from(u)), this.frontier[n].match = d, p && h10 < 0 && i && i.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let g = 0, m = a; g < h10; g++) {
      let b = m.lastChild;
      this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), m = b.content;
    }
    this.unplaced = p ? e == 0 ? ke.empty : new ke(ya(o.content, e - 1, 1), e - 1, h10 < 0 ? o.openEnd : e - 1) : new ke(ya(o.content, e, c), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !lf(this.$to, this.$to.depth, e.type, e.match, false) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: i } = this.$to, s = this.$to.after(i);
    for (; i > 1 && s == this.$to.end(--i); )
      ++s;
    return s;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: i, type: s } = this.frontier[n], r = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), o = lf(e, n, s, i, r);
      if (o) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: l, type: c } = this.frontier[a], u = lf(e, a, c, l, true);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: n, fit: o, move: r ? e.doc.resolve(e.after(n + 1)) : e };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = va(this.placed, n.depth, n.fit)), e = n.move;
    for (let i = n.depth + 1; i <= e.depth; i++) {
      let s = e.node(i), r = s.type.contentMatch.fillBefore(s.content, true, e.index(i));
      this.openFrontierNode(s.type, s.attrs, r);
    }
    return e;
  }
  openFrontierNode(e, n = null, i) {
    let s = this.frontier[this.depth];
    s.match = s.match.matchType(e), this.placed = va(this.placed, this.depth, ce.from(e.create(n, i))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(ce.empty, true);
    n.childCount && (this.placed = va(this.placed, this.frontier.length, n));
  }
};
function ya(t10, e, n) {
  return e == 0 ? t10.cutByIndex(n, t10.childCount) : t10.replaceChild(0, t10.firstChild.copy(ya(t10.firstChild.content, e - 1, n)));
}
function va(t10, e, n) {
  return e == 0 ? t10.append(n) : t10.replaceChild(t10.childCount - 1, t10.lastChild.copy(va(t10.lastChild.content, e - 1, n)));
}
function af(t10, e) {
  for (let n = 0; n < e; n++)
    t10 = t10.firstChild.content;
  return t10;
}
function H2(t10, e, n) {
  if (e <= 0)
    return t10;
  let i = t10.content;
  return e > 1 && (i = i.replaceChild(0, H2(i.firstChild, e - 1, i.childCount == 1 ? n - 1 : 0))), e > 0 && (i = t10.type.contentMatch.fillBefore(i).append(i), n <= 0 && (i = i.append(t10.type.contentMatch.matchFragment(i).fillBefore(ce.empty, true)))), t10.copy(i);
}
function lf(t10, e, n, i, s) {
  let r = t10.node(e), o = s ? t10.indexAfter(e) : t10.index(e);
  if (o == r.childCount && !n.compatibleContent(r.type))
    return null;
  let a = i.fillBefore(r.content, true, o);
  return a && !h$(n, r.content, o) ? a : null;
}
function h$(t10, e, n) {
  for (let i = n; i < e.childCount; i++)
    if (!t10.allowsMarks(e.child(i).marks))
      return true;
  return false;
}
function p$(t10) {
  return t10.spec.defining || t10.spec.definingForContent;
}
function m$(t10, e, n, i) {
  if (!i.size)
    return t10.deleteRange(e, n);
  let s = t10.doc.resolve(e), r = t10.doc.resolve(n);
  if (j2(s, r, i))
    return t10.step(new Wt(e, n, i));
  let o = U2(s, t10.doc.resolve(n));
  o[o.length - 1] == 0 && o.pop();
  let a = -(s.depth + 1);
  o.unshift(a);
  for (let f = s.depth, h10 = s.pos - 1; f > 0; f--, h10--) {
    let p = s.node(f).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    o.indexOf(f) > -1 ? a = f : s.before(f) == h10 && o.splice(1, 0, -f);
  }
  let l = o.indexOf(a), c = [], u = i.openStart;
  for (let f = i.content, h10 = 0; ; h10++) {
    let p = f.firstChild;
    if (c.push(p), h10 == i.openStart)
      break;
    f = p.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let h10 = c[f], p = p$(h10.type);
    if (p && !h10.sameMarkup(s.node(Math.abs(a) - 1)))
      u = f;
    else if (p || !h10.type.isTextblock)
      break;
  }
  for (let f = i.openStart; f >= 0; f--) {
    let h10 = (f + u + 1) % (i.openStart + 1), p = c[h10];
    if (p)
      for (let g = 0; g < o.length; g++) {
        let m = o[(g + l) % o.length], b = true;
        m < 0 && (b = false, m = -m);
        let x = s.node(m - 1), k = s.index(m - 1);
        if (x.canReplaceWith(k, k, p.type, p.marks))
          return t10.replace(s.before(m), b ? r.after(m) : n, new ke(W2(i.content, 0, i.openStart, h10), h10, i.openEnd));
      }
  }
  let d = t10.steps.length;
  for (let f = o.length - 1; f >= 0 && (t10.replace(e, n, i), !(t10.steps.length > d)); f--) {
    let h10 = o[f];
    h10 < 0 || (e = s.before(h10), n = r.after(h10));
  }
}
function W2(t10, e, n, i, s) {
  if (e < n) {
    let r = t10.firstChild;
    t10 = t10.replaceChild(0, r.copy(W2(r.content, e + 1, n, i, r)));
  }
  if (e > i) {
    let r = s.contentMatchAt(0), o = r.fillBefore(t10).append(t10);
    t10 = o.append(r.matchFragment(o).fillBefore(ce.empty, true));
  }
  return t10;
}
function g$(t10, e, n, i) {
  if (!i.isInline && e == n && t10.doc.resolve(e).parent.content.size) {
    let s = d$(t10.doc, e, i.type);
    s != null && (e = n = s);
  }
  t10.replaceRange(e, n, new ke(ce.from(i), 0, 0));
}
function b$(t10, e, n) {
  let i = t10.doc.resolve(e), s = t10.doc.resolve(n), r = U2(i, s);
  for (let o = 0; o < r.length; o++) {
    let a = r[o], l = o == r.length - 1;
    if (l && a == 0 || i.node(a).type.contentMatch.validEnd)
      return t10.delete(i.start(a), s.end(a));
    if (a > 0 && (l || i.node(a - 1).canReplace(i.index(a - 1), s.indexAfter(a - 1))))
      return t10.delete(i.before(a), s.after(a));
  }
  for (let o = 1; o <= i.depth && o <= s.depth; o++)
    if (e - i.start(o) == i.depth - o && n > i.end(o) && s.end(o) - n != s.depth - o && i.start(o - 1) == s.start(o - 1) && i.node(o - 1).canReplace(i.index(o - 1), s.index(o - 1)))
      return t10.delete(i.before(o), n);
  t10.delete(e, n);
}
function U2(t10, e) {
  let n = [], i = Math.min(t10.depth, e.depth);
  for (let s = i; s >= 0; s--) {
    let r = t10.start(s);
    if (r < t10.pos - (t10.depth - s) || e.end(s) > e.pos + (e.depth - s) || t10.node(s).type.spec.isolating || e.node(s).type.spec.isolating)
      break;
    (r == e.start(s) || s == t10.depth && s == e.depth && t10.parent.inlineContent && e.parent.inlineContent && s && e.start(s - 1) == r - 1) && n.push(s);
  }
  return n;
}
var Oo = class _Oo extends cn {
  /**
  Construct an attribute step.
  */
  constructor(e, n, i) {
    super(), this.pos = e, this.attr = n, this.value = i;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return Rt.fail("No node at attribute step's position");
    let i = /* @__PURE__ */ Object.create(null);
    for (let r in n.attrs)
      i[r] = n.attrs[r];
    i[this.attr] = this.value;
    let s = n.type.create(i, null, n.marks);
    return Rt.fromReplace(e, this.pos, this.pos + 1, new ke(ce.from(s), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return Hn.empty;
  }
  invert(e) {
    return new _Oo(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new _Oo(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _Oo(n.pos, n.attr, n.value);
  }
};
cn.jsonID("attr", Oo);
var rl = class _rl extends cn {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let s in e.attrs)
      n[s] = e.attrs[s];
    n[this.attr] = this.value;
    let i = e.type.create(n, e.content, e.marks);
    return Rt.ok(i);
  }
  getMap() {
    return Hn.empty;
  }
  invert(e) {
    return new _rl(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _rl(n.attr, n.value);
  }
};
cn.jsonID("docAttr", rl);
var Do = class extends Error {
};
Do = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
Do.prototype = Object.create(Error.prototype);
Do.prototype.constructor = Do;
Do.prototype.name = "TransformError";
var q2 = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new sl();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new Do(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, i = ke.empty) {
    let s = kd(this.doc, e, n, i);
    return s && this.step(s), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, i) {
    return this.replace(e, n, new ke(ce.from(i), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, ke.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, i) {
    return m$(this, e, n, i), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, i) {
    return g$(this, e, n, i), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return b$(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return t$(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return u$(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return s$(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, i, s = null) {
    return r$(this, e, n, i, s), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, i = null, s) {
    return a$(this, e, n, i, s), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, i) {
    return this.step(new Oo(e, n, i)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new rl(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new Fs(e, n)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    if (!(n instanceof dt)) {
      let i = this.doc.nodeAt(e);
      if (!i)
        throw new RangeError("No node at position " + e);
      if (n = n.isInSet(i.marks), !n)
        return this;
    }
    return this.step(new Po(e, n)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, n = 1, i) {
    return l$(this, e, n, i), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, i) {
    return QD(this, e, n, i), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, i) {
    return ZD(this, e, n, i), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, i) {
    return Jp(this, e, n, i), this;
  }
};
var cf = /* @__PURE__ */ Object.create(null);
var je = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, i) {
    this.$anchor = e, this.$head = n, this.ranges = i || [new y$(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = ke.empty) {
    let i = n.content.lastChild, s = null;
    for (let a = 0; a < n.openEnd; a++)
      s = i, i = i.lastChild;
    let r = e.steps.length, o = this.ranges;
    for (let a = 0; a < o.length; a++) {
      let { $from: l, $to: c } = o[a], u = e.mapping.slice(r);
      e.replaceRange(u.map(l.pos), u.map(c.pos), a ? ke.empty : n), a == 0 && S0(e, r, (i ? i.isInline : s && s.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let i = e.steps.length, s = this.ranges;
    for (let r = 0; r < s.length; r++) {
      let { $from: o, $to: a } = s[r], l = e.mapping.slice(i), c = l.map(o.pos), u = l.map(a.pos);
      r ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, n), S0(e, i, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, i = false) {
    let s = e.parent.inlineContent ? new Be(e) : fo(e.node(0), e.parent, e.pos, e.index(), n, i);
    if (s)
      return s;
    for (let r = e.depth - 1; r >= 0; r--) {
      let o = n < 0 ? fo(e.node(0), e.node(r), e.before(r + 1), e.index(r), n, i) : fo(e.node(0), e.node(r), e.after(r + 1), e.index(r) + 1, n, i);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new Yn(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return fo(e, e, 0, 0, 1) || new Yn(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return fo(e, e, e.content.size, e.childCount, -1) || new Yn(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let i = cf[n.type];
    if (!i)
      throw new RangeError(`No selection type ${n.type} defined`);
    return i.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in cf)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return cf[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Be.between(this.$anchor, this.$head).getBookmark();
  }
};
je.prototype.visible = true;
var y$ = class {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
};
var x0 = false;
function k0(t10) {
  !x0 && !t10.parent.inlineContent && (x0 = true, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t10.parent.type.name + ")"));
}
var Be = class _Be extends je {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    k0(e), k0(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let i = e.resolve(n.map(this.head));
    if (!i.parent.inlineContent)
      return je.near(i);
    let s = e.resolve(n.map(this.anchor));
    return new _Be(s.parent.inlineContent ? s : i, i);
  }
  replace(e, n = ke.empty) {
    if (super.replace(e, n), n == ke.empty) {
      let i = this.$from.marksAcross(this.$to);
      i && e.ensureMarks(i);
    }
  }
  eq(e) {
    return e instanceof _Be && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new Sd(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _Be(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, i = n) {
    let s = e.resolve(n);
    return new this(s, i == n ? s : e.resolve(i));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, i) {
    let s = e.pos - n.pos;
    if ((!i || s) && (i = s >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let r = je.findFrom(n, i, true) || je.findFrom(n, -i, true);
      if (r)
        n = r.$head;
      else
        return je.near(n, i);
    }
    return e.parent.inlineContent || (s == 0 ? e = n : (e = (je.findFrom(e, -i, true) || je.findFrom(e, i, true)).$anchor, e.pos < n.pos != s < 0 && (e = n))), new _Be(e, n);
  }
};
je.jsonID("text", Be);
var Sd = class _Sd {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new _Sd(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Be.between(e.resolve(this.anchor), e.resolve(this.head));
  }
};
var Pe = class _Pe extends je {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, i = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, i), this.node = n;
  }
  map(e, n) {
    let { deleted: i, pos: s } = n.mapResult(this.anchor), r = e.resolve(s);
    return i ? je.near(r) : new _Pe(r);
  }
  content() {
    return new ke(ce.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof _Pe && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Qp(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _Pe(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new _Pe(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== false;
  }
};
Pe.prototype.visible = false;
je.jsonID("node", Pe);
var Qp = class _Qp {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: i } = e.mapResult(this.anchor);
    return n ? new Sd(i, i) : new _Qp(i);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), i = n.nodeAfter;
    return i && Pe.isSelectable(i) ? new Pe(n) : je.near(n);
  }
};
var Yn = class _Yn extends je {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = ke.empty) {
    if (n == ke.empty) {
      e.delete(0, e.doc.content.size);
      let i = je.atStart(e.doc);
      i.eq(e.selection) || e.setSelection(i);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new _Yn(e);
  }
  map(e) {
    return new _Yn(e);
  }
  eq(e) {
    return e instanceof _Yn;
  }
  getBookmark() {
    return v$;
  }
};
je.jsonID("all", Yn);
var v$ = {
  map() {
    return this;
  },
  resolve(t10) {
    return new Yn(t10);
  }
};
function fo(t10, e, n, i, s, r = false) {
  if (e.inlineContent)
    return Be.create(t10, n);
  for (let o = i - (s > 0 ? 0 : 1); s > 0 ? o < e.childCount : o >= 0; o += s) {
    let a = e.child(o);
    if (a.isAtom) {
      if (!r && Pe.isSelectable(a))
        return Pe.create(t10, n - (s < 0 ? a.nodeSize : 0));
    } else {
      let l = fo(t10, a, n + s, s < 0 ? a.childCount : 0, s, r);
      if (l)
        return l;
    }
    n += a.nodeSize * s;
  }
  return null;
}
function S0(t10, e, n) {
  let i = t10.steps.length - 1;
  if (i < e)
    return;
  let s = t10.steps[i];
  if (!(s instanceof Wt || s instanceof Ut))
    return;
  let r = t10.mapping.maps[i], o;
  r.forEach((a, l, c, u) => {
    o == null && (o = u);
  }), t10.setSelection(je.near(t10.doc.resolve(o), n));
}
var w0 = 1;
var C0 = 2;
var O0 = 4;
var x$ = class extends q2 {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | w0) & -3, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & w0) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= C0, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return dt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & C0) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & -3, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = true) {
    let i = this.selection;
    return n && (e = e.mark(this.storedMarks || (i.empty ? i.$from.marks() : i.$from.marksAcross(i.$to) || dt.none))), i.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, i) {
    let s = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(s.text(e), true) : this.deleteSelection();
    {
      if (i == null && (i = n), i = i ?? n, !e)
        return this.deleteRange(n, i);
      let r = this.storedMarks;
      if (!r) {
        let o = this.doc.resolve(n);
        r = i == n ? o.marks() : o.marksAcross(this.doc.resolve(i));
      }
      return this.replaceRangeWith(n, i, s.text(e, r)), this.selection.empty || this.setSelection(je.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= O0, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & O0) > 0;
  }
};
function E0(t10, e) {
  return !e || !t10 ? t10 : t10.bind(e);
}
var xa = class {
  constructor(e, n, i) {
    this.name = e, this.init = E0(n.init, i), this.apply = E0(n.apply, i);
  }
};
var k$ = [
  new xa("doc", {
    init(t10) {
      return t10.doc || t10.schema.topNodeType.createAndFill();
    },
    apply(t10) {
      return t10.doc;
    }
  }),
  new xa("selection", {
    init(t10, e) {
      return t10.selection || je.atStart(e.doc);
    },
    apply(t10) {
      return t10.selection;
    }
  }),
  new xa("storedMarks", {
    init(t10) {
      return t10.storedMarks || null;
    },
    apply(t10, e, n, i) {
      return i.selection.$cursor ? t10.storedMarks : null;
    }
  }),
  new xa("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t10, e) {
      return t10.scrolledIntoView ? e + 1 : e;
    }
  })
];
var uf = class {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = k$.slice(), n && n.forEach((i) => {
      if (this.pluginsByKey[i.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + i.key + ")");
      this.plugins.push(i), this.pluginsByKey[i.key] = i, i.spec.state && this.fields.push(new xa(i.key, i.spec.state, i));
    });
  }
};
var vo = class _vo {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != n) {
        let s = this.config.plugins[i];
        if (s.spec.filterTransaction && !s.spec.filterTransaction.call(s, e, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], i = this.applyInner(e), s = null;
    for (; ; ) {
      let r = false;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let a = this.config.plugins[o];
        if (a.spec.appendTransaction) {
          let l = s ? s[o].n : 0, c = s ? s[o].state : this, u = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, i);
          if (u && i.filterTransaction(u, o)) {
            if (u.setMeta("appendedTransaction", e), !s) {
              s = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                s.push(d < o ? { state: i, n: n.length } : { state: this, n: 0 });
            }
            n.push(u), i = i.applyInner(u), r = true;
          }
          s && (s[o] = { state: i, n: n.length });
        }
      }
      if (!r)
        return { state: i, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new _vo(this.config), i = this.config.fields;
    for (let s = 0; s < i.length; s++) {
      let r = i[s];
      n[r.name] = r.apply(e, this[r.name], this, n);
    }
    return n;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new x$(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new uf(e.doc ? e.doc.type.schema : e.schema, e.plugins), i = new _vo(n);
    for (let s = 0; s < n.fields.length; s++)
      i[n.fields[s].name] = n.fields[s].init(e, i);
    return i;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new uf(this.schema, e.plugins), i = n.fields, s = new _vo(n);
    for (let r = 0; r < i.length; r++) {
      let o = i[r].name;
      s[o] = this.hasOwnProperty(o) ? this[o] : i[r].init(e, s);
    }
    return s;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((i) => i.toJSON())), e && typeof e == "object")
      for (let i in e) {
        if (i == "doc" || i == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let s = e[i], r = s.spec.state;
        r && r.toJSON && (n[i] = r.toJSON.call(s, this[s.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, i) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let s = new uf(e.schema, e.plugins), r = new _vo(s);
    return s.fields.forEach((o) => {
      if (o.name == "doc")
        r.doc = Hs.fromJSON(e.schema, n.doc);
      else if (o.name == "selection")
        r.selection = je.fromJSON(r.doc, n.selection);
      else if (o.name == "storedMarks")
        n.storedMarks && (r.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (i)
          for (let a in i) {
            let l = i[a], c = l.spec.state;
            if (l.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              r[o.name] = c.fromJSON.call(l, e, n[a], r);
              return;
            }
          }
        r[o.name] = o.init(e, r);
      }
    }), r;
  }
};
function K2(t10, e, n) {
  for (let i in t10) {
    let s = t10[i];
    s instanceof Function ? s = s.bind(e) : i == "handleDOMEvents" && (s = K2(s, e, {})), n[i] = s;
  }
  return n;
}
var It = class {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && K2(e.props, this, this.props), this.key = e.key ? e.key.key : Y2("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
};
var df = /* @__PURE__ */ Object.create(null);
function Y2(t10) {
  return t10 in df ? t10 + "$" + ++df[t10] : (df[t10] = 0, t10 + "$");
}
var Zt = class {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = Y2(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
};
var Jt = function(t10) {
  for (var e = 0; ; e++)
    if (t10 = t10.previousSibling, !t10)
      return e;
};
var $o = function(t10) {
  let e = t10.assignedSlot || t10.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
var Ah = null;
var as = function(t10, e, n) {
  let i = Ah || (Ah = document.createRange());
  return i.setEnd(t10, n ?? t10.nodeValue.length), i.setStart(t10, e || 0), i;
};
var S$ = function() {
  Ah = null;
};
var Yr = function(t10, e, n, i) {
  return n && (M0(t10, e, n, i, -1) || M0(t10, e, n, i, 1));
};
var w$ = /^(img|br|input|textarea|hr)$/i;
function M0(t10, e, n, i, s) {
  for (; ; ) {
    if (t10 == n && e == i)
      return true;
    if (e == (s < 0 ? 0 : oi(t10))) {
      let r = t10.parentNode;
      if (!r || r.nodeType != 1 || Nl(t10) || w$.test(t10.nodeName) || t10.contentEditable == "false")
        return false;
      e = Jt(t10) + (s < 0 ? 0 : 1), t10 = r;
    } else if (t10.nodeType == 1) {
      if (t10 = t10.childNodes[e + (s < 0 ? -1 : 0)], t10.contentEditable == "false")
        return false;
      e = s < 0 ? oi(t10) : 0;
    } else
      return false;
  }
}
function oi(t10) {
  return t10.nodeType == 3 ? t10.nodeValue.length : t10.childNodes.length;
}
function C$(t10, e) {
  for (; ; ) {
    if (t10.nodeType == 3 && e)
      return t10;
    if (t10.nodeType == 1 && e > 0) {
      if (t10.contentEditable == "false")
        return null;
      t10 = t10.childNodes[e - 1], e = oi(t10);
    } else if (t10.parentNode && !Nl(t10))
      e = Jt(t10), t10 = t10.parentNode;
    else
      return null;
  }
}
function O$(t10, e) {
  for (; ; ) {
    if (t10.nodeType == 3 && e < t10.nodeValue.length)
      return t10;
    if (t10.nodeType == 1 && e < t10.childNodes.length) {
      if (t10.contentEditable == "false")
        return null;
      t10 = t10.childNodes[e], e = 0;
    } else if (t10.parentNode && !Nl(t10))
      e = Jt(t10) + 1, t10 = t10.parentNode;
    else
      return null;
  }
}
function E$(t10, e, n) {
  for (let i = e == 0, s = e == oi(t10); i || s; ) {
    if (t10 == n)
      return true;
    let r = Jt(t10);
    if (t10 = t10.parentNode, !t10)
      return false;
    i = i && r == 0, s = s && r == oi(t10);
  }
}
function Nl(t10) {
  let e;
  for (let n = t10; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t10 || e.contentDOM == t10);
}
var wd = function(t10) {
  return t10.focusNode && Yr(t10.focusNode, t10.focusOffset, t10.anchorNode, t10.anchorOffset);
};
function Cr(t10, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", true, true), n.keyCode = t10, n.key = n.code = e, n;
}
function M$(t10) {
  let e = t10.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function T$(t10, e, n) {
  if (t10.caretPositionFromPoint)
    try {
      let i = t10.caretPositionFromPoint(e, n);
      if (i)
        return { node: i.offsetNode, offset: Math.min(oi(i.offsetNode), i.offset) };
    } catch {
    }
  if (t10.caretRangeFromPoint) {
    let i = t10.caretRangeFromPoint(e, n);
    if (i)
      return { node: i.startContainer, offset: Math.min(oi(i.startContainer), i.startOffset) };
  }
}
var Ki = typeof navigator < "u" ? navigator : null;
var T0 = typeof document < "u" ? document : null;
var ar = Ki && Ki.userAgent || "";
var _h = /Edge\/(\d+)/.exec(ar);
var G2 = /MSIE \d/.exec(ar);
var Nh = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ar);
var In = !!(G2 || Nh || _h);
var Us = G2 ? document.documentMode : Nh ? +Nh[1] : _h ? +_h[1] : 0;
var vi = !In && /gecko\/(\d+)/i.test(ar);
vi && +(/Firefox\/(\d+)/.exec(ar) || [0, 0])[1];
var Lh = !In && /Chrome\/(\d+)/.exec(ar);
var nn = !!Lh;
var J2 = Lh ? +Lh[1] : 0;
var bn = !In && !!Ki && /Apple Computer/.test(Ki.vendor);
var Ro = bn && (/Mobile\/\w+/.test(ar) || !!Ki && Ki.maxTouchPoints > 2);
var ii = Ro || (Ki ? /Mac/.test(Ki.platform) : false);
var A$ = Ki ? /Win/.test(Ki.platform) : false;
var fs = /Android \d/.test(ar);
var Ll = !!T0 && "webkitFontSmoothing" in T0.documentElement.style;
var _$ = Ll ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function N$(t10) {
  let e = t10.defaultView && t10.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t10.documentElement.clientWidth,
    top: 0,
    bottom: t10.documentElement.clientHeight
  };
}
function Xi(t10, e) {
  return typeof t10 == "number" ? t10 : t10[e];
}
function L$(t10) {
  let e = t10.getBoundingClientRect(), n = e.width / t10.offsetWidth || 1, i = e.height / t10.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t10.clientWidth * n,
    top: e.top,
    bottom: e.top + t10.clientHeight * i
  };
}
function A0(t10, e, n) {
  let i = t10.someProp("scrollThreshold") || 0, s = t10.someProp("scrollMargin") || 5, r = t10.dom.ownerDocument;
  for (let o = n || t10.dom; o; ) {
    if (o.nodeType != 1) {
      o = $o(o);
      continue;
    }
    let a = o, l = a == r.body, c = l ? N$(r) : L$(a), u = 0, d = 0;
    if (e.top < c.top + Xi(i, "top") ? d = -(c.top - e.top + Xi(s, "top")) : e.bottom > c.bottom - Xi(i, "bottom") && (d = e.bottom - e.top > c.bottom - c.top ? e.top + Xi(s, "top") - c.top : e.bottom - c.bottom + Xi(s, "bottom")), e.left < c.left + Xi(i, "left") ? u = -(c.left - e.left + Xi(s, "left")) : e.right > c.right - Xi(i, "right") && (u = e.right - c.right + Xi(s, "right")), u || d)
      if (l)
        r.defaultView.scrollBy(u, d);
      else {
        let h10 = a.scrollLeft, p = a.scrollTop;
        d && (a.scrollTop += d), u && (a.scrollLeft += u);
        let g = a.scrollLeft - h10, m = a.scrollTop - p;
        e = { left: e.left - g, top: e.top - m, right: e.right - g, bottom: e.bottom - m };
      }
    let f = l ? "fixed" : getComputedStyle(o).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    o = f == "absolute" ? o.offsetParent : $o(o);
  }
}
function I$(t10) {
  let e = t10.dom.getBoundingClientRect(), n = Math.max(0, e.top), i, s;
  for (let r = (e.left + e.right) / 2, o = n + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let a = t10.root.elementFromPoint(r, o);
    if (!a || a == t10.dom || !t10.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      i = a, s = l.top;
      break;
    }
  }
  return { refDOM: i, refTop: s, stack: X2(t10.dom) };
}
function X2(t10) {
  let e = [], n = t10.ownerDocument;
  for (let i = t10; i && (e.push({ dom: i, top: i.scrollTop, left: i.scrollLeft }), t10 != n); i = $o(i))
    ;
  return e;
}
function P$({ refDOM: t10, refTop: e, stack: n }) {
  let i = t10 ? t10.getBoundingClientRect().top : 0;
  Q2(n, i == 0 ? 0 : i - e);
}
function Q2(t10, e) {
  for (let n = 0; n < t10.length; n++) {
    let { dom: i, top: s, left: r } = t10[n];
    i.scrollTop != s + e && (i.scrollTop = s + e), i.scrollLeft != r && (i.scrollLeft = r);
  }
}
var oo = null;
function D$(t10) {
  if (t10.setActive)
    return t10.setActive();
  if (oo)
    return t10.focus(oo);
  let e = X2(t10);
  t10.focus(oo == null ? {
    get preventScroll() {
      return oo = { preventScroll: true }, true;
    }
  } : void 0), oo || (oo = false, Q2(e, 0));
}
function Z2(t10, e) {
  let n, i = 2e8, s, r = 0, o = e.top, a = e.top, l, c;
  for (let u = t10.firstChild, d = 0; u; u = u.nextSibling, d++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = as(u).getClientRects();
    else
      continue;
    for (let h10 = 0; h10 < f.length; h10++) {
      let p = f[h10];
      if (p.top <= o && p.bottom >= a) {
        o = Math.max(p.bottom, o), a = Math.min(p.top, a);
        let g = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
        if (g < i) {
          n = u, i = g, s = g && n.nodeType == 3 ? {
            left: p.right < e.left ? p.right : p.left,
            top: e.top
          } : e, u.nodeType == 1 && g && (r = d + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
          continue;
        }
      } else p.top > e.top && !l && p.left <= e.left && p.right >= e.left && (l = u, c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top });
      !n && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (r = d + 1);
    }
  }
  return !n && l && (n = l, s = c, i = 0), n && n.nodeType == 3 ? $$(n, s) : !n || i && n.nodeType == 1 ? { node: t10, offset: r } : Z2(n, s);
}
function $$(t10, e) {
  let n = t10.nodeValue.length, i = document.createRange();
  for (let s = 0; s < n; s++) {
    i.setEnd(t10, s + 1), i.setStart(t10, s);
    let r = _s(i, 1);
    if (r.top != r.bottom && Zp(e, r))
      return { node: t10, offset: s + (e.left >= (r.left + r.right) / 2 ? 1 : 0) };
  }
  return { node: t10, offset: 0 };
}
function Zp(t10, e) {
  return t10.left >= e.left - 1 && t10.left <= e.right + 1 && t10.top >= e.top - 1 && t10.top <= e.bottom + 1;
}
function R$(t10, e) {
  let n = t10.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t10.getBoundingClientRect().left ? n : t10;
}
function F$(t10, e, n) {
  let { node: i, offset: s } = Z2(e, n), r = -1;
  if (i.nodeType == 1 && !i.firstChild) {
    let o = i.getBoundingClientRect();
    r = o.left != o.right && n.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return t10.docView.posFromDOM(i, s, r);
}
function V$(t10, e, n, i) {
  let s = -1;
  for (let r = e, o = false; r != t10.dom; ) {
    let a = t10.docView.nearestDesc(r, true), l;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && (!o && l.left > i.left || l.top > i.top ? s = a.posBefore : (!o && l.right < i.left || l.bottom < i.top) && (s = a.posAfter), o = true), !a.contentDOM && s < 0 && !a.node.isText))
      return (a.node.isBlock ? i.top < (l.top + l.bottom) / 2 : i.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    r = a.dom.parentNode;
  }
  return s > -1 ? s : t10.docView.posFromDOM(e, n, -1);
}
function ex(t10, e, n) {
  let i = t10.childNodes.length;
  if (i && n.top < n.bottom)
    for (let s = Math.max(0, Math.min(i - 1, Math.floor(i * (e.top - n.top) / (n.bottom - n.top)) - 2)), r = s; ; ) {
      let o = t10.childNodes[r];
      if (o.nodeType == 1) {
        let a = o.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if (Zp(e, c))
            return ex(o, e, c);
        }
      }
      if ((r = (r + 1) % i) == s)
        break;
    }
  return t10;
}
function B$(t10, e) {
  let n = t10.dom.ownerDocument, i, s = 0, r = T$(n, e.left, e.top);
  r && ({ node: i, offset: s } = r);
  let o = (t10.root.elementFromPoint ? t10.root : n).elementFromPoint(e.left, e.top), a;
  if (!o || !t10.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = t10.dom.getBoundingClientRect();
    if (!Zp(e, c) || (o = ex(t10.dom, e, c), !o))
      return null;
  }
  if (bn)
    for (let c = o; i && c; c = $o(c))
      c.draggable && (i = void 0);
  if (o = R$(o, e), i) {
    if (vi && i.nodeType == 1 && (s = Math.min(s, i.childNodes.length), s < i.childNodes.length)) {
      let u = i.childNodes[s], d;
      u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && s++;
    }
    let c;
    Ll && s && i.nodeType == 1 && (c = i.childNodes[s - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && s--, i == t10.dom && s == i.childNodes.length - 1 && i.lastChild.nodeType == 1 && e.top > i.lastChild.getBoundingClientRect().bottom ? a = t10.state.doc.content.size : (s == 0 || i.nodeType != 1 || i.childNodes[s - 1].nodeName != "BR") && (a = V$(t10, i, s, e));
  }
  a == null && (a = F$(t10, o, e));
  let l = t10.docView.nearestDesc(o, true);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function _0(t10) {
  return t10.top < t10.bottom || t10.left < t10.right;
}
function _s(t10, e) {
  let n = t10.getClientRects();
  if (n.length) {
    let i = n[e < 0 ? 0 : n.length - 1];
    if (_0(i))
      return i;
  }
  return Array.prototype.find.call(n, _0) || t10.getBoundingClientRect();
}
var z$ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function tx(t10, e, n) {
  let { node: i, offset: s, atom: r } = t10.docView.domFromPos(e, n < 0 ? -1 : 1), o = Ll || vi;
  if (i.nodeType == 3)
    if (o && (z$.test(i.nodeValue) || (n < 0 ? !s : s == i.nodeValue.length))) {
      let l = _s(as(i, s, s), n);
      if (vi && s && /\s/.test(i.nodeValue[s - 1]) && s < i.nodeValue.length) {
        let c = _s(as(i, s - 1, s - 1), -1);
        if (c.top == l.top) {
          let u = _s(as(i, s, s + 1), -1);
          if (u.top != l.top)
            return oa(u, u.left < c.left);
        }
      }
      return l;
    } else {
      let l = s, c = s, u = n < 0 ? 1 : -1;
      return n < 0 && !s ? (c++, u = -1) : n >= 0 && s == i.nodeValue.length ? (l--, u = 1) : n < 0 ? l-- : c++, oa(_s(as(i, l, c), u), u < 0);
    }
  if (!t10.state.doc.resolve(e - (r || 0)).parent.inlineContent) {
    if (r == null && s && (n < 0 || s == oi(i))) {
      let l = i.childNodes[s - 1];
      if (l.nodeType == 1)
        return ff(l.getBoundingClientRect(), false);
    }
    if (r == null && s < oi(i)) {
      let l = i.childNodes[s];
      if (l.nodeType == 1)
        return ff(l.getBoundingClientRect(), true);
    }
    return ff(i.getBoundingClientRect(), n >= 0);
  }
  if (r == null && s && (n < 0 || s == oi(i))) {
    let l = i.childNodes[s - 1], c = l.nodeType == 3 ? as(l, oi(l) - (o ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (c)
      return oa(_s(c, 1), false);
  }
  if (r == null && s < oi(i)) {
    let l = i.childNodes[s];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let c = l ? l.nodeType == 3 ? as(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (c)
      return oa(_s(c, -1), true);
  }
  return oa(_s(i.nodeType == 3 ? as(i) : i, -n), n >= 0);
}
function oa(t10, e) {
  if (t10.width == 0)
    return t10;
  let n = e ? t10.left : t10.right;
  return { top: t10.top, bottom: t10.bottom, left: n, right: n };
}
function ff(t10, e) {
  if (t10.height == 0)
    return t10;
  let n = e ? t10.top : t10.bottom;
  return { top: n, bottom: n, left: t10.left, right: t10.right };
}
function nx(t10, e, n) {
  let i = t10.state, s = t10.root.activeElement;
  i != e && t10.updateState(e), s != t10.dom && t10.focus();
  try {
    return n();
  } finally {
    i != e && t10.updateState(i), s != t10.dom && s && s.focus();
  }
}
function j$(t10, e, n) {
  let i = e.selection, s = n == "up" ? i.$from : i.$to;
  return nx(t10, e, () => {
    let { node: r } = t10.docView.domFromPos(s.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t10.docView.nearestDesc(r, true);
      if (!a)
        break;
      if (a.node.isBlock) {
        r = a.contentDOM || a.dom;
        break;
      }
      r = a.dom.parentNode;
    }
    let o = tx(t10, s.pos, 1);
    for (let a = r.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = as(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < l.length; c++) {
        let u = l[c];
        if (u.bottom > u.top + 1 && (n == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var H$ = /[\u0590-\u08ac]/;
function W$(t10, e, n) {
  let { $head: i } = e.selection;
  if (!i.parent.isTextblock)
    return false;
  let s = i.parentOffset, r = !s, o = s == i.parent.content.size, a = t10.domSelection();
  return a ? !H$.test(i.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? r : o : nx(t10, e, () => {
    let { focusNode: l, focusOffset: c, anchorNode: u, anchorOffset: d } = t10.domSelectionRange(), f = a.caretBidiLevel;
    a.modify("move", n, "character");
    let h10 = i.depth ? t10.docView.domAfterPos(i.before()) : t10.dom, { focusNode: p, focusOffset: g } = t10.domSelectionRange(), m = p && !h10.contains(p.nodeType == 1 ? p : p.parentNode) || l == p && c == g;
    try {
      a.collapse(u, d), l && (l != u || c != d) && a.extend && a.extend(l, c);
    } catch {
    }
    return f != null && (a.caretBidiLevel = f), m;
  }) : i.pos == i.start() || i.pos == i.end();
}
var N0 = null;
var L0 = null;
var I0 = false;
function U$(t10, e, n) {
  return N0 == e && L0 == n ? I0 : (N0 = e, L0 = n, I0 = n == "up" || n == "down" ? j$(t10, e, n) : W$(t10, e, n));
}
var li = 0;
var P0 = 1;
var Mr = 2;
var Yi = 3;
var Il = class {
  constructor(e, n, i, s) {
    this.parent = e, this.children = n, this.dom = i, this.contentDOM = s, this.dirty = li, i.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return false;
  }
  matchesMark(e) {
    return false;
  }
  matchesNode(e, n, i) {
    return false;
  }
  matchesHack(e) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, i = this.posAtStart; ; n++) {
      let s = this.children[n];
      if (s == e)
        return i;
      i += s.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, i) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (i < 0) {
        let r, o;
        if (e == this.contentDOM)
          r = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          r = e.previousSibling;
        }
        for (; r && !((o = r.pmViewDesc) && o.parent == this); )
          r = r.previousSibling;
        return r ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let r, o;
        if (e == this.contentDOM)
          r = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          r = e.nextSibling;
        }
        for (; r && !((o = r.pmViewDesc) && o.parent == this); )
          r = r.nextSibling;
        return r ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let s;
    if (e == this.dom && this.contentDOM)
      s = n > Jt(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      s = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let r = e; ; r = r.parentNode) {
          if (r == this.dom) {
            s = false;
            break;
          }
          if (r.previousSibling)
            break;
        }
      if (s == null && n == e.childNodes.length)
        for (let r = e; ; r = r.parentNode) {
          if (r == this.dom) {
            s = true;
            break;
          }
          if (r.nextSibling)
            break;
        }
    }
    return s ?? i > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = false) {
    for (let i = true, s = e; s; s = s.parentNode) {
      let r = this.getDesc(s), o;
      if (r && (!n || r.node))
        if (i && (o = r.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          i = false;
        else
          return r;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let i = n; i; i = i.parent)
      if (i == this)
        return n;
  }
  posFromDOM(e, n, i) {
    for (let s = e; s; s = s.parentNode) {
      let r = this.getDesc(s);
      if (r)
        return r.localPosFromDOM(e, n, i);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, i = 0; n < this.children.length; n++) {
      let s = this.children[n], r = i + s.size;
      if (i == e && r != i) {
        for (; !s.border && s.children.length; )
          for (let o = 0; o < s.children.length; o++) {
            let a = s.children[o];
            if (a.size) {
              s = a;
              break;
            }
          }
        return s;
      }
      if (e < r)
        return s.descAt(e - i - s.border);
      i = r;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let i = 0, s = 0;
    for (let r = 0; i < this.children.length; i++) {
      let o = this.children[i], a = r + o.size;
      if (a > e || o instanceof sx) {
        s = e - r;
        break;
      }
      r = a;
    }
    if (s)
      return this.children[i].domFromPos(s - this.children[i].border, n);
    for (let r; i && !(r = this.children[i - 1]).size && r instanceof ix && r.side >= 0; i--)
      ;
    if (n <= 0) {
      let r, o = true;
      for (; r = i ? this.children[i - 1] : null, !(!r || r.dom.parentNode == this.contentDOM); i--, o = false)
        ;
      return r && n && o && !r.border && !r.domAtom ? r.domFromPos(r.size, n) : { node: this.contentDOM, offset: r ? Jt(r.dom) + 1 : 0 };
    } else {
      let r, o = true;
      for (; r = i < this.children.length ? this.children[i] : null, !(!r || r.dom.parentNode == this.contentDOM); i++, o = false)
        ;
      return r && o && !r.border && !r.domAtom ? r.domFromPos(0, n) : { node: this.contentDOM, offset: r ? Jt(r.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, i = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let s = -1, r = -1;
    for (let o = i, a = 0; ; a++) {
      let l = this.children[a], c = o + l.size;
      if (s == -1 && e <= c) {
        let u = o + l.border;
        if (e >= u && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, u);
        e = o;
        for (let d = a; d > 0; d--) {
          let f = this.children[d - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            s = Jt(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        s == -1 && (s = 0);
      }
      if (s > -1 && (c > n || a == this.children.length - 1)) {
        n = c;
        for (let u = a + 1; u < this.children.length; u++) {
          let d = this.children[u];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            r = Jt(d.dom);
            break;
          }
          n += d.size;
        }
        r == -1 && (r = this.contentDOM.childNodes.length);
        break;
      }
      o = c;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: s, toOffset: r };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: i } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || i == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[i];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, i, s = false) {
    let r = Math.min(e, n), o = Math.max(e, n);
    for (let h10 = 0, p = 0; h10 < this.children.length; h10++) {
      let g = this.children[h10], m = p + g.size;
      if (r > p && o < m)
        return g.setSelection(e - p - g.border, n - p - g.border, i, s);
      p = m;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), c = i.root.getSelection(), u = i.domSelectionRange(), d = false;
    if ((vi || bn) && e == n) {
      let { node: h10, offset: p } = a;
      if (h10.nodeType == 3) {
        if (d = !!(p && h10.nodeValue[p - 1] == `
`), d && p == h10.nodeValue.length)
          for (let g = h10, m; g; g = g.parentNode) {
            if (m = g.nextSibling) {
              m.nodeName == "BR" && (a = l = { node: m.parentNode, offset: Jt(m) + 1 });
              break;
            }
            let b = g.pmViewDesc;
            if (b && b.node && b.node.isBlock)
              break;
          }
      } else {
        let g = h10.childNodes[p - 1];
        d = g && (g.nodeName == "BR" || g.contentEditable == "false");
      }
    }
    if (vi && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
      let h10 = u.focusNode.childNodes[u.focusOffset];
      h10 && h10.contentEditable == "false" && (s = true);
    }
    if (!(s || d && bn) && Yr(a.node, a.offset, u.anchorNode, u.anchorOffset) && Yr(l.node, l.offset, u.focusNode, u.focusOffset))
      return;
    let f = false;
    if ((c.extend || e == n) && !d) {
      c.collapse(a.node, a.offset);
      try {
        e != n && c.extend(l.node, l.offset), f = true;
      } catch {
      }
    }
    if (!f) {
      if (e > n) {
        let p = a;
        a = l, l = p;
      }
      let h10 = document.createRange();
      h10.setEnd(l.node, l.offset), h10.setStart(a.node, a.offset), c.removeAllRanges(), c.addRange(h10);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let i = 0, s = 0; s < this.children.length; s++) {
      let r = this.children[s], o = i + r.size;
      if (i == o ? e <= o && n >= i : e < o && n > i) {
        let a = i + r.border, l = o - r.border;
        if (e >= a && n <= l) {
          this.dirty = e == i || n == o ? Mr : P0, e == a && n == l && (r.contentLost || r.dom.parentNode != this.contentDOM) ? r.dirty = Yi : r.markDirty(e - a, n - a);
          return;
        } else
          r.dirty = r.dom == r.contentDOM && r.dom.parentNode == this.contentDOM && !r.children.length ? Mr : Yi;
      }
      i = o;
    }
    this.dirty = Mr;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let i = e == 1 ? Mr : P0;
      n.dirty < i && (n.dirty = i);
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  isText(e) {
    return false;
  }
};
var ix = class extends Il {
  constructor(e, n, i, s) {
    let r, o = n.type.toDOM;
    if (typeof o == "function" && (o = o(i, () => {
      if (!r)
        return s;
      if (r.parent)
        return r.parent.posBeforeChild(r);
    })), !n.type.spec.raw) {
      if (o.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(o), o = a;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = n, this.widget = n, r = this;
  }
  matchesWidget(e) {
    return this.dirty == li && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : false;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
};
var q$ = class extends Il {
  constructor(e, n, i, s) {
    super(e, [], n, null), this.textDOM = i, this.text = s;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
};
var Gr = class _Gr extends Il {
  constructor(e, n, i, s, r) {
    super(e, [], i, s), this.mark = n, this.spec = r;
  }
  static create(e, n, i, s) {
    let r = s.nodeViews[n.type.name], o = r && r(n, s, i);
    return (!o || !o.dom) && (o = so.renderSpec(document, n.type.spec.toDOM(n, i), null, n.attrs)), new _Gr(e, n, o.dom, o.contentDOM || o.dom, o);
  }
  parseRule() {
    return this.dirty & Yi || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Yi && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != li) {
      let i = this.parent;
      for (; !i.node; )
        i = i.parent;
      i.dirty < this.dirty && (i.dirty = this.dirty), this.dirty = li;
    }
  }
  slice(e, n, i) {
    let s = _Gr.create(this.parent, this.mark, true, i), r = this.children, o = this.size;
    n < o && (r = Ph(r, n, o, i)), e > 0 && (r = Ph(r, 0, e, i));
    for (let a = 0; a < r.length; a++)
      r[a].parent = s;
    return s.children = r, s;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
};
var qs = class _qs extends Il {
  constructor(e, n, i, s, r, o, a, l, c) {
    super(e, [], r, o), this.node = n, this.outerDeco = i, this.innerDeco = s, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, i, s, r, o) {
    let a = r.nodeViews[n.type.name], l, c = a && a(n, r, () => {
      if (!l)
        return o;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, i, s), u = c && c.dom, d = c && c.contentDOM;
    if (n.isText) {
      if (!u)
        u = document.createTextNode(n.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: d } = so.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !d && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), n.type.spec.draggable && (u.draggable = true));
    let f = u;
    return u = ax(u, i, n), c ? l = new K$(e, n, i, s, u, d || null, f, c, r, o + 1) : n.isText ? new Cd(e, n, i, s, u, f, r) : new _qs(e, n, i, s, u, d || null, f, r, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let i = this.children[n];
        if (this.dom.contains(i.dom.parentNode)) {
          e.contentElement = i.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => ce.empty);
    }
    return e;
  }
  matchesNode(e, n, i) {
    return this.dirty == li && e.eq(this.node) && nu(n, this.outerDeco) && i.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let i = this.node.inlineContent, s = n, r = e.composing ? this.localCompositionInfo(e, n) : null, o = r && r.pos > -1 ? r : null, a = r && r.pos < 0, l = new G$(this, o && o.node, e);
    Q$(this.node, this.innerDeco, (c, u, d) => {
      c.spec.marks ? l.syncToMarks(c.spec.marks, i, e) : c.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? dt.none : this.node.child(u).marks, i, e), l.placeWidget(c, e, s);
    }, (c, u, d, f) => {
      l.syncToMarks(c.marks, i, e);
      let h10;
      l.findNodeMatch(c, u, d, f) || a && e.state.selection.from > s && e.state.selection.to < s + c.nodeSize && (h10 = l.findIndexWithChild(r.node)) > -1 && l.updateNodeAt(c, u, d, h10, e) || l.updateNextNode(c, u, d, e, f, s) || l.addNode(c, u, d, e, s), s += c.nodeSize;
    }), l.syncToMarks([], i, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Mr) && (o && this.protectLocalComposition(e, o), rx(this.contentDOM, this.children, e), Ro && Z$(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: i, to: s } = e.state.selection;
    if (!(e.state.selection instanceof Be) || i < n || s > n + this.node.content.size)
      return null;
    let r = e.input.compositionNode;
    if (!r || !this.dom.contains(r.parentNode))
      return null;
    if (this.node.inlineContent) {
      let o = r.nodeValue, a = eR(this.node.content, o, i - n, s - n);
      return a < 0 ? null : { node: r, pos: a, text: o };
    } else
      return { node: r, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: i, text: s }) {
    if (this.getDesc(n))
      return;
    let r = n;
    for (; r.parentNode != this.contentDOM; r = r.parentNode) {
      for (; r.previousSibling; )
        r.parentNode.removeChild(r.previousSibling);
      for (; r.nextSibling; )
        r.parentNode.removeChild(r.nextSibling);
      r.pmViewDesc && (r.pmViewDesc = void 0);
    }
    let o = new q$(this, r, n, s);
    e.input.compositionNodes.push(o), this.children = Ph(this.children, i, i + s.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, i, s) {
    return this.dirty == Yi || !e.sameMarkup(this.node) ? false : (this.updateInner(e, n, i, s), true);
  }
  updateInner(e, n, i, s) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = i, this.contentDOM && this.updateChildren(s, this.posAtStart), this.dirty = li;
  }
  updateOuterDeco(e) {
    if (nu(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, i = this.dom;
    this.dom = ox(this.dom, this.nodeDOM, Ih(this.outerDeco, this.node, n), Ih(e, this.node, n)), this.dom != i && (i.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = true);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function D0(t10, e, n, i, s) {
  ax(i, e, t10);
  let r = new qs(void 0, t10, e, n, i, i, i, s, 0);
  return r.contentDOM && r.updateChildren(s, 0), r;
}
var Cd = class _Cd extends qs {
  constructor(e, n, i, s, r, o, a) {
    super(e, n, i, s, r, null, o, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || true };
  }
  update(e, n, i, s) {
    return this.dirty == Yi || this.dirty != li && !this.inParent() || !e.sameMarkup(this.node) ? false : (this.updateOuterDeco(n), (this.dirty != li || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, s.trackWrites == this.nodeDOM && (s.trackWrites = null)), this.node = e, this.dirty = li, true);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return true;
    return false;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, i) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, i);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, i) {
    let s = this.node.cut(e, n), r = document.createTextNode(s.text);
    return new _Cd(this.parent, s, this.outerDeco, this.innerDeco, r, r, i);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Yi);
  }
  get domAtom() {
    return false;
  }
  isText(e) {
    return this.node.text == e;
  }
};
var sx = class extends Il {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(e) {
    return this.dirty == li && this.dom.nodeName == e;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var K$ = class extends qs {
  constructor(e, n, i, s, r, o, a, l, c, u) {
    super(e, n, i, s, r, o, a, c, u), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, i, s) {
    if (this.dirty == Yi)
      return false;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let r = this.spec.update(e, n, i);
      return r && this.updateInner(e, n, i, s), r;
    } else return !this.contentDOM && !e.isLeaf ? false : super.update(e, n, i, s);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, i, s) {
    this.spec.setSelection ? this.spec.setSelection(e, n, i.root) : super.setSelection(e, n, i, s);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : false;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
};
function rx(t10, e, n) {
  let i = t10.firstChild, s = false;
  for (let r = 0; r < e.length; r++) {
    let o = e[r], a = o.dom;
    if (a.parentNode == t10) {
      for (; a != i; )
        i = $0(i), s = true;
      i = i.nextSibling;
    } else
      s = true, t10.insertBefore(a, i);
    if (o instanceof Gr) {
      let l = i ? i.previousSibling : t10.lastChild;
      rx(o.contentDOM, o.children, n), i = l ? l.nextSibling : t10.firstChild;
    }
  }
  for (; i; )
    i = $0(i), s = true;
  s && n.trackWrites == t10 && (n.trackWrites = null);
}
var $a = function(t10) {
  t10 && (this.nodeName = t10);
};
$a.prototype = /* @__PURE__ */ Object.create(null);
var Tr = [new $a()];
function Ih(t10, e, n) {
  if (t10.length == 0)
    return Tr;
  let i = n ? Tr[0] : new $a(), s = [i];
  for (let r = 0; r < t10.length; r++) {
    let o = t10[r].type.attrs;
    if (o) {
      o.nodeName && s.push(i = new $a(o.nodeName));
      for (let a in o) {
        let l = o[a];
        l != null && (n && s.length == 1 && s.push(i = new $a(e.isInline ? "span" : "div")), a == "class" ? i.class = (i.class ? i.class + " " : "") + l : a == "style" ? i.style = (i.style ? i.style + ";" : "") + l : a != "nodeName" && (i[a] = l));
      }
    }
  }
  return s;
}
function ox(t10, e, n, i) {
  if (n == Tr && i == Tr)
    return e;
  let s = e;
  for (let r = 0; r < i.length; r++) {
    let o = i[r], a = n[r];
    if (r) {
      let l;
      a && a.nodeName == o.nodeName && s != t10 && (l = s.parentNode) && l.nodeName.toLowerCase() == o.nodeName || (l = document.createElement(o.nodeName), l.pmIsDeco = true, l.appendChild(s), a = Tr[0]), s = l;
    }
    Y$(s, a || Tr[0], o);
  }
  return s;
}
function Y$(t10, e, n) {
  for (let i in e)
    i != "class" && i != "style" && i != "nodeName" && !(i in n) && t10.removeAttribute(i);
  for (let i in n)
    i != "class" && i != "style" && i != "nodeName" && n[i] != e[i] && t10.setAttribute(i, n[i]);
  if (e.class != n.class) {
    let i = e.class ? e.class.split(" ").filter(Boolean) : [], s = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let r = 0; r < i.length; r++)
      s.indexOf(i[r]) == -1 && t10.classList.remove(i[r]);
    for (let r = 0; r < s.length; r++)
      i.indexOf(s[r]) == -1 && t10.classList.add(s[r]);
    t10.classList.length == 0 && t10.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let i = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, s;
      for (; s = i.exec(e.style); )
        t10.style.removeProperty(s[1]);
    }
    n.style && (t10.style.cssText += n.style);
  }
}
function ax(t10, e, n) {
  return ox(t10, t10, Tr, Ih(e, n, t10.nodeType != 1));
}
function nu(t10, e) {
  if (t10.length != e.length)
    return false;
  for (let n = 0; n < t10.length; n++)
    if (!t10[n].type.eq(e[n].type))
      return false;
  return true;
}
function $0(t10) {
  let e = t10.nextSibling;
  return t10.parentNode.removeChild(t10), e;
}
var G$ = class {
  constructor(e, n, i) {
    this.lock = n, this.view = i, this.index = 0, this.stack = [], this.changed = false, this.top = e, this.preMatch = J$(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let i = e; i < n; i++)
        this.top.children[i].destroy();
      this.top.children.splice(e, n - e), this.changed = true;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, i) {
    let s = 0, r = this.stack.length >> 1, o = Math.min(r, e.length);
    for (; s < o && (s == r - 1 ? this.top : this.stack[s + 1 << 1]).matchesMark(e[s]) && e[s].type.spec.spanning !== false; )
      s++;
    for (; s < r; )
      this.destroyRest(), this.top.dirty = li, this.index = this.stack.pop(), this.top = this.stack.pop(), r--;
    for (; r < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l];
        if (c.matchesMark(e[r]) && !this.isLocked(c.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = true, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = Gr.create(this.top, e[r], n, i);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = true;
      }
      this.index = 0, r++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, i, s) {
    let r = -1, o;
    if (s >= this.preMatch.index && (o = this.preMatch.matches[s - this.preMatch.index]).parent == this.top && o.matchesNode(e, n, i))
      r = this.top.children.indexOf(o, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a];
        if (c.matchesNode(e, n, i) && !this.preMatch.matched.has(c)) {
          r = a;
          break;
        }
      }
    return r < 0 ? false : (this.destroyBetween(this.index, r), this.index++, true);
  }
  updateNodeAt(e, n, i, s, r) {
    let o = this.top.children[s];
    return o.dirty == Yi && o.dom == o.contentDOM && (o.dirty = Mr), o.update(e, n, i, r) ? (this.destroyBetween(this.index, s), this.index++, true) : false;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let i = e.pmViewDesc;
        if (i) {
          for (let s = this.index; s < this.top.children.length; s++)
            if (this.top.children[s] == i)
              return s;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, i, s, r, o) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof qs) {
        let c = this.preMatch.matched.get(l);
        if (c != null && c != r)
          return false;
        let u = l.dom, d, f = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Yi && nu(n, l.outerDeco));
        if (!f && l.update(e, n, i, s))
          return this.destroyBetween(this.index, a), l.dom != u && (this.changed = true), this.index++, true;
        if (!f && (d = this.recreateWrapper(l, e, n, i, s, o)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = d, d.contentDOM && (d.dirty = Mr, d.updateChildren(s, o + 1), d.dirty = li), this.changed = true, this.index++, true;
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, i, s, r, o) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !nu(i, e.outerDeco) || !s.eq(e.innerDeco))
      return null;
    let a = qs.create(this.top, n, i, s, r, o);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, i, s, r) {
    let o = qs.create(this.top, e, n, i, s, r);
    o.contentDOM && o.updateChildren(s, r + 1), this.top.children.splice(this.index++, 0, o), this.changed = true;
  }
  placeWidget(e, n, i) {
    let s = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (s && s.matchesWidget(e) && (e == s.widget || !s.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let r = new ix(this.top, e, n, i);
      this.top.children.splice(this.index++, 0, r), this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof Gr; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof Cd) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((bn || nn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let i = document.createElement(e);
      e == "IMG" && (i.className = "ProseMirror-separator", i.alt = ""), e == "BR" && (i.className = "ProseMirror-trailingBreak");
      let s = new sx(this.top, [], i, null);
      n != this.top ? n.children.push(s) : n.children.splice(this.index++, 0, s), this.changed = true;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
};
function J$(t10, e) {
  let n = e, i = n.children.length, s = t10.childCount, r = /* @__PURE__ */ new Map(), o = [];
  e: for (; s > 0; ) {
    let a;
    for (; ; )
      if (i) {
        let c = n.children[i - 1];
        if (c instanceof Gr)
          n = c, i = c.children.length;
        else {
          a = c, i--;
          break;
        }
      } else {
        if (n == e)
          break e;
        i = n.parent.children.indexOf(n), n = n.parent;
      }
    let l = a.node;
    if (l) {
      if (l != t10.child(s - 1))
        break;
      --s, r.set(a, s), o.push(a);
    }
  }
  return { index: s, matched: r, matches: o.reverse() };
}
function X$(t10, e) {
  return t10.type.side - e.type.side;
}
function Q$(t10, e, n, i) {
  let s = e.locals(t10), r = 0;
  if (s.length == 0) {
    for (let c = 0; c < t10.childCount; c++) {
      let u = t10.child(c);
      i(u, s, e.forChild(r, u), c), r += u.nodeSize;
    }
    return;
  }
  let o = 0, a = [], l = null;
  for (let c = 0; ; ) {
    let u, d;
    for (; o < s.length && s[o].to == r; ) {
      let m = s[o++];
      m.widget && (u ? (d || (d = [u])).push(m) : u = m);
    }
    if (u)
      if (d) {
        d.sort(X$);
        for (let m = 0; m < d.length; m++)
          n(d[m], c, !!l);
      } else
        n(u, c, !!l);
    let f, h10;
    if (l)
      h10 = -1, f = l, l = null;
    else if (c < t10.childCount)
      h10 = c, f = t10.child(c++);
    else
      break;
    for (let m = 0; m < a.length; m++)
      a[m].to <= r && a.splice(m--, 1);
    for (; o < s.length && s[o].from <= r && s[o].to > r; )
      a.push(s[o++]);
    let p = r + f.nodeSize;
    if (f.isText) {
      let m = p;
      o < s.length && s[o].from < m && (m = s[o].from);
      for (let b = 0; b < a.length; b++)
        a[b].to < m && (m = a[b].to);
      m < p && (l = f.cut(m - r), f = f.cut(0, m - r), p = m, h10 = -1);
    } else
      for (; o < s.length && s[o].to < p; )
        o++;
    let g = f.isInline && !f.isLeaf ? a.filter((m) => !m.inline) : a.slice();
    i(f, g, e.forChild(r, f), h10), r = p;
  }
}
function Z$(t10) {
  if (t10.nodeName == "UL" || t10.nodeName == "OL") {
    let e = t10.style.cssText;
    t10.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t10).listStyle, t10.style.cssText = e;
  }
}
function eR(t10, e, n, i) {
  for (let s = 0, r = 0; s < t10.childCount && r <= i; ) {
    let o = t10.child(s++), a = r;
    if (r += o.nodeSize, !o.isText)
      continue;
    let l = o.text;
    for (; s < t10.childCount; ) {
      let c = t10.child(s++);
      if (r += c.nodeSize, !c.isText)
        break;
      l += c.text;
    }
    if (r >= n) {
      if (r >= i && l.slice(i - e.length - a, i - a) == e)
        return i - e.length;
      let c = a < i ? l.lastIndexOf(e, i - a - 1) : -1;
      if (c >= 0 && c + e.length + a >= n)
        return a + c;
      if (n == i && l.length >= i + e.length - a && l.slice(i - a, i - a + e.length) == e)
        return i;
    }
  }
  return -1;
}
function Ph(t10, e, n, i, s) {
  let r = [];
  for (let o = 0, a = 0; o < t10.length; o++) {
    let l = t10[o], c = a, u = a += l.size;
    c >= n || u <= e ? r.push(l) : (c < e && r.push(l.slice(0, e - c, i)), s && (r.push(s), s = void 0), u > n && r.push(l.slice(n - c, l.size, i)));
  }
  return r;
}
function em(t10, e = null) {
  let n = t10.domSelectionRange(), i = t10.state.doc;
  if (!n.focusNode)
    return null;
  let s = t10.docView.nearestDesc(n.focusNode), r = s && s.size == 0, o = t10.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (o < 0)
    return null;
  let a = i.resolve(o), l, c;
  if (wd(n)) {
    for (l = o; s && !s.node; )
      s = s.parent;
    let d = s.node;
    if (s && d.isAtom && Pe.isSelectable(d) && s.parent && !(d.isInline && E$(n.focusNode, n.focusOffset, s.dom))) {
      let f = s.posBefore;
      c = new Pe(o == f ? a : i.resolve(f));
    }
  } else {
    if (n instanceof t10.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let d = o, f = o;
      for (let h10 = 0; h10 < n.rangeCount; h10++) {
        let p = n.getRangeAt(h10);
        d = Math.min(d, t10.docView.posFromDOM(p.startContainer, p.startOffset, 1)), f = Math.max(f, t10.docView.posFromDOM(p.endContainer, p.endOffset, -1));
      }
      if (d < 0)
        return null;
      [l, o] = f == t10.state.selection.anchor ? [f, d] : [d, f], a = i.resolve(o);
    } else
      l = t10.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let u = i.resolve(l);
  if (!c) {
    let d = e == "pointer" || t10.state.selection.head < a.pos && !r ? 1 : -1;
    c = tm(t10, u, a, d);
  }
  return c;
}
function lx(t10) {
  return t10.editable ? t10.hasFocus() : ux(t10) && document.activeElement && document.activeElement.contains(t10.dom);
}
function ys(t10, e = false) {
  let n = t10.state.selection;
  if (cx(t10, n), !!lx(t10)) {
    if (!e && t10.input.mouseDown && t10.input.mouseDown.allowDefault && nn) {
      let i = t10.domSelectionRange(), s = t10.domObserver.currentSelection;
      if (i.anchorNode && s.anchorNode && Yr(i.anchorNode, i.anchorOffset, s.anchorNode, s.anchorOffset)) {
        t10.input.mouseDown.delayedSelectionSync = true, t10.domObserver.setCurSelection();
        return;
      }
    }
    if (t10.domObserver.disconnectSelection(), t10.cursorWrapper)
      nR(t10);
    else {
      let { anchor: i, head: s } = n, r, o;
      R0 && !(n instanceof Be) && (n.$from.parent.inlineContent || (r = F0(t10, n.from)), !n.empty && !n.$from.parent.inlineContent && (o = F0(t10, n.to))), t10.docView.setSelection(i, s, t10, e), R0 && (r && V0(r), o && V0(o)), n.visible ? t10.dom.classList.remove("ProseMirror-hideselection") : (t10.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && tR(t10));
    }
    t10.domObserver.setCurSelection(), t10.domObserver.connectSelection();
  }
}
var R0 = bn || nn && J2 < 63;
function F0(t10, e) {
  let { node: n, offset: i } = t10.docView.domFromPos(e, 0), s = i < n.childNodes.length ? n.childNodes[i] : null, r = i ? n.childNodes[i - 1] : null;
  if (bn && s && s.contentEditable == "false")
    return hf(s);
  if ((!s || s.contentEditable == "false") && (!r || r.contentEditable == "false")) {
    if (s)
      return hf(s);
    if (r)
      return hf(r);
  }
}
function hf(t10) {
  return t10.contentEditable = "true", bn && t10.draggable && (t10.draggable = false, t10.wasDraggable = true), t10;
}
function V0(t10) {
  t10.contentEditable = "false", t10.wasDraggable && (t10.draggable = true, t10.wasDraggable = null);
}
function tR(t10) {
  let e = t10.dom.ownerDocument;
  e.removeEventListener("selectionchange", t10.input.hideSelectionGuard);
  let n = t10.domSelectionRange(), i = n.anchorNode, s = n.anchorOffset;
  e.addEventListener("selectionchange", t10.input.hideSelectionGuard = () => {
    (n.anchorNode != i || n.anchorOffset != s) && (e.removeEventListener("selectionchange", t10.input.hideSelectionGuard), setTimeout(() => {
      (!lx(t10) || t10.state.selection.visible) && t10.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function nR(t10) {
  let e = t10.domSelection(), n = document.createRange();
  if (!e)
    return;
  let i = t10.cursorWrapper.dom, s = i.nodeName == "IMG";
  s ? n.setStart(i.parentNode, Jt(i) + 1) : n.setStart(i, 0), n.collapse(true), e.removeAllRanges(), e.addRange(n), !s && !t10.state.selection.visible && In && Us <= 11 && (i.disabled = true, i.disabled = false);
}
function cx(t10, e) {
  if (e instanceof Pe) {
    let n = t10.docView.descAt(e.from);
    n != t10.lastSelectedViewDesc && (B0(t10), n && n.selectNode(), t10.lastSelectedViewDesc = n);
  } else
    B0(t10);
}
function B0(t10) {
  t10.lastSelectedViewDesc && (t10.lastSelectedViewDesc.parent && t10.lastSelectedViewDesc.deselectNode(), t10.lastSelectedViewDesc = void 0);
}
function tm(t10, e, n, i) {
  return t10.someProp("createSelectionBetween", (s) => s(t10, e, n)) || Be.between(e, n, i);
}
function z0(t10) {
  return t10.editable && !t10.hasFocus() ? false : ux(t10);
}
function ux(t10) {
  let e = t10.domSelectionRange();
  if (!e.anchorNode)
    return false;
  try {
    return t10.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t10.editable || t10.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return false;
  }
}
function iR(t10) {
  let e = t10.docView.domFromPos(t10.state.selection.anchor, 0), n = t10.domSelectionRange();
  return Yr(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function Dh(t10, e) {
  let { $anchor: n, $head: i } = t10.selection, s = e > 0 ? n.max(i) : n.min(i), r = s.parent.inlineContent ? s.depth ? t10.doc.resolve(e > 0 ? s.after() : s.before()) : null : s;
  return r && je.findFrom(r, e);
}
function Ls(t10, e) {
  return t10.dispatch(t10.state.tr.setSelection(e).scrollIntoView()), true;
}
function j0(t10, e, n) {
  let i = t10.state.selection;
  if (i instanceof Be)
    if (n.indexOf("s") > -1) {
      let { $head: s } = i, r = s.textOffset ? null : e < 0 ? s.nodeBefore : s.nodeAfter;
      if (!r || r.isText || !r.isLeaf)
        return false;
      let o = t10.state.doc.resolve(s.pos + r.nodeSize * (e < 0 ? -1 : 1));
      return Ls(t10, new Be(i.$anchor, o));
    } else if (i.empty) {
      if (t10.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let s = Dh(t10.state, e);
        return s && s instanceof Pe ? Ls(t10, s) : false;
      } else if (!(ii && n.indexOf("m") > -1)) {
        let s = i.$head, r = s.textOffset ? null : e < 0 ? s.nodeBefore : s.nodeAfter, o;
        if (!r || r.isText)
          return false;
        let a = e < 0 ? s.pos - r.nodeSize : s.pos;
        return r.isAtom || (o = t10.docView.descAt(a)) && !o.contentDOM ? Pe.isSelectable(r) ? Ls(t10, new Pe(e < 0 ? t10.state.doc.resolve(s.pos - r.nodeSize) : s)) : Ll ? Ls(t10, new Be(t10.state.doc.resolve(e < 0 ? a : a + r.nodeSize))) : false : false;
      }
    } else return false;
  else {
    if (i instanceof Pe && i.node.isInline)
      return Ls(t10, new Be(e > 0 ? i.$to : i.$from));
    {
      let s = Dh(t10.state, e);
      return s ? Ls(t10, s) : false;
    }
  }
}
function iu(t10) {
  return t10.nodeType == 3 ? t10.nodeValue.length : t10.childNodes.length;
}
function Ra(t10, e) {
  let n = t10.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t10.nextSibling || t10.nodeName != "BR");
}
function ao(t10, e) {
  return e < 0 ? sR(t10) : rR(t10);
}
function sR(t10) {
  let e = t10.domSelectionRange(), n = e.focusNode, i = e.focusOffset;
  if (!n)
    return;
  let s, r, o = false;
  for (vi && n.nodeType == 1 && i < iu(n) && Ra(n.childNodes[i], -1) && (o = true); ; )
    if (i > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[i - 1];
        if (Ra(a, -1))
          s = n, r = --i;
        else if (a.nodeType == 3)
          n = a, i = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (dx(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && Ra(a, -1); )
          s = n.parentNode, r = Jt(a), a = a.previousSibling;
        if (a)
          n = a, i = iu(n);
        else {
          if (n = n.parentNode, n == t10.dom)
            break;
          i = 0;
        }
      }
    }
  o ? $h(t10, n, i) : s && $h(t10, s, r);
}
function rR(t10) {
  let e = t10.domSelectionRange(), n = e.focusNode, i = e.focusOffset;
  if (!n)
    return;
  let s = iu(n), r, o;
  for (; ; )
    if (i < s) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[i];
      if (Ra(a, 1))
        r = n, o = ++i;
      else
        break;
    } else {
      if (dx(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && Ra(a, 1); )
          r = a.parentNode, o = Jt(a) + 1, a = a.nextSibling;
        if (a)
          n = a, i = 0, s = iu(n);
        else {
          if (n = n.parentNode, n == t10.dom)
            break;
          i = s = 0;
        }
      }
    }
  r && $h(t10, r, o);
}
function dx(t10) {
  let e = t10.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function oR(t10, e) {
  for (; t10 && e == t10.childNodes.length && !Nl(t10); )
    e = Jt(t10) + 1, t10 = t10.parentNode;
  for (; t10 && e < t10.childNodes.length; ) {
    let n = t10.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t10 = n, e = 0;
  }
}
function aR(t10, e) {
  for (; t10 && !e && !Nl(t10); )
    e = Jt(t10), t10 = t10.parentNode;
  for (; t10 && e; ) {
    let n = t10.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t10 = n, e = t10.childNodes.length;
  }
}
function $h(t10, e, n) {
  if (e.nodeType != 3) {
    let r, o;
    (o = oR(e, n)) ? (e = o, n = 0) : (r = aR(e, n)) && (e = r, n = r.nodeValue.length);
  }
  let i = t10.domSelection();
  if (!i)
    return;
  if (wd(i)) {
    let r = document.createRange();
    r.setEnd(e, n), r.setStart(e, n), i.removeAllRanges(), i.addRange(r);
  } else i.extend && i.extend(e, n);
  t10.domObserver.setCurSelection();
  let { state: s } = t10;
  setTimeout(() => {
    t10.state == s && ys(t10);
  }, 50);
}
function H0(t10, e) {
  let n = t10.state.doc.resolve(e);
  if (!(nn || A$) && n.parent.inlineContent) {
    let s = t10.coordsAtPos(e);
    if (e > n.start()) {
      let r = t10.coordsAtPos(e - 1), o = (r.top + r.bottom) / 2;
      if (o > s.top && o < s.bottom && Math.abs(r.left - s.left) > 1)
        return r.left < s.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let r = t10.coordsAtPos(e + 1), o = (r.top + r.bottom) / 2;
      if (o > s.top && o < s.bottom && Math.abs(r.left - s.left) > 1)
        return r.left > s.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t10.dom).direction == "rtl" ? "rtl" : "ltr";
}
function W0(t10, e, n) {
  let i = t10.state.selection;
  if (i instanceof Be && !i.empty || n.indexOf("s") > -1 || ii && n.indexOf("m") > -1)
    return false;
  let { $from: s, $to: r } = i;
  if (!s.parent.inlineContent || t10.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Dh(t10.state, e);
    if (o && o instanceof Pe)
      return Ls(t10, o);
  }
  if (!s.parent.inlineContent) {
    let o = e < 0 ? s : r, a = i instanceof Yn ? je.near(o, e) : je.findFrom(o, e);
    return a ? Ls(t10, a) : false;
  }
  return false;
}
function U0(t10, e) {
  if (!(t10.state.selection instanceof Be))
    return true;
  let { $head: n, $anchor: i, empty: s } = t10.state.selection;
  if (!n.sameParent(i))
    return true;
  if (!s)
    return false;
  if (t10.endOfTextblock(e > 0 ? "forward" : "backward"))
    return true;
  let r = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (r && !r.isText) {
    let o = t10.state.tr;
    return e < 0 ? o.delete(n.pos - r.nodeSize, n.pos) : o.delete(n.pos, n.pos + r.nodeSize), t10.dispatch(o), true;
  }
  return false;
}
function q0(t10, e, n) {
  t10.domObserver.stop(), e.contentEditable = n, t10.domObserver.start();
}
function lR(t10) {
  if (!bn || t10.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode: e, focusOffset: n } = t10.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let i = e.firstChild;
    q0(t10, i, "true"), setTimeout(() => q0(t10, i, "false"), 20);
  }
  return false;
}
function cR(t10) {
  let e = "";
  return t10.ctrlKey && (e += "c"), t10.metaKey && (e += "m"), t10.altKey && (e += "a"), t10.shiftKey && (e += "s"), e;
}
function uR(t10, e) {
  let n = e.keyCode, i = cR(e);
  if (n == 8 || ii && n == 72 && i == "c")
    return U0(t10, -1) || ao(t10, -1);
  if (n == 46 && !e.shiftKey || ii && n == 68 && i == "c")
    return U0(t10, 1) || ao(t10, 1);
  if (n == 13 || n == 27)
    return true;
  if (n == 37 || ii && n == 66 && i == "c") {
    let s = n == 37 ? H0(t10, t10.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return j0(t10, s, i) || ao(t10, s);
  } else if (n == 39 || ii && n == 70 && i == "c") {
    let s = n == 39 ? H0(t10, t10.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return j0(t10, s, i) || ao(t10, s);
  } else {
    if (n == 38 || ii && n == 80 && i == "c")
      return W0(t10, -1, i) || ao(t10, -1);
    if (n == 40 || ii && n == 78 && i == "c")
      return lR(t10) || W0(t10, 1, i) || ao(t10, 1);
    if (i == (ii ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return true;
  }
  return false;
}
function nm(t10, e) {
  t10.someProp("transformCopied", (h10) => {
    e = h10(e, t10);
  });
  let n = [], { content: i, openStart: s, openEnd: r } = e;
  for (; s > 1 && r > 1 && i.childCount == 1 && i.firstChild.childCount == 1; ) {
    s--, r--;
    let h10 = i.firstChild;
    n.push(h10.type.name, h10.attrs != h10.type.defaultAttrs ? h10.attrs : null), i = h10.content;
  }
  let o = t10.someProp("clipboardSerializer") || so.fromSchema(t10.state.schema), a = bx(), l = a.createElement("div");
  l.appendChild(o.serializeFragment(i, { document: a }));
  let c = l.firstChild, u, d = 0;
  for (; c && c.nodeType == 1 && (u = gx[c.nodeName.toLowerCase()]); ) {
    for (let h10 = u.length - 1; h10 >= 0; h10--) {
      let p = a.createElement(u[h10]);
      for (; l.firstChild; )
        p.appendChild(l.firstChild);
      l.appendChild(p), d++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${s} ${r}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
  let f = t10.someProp("clipboardTextSerializer", (h10) => h10(e, t10)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function fx(t10, e, n, i, s) {
  let r = s.parent.type.spec.code, o, a;
  if (!n && !e)
    return null;
  let l = e && (i || r || !n);
  if (l) {
    if (t10.someProp("transformPastedText", (f) => {
      e = f(e, r || i, t10);
    }), r)
      return e ? new ke(ce.from(t10.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : ke.empty;
    let d = t10.someProp("clipboardTextParser", (f) => f(e, s, i, t10));
    if (d)
      a = d;
    else {
      let f = s.marks(), { schema: h10 } = t10.state, p = so.fromSchema(h10);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((g) => {
        let m = o.appendChild(document.createElement("p"));
        g && m.appendChild(p.serializeNode(h10.text(g, f)));
      });
    }
  } else
    t10.someProp("transformPastedHTML", (d) => {
      n = d(n, t10);
    }), o = pR(n), Ll && mR(o);
  let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let d = +u[3]; d > 0; d--) {
      let f = o.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      o = f;
    }
  if (a || (a = (t10.someProp("clipboardParser") || t10.someProp("domParser") || Ws.fromSchema(t10.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(l || u),
    context: s,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !dR.test(f.parentNode.nodeName) ? { ignore: true } : null;
    }
  })), u)
    a = gR(K0(a, +u[1], +u[2]), u[4]);
  else if (a = ke.maxOpen(fR(a.content, s), true), a.openStart || a.openEnd) {
    let d = 0, f = 0;
    for (let h10 = a.content.firstChild; d < a.openStart && !h10.type.spec.isolating; d++, h10 = h10.firstChild)
      ;
    for (let h10 = a.content.lastChild; f < a.openEnd && !h10.type.spec.isolating; f++, h10 = h10.lastChild)
      ;
    a = K0(a, d, f);
  }
  return t10.someProp("transformPasted", (d) => {
    a = d(a, t10);
  }), a;
}
var dR = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function fR(t10, e) {
  if (t10.childCount < 2)
    return t10;
  for (let n = e.depth; n >= 0; n--) {
    let s = e.node(n).contentMatchAt(e.index(n)), r, o = [];
    if (t10.forEach((a) => {
      if (!o)
        return;
      let l = s.findWrapping(a.type), c;
      if (!l)
        return o = null;
      if (c = o.length && r.length && px(l, r, a, o[o.length - 1], 0))
        o[o.length - 1] = c;
      else {
        o.length && (o[o.length - 1] = mx(o[o.length - 1], r.length));
        let u = hx(a, l);
        o.push(u), s = s.matchType(u.type), r = l;
      }
    }), o)
      return ce.from(o);
  }
  return t10;
}
function hx(t10, e, n = 0) {
  for (let i = e.length - 1; i >= n; i--)
    t10 = e[i].create(null, ce.from(t10));
  return t10;
}
function px(t10, e, n, i, s) {
  if (s < t10.length && s < e.length && t10[s] == e[s]) {
    let r = px(t10, e, n, i.lastChild, s + 1);
    if (r)
      return i.copy(i.content.replaceChild(i.childCount - 1, r));
    if (i.contentMatchAt(i.childCount).matchType(s == t10.length - 1 ? n.type : t10[s + 1]))
      return i.copy(i.content.append(ce.from(hx(n, t10, s + 1))));
  }
}
function mx(t10, e) {
  if (e == 0)
    return t10;
  let n = t10.content.replaceChild(t10.childCount - 1, mx(t10.lastChild, e - 1)), i = t10.contentMatchAt(t10.childCount).fillBefore(ce.empty, true);
  return t10.copy(n.append(i));
}
function Rh(t10, e, n, i, s, r) {
  let o = e < 0 ? t10.firstChild : t10.lastChild, a = o.content;
  return t10.childCount > 1 && (r = 0), s < i - 1 && (a = Rh(a, e, n, i, s + 1, r)), s >= n && (a = e < 0 ? o.contentMatchAt(0).fillBefore(a, r <= s).append(a) : a.append(o.contentMatchAt(o.childCount).fillBefore(ce.empty, true))), t10.replaceChild(e < 0 ? 0 : t10.childCount - 1, o.copy(a));
}
function K0(t10, e, n) {
  return e < t10.openStart && (t10 = new ke(Rh(t10.content, -1, e, t10.openStart, 0, t10.openEnd), e, t10.openEnd)), n < t10.openEnd && (t10 = new ke(Rh(t10.content, 1, n, t10.openEnd, 0, 0), t10.openStart, n)), t10;
}
var gx = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var Y0 = null;
function bx() {
  return Y0 || (Y0 = document.implementation.createHTMLDocument("title"));
}
var pf = null;
function hR(t10) {
  let e = window.trustedTypes;
  return e ? (pf || (pf = e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), pf.createHTML(t10)) : t10;
}
function pR(t10) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t10);
  e && (t10 = t10.slice(e[0].length));
  let n = bx().createElement("div"), i = /<([a-z][^>\s]+)/i.exec(t10), s;
  if ((s = i && gx[i[1].toLowerCase()]) && (t10 = s.map((r) => "<" + r + ">").join("") + t10 + s.map((r) => "</" + r + ">").reverse().join("")), n.innerHTML = hR(t10), s)
    for (let r = 0; r < s.length; r++)
      n = n.querySelector(s[r]) || n;
  return n;
}
function mR(t10) {
  let e = t10.querySelectorAll(nn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    i.childNodes.length == 1 && i.textContent == " " && i.parentNode && i.parentNode.replaceChild(t10.ownerDocument.createTextNode(" "), i);
  }
}
function gR(t10, e) {
  if (!t10.size)
    return t10;
  let n = t10.content.firstChild.type.schema, i;
  try {
    i = JSON.parse(e);
  } catch {
    return t10;
  }
  let { content: s, openStart: r, openEnd: o } = t10;
  for (let a = i.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[i[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    s = ce.from(l.create(i[a + 1], s)), r++, o++;
  }
  return new ke(s, r, o);
}
var yn = {};
var vn = {};
var bR = { touchstart: true, touchmove: true };
var yR = class {
  constructor() {
    this.shiftKey = false, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = false, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
};
function vR(t10) {
  for (let e in yn) {
    let n = yn[e];
    t10.dom.addEventListener(e, t10.input.eventHandlers[e] = (i) => {
      kR(t10, i) && !im(t10, i) && (t10.editable || !(i.type in vn)) && n(t10, i);
    }, bR[e] ? { passive: true } : void 0);
  }
  bn && t10.dom.addEventListener("input", () => null), Fh(t10);
}
function Vs(t10, e) {
  t10.input.lastSelectionOrigin = e, t10.input.lastSelectionTime = Date.now();
}
function xR(t10) {
  t10.domObserver.stop();
  for (let e in t10.input.eventHandlers)
    t10.dom.removeEventListener(e, t10.input.eventHandlers[e]);
  clearTimeout(t10.input.composingTimeout), clearTimeout(t10.input.lastIOSEnterFallbackTimeout);
}
function Fh(t10) {
  t10.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t10.input.eventHandlers[n] || t10.dom.addEventListener(n, t10.input.eventHandlers[n] = (i) => im(t10, i));
  });
}
function im(t10, e) {
  return t10.someProp("handleDOMEvents", (n) => {
    let i = n[e.type];
    return i ? i(t10, e) || e.defaultPrevented : false;
  });
}
function kR(t10, e) {
  if (!e.bubbles)
    return true;
  if (e.defaultPrevented)
    return false;
  for (let n = e.target; n != t10.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return false;
  return true;
}
function SR(t10, e) {
  !im(t10, e) && yn[e.type] && (t10.editable || !(e.type in vn)) && yn[e.type](t10, e);
}
vn.keydown = (t10, e) => {
  let n = e;
  if (t10.input.shiftKey = n.keyCode == 16 || n.shiftKey, !vx(t10, n) && (t10.input.lastKeyCode = n.keyCode, t10.input.lastKeyCodeTime = Date.now(), !(fs && nn && n.keyCode == 13)))
    if (n.keyCode != 229 && t10.domObserver.forceFlush(), Ro && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let i = Date.now();
      t10.input.lastIOSEnter = i, t10.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t10.input.lastIOSEnter == i && (t10.someProp("handleKeyDown", (s) => s(t10, Cr(13, "Enter"))), t10.input.lastIOSEnter = 0);
      }, 200);
    } else t10.someProp("handleKeyDown", (i) => i(t10, n)) || uR(t10, n) ? n.preventDefault() : Vs(t10, "key");
};
vn.keyup = (t10, e) => {
  e.keyCode == 16 && (t10.input.shiftKey = false);
};
vn.keypress = (t10, e) => {
  let n = e;
  if (vx(t10, n) || !n.charCode || n.ctrlKey && !n.altKey || ii && n.metaKey)
    return;
  if (t10.someProp("handleKeyPress", (s) => s(t10, n))) {
    n.preventDefault();
    return;
  }
  let i = t10.state.selection;
  if (!(i instanceof Be) || !i.$from.sameParent(i.$to)) {
    let s = String.fromCharCode(n.charCode);
    !/[\r\n]/.test(s) && !t10.someProp("handleTextInput", (r) => r(t10, i.$from.pos, i.$to.pos, s)) && t10.dispatch(t10.state.tr.insertText(s).scrollIntoView()), n.preventDefault();
  }
};
function Od(t10) {
  return { left: t10.clientX, top: t10.clientY };
}
function wR(t10, e) {
  let n = e.x - t10.clientX, i = e.y - t10.clientY;
  return n * n + i * i < 100;
}
function sm(t10, e, n, i, s) {
  if (i == -1)
    return false;
  let r = t10.state.doc.resolve(i);
  for (let o = r.depth + 1; o > 0; o--)
    if (t10.someProp(e, (a) => o > r.depth ? a(t10, n, r.nodeAfter, r.before(o), s, true) : a(t10, n, r.node(o), r.before(o), s, false)))
      return true;
  return false;
}
function Eo(t10, e, n) {
  if (t10.focused || t10.focus(), t10.state.selection.eq(e))
    return;
  let i = t10.state.tr.setSelection(e);
  i.setMeta("pointer", true), t10.dispatch(i);
}
function CR(t10, e) {
  if (e == -1)
    return false;
  let n = t10.state.doc.resolve(e), i = n.nodeAfter;
  return i && i.isAtom && Pe.isSelectable(i) ? (Eo(t10, new Pe(n)), true) : false;
}
function OR(t10, e) {
  if (e == -1)
    return false;
  let n = t10.state.selection, i, s;
  n instanceof Pe && (i = n.node);
  let r = t10.state.doc.resolve(e);
  for (let o = r.depth + 1; o > 0; o--) {
    let a = o > r.depth ? r.nodeAfter : r.node(o);
    if (Pe.isSelectable(a)) {
      i && n.$from.depth > 0 && o >= n.$from.depth && r.before(n.$from.depth + 1) == n.$from.pos ? s = r.before(n.$from.depth) : s = r.before(o);
      break;
    }
  }
  return s != null ? (Eo(t10, Pe.create(t10.state.doc, s)), true) : false;
}
function ER(t10, e, n, i, s) {
  return sm(t10, "handleClickOn", e, n, i) || t10.someProp("handleClick", (r) => r(t10, e, i)) || (s ? OR(t10, n) : CR(t10, n));
}
function MR(t10, e, n, i) {
  return sm(t10, "handleDoubleClickOn", e, n, i) || t10.someProp("handleDoubleClick", (s) => s(t10, e, i));
}
function TR(t10, e, n, i) {
  return sm(t10, "handleTripleClickOn", e, n, i) || t10.someProp("handleTripleClick", (s) => s(t10, e, i)) || AR(t10, n, i);
}
function AR(t10, e, n) {
  if (n.button != 0)
    return false;
  let i = t10.state.doc;
  if (e == -1)
    return i.inlineContent ? (Eo(t10, Be.create(i, 0, i.content.size)), true) : false;
  let s = i.resolve(e);
  for (let r = s.depth + 1; r > 0; r--) {
    let o = r > s.depth ? s.nodeAfter : s.node(r), a = s.before(r);
    if (o.inlineContent)
      Eo(t10, Be.create(i, a + 1, a + 1 + o.content.size));
    else if (Pe.isSelectable(o))
      Eo(t10, Pe.create(i, a));
    else
      continue;
    return true;
  }
}
function rm(t10) {
  return su(t10);
}
var yx = ii ? "metaKey" : "ctrlKey";
yn.mousedown = (t10, e) => {
  let n = e;
  t10.input.shiftKey = n.shiftKey;
  let i = rm(t10), s = Date.now(), r = "singleClick";
  s - t10.input.lastClick.time < 500 && wR(n, t10.input.lastClick) && !n[yx] && (t10.input.lastClick.type == "singleClick" ? r = "doubleClick" : t10.input.lastClick.type == "doubleClick" && (r = "tripleClick")), t10.input.lastClick = { time: s, x: n.clientX, y: n.clientY, type: r };
  let o = t10.posAtCoords(Od(n));
  o && (r == "singleClick" ? (t10.input.mouseDown && t10.input.mouseDown.done(), t10.input.mouseDown = new _R(t10, o, n, !!i)) : (r == "doubleClick" ? MR : TR)(t10, o.pos, o.inside, n) ? n.preventDefault() : Vs(t10, "pointer"));
};
var _R = class {
  constructor(e, n, i, s) {
    this.view = e, this.pos = n, this.event = i, this.flushed = s, this.delayedSelectionSync = false, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!i[yx], this.allowDefault = i.shiftKey;
    let r, o;
    if (n.inside > -1)
      r = e.state.doc.nodeAt(n.inside), o = n.inside;
    else {
      let u = e.state.doc.resolve(n.pos);
      r = u.parent, o = u.depth ? u.before() : 0;
    }
    const a = s ? null : i.target, l = a ? e.docView.nearestDesc(a, true) : null;
    this.target = l && l.dom.nodeType == 1 ? l.dom : null;
    let { selection: c } = e.state;
    (i.button == 0 && r.type.spec.draggable && r.type.spec.selectable !== false || c instanceof Pe && c.from <= o && c.to > o) && (this.mightDrag = {
      node: r,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && vi && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = true), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Vs(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => ys(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(Od(e))), this.updateAllowDefault(e), this.allowDefault || !n ? Vs(this.view, "pointer") : ER(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    bn && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    nn && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Eo(this.view, je.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : Vs(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Vs(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = true);
  }
};
yn.touchstart = (t10) => {
  t10.input.lastTouch = Date.now(), rm(t10), Vs(t10, "pointer");
};
yn.touchmove = (t10) => {
  t10.input.lastTouch = Date.now(), Vs(t10, "pointer");
};
yn.contextmenu = (t10) => rm(t10);
function vx(t10, e) {
  return t10.composing ? true : bn && Math.abs(e.timeStamp - t10.input.compositionEndedAt) < 500 ? (t10.input.compositionEndedAt = -2e8, true) : false;
}
var NR = fs ? 5e3 : -1;
vn.compositionstart = vn.compositionupdate = (t10) => {
  if (!t10.composing) {
    t10.domObserver.flush();
    let { state: e } = t10, n = e.selection.$to;
    if (e.selection instanceof Be && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((i) => i.type.spec.inclusive === false)))
      t10.markCursor = t10.state.storedMarks || n.marks(), su(t10, true), t10.markCursor = null;
    else if (su(t10, !e.selection.empty), vi && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let i = t10.domSelectionRange();
      for (let s = i.focusNode, r = i.focusOffset; s && s.nodeType == 1 && r != 0; ) {
        let o = r < 0 ? s.lastChild : s.childNodes[r - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          let a = t10.domSelection();
          a && a.collapse(o, o.nodeValue.length);
          break;
        } else
          s = o, r = -1;
      }
    }
    t10.input.composing = true;
  }
  xx(t10, NR);
};
vn.compositionend = (t10, e) => {
  t10.composing && (t10.input.composing = false, t10.input.compositionEndedAt = e.timeStamp, t10.input.compositionPendingChanges = t10.domObserver.pendingRecords().length ? t10.input.compositionID : 0, t10.input.compositionNode = null, t10.input.compositionPendingChanges && Promise.resolve().then(() => t10.domObserver.flush()), t10.input.compositionID++, xx(t10, 20));
};
function xx(t10, e) {
  clearTimeout(t10.input.composingTimeout), e > -1 && (t10.input.composingTimeout = setTimeout(() => su(t10), e));
}
function kx(t10) {
  for (t10.composing && (t10.input.composing = false, t10.input.compositionEndedAt = IR()); t10.input.compositionNodes.length > 0; )
    t10.input.compositionNodes.pop().markParentsDirty();
}
function LR(t10) {
  let e = t10.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = C$(e.focusNode, e.focusOffset), i = O$(e.focusNode, e.focusOffset);
  if (n && i && n != i) {
    let s = i.pmViewDesc, r = t10.domObserver.lastChangedTextNode;
    if (n == r || i == r)
      return r;
    if (!s || !s.isText(i.nodeValue))
      return i;
    if (t10.input.compositionNode == i) {
      let o = n.pmViewDesc;
      if (!(!o || !o.isText(n.nodeValue)))
        return i;
    }
  }
  return n || i;
}
function IR() {
  let t10 = document.createEvent("Event");
  return t10.initEvent("event", true, true), t10.timeStamp;
}
function su(t10, e = false) {
  if (!(fs && t10.domObserver.flushingSoon >= 0)) {
    if (t10.domObserver.forceFlush(), kx(t10), e || t10.docView && t10.docView.dirty) {
      let n = em(t10);
      return n && !n.eq(t10.state.selection) ? t10.dispatch(t10.state.tr.setSelection(n)) : (t10.markCursor || e) && !t10.state.selection.empty ? t10.dispatch(t10.state.tr.deleteSelection()) : t10.updateState(t10.state), true;
    }
    return false;
  }
}
function PR(t10, e) {
  if (!t10.dom.parentNode)
    return;
  let n = t10.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let i = getSelection(), s = document.createRange();
  s.selectNodeContents(e), t10.dom.blur(), i.removeAllRanges(), i.addRange(s), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t10.focus();
  }, 50);
}
var ol = In && Us < 15 || Ro && _$ < 604;
yn.copy = vn.cut = (t10, e) => {
  let n = e, i = t10.state.selection, s = n.type == "cut";
  if (i.empty)
    return;
  let r = ol ? null : n.clipboardData, o = i.content(), { dom: a, text: l } = nm(t10, o);
  r ? (n.preventDefault(), r.clearData(), r.setData("text/html", a.innerHTML), r.setData("text/plain", l)) : PR(t10, a), s && t10.dispatch(t10.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function DR(t10) {
  return t10.openStart == 0 && t10.openEnd == 0 && t10.content.childCount == 1 ? t10.content.firstChild : null;
}
function $R(t10, e) {
  if (!t10.dom.parentNode)
    return;
  let n = t10.input.shiftKey || t10.state.selection.$from.parent.type.spec.code, i = t10.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (i.contentEditable = "true"), i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.focus();
  let s = t10.input.shiftKey && t10.input.lastKeyCode != 45;
  setTimeout(() => {
    t10.focus(), i.parentNode && i.parentNode.removeChild(i), n ? al(t10, i.value, null, s, e) : al(t10, i.textContent, i.innerHTML, s, e);
  }, 50);
}
function al(t10, e, n, i, s) {
  let r = fx(t10, e, n, i, t10.state.selection.$from);
  if (t10.someProp("handlePaste", (l) => l(t10, s, r || ke.empty)))
    return true;
  if (!r)
    return false;
  let o = DR(r), a = o ? t10.state.tr.replaceSelectionWith(o, i) : t10.state.tr.replaceSelection(r);
  return t10.dispatch(a.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste")), true;
}
function Sx(t10) {
  let e = t10.getData("text/plain") || t10.getData("Text");
  if (e)
    return e;
  let n = t10.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
vn.paste = (t10, e) => {
  let n = e;
  if (t10.composing && !fs)
    return;
  let i = ol ? null : n.clipboardData, s = t10.input.shiftKey && t10.input.lastKeyCode != 45;
  i && al(t10, Sx(i), i.getData("text/html"), s, n) ? n.preventDefault() : $R(t10, n);
};
var wx = class {
  constructor(e, n, i) {
    this.slice = e, this.move = n, this.node = i;
  }
};
var Cx = ii ? "altKey" : "ctrlKey";
yn.dragstart = (t10, e) => {
  let n = e, i = t10.input.mouseDown;
  if (i && i.done(), !n.dataTransfer)
    return;
  let s = t10.state.selection, r = s.empty ? null : t10.posAtCoords(Od(n)), o;
  if (!(r && r.pos >= s.from && r.pos <= (s instanceof Pe ? s.to - 1 : s.to))) {
    if (i && i.mightDrag)
      o = Pe.create(t10.state.doc, i.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let d = t10.docView.nearestDesc(n.target, true);
      d && d.node.type.spec.draggable && d != t10.docView && (o = Pe.create(t10.state.doc, d.posBefore));
    }
  }
  let a = (o || t10.state.selection).content(), { dom: l, text: c, slice: u } = nm(t10, a);
  (!n.dataTransfer.files.length || !nn || J2 > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(ol ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", ol || n.dataTransfer.setData("text/plain", c), t10.dragging = new wx(u, !n[Cx], o);
};
yn.dragend = (t10) => {
  let e = t10.dragging;
  window.setTimeout(() => {
    t10.dragging == e && (t10.dragging = null);
  }, 50);
};
vn.dragover = vn.dragenter = (t10, e) => e.preventDefault();
vn.drop = (t10, e) => {
  let n = e, i = t10.dragging;
  if (t10.dragging = null, !n.dataTransfer)
    return;
  let s = t10.posAtCoords(Od(n));
  if (!s)
    return;
  let r = t10.state.doc.resolve(s.pos), o = i && i.slice;
  o ? t10.someProp("transformPasted", (p) => {
    o = p(o, t10);
  }) : o = fx(t10, Sx(n.dataTransfer), ol ? null : n.dataTransfer.getData("text/html"), false, r);
  let a = !!(i && !n[Cx]);
  if (t10.someProp("handleDrop", (p) => p(t10, n, o || ke.empty, a))) {
    n.preventDefault();
    return;
  }
  if (!o)
    return;
  n.preventDefault();
  let l = o ? z2(t10.state.doc, r.pos, o) : r.pos;
  l == null && (l = r.pos);
  let c = t10.state.tr;
  if (a) {
    let { node: p } = i;
    p ? p.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(l), d = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = c.doc;
  if (d ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(f))
    return;
  let h10 = c.doc.resolve(u);
  if (d && Pe.isSelectable(o.content.firstChild) && h10.nodeAfter && h10.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new Pe(h10));
  else {
    let p = c.mapping.map(l);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((g, m, b, x) => p = x), c.setSelection(tm(t10, h10, c.doc.resolve(p)));
  }
  t10.focus(), t10.dispatch(c.setMeta("uiEvent", "drop"));
};
yn.focus = (t10) => {
  t10.input.lastFocus = Date.now(), t10.focused || (t10.domObserver.stop(), t10.dom.classList.add("ProseMirror-focused"), t10.domObserver.start(), t10.focused = true, setTimeout(() => {
    t10.docView && t10.hasFocus() && !t10.domObserver.currentSelection.eq(t10.domSelectionRange()) && ys(t10);
  }, 20));
};
yn.blur = (t10, e) => {
  let n = e;
  t10.focused && (t10.domObserver.stop(), t10.dom.classList.remove("ProseMirror-focused"), t10.domObserver.start(), n.relatedTarget && t10.dom.contains(n.relatedTarget) && t10.domObserver.currentSelection.clear(), t10.focused = false);
};
yn.beforeinput = (t10, e) => {
  if (nn && fs && e.inputType == "deleteContentBackward") {
    t10.domObserver.flushSoon();
    let { domChangeCount: i } = t10.input;
    setTimeout(() => {
      if (t10.input.domChangeCount != i || (t10.dom.blur(), t10.focus(), t10.someProp("handleKeyDown", (r) => r(t10, Cr(8, "Backspace")))))
        return;
      let { $cursor: s } = t10.state.selection;
      s && s.pos > 0 && t10.dispatch(t10.state.tr.delete(s.pos - 1, s.pos).scrollIntoView());
    }, 50);
  }
};
for (let t10 in vn)
  yn[t10] = vn[t10];
function ll(t10, e) {
  if (t10 == e)
    return true;
  for (let n in t10)
    if (t10[n] !== e[n])
      return false;
  for (let n in e)
    if (!(n in t10))
      return false;
  return true;
}
var ru = class _ru {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || Rr, this.side = this.spec.side || 0;
  }
  map(e, n, i, s) {
    let { pos: r, deleted: o } = e.mapResult(n.from + s, this.side < 0 ? -1 : 1);
    return o ? null : new Un(r - i, r - i, this);
  }
  valid() {
    return true;
  }
  eq(e) {
    return this == e || e instanceof _ru && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && ll(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
};
var Ks = class _Ks {
  constructor(e, n) {
    this.attrs = e, this.spec = n || Rr;
  }
  map(e, n, i, s) {
    let r = e.map(n.from + s, this.spec.inclusiveStart ? -1 : 1) - i, o = e.map(n.to + s, this.spec.inclusiveEnd ? 1 : -1) - i;
    return r >= o ? null : new Un(r, o, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof _Ks && ll(this.attrs, e.attrs) && ll(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof _Ks;
  }
  destroy() {
  }
};
var om = class _om {
  constructor(e, n) {
    this.attrs = e, this.spec = n || Rr;
  }
  map(e, n, i, s) {
    let r = e.mapResult(n.from + s, 1);
    if (r.deleted)
      return null;
    let o = e.mapResult(n.to + s, -1);
    return o.deleted || o.pos <= r.pos ? null : new Un(r.pos - i, o.pos - i, this);
  }
  valid(e, n) {
    let { index: i, offset: s } = e.content.findIndex(n.from), r;
    return s == n.from && !(r = e.child(i)).isText && s + r.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof _om && ll(this.attrs, e.attrs) && ll(this.spec, e.spec);
  }
  destroy() {
  }
};
var Un = class _Un {
  /**
  @internal
  */
  constructor(e, n, i) {
    this.from = e, this.to = n, this.type = i;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new _Un(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, i) {
    return this.type.map(e, this, n, i);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, i) {
    return new _Un(e, e, new ru(n, i));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, i, s) {
    return new _Un(e, n, new Ks(i, s));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, i, s) {
    return new _Un(e, n, new om(i, s));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Ks;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof ru;
  }
};
var ho = [];
var Rr = {};
var $t = class _$t {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : ho, this.children = n.length ? n : ho;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? ou(n, e, 0, Rr) : tn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, i) {
    let s = [];
    return this.findInner(e ?? 0, n ?? 1e9, s, 0, i), s;
  }
  findInner(e, n, i, s, r) {
    for (let o = 0; o < this.local.length; o++) {
      let a = this.local[o];
      a.from <= n && a.to >= e && (!r || r(a.spec)) && i.push(a.copy(a.from + s, a.to + s));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < n && this.children[o + 1] > e) {
        let a = this.children[o] + 1;
        this.children[o + 2].findInner(e - a, n - a, i, s + a, r);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, i) {
    return this == tn || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, i || Rr);
  }
  /**
  @internal
  */
  mapInner(e, n, i, s, r) {
    let o;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, i, s);
      l && l.type.valid(n, l) ? (o || (o = [])).push(l) : r.onRemove && r.onRemove(this.local[a].spec);
    }
    return this.children.length ? RR(this.children, o || [], e, n, i, s, r) : o ? new _$t(o.sort(Fr), ho) : tn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == tn ? _$t.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, i) {
    let s, r = 0;
    e.forEach((a, l) => {
      let c = l + i, u;
      if (u = Ex(n, a, c)) {
        for (s || (s = this.children.slice()); r < s.length && s[r] < l; )
          r += 3;
        s[r] == l ? s[r + 2] = s[r + 2].addInner(a, u, c + 1) : s.splice(r, 0, l, l + a.nodeSize, ou(u, a, c + 1, Rr)), r += 3;
      }
    });
    let o = Ox(r ? Mx(n) : n, -i);
    for (let a = 0; a < o.length; a++)
      o[a].type.valid(e, o[a]) || o.splice(a--, 1);
    return new _$t(o.length ? this.local.concat(o).sort(Fr) : this.local, s || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == tn ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let i = this.children, s = this.local;
    for (let r = 0; r < i.length; r += 3) {
      let o, a = i[r] + n, l = i[r + 1] + n;
      for (let u = 0, d; u < e.length; u++)
        (d = e[u]) && d.from > a && d.to < l && (e[u] = null, (o || (o = [])).push(d));
      if (!o)
        continue;
      i == this.children && (i = this.children.slice());
      let c = i[r + 2].removeInner(o, a + 1);
      c != tn ? i[r + 2] = c : (i.splice(r, 3), r -= 3);
    }
    if (s.length) {
      for (let r = 0, o; r < e.length; r++)
        if (o = e[r])
          for (let a = 0; a < s.length; a++)
            s[a].eq(o, n) && (s == this.local && (s = this.local.slice()), s.splice(a--, 1));
    }
    return i == this.children && s == this.local ? this : s.length || i.length ? new _$t(s, i) : tn;
  }
  forChild(e, n) {
    if (this == tn)
      return this;
    if (n.isLeaf)
      return _$t.empty;
    let i, s;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (i = this.children[a + 2]);
        break;
      }
    let r = e + 1, o = r + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < o && l.to > r && l.type instanceof Ks) {
        let c = Math.max(r, l.from) - r, u = Math.min(o, l.to) - r;
        c < u && (s || (s = [])).push(l.copy(c, u));
      }
    }
    if (s) {
      let a = new _$t(s.sort(Fr), ho);
      return i ? new Ds([a, i]) : a;
    }
    return i || tn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return true;
    if (!(e instanceof _$t) || this.local.length != e.local.length || this.children.length != e.children.length)
      return false;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return false;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(e) {
    return am(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == tn)
      return ho;
    if (e.inlineContent || !this.local.some(Ks.is))
      return this.local;
    let n = [];
    for (let i = 0; i < this.local.length; i++)
      this.local[i].type instanceof Ks || n.push(this.local[i]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
};
$t.empty = new $t([], []);
$t.removeOverlap = am;
var tn = $t.empty;
var Ds = class _Ds {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const i = this.members.map((s) => s.map(e, n, Rr));
    return _Ds.from(i);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return $t.empty;
    let i = [];
    for (let s = 0; s < this.members.length; s++) {
      let r = this.members[s].forChild(e, n);
      r != tn && (r instanceof _Ds ? i = i.concat(r.members) : i.push(r));
    }
    return _Ds.from(i);
  }
  eq(e) {
    if (!(e instanceof _Ds) || e.members.length != this.members.length)
      return false;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return false;
    return true;
  }
  locals(e) {
    let n, i = true;
    for (let s = 0; s < this.members.length; s++) {
      let r = this.members[s].localsInner(e);
      if (r.length)
        if (!n)
          n = r;
        else {
          i && (n = n.slice(), i = false);
          for (let o = 0; o < r.length; o++)
            n.push(r[o]);
        }
    }
    return n ? am(i ? n : n.sort(Fr)) : ho;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return tn;
      case 1:
        return e[0];
      default:
        return new _Ds(e.every((n) => n instanceof $t) ? e : e.reduce((n, i) => n.concat(i instanceof $t ? i : i.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
};
function RR(t10, e, n, i, s, r, o) {
  let a = t10.slice();
  for (let c = 0, u = r; c < n.maps.length; c++) {
    let d = 0;
    n.maps[c].forEach((f, h10, p, g) => {
      let m = g - p - (h10 - f);
      for (let b = 0; b < a.length; b += 3) {
        let x = a[b + 1];
        if (x < 0 || f > x + u - d)
          continue;
        let k = a[b] + u - d;
        h10 >= k ? a[b + 1] = f <= k ? -2 : -1 : f >= u && m && (a[b] += m, a[b + 1] += m);
      }
      d += m;
    }), u = n.maps[c].map(u, -1);
  }
  let l = false;
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        l = true, a[c + 1] = -1;
        continue;
      }
      let u = n.map(t10[c] + r), d = u - s;
      if (d < 0 || d >= i.content.size) {
        l = true;
        continue;
      }
      let f = n.map(t10[c + 1] + r, -1), h10 = f - s, { index: p, offset: g } = i.content.findIndex(d), m = i.maybeChild(p);
      if (m && g == d && g + m.nodeSize == h10) {
        let b = a[c + 2].mapInner(n, m, u + 1, t10[c] + r + 1, o);
        b != tn ? (a[c] = d, a[c + 1] = h10, a[c + 2] = b) : (a[c + 1] = -2, l = true);
      } else
        l = true;
    }
  if (l) {
    let c = FR(a, t10, e, n, s, r, o), u = ou(c, i, 0, o);
    e = u.local;
    for (let d = 0; d < a.length; d += 3)
      a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
    for (let d = 0, f = 0; d < u.children.length; d += 3) {
      let h10 = u.children[d];
      for (; f < a.length && a[f] < h10; )
        f += 3;
      a.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
    }
  }
  return new $t(e.sort(Fr), a);
}
function Ox(t10, e) {
  if (!e || !t10.length)
    return t10;
  let n = [];
  for (let i = 0; i < t10.length; i++) {
    let s = t10[i];
    n.push(new Un(s.from + e, s.to + e, s.type));
  }
  return n;
}
function FR(t10, e, n, i, s, r, o) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let d = l.local[u].map(i, s, c);
      d ? n.push(d) : o.onRemove && o.onRemove(l.local[u].spec);
    }
    for (let u = 0; u < l.children.length; u += 3)
      a(l.children[u + 2], l.children[u] + c + 1);
  }
  for (let l = 0; l < t10.length; l += 3)
    t10[l + 1] == -1 && a(t10[l + 2], e[l] + r + 1);
  return n;
}
function Ex(t10, e, n) {
  if (e.isLeaf)
    return null;
  let i = n + e.nodeSize, s = null;
  for (let r = 0, o; r < t10.length; r++)
    (o = t10[r]) && o.from > n && o.to < i && ((s || (s = [])).push(o), t10[r] = null);
  return s;
}
function Mx(t10) {
  let e = [];
  for (let n = 0; n < t10.length; n++)
    t10[n] != null && e.push(t10[n]);
  return e;
}
function ou(t10, e, n, i) {
  let s = [], r = false;
  e.forEach((a, l) => {
    let c = Ex(t10, a, l + n);
    if (c) {
      r = true;
      let u = ou(c, a, n + l + 1, i);
      u != tn && s.push(l, l + a.nodeSize, u);
    }
  });
  let o = Ox(r ? Mx(t10) : t10, -n).sort(Fr);
  for (let a = 0; a < o.length; a++)
    o[a].type.valid(e, o[a]) || (i.onRemove && i.onRemove(o[a].spec), o.splice(a--, 1));
  return o.length || s.length ? new $t(o, s) : tn;
}
function Fr(t10, e) {
  return t10.from - e.from || t10.to - e.to;
}
function am(t10) {
  let e = t10;
  for (let n = 0; n < e.length - 1; n++) {
    let i = e[n];
    if (i.from != i.to)
      for (let s = n + 1; s < e.length; s++) {
        let r = e[s];
        if (r.from == i.from) {
          r.to != i.to && (e == t10 && (e = t10.slice()), e[s] = r.copy(r.from, i.to), G0(e, s + 1, r.copy(i.to, r.to)));
          continue;
        } else {
          r.from < i.to && (e == t10 && (e = t10.slice()), e[n] = i.copy(i.from, r.from), G0(e, s, i.copy(r.from, i.to)));
          break;
        }
      }
  }
  return e;
}
function G0(t10, e, n) {
  for (; e < t10.length && Fr(n, t10[e]) > 0; )
    e++;
  t10.splice(e, 0, n);
}
function mf(t10) {
  let e = [];
  return t10.someProp("decorations", (n) => {
    let i = n(t10.state);
    i && i != tn && e.push(i);
  }), t10.cursorWrapper && e.push($t.create(t10.state.doc, [t10.cursorWrapper.deco])), Ds.from(e);
}
var VR = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var BR = In && Us <= 11;
var zR = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
};
var jR = class {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new zR(), this.onCharData = null, this.suppressingSelectionUpdates = false, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((i) => {
      for (let s = 0; s < i.length; s++)
        this.queue.push(i[s]);
      In && Us <= 11 && i.some((s) => s.type == "childList" && s.removedNodes.length || s.type == "characterData" && s.oldValue.length > s.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), BR && (this.onCharData = (i) => {
      this.queue.push({ target: i.target, type: "characterData", oldValue: i.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, VR)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true, setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (z0(this.view)) {
      if (this.suppressingSelectionUpdates)
        return ys(this.view);
      if (In && Us <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Yr(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return true;
    let n = /* @__PURE__ */ new Set(), i;
    for (let r = e.focusNode; r; r = $o(r))
      n.add(r);
    for (let r = e.anchorNode; r; r = $o(r))
      if (n.has(r)) {
        i = r;
        break;
      }
    let s = i && this.view.docView.nearestDesc(i);
    if (s && s.ignoreMutation({
      type: "selection",
      target: i.nodeType == 3 ? i.parentNode : i
    }))
      return this.setCurSelection(), true;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let i = e.domSelectionRange(), s = !this.suppressingSelectionUpdates && !this.currentSelection.eq(i) && z0(e) && !this.ignoreSelectionChange(i), r = -1, o = -1, a = false, l = [];
    if (e.editable)
      for (let u = 0; u < n.length; u++) {
        let d = this.registerMutation(n[u], l);
        d && (r = r < 0 ? d.from : Math.min(d.from, r), o = o < 0 ? d.to : Math.max(d.to, o), d.typeOver && (a = true));
      }
    if (vi && l.length) {
      let u = l.filter((d) => d.nodeName == "BR");
      if (u.length == 2) {
        let [d, f] = u;
        d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let f of u) {
          let h10 = f.parentNode;
          h10 && h10.nodeName == "LI" && (!d || UR(e, d) != h10) && f.remove();
        }
      }
    }
    let c = null;
    r < 0 && s && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && wd(i) && (c = em(e)) && c.eq(je.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, ys(e), this.currentSelection.set(i), e.scrollToSelection()) : (r > -1 || s) && (r > -1 && (e.docView.markDirty(r, o), HR(e)), this.handleDOMChange(r, o, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(i) || ys(e), this.currentSelection.set(i));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let i = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (i == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !i || i.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let d = e.addedNodes[u];
        n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (i.contentDOM && i.contentDOM != i.dom && !i.contentDOM.contains(e.target))
        return { from: i.posBefore, to: i.posAfter };
      let s = e.previousSibling, r = e.nextSibling;
      if (In && Us <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: d, nextSibling: f } = e.addedNodes[u];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (s = d), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (r = f);
        }
      let o = s && s.parentNode == e.target ? Jt(s) + 1 : 0, a = i.localPosFromDOM(e.target, o, -1), l = r && r.parentNode == e.target ? Jt(r) : e.target.childNodes.length, c = i.localPosFromDOM(e.target, l, 1);
      return { from: a, to: c };
    } else return e.type == "attributes" ? { from: i.posAtStart - i.border, to: i.posAtEnd + i.border } : (this.lastChangedTextNode = e.target, {
      from: i.posAtStart,
      to: i.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
};
var J0 = /* @__PURE__ */ new WeakMap();
var X0 = false;
function HR(t10) {
  if (!J0.has(t10) && (J0.set(t10, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t10.dom).whiteSpace) !== -1)) {
    if (t10.requiresGeckoHackNode = vi, X0)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), X0 = true;
  }
}
function Q0(t10, e) {
  let n = e.startContainer, i = e.startOffset, s = e.endContainer, r = e.endOffset, o = t10.domAtPos(t10.state.selection.anchor);
  return Yr(o.node, o.offset, s, r) && ([n, i, s, r] = [s, r, n, i]), { anchorNode: n, anchorOffset: i, focusNode: s, focusOffset: r };
}
function WR(t10, e) {
  if (e.getComposedRanges) {
    let s = e.getComposedRanges(t10.root)[0];
    if (s)
      return Q0(t10, s);
  }
  let n;
  function i(s) {
    s.preventDefault(), s.stopImmediatePropagation(), n = s.getTargetRanges()[0];
  }
  return t10.dom.addEventListener("beforeinput", i, true), document.execCommand("indent"), t10.dom.removeEventListener("beforeinput", i, true), n ? Q0(t10, n) : null;
}
function UR(t10, e) {
  for (let n = e.parentNode; n && n != t10.dom; n = n.parentNode) {
    let i = t10.docView.nearestDesc(n, true);
    if (i && i.node.isBlock)
      return n;
  }
  return null;
}
function qR(t10, e, n) {
  let { node: i, fromOffset: s, toOffset: r, from: o, to: a } = t10.docView.parseRange(e, n), l = t10.domSelectionRange(), c, u = l.anchorNode;
  if (u && t10.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: l.anchorOffset }], wd(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), nn && t10.input.lastKeyCode === 8)
    for (let m = r; m > s; m--) {
      let b = i.childNodes[m - 1], x = b.pmViewDesc;
      if (b.nodeName == "BR" && !x) {
        r = m;
        break;
      }
      if (!x || x.size)
        break;
    }
  let d = t10.state.doc, f = t10.someProp("domParser") || Ws.fromSchema(t10.state.schema), h10 = d.resolve(o), p = null, g = f.parse(i, {
    topNode: h10.parent,
    topMatch: h10.parent.contentMatchAt(h10.index()),
    topOpen: true,
    from: s,
    to: r,
    preserveWhitespace: h10.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: c,
    ruleFromNode: KR,
    context: h10
  });
  if (c && c[0].pos != null) {
    let m = c[0].pos, b = c[1] && c[1].pos;
    b == null && (b = m), p = { anchor: m + o, head: b + o };
  }
  return { doc: g, sel: p, from: o, to: a };
}
function KR(t10) {
  let e = t10.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t10.nodeName == "BR" && t10.parentNode) {
    if (bn && /^(ul|ol)$/i.test(t10.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t10.parentNode.lastChild == t10 || bn && /^(tr|table)$/i.test(t10.parentNode.nodeName))
      return { ignore: true };
  } else if (t10.nodeName == "IMG" && t10.getAttribute("mark-placeholder"))
    return { ignore: true };
  return null;
}
var YR = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function GR(t10, e, n, i, s) {
  let r = t10.input.compositionPendingChanges || (t10.composing ? t10.input.compositionID : 0);
  if (t10.input.compositionPendingChanges = 0, e < 0) {
    let N = t10.input.lastSelectionTime > Date.now() - 50 ? t10.input.lastSelectionOrigin : null, V = em(t10, N);
    if (V && !t10.state.selection.eq(V)) {
      if (nn && fs && t10.input.lastKeyCode === 13 && Date.now() - 100 < t10.input.lastKeyCodeTime && t10.someProp("handleKeyDown", (F) => F(t10, Cr(13, "Enter"))))
        return;
      let Y = t10.state.tr.setSelection(V);
      N == "pointer" ? Y.setMeta("pointer", true) : N == "key" && Y.scrollIntoView(), r && Y.setMeta("composition", r), t10.dispatch(Y);
    }
    return;
  }
  let o = t10.state.doc.resolve(e), a = o.sharedDepth(n);
  e = o.before(a + 1), n = t10.state.doc.resolve(n).after(a + 1);
  let l = t10.state.selection, c = qR(t10, e, n), u = t10.state.doc, d = u.slice(c.from, c.to), f, h10;
  t10.input.lastKeyCode === 8 && Date.now() - 100 < t10.input.lastKeyCodeTime ? (f = t10.state.selection.to, h10 = "end") : (f = t10.state.selection.from, h10 = "start"), t10.input.lastKeyCode = null;
  let p = QR(d.content, c.doc.content, c.from, f, h10);
  if (p && t10.input.domChangeCount++, (Ro && t10.input.lastIOSEnter > Date.now() - 225 || fs) && s.some((N) => N.nodeType == 1 && !YR.test(N.nodeName)) && (!p || p.endA >= p.endB) && t10.someProp("handleKeyDown", (N) => N(t10, Cr(13, "Enter")))) {
    t10.input.lastIOSEnter = 0;
    return;
  }
  if (!p)
    if (i && l instanceof Be && !l.empty && l.$head.sameParent(l.$anchor) && !t10.composing && !(c.sel && c.sel.anchor != c.sel.head))
      p = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (c.sel) {
        let N = Z0(t10, t10.state.doc, c.sel);
        if (N && !N.eq(t10.state.selection)) {
          let V = t10.state.tr.setSelection(N);
          r && V.setMeta("composition", r), t10.dispatch(V);
        }
      }
      return;
    }
  t10.state.selection.from < t10.state.selection.to && p.start == p.endB && t10.state.selection instanceof Be && (p.start > t10.state.selection.from && p.start <= t10.state.selection.from + 2 && t10.state.selection.from >= c.from ? p.start = t10.state.selection.from : p.endA < t10.state.selection.to && p.endA >= t10.state.selection.to - 2 && t10.state.selection.to <= c.to && (p.endB += t10.state.selection.to - p.endA, p.endA = t10.state.selection.to)), In && Us <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > c.from && c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == "  " && (p.start--, p.endA--, p.endB--);
  let g = c.doc.resolveNoCache(p.start - c.from), m = c.doc.resolveNoCache(p.endB - c.from), b = u.resolve(p.start), x = g.sameParent(m) && g.parent.inlineContent && b.end() >= p.endA, k;
  if ((Ro && t10.input.lastIOSEnter > Date.now() - 225 && (!x || s.some((N) => N.nodeName == "DIV" || N.nodeName == "P")) || !x && g.pos < c.doc.content.size && !g.sameParent(m) && (k = je.findFrom(c.doc.resolve(g.pos + 1), 1, true)) && k.head == m.pos) && t10.someProp("handleKeyDown", (N) => N(t10, Cr(13, "Enter")))) {
    t10.input.lastIOSEnter = 0;
    return;
  }
  if (t10.state.selection.anchor > p.start && XR(u, p.start, p.endA, g, m) && t10.someProp("handleKeyDown", (N) => N(t10, Cr(8, "Backspace")))) {
    fs && nn && t10.domObserver.suppressSelectionUpdates();
    return;
  }
  nn && p.endB == p.start && (t10.input.lastChromeDelete = Date.now()), fs && !x && g.start() != m.start() && m.parentOffset == 0 && g.depth == m.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == p.endA && (p.endB -= 2, m = c.doc.resolveNoCache(p.endB - c.from), setTimeout(() => {
    t10.someProp("handleKeyDown", function(N) {
      return N(t10, Cr(13, "Enter"));
    });
  }, 20));
  let v = p.start, S = p.endA, w, E, M;
  if (x) {
    if (g.pos == m.pos)
      In && Us <= 11 && g.parentOffset == 0 && (t10.domObserver.suppressSelectionUpdates(), setTimeout(() => ys(t10), 20)), w = t10.state.tr.delete(v, S), E = u.resolve(p.start).marksAcross(u.resolve(p.endA));
    else if (
      // Adding or removing a mark
      p.endA == p.endB && (M = JR(g.parent.content.cut(g.parentOffset, m.parentOffset), b.parent.content.cut(b.parentOffset, p.endA - b.start())))
    )
      w = t10.state.tr, M.type == "add" ? w.addMark(v, S, M.mark) : w.removeMark(v, S, M.mark);
    else if (g.parent.child(g.index()).isText && g.index() == m.index() - (m.textOffset ? 0 : 1)) {
      let N = g.parent.textBetween(g.parentOffset, m.parentOffset);
      if (t10.someProp("handleTextInput", (V) => V(t10, v, S, N)))
        return;
      w = t10.state.tr.insertText(N, v, S);
    }
  }
  if (w || (w = t10.state.tr.replace(v, S, c.doc.slice(p.start - c.from, p.endB - c.from))), c.sel) {
    let N = Z0(t10, w.doc, c.sel);
    N && !(nn && t10.composing && N.empty && (p.start != p.endB || t10.input.lastChromeDelete < Date.now() - 100) && (N.head == v || N.head == w.mapping.map(S) - 1) || In && N.empty && N.head == v) && w.setSelection(N);
  }
  E && w.ensureMarks(E), r && w.setMeta("composition", r), t10.dispatch(w.scrollIntoView());
}
function Z0(t10, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : tm(t10, e.resolve(n.anchor), e.resolve(n.head));
}
function JR(t10, e) {
  let n = t10.firstChild.marks, i = e.firstChild.marks, s = n, r = i, o, a, l;
  for (let u = 0; u < i.length; u++)
    s = i[u].removeFromSet(s);
  for (let u = 0; u < n.length; u++)
    r = n[u].removeFromSet(r);
  if (s.length == 1 && r.length == 0)
    a = s[0], o = "add", l = (u) => u.mark(a.addToSet(u.marks));
  else if (s.length == 0 && r.length == 1)
    a = r[0], o = "remove", l = (u) => u.mark(a.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(l(e.child(u)));
  if (ce.from(c).eq(t10))
    return { mark: a, type: o };
}
function XR(t10, e, n, i, s) {
  if (
    // The content must have shrunk
    n - e <= s.pos - i.pos || // newEnd must point directly at or after the end of the block that newStart points into
    gf(i, true, false) < s.pos
  )
    return false;
  let r = t10.resolve(e);
  if (!i.parent.isTextblock) {
    let a = r.nodeAfter;
    return a != null && n == e + a.nodeSize;
  }
  if (r.parentOffset < r.parent.content.size || !r.parent.isTextblock)
    return false;
  let o = t10.resolve(gf(r, true, true));
  return !o.parent.isTextblock || o.pos > n || gf(o, true, false) < n ? false : i.parent.content.cut(i.parentOffset).eq(o.parent.content);
}
function gf(t10, e, n) {
  let i = t10.depth, s = e ? t10.end() : t10.pos;
  for (; i > 0 && (e || t10.indexAfter(i) == t10.node(i).childCount); )
    i--, s++, e = false;
  if (n) {
    let r = t10.node(i).maybeChild(t10.indexAfter(i));
    for (; r && !r.isLeaf; )
      r = r.firstChild, s++;
  }
  return s;
}
function QR(t10, e, n, i, s) {
  let r = t10.findDiffStart(e, n);
  if (r == null)
    return null;
  let { a: o, b: a } = t10.findDiffEnd(e, n + t10.size, n + e.size);
  if (s == "end") {
    let l = Math.max(0, r - Math.min(o, a));
    i -= o + l - r;
  }
  if (o < r && t10.size < e.size) {
    let l = i <= r && i >= o ? r - i : 0;
    r -= l, r && r < e.size && eb(e.textBetween(r - 1, r + 1)) && (r += l ? 1 : -1), a = r + (a - o), o = r;
  } else if (a < r) {
    let l = i <= r && i >= a ? r - i : 0;
    r -= l, r && r < t10.size && eb(t10.textBetween(r - 1, r + 1)) && (r += l ? 1 : -1), o = r + (o - a), a = r;
  }
  return { start: r, endA: o, endB: a };
}
function eb(t10) {
  if (t10.length != 2)
    return false;
  let e = t10.charCodeAt(0), n = t10.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
var ZR = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = false, this.trackWrites = null, this.mounted = false, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new yR(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = false, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(rb), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = true)), this.editable = ib(this), nb(this), this.nodeViews = sb(this), this.docView = D0(this.state.doc, tb(this), mf(this), this.dom, this), this.domObserver = new jR(this, (i, s, r, o) => GR(this, i, s, r, o)), this.domObserver.start(), vR(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Fh(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(rb), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let i in this._props)
      n[i] = this._props[i];
    n.state = this.state;
    for (let i in e)
      n[i] = e[i];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var i;
    let s = this.state, r = false, o = false;
    e.storedMarks && this.composing && (kx(this), o = true), this.state = e;
    let a = s.plugins != e.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let h10 = sb(this);
      t7(h10, this.nodeViews) && (this.nodeViews = h10, r = true);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && Fh(this), this.editable = ib(this), nb(this);
    let l = mf(this), c = tb(this), u = s.plugins != e.plugins && !s.doc.eq(e.doc) ? "reset" : e.scrollToSelection > s.scrollToSelection ? "to selection" : "preserve", d = r || !this.docView.matchesNode(e.doc, c, l);
    (d || !e.selection.eq(s.selection)) && (o = true);
    let f = u == "preserve" && o && this.dom.style.overflowAnchor == null && I$(this);
    if (o) {
      this.domObserver.stop();
      let h10 = d && (In || nn) && !this.composing && !s.selection.empty && !e.selection.empty && e7(s.selection, e.selection);
      if (d) {
        let p = nn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = LR(this)), (r || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = D0(e.doc, c, l, this.dom, this)), p && !this.trackWrites && (h10 = true);
      }
      h10 || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && iR(this)) ? ys(this, h10) : (cx(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(s), !((i = this.dragging) === null || i === void 0) && i.node && !s.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, s), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && P$(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof Pe) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && A0(this, n.getBoundingClientRect(), e);
      } else
        A0(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let i = this.directPlugins[n];
        i.spec.view && this.pluginViews.push(i.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let i = this.state.plugins[n];
        i.spec.view && this.pluginViews.push(i.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let i = this.pluginViews[n];
        i.update && i.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let i = e.node, s = -1;
    if (this.state.doc.nodeAt(i.from) == i.node)
      s = i.from;
    else {
      let r = i.from + (this.state.doc.content.size - n.doc.content.size);
      (r > 0 && this.state.doc.nodeAt(r)) == i.node && (s = r);
    }
    this.dragging = new wx(e.slice, e.move, s < 0 ? void 0 : Pe.create(this.state.doc, s));
  }
  someProp(e, n) {
    let i = this._props && this._props[e], s;
    if (i != null && (s = n ? n(i) : i))
      return s;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let a = this.directPlugins[o].props[e];
      if (a != null && (s = n ? n(a) : a))
        return s;
    }
    let r = this.state.plugins;
    if (r)
      for (let o = 0; o < r.length; o++) {
        let a = r[o].props[e];
        if (a != null && (s = n ? n(a) : a))
          return s;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (In) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return true;
      if (!e || !this.dom.contains(e))
        return false;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return false;
        e = e.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && D$(this.dom), ys(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return B$(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return tx(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, i = -1) {
    let s = this.docView.posFromDOM(e, n, i);
    if (s == null)
      throw new RangeError("DOM position not inside the editor");
    return s;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return U$(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return al(this, "", e, false, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return al(this, e, null, true, n || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return nm(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (xR(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], mf(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, S$());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return SR(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let n = this._props.dispatchTransaction;
    n ? n.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? bn && this.root.nodeType === 11 && M$(this.dom.ownerDocument) == this.dom && WR(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function tb(t10) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t10.editable), t10.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t10.state)), n)
      for (let i in n)
        i == "class" ? e.class += " " + n[i] : i == "style" ? e.style = (e.style ? e.style + ";" : "") + n[i] : !e[i] && i != "contenteditable" && i != "nodeName" && (e[i] = String(n[i]));
  }), e.translate || (e.translate = "no"), [Un.node(0, t10.state.doc.content.size, e)];
}
function nb(t10) {
  if (t10.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t10.cursorWrapper = { dom: e, deco: Un.widget(t10.state.selection.from, e, { raw: true, marks: t10.markCursor }) };
  } else
    t10.cursorWrapper = null;
}
function ib(t10) {
  return !t10.someProp("editable", (e) => e(t10.state) === false);
}
function e7(t10, e) {
  let n = Math.min(t10.$anchor.sharedDepth(t10.head), e.$anchor.sharedDepth(e.head));
  return t10.$anchor.start(n) != e.$anchor.start(n);
}
function sb(t10) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(i) {
    for (let s in i)
      Object.prototype.hasOwnProperty.call(e, s) || (e[s] = i[s]);
  }
  return t10.someProp("nodeViews", n), t10.someProp("markViews", n), e;
}
function t7(t10, e) {
  let n = 0, i = 0;
  for (let s in t10) {
    if (t10[s] != e[s])
      return true;
    n++;
  }
  for (let s in e)
    i++;
  return n != i;
}
function rb(t10) {
  if (t10.spec.state || t10.spec.filterTransaction || t10.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var nr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var au = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var n7 = typeof navigator < "u" && /Mac/.test(navigator.platform);
var i7 = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (Xt = 0; Xt < 10; Xt++) nr[48 + Xt] = nr[96 + Xt] = String(Xt);
var Xt;
for (Xt = 1; Xt <= 24; Xt++) nr[Xt + 111] = "F" + Xt;
var Xt;
for (Xt = 65; Xt <= 90; Xt++)
  nr[Xt] = String.fromCharCode(Xt + 32), au[Xt] = String.fromCharCode(Xt);
var Xt;
for (bf in nr) au.hasOwnProperty(bf) || (au[bf] = nr[bf]);
var bf;
function s7(t10) {
  var e = n7 && t10.metaKey && t10.shiftKey && !t10.ctrlKey && !t10.altKey || i7 && t10.shiftKey && t10.key && t10.key.length == 1 || t10.key == "Unidentified", n = !e && t10.key || (t10.shiftKey ? au : nr)[t10.keyCode] || t10.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
var r7 = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function o7(t10) {
  let e = t10.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let i, s, r, o;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = true;
    else if (/^a(lt)?$/i.test(l))
      i = true;
    else if (/^(c|ctrl|control)$/i.test(l))
      s = true;
    else if (/^s(hift)?$/i.test(l))
      r = true;
    else if (/^mod$/i.test(l))
      r7 ? o = true : s = true;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return i && (n = "Alt-" + n), s && (n = "Ctrl-" + n), o && (n = "Meta-" + n), r && (n = "Shift-" + n), n;
}
function a7(t10) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t10)
    e[o7(n)] = t10[n];
  return e;
}
function yf(t10, e, n = true) {
  return e.altKey && (t10 = "Alt-" + t10), e.ctrlKey && (t10 = "Ctrl-" + t10), e.metaKey && (t10 = "Meta-" + t10), n && e.shiftKey && (t10 = "Shift-" + t10), t10;
}
function l7(t10) {
  return new It({ props: { handleKeyDown: Tx(t10) } });
}
function Tx(t10) {
  let e = a7(t10);
  return function(n, i) {
    let s = s7(i), r, o = e[yf(s, i)];
    if (o && o(n.state, n.dispatch, n))
      return true;
    if (s.length == 1 && s != " ") {
      if (i.shiftKey) {
        let a = e[yf(s, i, false)];
        if (a && a(n.state, n.dispatch, n))
          return true;
      }
      if ((i.shiftKey || i.altKey || i.metaKey || s.charCodeAt(0) > 127) && (r = nr[i.keyCode]) && r != s) {
        let a = e[yf(r, i)];
        if (a && a(n.state, n.dispatch, n))
          return true;
      }
    }
    return false;
  };
}
var lm = (t10, e) => t10.selection.empty ? false : (e && e(t10.tr.deleteSelection().scrollIntoView()), true);
function Ax(t10, e) {
  let { $cursor: n } = t10.selection;
  return !n || (e ? !e.endOfTextblock("backward", t10) : n.parentOffset > 0) ? null : n;
}
var _x = (t10, e, n) => {
  let i = Ax(t10, n);
  if (!i)
    return false;
  let s = cm(i);
  if (!s) {
    let o = i.blockRange(), a = o && Xo(o);
    return a == null ? false : (e && e(t10.tr.lift(o, a).scrollIntoView()), true);
  }
  let r = s.nodeBefore;
  if (Vx(t10, s, e, -1))
    return true;
  if (i.parent.content.size == 0 && (Fo(r, "end") || Pe.isSelectable(r)))
    for (let o = i.depth; ; o--) {
      let a = kd(t10.doc, i.before(o), i.after(o), ke.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = t10.tr.step(a);
          l.setSelection(Fo(r, "end") ? je.findFrom(l.doc.resolve(l.mapping.map(s.pos, -1)), -1) : Pe.create(l.doc, s.pos - r.nodeSize)), e(l.scrollIntoView());
        }
        return true;
      }
      if (o == 1 || i.node(o - 1).childCount > 1)
        break;
    }
  return r.isAtom && s.depth == i.depth - 1 ? (e && e(t10.tr.delete(s.pos - r.nodeSize, s.pos).scrollIntoView()), true) : false;
};
var c7 = (t10, e, n) => {
  let i = Ax(t10, n);
  if (!i)
    return false;
  let s = cm(i);
  return s ? Nx(t10, s, e) : false;
};
var u7 = (t10, e, n) => {
  let i = Ix(t10, n);
  if (!i)
    return false;
  let s = um(i);
  return s ? Nx(t10, s, e) : false;
};
function Nx(t10, e, n) {
  let i = e.nodeBefore, s = i, r = e.pos - 1;
  for (; !s.isTextblock; r--) {
    if (s.type.spec.isolating)
      return false;
    let u = s.lastChild;
    if (!u)
      return false;
    s = u;
  }
  let o = e.nodeAfter, a = o, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return false;
    let u = a.firstChild;
    if (!u)
      return false;
    a = u;
  }
  let c = kd(t10.doc, r, l, ke.empty);
  if (!c || c.from != r || c instanceof Wt && c.slice.size >= l - r)
    return false;
  if (n) {
    let u = t10.tr.step(c);
    u.setSelection(Be.create(u.doc, r)), n(u.scrollIntoView());
  }
  return true;
}
function Fo(t10, e, n = false) {
  for (let i = t10; i; i = e == "start" ? i.firstChild : i.lastChild) {
    if (i.isTextblock)
      return true;
    if (n && i.childCount != 1)
      return false;
  }
  return false;
}
var Lx = (t10, e, n) => {
  let { $head: i, empty: s } = t10.selection, r = i;
  if (!s)
    return false;
  if (i.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t10) : i.parentOffset > 0)
      return false;
    r = cm(i);
  }
  let o = r && r.nodeBefore;
  return !o || !Pe.isSelectable(o) ? false : (e && e(t10.tr.setSelection(Pe.create(t10.doc, r.pos - o.nodeSize)).scrollIntoView()), true);
};
function cm(t10) {
  if (!t10.parent.type.spec.isolating)
    for (let e = t10.depth - 1; e >= 0; e--) {
      if (t10.index(e) > 0)
        return t10.doc.resolve(t10.before(e + 1));
      if (t10.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function Ix(t10, e) {
  let { $cursor: n } = t10.selection;
  return !n || (e ? !e.endOfTextblock("forward", t10) : n.parentOffset < n.parent.content.size) ? null : n;
}
var Px = (t10, e, n) => {
  let i = Ix(t10, n);
  if (!i)
    return false;
  let s = um(i);
  if (!s)
    return false;
  let r = s.nodeAfter;
  if (Vx(t10, s, e, 1))
    return true;
  if (i.parent.content.size == 0 && (Fo(r, "start") || Pe.isSelectable(r))) {
    let o = kd(t10.doc, i.before(), i.after(), ke.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let a = t10.tr.step(o);
        a.setSelection(Fo(r, "start") ? je.findFrom(a.doc.resolve(a.mapping.map(s.pos)), 1) : Pe.create(a.doc, a.mapping.map(s.pos))), e(a.scrollIntoView());
      }
      return true;
    }
  }
  return r.isAtom && s.depth == i.depth - 1 ? (e && e(t10.tr.delete(s.pos, s.pos + r.nodeSize).scrollIntoView()), true) : false;
};
var Dx = (t10, e, n) => {
  let { $head: i, empty: s } = t10.selection, r = i;
  if (!s)
    return false;
  if (i.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t10) : i.parentOffset < i.parent.content.size)
      return false;
    r = um(i);
  }
  let o = r && r.nodeAfter;
  return !o || !Pe.isSelectable(o) ? false : (e && e(t10.tr.setSelection(Pe.create(t10.doc, r.pos)).scrollIntoView()), true);
};
function um(t10) {
  if (!t10.parent.type.spec.isolating)
    for (let e = t10.depth - 1; e >= 0; e--) {
      let n = t10.node(e);
      if (t10.index(e) + 1 < n.childCount)
        return t10.doc.resolve(t10.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
var d7 = (t10, e) => {
  let n = t10.selection, i = n instanceof Pe, s;
  if (i) {
    if (n.node.isTextblock || !or(t10.doc, n.from))
      return false;
    s = n.from;
  } else if (s = xd(t10.doc, n.from, -1), s == null)
    return false;
  if (e) {
    let r = t10.tr.join(s);
    i && r.setSelection(Pe.create(r.doc, s - t10.doc.resolve(s).nodeBefore.nodeSize)), e(r.scrollIntoView());
  }
  return true;
};
var f7 = (t10, e) => {
  let n = t10.selection, i;
  if (n instanceof Pe) {
    if (n.node.isTextblock || !or(t10.doc, n.to))
      return false;
    i = n.to;
  } else if (i = xd(t10.doc, n.to, 1), i == null)
    return false;
  return e && e(t10.tr.join(i).scrollIntoView()), true;
};
var h7 = (t10, e) => {
  let { $from: n, $to: i } = t10.selection, s = n.blockRange(i), r = s && Xo(s);
  return r == null ? false : (e && e(t10.tr.lift(s, r).scrollIntoView()), true);
};
var $x = (t10, e) => {
  let { $head: n, $anchor: i } = t10.selection;
  return !n.parent.type.spec.code || !n.sameParent(i) ? false : (e && e(t10.tr.insertText(`
`).scrollIntoView()), true);
};
function dm(t10) {
  for (let e = 0; e < t10.edgeCount; e++) {
    let { type: n } = t10.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
var p7 = (t10, e) => {
  let { $head: n, $anchor: i } = t10.selection;
  if (!n.parent.type.spec.code || !n.sameParent(i))
    return false;
  let s = n.node(-1), r = n.indexAfter(-1), o = dm(s.contentMatchAt(r));
  if (!o || !s.canReplaceWith(r, r, o))
    return false;
  if (e) {
    let a = n.after(), l = t10.tr.replaceWith(a, a, o.createAndFill());
    l.setSelection(je.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return true;
};
var Rx = (t10, e) => {
  let n = t10.selection, { $from: i, $to: s } = n;
  if (n instanceof Yn || i.parent.inlineContent || s.parent.inlineContent)
    return false;
  let r = dm(s.parent.contentMatchAt(s.indexAfter()));
  if (!r || !r.isTextblock)
    return false;
  if (e) {
    let o = (!i.parentOffset && s.index() < s.parent.childCount ? i : s).pos, a = t10.tr.insert(o, r.createAndFill());
    a.setSelection(Be.create(a.doc, o + 1)), e(a.scrollIntoView());
  }
  return true;
};
var Fx = (t10, e) => {
  let { $cursor: n } = t10.selection;
  if (!n || n.parent.content.size)
    return false;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let r = n.before();
    if (bs(t10.doc, r))
      return e && e(t10.tr.split(r).scrollIntoView()), true;
  }
  let i = n.blockRange(), s = i && Xo(i);
  return s == null ? false : (e && e(t10.tr.lift(i, s).scrollIntoView()), true);
};
function m7(t10) {
  return (e, n) => {
    let { $from: i, $to: s } = e.selection;
    if (e.selection instanceof Pe && e.selection.node.isBlock)
      return !i.parentOffset || !bs(e.doc, i.pos) ? false : (n && n(e.tr.split(i.pos).scrollIntoView()), true);
    if (!i.depth)
      return false;
    let r = [], o, a, l = false, c = false;
    for (let h10 = i.depth; ; h10--)
      if (i.node(h10).isBlock) {
        l = i.end(h10) == i.pos + (i.depth - h10), c = i.start(h10) == i.pos - (i.depth - h10), a = dm(i.node(h10 - 1).contentMatchAt(i.indexAfter(h10 - 1))), r.unshift(l && a ? { type: a } : null), o = h10;
        break;
      } else {
        if (h10 == 1)
          return false;
        r.unshift(null);
      }
    let u = e.tr;
    (e.selection instanceof Be || e.selection instanceof Yn) && u.deleteSelection();
    let d = u.mapping.map(i.pos), f = bs(u.doc, d, r.length, r);
    if (f || (r[0] = a ? { type: a } : null, f = bs(u.doc, d, r.length, r)), u.split(d, r.length, r), !l && c && i.node(o).type != a) {
      let h10 = u.mapping.map(i.before(o)), p = u.doc.resolve(h10);
      a && i.node(o - 1).canReplaceWith(p.index(), p.index() + 1, a) && u.setNodeMarkup(u.mapping.map(i.before(o)), a);
    }
    return n && n(u.scrollIntoView()), true;
  };
}
var g7 = m7();
var b7 = (t10, e) => {
  let { $from: n, to: i } = t10.selection, s, r = n.sharedDepth(i);
  return r == 0 ? false : (s = n.before(r), e && e(t10.tr.setSelection(Pe.create(t10.doc, s))), true);
};
function y7(t10, e, n) {
  let i = e.nodeBefore, s = e.nodeAfter, r = e.index();
  return !i || !s || !i.type.compatibleContent(s.type) ? false : !i.content.size && e.parent.canReplace(r - 1, r) ? (n && n(t10.tr.delete(e.pos - i.nodeSize, e.pos).scrollIntoView()), true) : !e.parent.canReplace(r, r + 1) || !(s.isTextblock || or(t10.doc, e.pos)) ? false : (n && n(t10.tr.join(e.pos).scrollIntoView()), true);
}
function Vx(t10, e, n, i) {
  let s = e.nodeBefore, r = e.nodeAfter, o, a, l = s.type.spec.isolating || r.type.spec.isolating;
  if (!l && y7(t10, e, n))
    return true;
  let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (o = (a = s.contentMatchAt(s.childCount)).findWrapping(r.type)) && a.matchType(o[0] || r.type).validEnd) {
    if (n) {
      let h10 = e.pos + r.nodeSize, p = ce.empty;
      for (let b = o.length - 1; b >= 0; b--)
        p = ce.from(o[b].create(null, p));
      p = ce.from(s.copy(p));
      let g = t10.tr.step(new Ut(e.pos - 1, h10, e.pos, h10, new ke(p, 1, 0), o.length, true)), m = g.doc.resolve(h10 + 2 * o.length);
      m.nodeAfter && m.nodeAfter.type == s.type && or(g.doc, m.pos) && g.join(m.pos), n(g.scrollIntoView());
    }
    return true;
  }
  let u = r.type.spec.isolating || i > 0 && l ? null : je.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), f = d && Xo(d);
  if (f != null && f >= e.depth)
    return n && n(t10.tr.lift(d, f).scrollIntoView()), true;
  if (c && Fo(r, "start", true) && Fo(s, "end")) {
    let h10 = s, p = [];
    for (; p.push(h10), !h10.isTextblock; )
      h10 = h10.lastChild;
    let g = r, m = 1;
    for (; !g.isTextblock; g = g.firstChild)
      m++;
    if (h10.canReplace(h10.childCount, h10.childCount, g.content)) {
      if (n) {
        let b = ce.empty;
        for (let k = p.length - 1; k >= 0; k--)
          b = ce.from(p[k].copy(b));
        let x = t10.tr.step(new Ut(e.pos - p.length, e.pos + r.nodeSize, e.pos + m, e.pos + r.nodeSize - m, new ke(b, p.length, 0), 0, true));
        n(x.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function Bx(t10) {
  return function(e, n) {
    let i = e.selection, s = t10 < 0 ? i.$from : i.$to, r = s.depth;
    for (; s.node(r).isInline; ) {
      if (!r)
        return false;
      r--;
    }
    return s.node(r).isTextblock ? (n && n(e.tr.setSelection(Be.create(e.doc, t10 < 0 ? s.start(r) : s.end(r)))), true) : false;
  };
}
var v7 = Bx(-1);
var x7 = Bx(1);
function k7(t10, e = null) {
  return function(n, i) {
    let { $from: s, $to: r } = n.selection, o = s.blockRange(r), a = o && Xp(o, t10, e);
    return a ? (i && i(n.tr.wrap(o, a).scrollIntoView()), true) : false;
  };
}
function ob(t10, e = null) {
  return function(n, i) {
    let s = false;
    for (let r = 0; r < n.selection.ranges.length && !s; r++) {
      let { $from: { pos: o }, $to: { pos: a } } = n.selection.ranges[r];
      n.doc.nodesBetween(o, a, (l, c) => {
        if (s)
          return false;
        if (!(!l.isTextblock || l.hasMarkup(t10, e)))
          if (l.type == t10)
            s = true;
          else {
            let u = n.doc.resolve(c), d = u.index();
            s = u.parent.canReplaceWith(d, d + 1, t10);
          }
      });
    }
    if (!s)
      return false;
    if (i) {
      let r = n.tr;
      for (let o = 0; o < n.selection.ranges.length; o++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[o];
        r.setBlockType(a, l, t10, e);
      }
      i(r.scrollIntoView());
    }
    return true;
  };
}
function fm(...t10) {
  return function(e, n, i) {
    for (let s = 0; s < t10.length; s++)
      if (t10[s](e, n, i))
        return true;
    return false;
  };
}
fm(lm, _x, Lx);
fm(lm, Px, Dx);
fm($x, Rx, Fx, g7);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function S7(t10, e = null) {
  return function(n, i) {
    let { $from: s, $to: r } = n.selection, o = s.blockRange(r);
    if (!o)
      return false;
    let a = i ? n.tr : null;
    return w7(a, o, t10, e) ? (i && i(a.scrollIntoView()), true) : false;
  };
}
function w7(t10, e, n, i = null) {
  let s = false, r = e, o = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return false;
    let l = o.resolve(e.start - 2);
    r = new eu(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new eu(e.$from, o.resolve(e.$to.end(e.depth)), e.depth)), s = true;
  }
  let a = Xp(r, n, i, e);
  return a ? (t10 && C7(t10, e, a, s, n), true) : false;
}
function C7(t10, e, n, i, s) {
  let r = ce.empty;
  for (let u = n.length - 1; u >= 0; u--)
    r = ce.from(n[u].type.create(n[u].attrs, r));
  t10.step(new Ut(e.start - (i ? 2 : 0), e.end, e.start, e.end, new ke(r, 0, 0), n.length, true));
  let o = 0;
  for (let u = 0; u < n.length; u++)
    n[u].type == s && (o = u + 1);
  let a = n.length - o, l = e.start + n.length - (i ? 2 : 0), c = e.parent;
  for (let u = e.startIndex, d = e.endIndex, f = true; u < d; u++, f = false)
    !f && bs(t10.doc, l, a) && (t10.split(l, a), l += 2 * a), l += c.child(u).nodeSize;
  return t10;
}
function O7(t10) {
  return function(e, n) {
    let { $from: i, $to: s } = e.selection, r = i.blockRange(s, (o) => o.childCount > 0 && o.firstChild.type == t10);
    return r ? n ? i.node(r.depth - 1).type == t10 ? E7(e, n, t10, r) : M7(e, n, r) : true : false;
  };
}
function E7(t10, e, n, i) {
  let s = t10.tr, r = i.end, o = i.$to.end(i.depth);
  r < o && (s.step(new Ut(r - 1, o, r, o, new ke(ce.from(n.create(null, i.parent.copy())), 1, 0), 1, true)), i = new eu(s.doc.resolve(i.$from.pos), s.doc.resolve(o), i.depth));
  const a = Xo(i);
  if (a == null)
    return false;
  s.lift(i, a);
  let l = s.doc.resolve(s.mapping.map(r, -1) - 1);
  return or(s.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && s.join(l.pos), e(s.scrollIntoView()), true;
}
function M7(t10, e, n) {
  let i = t10.tr, s = n.parent;
  for (let h10 = n.end, p = n.endIndex - 1, g = n.startIndex; p > g; p--)
    h10 -= s.child(p).nodeSize, i.delete(h10 - 1, h10 + 1);
  let r = i.doc.resolve(n.start), o = r.nodeAfter;
  if (i.mapping.map(n.end) != n.start + r.nodeAfter.nodeSize)
    return false;
  let a = n.startIndex == 0, l = n.endIndex == s.childCount, c = r.node(-1), u = r.index(-1);
  if (!c.canReplace(u + (a ? 0 : 1), u + 1, o.content.append(l ? ce.empty : ce.from(s))))
    return false;
  let d = r.pos, f = d + o.nodeSize;
  return i.step(new Ut(d - (a ? 1 : 0), f + (l ? 1 : 0), d + 1, f - 1, new ke((a ? ce.empty : ce.from(s.copy(ce.empty))).append(l ? ce.empty : ce.from(s.copy(ce.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(i.scrollIntoView()), true;
}
function T7(t10) {
  return function(e, n) {
    let { $from: i, $to: s } = e.selection, r = i.blockRange(s, (c) => c.childCount > 0 && c.firstChild.type == t10);
    if (!r)
      return false;
    let o = r.startIndex;
    if (o == 0)
      return false;
    let a = r.parent, l = a.child(o - 1);
    if (l.type != t10)
      return false;
    if (n) {
      let c = l.lastChild && l.lastChild.type == a.type, u = ce.from(c ? t10.create() : null), d = new ke(ce.from(t10.create(null, ce.from(a.type.create(null, u)))), c ? 3 : 1, 0), f = r.start, h10 = r.end;
      n(e.tr.step(new Ut(f - (c ? 3 : 1), h10, f, h10, d, 1, true)).scrollIntoView());
    }
    return true;
  };
}
function Ed(t10) {
  const { state: e, transaction: n } = t10;
  let { selection: i } = n, { doc: s } = n, { storedMarks: r } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return r;
    },
    get selection() {
      return i;
    },
    get doc() {
      return s;
    },
    get tr() {
      return i = n.selection, s = n.doc, r = n.storedMarks, n;
    }
  };
}
var Md = class {
  constructor(e) {
    this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: e, editor: n, state: i } = this, { view: s } = n, { tr: r } = i, o = this.buildProps(r);
    return Object.fromEntries(Object.entries(e).map(([a, l]) => [a, (...u) => {
      const d = l(...u)(o);
      return !r.getMeta("preventDispatch") && !this.hasCustomState && s.dispatch(r), d;
    }]));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(e, n = true) {
    const { rawCommands: i, editor: s, state: r } = this, { view: o } = s, a = [], l = !!e, c = e || r.tr, u = () => (!l && n && !c.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(c), a.every((f) => f === true)), d = {
      ...Object.fromEntries(Object.entries(i).map(([f, h10]) => [f, (...g) => {
        const m = this.buildProps(c, n), b = h10(...g)(m);
        return a.push(b), d;
      }])),
      run: u
    };
    return d;
  }
  createCan(e) {
    const { rawCommands: n, state: i } = this, s = false, r = e || i.tr, o = this.buildProps(r, s);
    return {
      ...Object.fromEntries(Object.entries(n).map(([l, c]) => [l, (...u) => c(...u)({ ...o, dispatch: void 0 })])),
      chain: () => this.createChain(r, s)
    };
  }
  buildProps(e, n = true) {
    const { rawCommands: i, editor: s, state: r } = this, { view: o } = s, a = {
      tr: e,
      editor: s,
      view: o,
      state: Ed({
        state: r,
        transaction: e
      }),
      dispatch: n ? () => {
      } : void 0,
      chain: () => this.createChain(e, n),
      can: () => this.createCan(e),
      get commands() {
        return Object.fromEntries(Object.entries(i).map(([l, c]) => [l, (...u) => c(...u)(a)]));
      }
    };
    return a;
  }
};
var A7 = class {
  constructor() {
    this.callbacks = {};
  }
  on(e, n) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(n), this;
  }
  emit(e, ...n) {
    const i = this.callbacks[e];
    return i && i.forEach((s) => s.apply(this, n)), this;
  }
  off(e, n) {
    const i = this.callbacks[e];
    return i && (n ? this.callbacks[e] = i.filter((s) => s !== n) : delete this.callbacks[e]), this;
  }
  once(e, n) {
    const i = (...s) => {
      this.off(e, i), n.apply(this, s);
    };
    return this.on(e, i);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function we(t10, e, n) {
  return t10.config[e] === void 0 && t10.parent ? we(t10.parent, e, n) : typeof t10.config[e] == "function" ? t10.config[e].bind({
    ...n,
    parent: t10.parent ? we(t10.parent, e, n) : null
  }) : t10.config[e];
}
function Td(t10) {
  const e = t10.filter((s) => s.type === "extension"), n = t10.filter((s) => s.type === "node"), i = t10.filter((s) => s.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: i
  };
}
function zx(t10) {
  const e = [], { nodeExtensions: n, markExtensions: i } = Td(t10), s = [...n, ...i], r = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  return t10.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage,
      extensions: s
    }, l = we(o, "addGlobalAttributes", a);
    if (!l)
      return;
    l().forEach((u) => {
      u.types.forEach((d) => {
        Object.entries(u.attributes).forEach(([f, h10]) => {
          e.push({
            type: d,
            name: f,
            attribute: {
              ...r,
              ...h10
            }
          });
        });
      });
    });
  }), s.forEach((o) => {
    const a = {
      name: o.name,
      options: o.options,
      storage: o.storage
    }, l = we(o, "addAttributes", a);
    if (!l)
      return;
    const c = l();
    Object.entries(c).forEach(([u, d]) => {
      const f = {
        ...r,
        ...d
      };
      typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({
        type: o.name,
        name: u,
        attribute: f
      });
    });
  }), e;
}
function Kt(t10, e) {
  if (typeof t10 == "string") {
    if (!e.nodes[t10])
      throw Error(`There is no node type named '${t10}'. Maybe you forgot to add the extension?`);
    return e.nodes[t10];
  }
  return t10;
}
function Nt(...t10) {
  return t10.filter((e) => !!e).reduce((e, n) => {
    const i = { ...e };
    return Object.entries(n).forEach(([s, r]) => {
      if (!i[s]) {
        i[s] = r;
        return;
      }
      if (s === "class") {
        const a = r ? String(r).split(" ") : [], l = i[s] ? i[s].split(" ") : [], c = a.filter((u) => !l.includes(u));
        i[s] = [...l, ...c].join(" ");
      } else if (s === "style") {
        const a = r ? r.split(";").map((u) => u.trim()).filter(Boolean) : [], l = i[s] ? i[s].split(";").map((u) => u.trim()).filter(Boolean) : [], c = /* @__PURE__ */ new Map();
        l.forEach((u) => {
          const [d, f] = u.split(":").map((h10) => h10.trim());
          c.set(d, f);
        }), a.forEach((u) => {
          const [d, f] = u.split(":").map((h10) => h10.trim());
          c.set(d, f);
        }), i[s] = Array.from(c.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
      } else
        i[s] = r;
    }), i;
  }, {});
}
function Vh(t10, e) {
  return e.filter((n) => n.type === t10.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t10.attrs) || {} : {
    [n.name]: t10.attrs[n.name]
  }).reduce((n, i) => Nt(n, i), {});
}
function jx(t10) {
  return typeof t10 == "function";
}
function qe(t10, e = void 0, ...n) {
  return jx(t10) ? e ? t10.bind(e)(...n) : t10(...n) : t10;
}
function _7(t10 = {}) {
  return Object.keys(t10).length === 0 && t10.constructor === Object;
}
function N7(t10) {
  return typeof t10 != "string" ? t10 : t10.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t10) : t10 === "true" ? true : t10 === "false" ? false : t10;
}
function ab(t10, e) {
  return "style" in t10 ? t10 : {
    ...t10,
    getAttrs: (n) => {
      const i = t10.getAttrs ? t10.getAttrs(n) : t10.attrs;
      if (i === false)
        return false;
      const s = e.reduce((r, o) => {
        const a = o.attribute.parseHTML ? o.attribute.parseHTML(n) : N7(n.getAttribute(o.name));
        return a == null ? r : {
          ...r,
          [o.name]: a
        };
      }, {});
      return { ...i, ...s };
    }
  };
}
function lb(t10) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t10).filter(([e, n]) => e === "attrs" && _7(n) ? false : n != null)
  );
}
function L7(t10, e) {
  var n;
  const i = zx(t10), { nodeExtensions: s, markExtensions: r } = Td(t10), o = (n = s.find((c) => we(c, "topNode"))) === null || n === void 0 ? void 0 : n.name, a = Object.fromEntries(s.map((c) => {
    const u = i.filter((b) => b.type === c.name), d = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t10.reduce((b, x) => {
      const k = we(x, "extendNodeSchema", d);
      return {
        ...b,
        ...k ? k(c) : {}
      };
    }, {}), h10 = lb({
      ...f,
      content: qe(we(c, "content", d)),
      marks: qe(we(c, "marks", d)),
      group: qe(we(c, "group", d)),
      inline: qe(we(c, "inline", d)),
      atom: qe(we(c, "atom", d)),
      selectable: qe(we(c, "selectable", d)),
      draggable: qe(we(c, "draggable", d)),
      code: qe(we(c, "code", d)),
      whitespace: qe(we(c, "whitespace", d)),
      linebreakReplacement: qe(we(c, "linebreakReplacement", d)),
      defining: qe(we(c, "defining", d)),
      isolating: qe(we(c, "isolating", d)),
      attrs: Object.fromEntries(u.map((b) => {
        var x;
        return [b.name, { default: (x = b == null ? void 0 : b.attribute) === null || x === void 0 ? void 0 : x.default }];
      }))
    }), p = qe(we(c, "parseHTML", d));
    p && (h10.parseDOM = p.map((b) => ab(b, u)));
    const g = we(c, "renderHTML", d);
    g && (h10.toDOM = (b) => g({
      node: b,
      HTMLAttributes: Vh(b, u)
    }));
    const m = we(c, "renderText", d);
    return m && (h10.toText = m), [c.name, h10];
  })), l = Object.fromEntries(r.map((c) => {
    const u = i.filter((m) => m.type === c.name), d = {
      name: c.name,
      options: c.options,
      storage: c.storage,
      editor: e
    }, f = t10.reduce((m, b) => {
      const x = we(b, "extendMarkSchema", d);
      return {
        ...m,
        ...x ? x(c) : {}
      };
    }, {}), h10 = lb({
      ...f,
      inclusive: qe(we(c, "inclusive", d)),
      excludes: qe(we(c, "excludes", d)),
      group: qe(we(c, "group", d)),
      spanning: qe(we(c, "spanning", d)),
      code: qe(we(c, "code", d)),
      attrs: Object.fromEntries(u.map((m) => {
        var b;
        return [m.name, { default: (b = m == null ? void 0 : m.attribute) === null || b === void 0 ? void 0 : b.default }];
      }))
    }), p = qe(we(c, "parseHTML", d));
    p && (h10.parseDOM = p.map((m) => ab(m, u)));
    const g = we(c, "renderHTML", d);
    return g && (h10.toDOM = (m) => g({
      mark: m,
      HTMLAttributes: Vh(m, u)
    })), [c.name, h10];
  }));
  return new _2({
    topNode: o,
    nodes: a,
    marks: l
  });
}
function vf(t10, e) {
  return e.nodes[t10] || e.marks[t10] || null;
}
function cb(t10, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t10.name) : e;
}
function hm(t10, e) {
  const n = so.fromSchema(e).serializeFragment(t10), s = document.implementation.createHTMLDocument().createElement("div");
  return s.appendChild(n), s.innerHTML;
}
var I7 = (t10, e = 500) => {
  let n = "";
  const i = t10.parentOffset;
  return t10.parent.nodesBetween(Math.max(0, i - e), i, (s, r, o, a) => {
    var l, c;
    const u = ((c = (l = s.type.spec).toText) === null || c === void 0 ? void 0 : c.call(l, {
      node: s,
      pos: r,
      parent: o,
      index: a
    })) || s.textContent || "%leaf%";
    n += s.isAtom && !s.isText ? u : u.slice(0, Math.max(0, i - r));
  }), n;
};
function pm(t10) {
  return Object.prototype.toString.call(t10) === "[object RegExp]";
}
var Ad = class {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
};
var P7 = (t10, e) => {
  if (pm(e))
    return e.exec(t10);
  const n = e(t10);
  if (!n)
    return null;
  const i = [n.text];
  return i.index = n.index, i.input = t10, i.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), i.push(n.replaceWith)), i;
};
function ql(t10) {
  var e;
  const { editor: n, from: i, to: s, text: r, rules: o, plugin: a } = t10, { view: l } = n;
  if (l.composing)
    return false;
  const c = l.state.doc.resolve(i);
  if (
    // check for code node
    c.parent.type.spec.code || !((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) && e.marks.find((f) => f.type.spec.code)
  )
    return false;
  let u = false;
  const d = I7(c) + r;
  return o.forEach((f) => {
    if (u)
      return;
    const h10 = P7(d, f.find);
    if (!h10)
      return;
    const p = l.state.tr, g = Ed({
      state: l.state,
      transaction: p
    }), m = {
      from: i - (h10[0].length - r.length),
      to: s
    }, { commands: b, chain: x, can: k } = new Md({
      editor: n,
      state: g
    });
    f.handler({
      state: g,
      range: m,
      match: h10,
      commands: b,
      chain: x,
      can: k
    }) === null || !p.steps.length || (p.setMeta(a, {
      transform: p,
      from: i,
      to: s,
      text: r
    }), l.dispatch(p), u = true);
  }), u;
}
function D7(t10) {
  const { editor: e, rules: n } = t10, i = new It({
    state: {
      init() {
        return null;
      },
      apply(s, r, o) {
        const a = s.getMeta(i);
        if (a)
          return a;
        const l = s.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: u } = l;
          typeof u == "string" ? u = u : u = hm(ce.from(u), o.schema);
          const { from: d } = l, f = d + u.length;
          ql({
            editor: e,
            from: d,
            to: f,
            text: u,
            rules: n,
            plugin: i
          });
        }), s.selectionSet || s.docChanged ? null : r;
      }
    },
    props: {
      handleTextInput(s, r, o, a) {
        return ql({
          editor: e,
          from: r,
          to: o,
          text: a,
          rules: n,
          plugin: i
        });
      },
      handleDOMEvents: {
        compositionend: (s) => (setTimeout(() => {
          const { $cursor: r } = s.state.selection;
          r && ql({
            editor: e,
            from: r.pos,
            to: r.pos,
            text: "",
            rules: n,
            plugin: i
          });
        }), false)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(s, r) {
        if (r.key !== "Enter")
          return false;
        const { $cursor: o } = s.state.selection;
        return o ? ql({
          editor: e,
          from: o.pos,
          to: o.pos,
          text: `
`,
          rules: n,
          plugin: i
        }) : false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return i;
}
function $7(t10) {
  return Object.prototype.toString.call(t10).slice(8, -1);
}
function Kl(t10) {
  return $7(t10) !== "Object" ? false : t10.constructor === Object && Object.getPrototypeOf(t10) === Object.prototype;
}
function _d(t10, e) {
  const n = { ...t10 };
  return Kl(t10) && Kl(e) && Object.keys(e).forEach((i) => {
    Kl(e[i]) && Kl(t10[i]) ? n[i] = _d(t10[i], e[i]) : n[i] = e[i];
  }), n;
}
var xi = class _xi {
  constructor(e = {}) {
    this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = qe(we(this, "addOptions", {
      name: this.name
    }))), this.storage = qe(we(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new _xi(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => _d(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new _xi(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = qe(we(n, "addOptions", {
      name: n.name
    })), n.storage = qe(we(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: i } = e.state, s = e.state.selection.$from;
    if (s.pos === s.end()) {
      const o = s.marks();
      if (!!!o.find((c) => (c == null ? void 0 : c.type.name) === n.name))
        return false;
      const l = o.find((c) => (c == null ? void 0 : c.type.name) === n.name);
      return l && i.removeStoredMark(l), i.insertText(" ", s.pos), e.view.dispatch(i), true;
    }
    return false;
  }
};
function R7(t10) {
  return typeof t10 == "number";
}
var F7 = class {
  constructor(e) {
    this.find = e.find, this.handler = e.handler;
  }
};
var V7 = (t10, e, n) => {
  if (pm(e))
    return [...t10.matchAll(e)];
  const i = e(t10, n);
  return i ? i.map((s) => {
    const r = [s.text];
    return r.index = s.index, r.input = t10, r.data = s.data, s.replaceWith && (s.text.includes(s.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), r.push(s.replaceWith)), r;
  }) : [];
};
function B7(t10) {
  const { editor: e, state: n, from: i, to: s, rule: r, pasteEvent: o, dropEvent: a } = t10, { commands: l, chain: c, can: u } = new Md({
    editor: e,
    state: n
  }), d = [];
  return n.doc.nodesBetween(i, s, (h10, p) => {
    if (!h10.isTextblock || h10.type.spec.code)
      return;
    const g = Math.max(i, p), m = Math.min(s, p + h10.content.size), b = h10.textBetween(g - p, m - p, void 0, "￼");
    V7(b, r.find, o).forEach((k) => {
      if (k.index === void 0)
        return;
      const v = g + k.index + 1, S = v + k[0].length, w = {
        from: n.tr.mapping.map(v),
        to: n.tr.mapping.map(S)
      }, E = r.handler({
        state: n,
        range: w,
        match: k,
        commands: l,
        chain: c,
        can: u,
        pasteEvent: o,
        dropEvent: a
      });
      d.push(E);
    });
  }), d.every((h10) => h10 !== null);
}
var Yl = null;
var z7 = (t10) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) === null || e === void 0 || e.setData("text/html", t10), n;
};
function j7(t10) {
  const { editor: e, rules: n } = t10;
  let i = null, s = false, r = false, o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const l = ({ state: u, from: d, to: f, rule: h10, pasteEvt: p }) => {
    const g = u.tr, m = Ed({
      state: u,
      transaction: g
    });
    if (!(!B7({
      editor: e,
      state: m,
      from: Math.max(d - 1, 0),
      to: f.b - 1,
      rule: h10,
      pasteEvent: p,
      dropEvent: a
    }) || !g.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, g;
    }
  };
  return n.map((u) => new It({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const f = (p) => {
        var g;
        i = !((g = d.dom.parentElement) === null || g === void 0) && g.contains(p.target) ? d.dom.parentElement : null, i && (Yl = e);
      }, h10 = () => {
        Yl && (Yl = null);
      };
      return window.addEventListener("dragstart", f), window.addEventListener("dragend", h10), {
        destroy() {
          window.removeEventListener("dragstart", f), window.removeEventListener("dragend", h10);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, f) => {
          if (r = i === d.dom.parentElement, a = f, !r) {
            const h10 = Yl;
            h10 && setTimeout(() => {
              const p = h10.state.selection;
              p && h10.commands.deleteRange({ from: p.from, to: p.to });
            }, 10);
          }
          return false;
        },
        paste: (d, f) => {
          var h10;
          const p = (h10 = f.clipboardData) === null || h10 === void 0 ? void 0 : h10.getData("text/html");
          return o = f, s = !!(p != null && p.includes("data-pm-slice")), false;
        }
      }
    },
    appendTransaction: (d, f, h10) => {
      const p = d[0], g = p.getMeta("uiEvent") === "paste" && !s, m = p.getMeta("uiEvent") === "drop" && !r, b = p.getMeta("applyPasteRules"), x = !!b;
      if (!g && !m && !x)
        return;
      if (x) {
        let { text: S } = b;
        typeof S == "string" ? S = S : S = hm(ce.from(S), h10.schema);
        const { from: w } = b, E = w + S.length, M = z7(S);
        return l({
          rule: u,
          state: h10,
          from: w,
          to: { b: E },
          pasteEvt: M
        });
      }
      const k = f.doc.content.findDiffStart(h10.doc.content), v = f.doc.content.findDiffEnd(h10.doc.content);
      if (!(!R7(k) || !v || k === v.b))
        return l({
          rule: u,
          state: h10,
          from: k,
          to: v,
          pasteEvt: o
        });
    }
  }));
}
function H7(t10) {
  const e = t10.filter((n, i) => t10.indexOf(n) !== i);
  return Array.from(new Set(e));
}
var xo = class _xo {
  constructor(e, n) {
    this.splittableMarks = [], this.editor = n, this.extensions = _xo.resolve(e), this.schema = L7(this.extensions, n), this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(e) {
    const n = _xo.sort(_xo.flatten(e)), i = H7(n.map((s) => s.name));
    return i.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${i.map((s) => `'${s}'`).join(", ")}]. This can lead to issues.`), n;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(e) {
    return e.map((n) => {
      const i = {
        name: n.name,
        options: n.options,
        storage: n.storage
      }, s = we(n, "addExtensions", i);
      return s ? [n, ...this.flatten(s())] : n;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(e) {
    return e.sort((i, s) => {
      const r = we(i, "priority") || 100, o = we(s, "priority") || 100;
      return r > o ? -1 : r < o ? 1 : 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((e, n) => {
      const i = {
        name: n.name,
        options: n.options,
        storage: n.storage,
        editor: this.editor,
        type: vf(n.name, this.schema)
      }, s = we(n, "addCommands", i);
      return s ? {
        ...e,
        ...s()
      } : e;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: e } = this, n = _xo.sort([...this.extensions].reverse()), i = [], s = [], r = n.map((o) => {
      const a = {
        name: o.name,
        options: o.options,
        storage: o.storage,
        editor: e,
        type: vf(o.name, this.schema)
      }, l = [], c = we(o, "addKeyboardShortcuts", a);
      let u = {};
      if (o.type === "mark" && we(o, "exitable", a) && (u.ArrowRight = () => xi.handleExit({ editor: e, mark: o })), c) {
        const g = Object.fromEntries(Object.entries(c()).map(([m, b]) => [m, () => b({ editor: e })]));
        u = { ...u, ...g };
      }
      const d = l7(u);
      l.push(d);
      const f = we(o, "addInputRules", a);
      cb(o, e.options.enableInputRules) && f && i.push(...f());
      const h10 = we(o, "addPasteRules", a);
      cb(o, e.options.enablePasteRules) && h10 && s.push(...h10());
      const p = we(o, "addProseMirrorPlugins", a);
      if (p) {
        const g = p();
        l.push(...g);
      }
      return l;
    }).flat();
    return [
      D7({
        editor: e,
        rules: i
      }),
      ...j7({
        editor: e,
        rules: s
      }),
      ...r
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return zx(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: e } = this, { nodeExtensions: n } = Td(this.extensions);
    return Object.fromEntries(n.filter((i) => !!we(i, "addNodeView")).map((i) => {
      const s = this.attributes.filter((l) => l.type === i.name), r = {
        name: i.name,
        options: i.options,
        storage: i.storage,
        editor: e,
        type: Kt(i.name, this.schema)
      }, o = we(i, "addNodeView", r);
      if (!o)
        return [];
      const a = (l, c, u, d, f) => {
        const h10 = Vh(l, s);
        return o()({
          // pass-through
          node: l,
          view: c,
          getPos: u,
          decorations: d,
          innerDecorations: f,
          // tiptap-specific
          editor: e,
          extension: i,
          HTMLAttributes: h10
        });
      };
      return [i.name, a];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((e) => {
      var n;
      this.editor.extensionStorage[e.name] = e.storage;
      const i = {
        name: e.name,
        options: e.options,
        storage: e.storage,
        editor: this.editor,
        type: vf(e.name, this.schema)
      };
      e.type === "mark" && (!((n = qe(we(e, "keepOnSplit", i))) !== null && n !== void 0) || n) && this.splittableMarks.push(e.name);
      const s = we(e, "onBeforeCreate", i), r = we(e, "onCreate", i), o = we(e, "onUpdate", i), a = we(e, "onSelectionUpdate", i), l = we(e, "onTransaction", i), c = we(e, "onFocus", i), u = we(e, "onBlur", i), d = we(e, "onDestroy", i);
      s && this.editor.on("beforeCreate", s), r && this.editor.on("create", r), o && this.editor.on("update", o), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
    });
  }
};
var Vt = class _Vt {
  constructor(e = {}) {
    this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = qe(we(this, "addOptions", {
      name: this.name
    }))), this.storage = qe(we(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new _Vt(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => _d(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new _Vt({ ...this.config, ...e });
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = qe(we(n, "addOptions", {
      name: n.name
    })), n.storage = qe(we(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
};
function Hx(t10, e, n) {
  const { from: i, to: s } = e, { blockSeparator: r = `

`, textSerializers: o = {} } = n || {};
  let a = "";
  return t10.nodesBetween(i, s, (l, c, u, d) => {
    var f;
    l.isBlock && c > i && (a += r);
    const h10 = o == null ? void 0 : o[l.type.name];
    if (h10)
      return u && (a += h10({
        node: l,
        pos: c,
        parent: u,
        index: d,
        range: e
      })), false;
    l.isText && (a += (f = l == null ? void 0 : l.text) === null || f === void 0 ? void 0 : f.slice(Math.max(i, c) - c, s - c));
  }), a;
}
function mm(t10) {
  return Object.fromEntries(Object.entries(t10.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText]));
}
var W7 = Vt.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new It({
        key: new Zt("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t10 } = this, { state: e, schema: n } = t10, { doc: i, selection: s } = e, { ranges: r } = s, o = Math.min(...r.map((u) => u.$from.pos)), a = Math.max(...r.map((u) => u.$to.pos)), l = mm(n);
            return Hx(i, { from: o, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
});
var U7 = () => ({ editor: t10, view: e }) => (requestAnimationFrame(() => {
  var n;
  t10.isDestroyed || (e.dom.blur(), (n = window == null ? void 0 : window.getSelection()) === null || n === void 0 || n.removeAllRanges());
}), true);
var q7 = (t10 = false) => ({ commands: e }) => e.setContent("", t10);
var K7 = () => ({ state: t10, tr: e, dispatch: n }) => {
  const { selection: i } = e, { ranges: s } = i;
  return n && s.forEach(({ $from: r, $to: o }) => {
    t10.doc.nodesBetween(r.pos, o.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: c, mapping: u } = e, d = c.resolve(u.map(l)), f = c.resolve(u.map(l + a.nodeSize)), h10 = d.blockRange(f);
      if (!h10)
        return;
      const p = Xo(h10);
      if (a.type.isTextblock) {
        const { defaultType: g } = d.parent.contentMatchAt(d.index());
        e.setNodeMarkup(h10.start, g);
      }
      (p || p === 0) && e.lift(h10, p);
    });
  }), true;
};
var Y7 = (t10) => (e) => t10(e);
var G7 = () => ({ state: t10, dispatch: e }) => Rx(t10, e);
var J7 = (t10, e) => ({ editor: n, tr: i }) => {
  const { state: s } = n, r = s.doc.slice(t10.from, t10.to);
  i.deleteRange(t10.from, t10.to);
  const o = i.mapping.map(e);
  return i.insert(o, r.content), i.setSelection(new Be(i.doc.resolve(o - 1))), true;
};
var X7 = () => ({ tr: t10, dispatch: e }) => {
  const { selection: n } = t10, i = n.$anchor.node();
  if (i.content.size > 0)
    return false;
  const s = t10.selection.$anchor;
  for (let r = s.depth; r > 0; r -= 1)
    if (s.node(r).type === i.type) {
      if (e) {
        const a = s.before(r), l = s.after(r);
        t10.delete(a, l).scrollIntoView();
      }
      return true;
    }
  return false;
};
var Q7 = (t10) => ({ tr: e, state: n, dispatch: i }) => {
  const s = Kt(t10, n.schema), r = e.selection.$anchor;
  for (let o = r.depth; o > 0; o -= 1)
    if (r.node(o).type === s) {
      if (i) {
        const l = r.before(o), c = r.after(o);
        e.delete(l, c).scrollIntoView();
      }
      return true;
    }
  return false;
};
var Z7 = (t10) => ({ tr: e, dispatch: n }) => {
  const { from: i, to: s } = t10;
  return n && e.delete(i, s), true;
};
var e9 = () => ({ state: t10, dispatch: e }) => lm(t10, e);
var t9 = () => ({ commands: t10 }) => t10.keyboardShortcut("Enter");
var n9 = () => ({ state: t10, dispatch: e }) => p7(t10, e);
function lu(t10, e, n = { strict: true }) {
  const i = Object.keys(e);
  return i.length ? i.every((s) => n.strict ? e[s] === t10[s] : pm(e[s]) ? e[s].test(t10[s]) : e[s] === t10[s]) : true;
}
function Wx(t10, e, n = {}) {
  return t10.find((i) => i.type === e && lu(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((s) => [s, i.attrs[s]])),
    n
  ));
}
function ub(t10, e, n = {}) {
  return !!Wx(t10, e, n);
}
function gm(t10, e, n) {
  var i;
  if (!t10 || !e)
    return;
  let s = t10.parent.childAfter(t10.parentOffset);
  if ((!s.node || !s.node.marks.some((u) => u.type === e)) && (s = t10.parent.childBefore(t10.parentOffset)), !s.node || !s.node.marks.some((u) => u.type === e) || (n = n || ((i = s.node.marks[0]) === null || i === void 0 ? void 0 : i.attrs), !Wx([...s.node.marks], e, n)))
    return;
  let o = s.index, a = t10.start() + s.offset, l = o + 1, c = a + s.node.nodeSize;
  for (; o > 0 && ub([...t10.parent.child(o - 1).marks], e, n); )
    o -= 1, a -= t10.parent.child(o).nodeSize;
  for (; l < t10.parent.childCount && ub([...t10.parent.child(l).marks], e, n); )
    c += t10.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: c
  };
}
function lr(t10, e) {
  if (typeof t10 == "string") {
    if (!e.marks[t10])
      throw Error(`There is no mark type named '${t10}'. Maybe you forgot to add the extension?`);
    return e.marks[t10];
  }
  return t10;
}
var i9 = (t10, e = {}) => ({ tr: n, state: i, dispatch: s }) => {
  const r = lr(t10, i.schema), { doc: o, selection: a } = n, { $from: l, from: c, to: u } = a;
  if (s) {
    const d = gm(l, r, e);
    if (d && d.from <= c && d.to >= u) {
      const f = Be.create(o, d.from, d.to);
      n.setSelection(f);
    }
  }
  return true;
};
var s9 = (t10) => (e) => {
  const n = typeof t10 == "function" ? t10(e) : t10;
  for (let i = 0; i < n.length; i += 1)
    if (n[i](e))
      return true;
  return false;
};
function bm(t10) {
  return t10 instanceof Be;
}
function hs(t10 = 0, e = 0, n = 0) {
  return Math.min(Math.max(t10, e), n);
}
function Ux(t10, e = null) {
  if (!e)
    return null;
  const n = je.atStart(t10), i = je.atEnd(t10);
  if (e === "start" || e === true)
    return n;
  if (e === "end")
    return i;
  const s = n.from, r = i.to;
  return e === "all" ? Be.create(t10, hs(0, s, r), hs(t10.content.size, s, r)) : Be.create(t10, hs(e, s, r), hs(e, s, r));
}
function r9() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function ym() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var o9 = (t10 = null, e = {}) => ({ editor: n, view: i, tr: s, dispatch: r }) => {
  e = {
    scrollIntoView: true,
    ...e
  };
  const o = () => {
    (ym() || r9()) && i.dom.focus(), requestAnimationFrame(() => {
      n.isDestroyed || (i.focus(), e != null && e.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  if (i.hasFocus() && t10 === null || t10 === false)
    return true;
  if (r && t10 === null && !bm(n.state.selection))
    return o(), true;
  const a = Ux(s.doc, t10) || n.state.selection, l = n.state.selection.eq(a);
  return r && (l || s.setSelection(a), l && s.storedMarks && s.setStoredMarks(s.storedMarks), o()), true;
};
var a9 = (t10, e) => (n) => t10.every((i, s) => e(i, { ...n, index: s }));
var l9 = (t10, e) => ({ tr: n, commands: i }) => i.insertContentAt({ from: n.selection.from, to: n.selection.to }, t10, e);
var qx = (t10) => {
  const e = t10.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const i = e[n];
    i.nodeType === 3 && i.nodeValue && /^(\n\s\s|\n)$/.test(i.nodeValue) ? t10.removeChild(i) : i.nodeType === 1 && qx(i);
  }
  return t10;
};
function Gl(t10) {
  const e = `<body>${t10}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return qx(n);
}
function cu(t10, e, n) {
  if (t10 instanceof Hs || t10 instanceof ce)
    return t10;
  n = {
    slice: true,
    parseOptions: {},
    ...n
  };
  const i = typeof t10 == "object" && t10 !== null, s = typeof t10 == "string";
  if (i)
    try {
      if (Array.isArray(t10) && t10.length > 0)
        return ce.fromArray(t10.map((a) => e.nodeFromJSON(a)));
      const o = e.nodeFromJSON(t10);
      return n.errorOnInvalidContent && o.check(), o;
    } catch (r) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: r });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t10, "Error:", r), cu("", e, n);
    }
  if (s) {
    if (n.errorOnInvalidContent) {
      let o = false, a = "";
      const l = new _2({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (o = true, a = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? Ws.fromSchema(l).parseSlice(Gl(t10), n.parseOptions) : Ws.fromSchema(l).parse(Gl(t10), n.parseOptions), n.errorOnInvalidContent && o)
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${a}`) });
    }
    const r = Ws.fromSchema(e);
    return n.slice ? r.parseSlice(Gl(t10), n.parseOptions).content : r.parse(Gl(t10), n.parseOptions);
  }
  return cu("", e, n);
}
function c9(t10, e, n) {
  const i = t10.steps.length - 1;
  if (i < e)
    return;
  const s = t10.steps[i];
  if (!(s instanceof Wt || s instanceof Ut))
    return;
  const r = t10.mapping.maps[i];
  let o = 0;
  r.forEach((a, l, c, u) => {
    o === 0 && (o = u);
  }), t10.setSelection(je.near(t10.doc.resolve(o), n));
}
var u9 = (t10) => !("type" in t10);
var d9 = (t10, e, n) => ({ tr: i, dispatch: s, editor: r }) => {
  var o;
  if (s) {
    n = {
      parseOptions: r.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...n
    };
    let a;
    try {
      a = cu(e, r.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...n.parseOptions
        },
        errorOnInvalidContent: (o = n.errorOnInvalidContent) !== null && o !== void 0 ? o : r.options.enableContentCheck
      });
    } catch (p) {
      return r.emit("contentError", {
        editor: r,
        error: p,
        disableCollaboration: () => {
          r.storage.collaboration && (r.storage.collaboration.isDisabled = true);
        }
      }), false;
    }
    let { from: l, to: c } = typeof t10 == "number" ? { from: t10, to: t10 } : { from: t10.from, to: t10.to }, u = true, d = true;
    if ((u9(a) ? a : [a]).forEach((p) => {
      p.check(), u = u ? p.isText && p.marks.length === 0 : false, d = d ? p.isBlock : false;
    }), l === c && d) {
      const { parent: p } = i.doc.resolve(l);
      p.isTextblock && !p.type.spec.code && !p.childCount && (l -= 1, c += 1);
    }
    let h10;
    if (u) {
      if (Array.isArray(e))
        h10 = e.map((p) => p.text || "").join("");
      else if (e instanceof ce) {
        let p = "";
        e.forEach((g) => {
          g.text && (p += g.text);
        }), h10 = p;
      } else typeof e == "object" && e && e.text ? h10 = e.text : h10 = e;
      i.insertText(h10, l, c);
    } else
      h10 = a, i.replaceWith(l, c, h10);
    n.updateSelection && c9(i, i.steps.length - 1, -1), n.applyInputRules && i.setMeta("applyInputRules", { from: l, text: h10 }), n.applyPasteRules && i.setMeta("applyPasteRules", { from: l, text: h10 });
  }
  return true;
};
var f9 = () => ({ state: t10, dispatch: e }) => d7(t10, e);
var h9 = () => ({ state: t10, dispatch: e }) => f7(t10, e);
var p9 = () => ({ state: t10, dispatch: e }) => _x(t10, e);
var m9 = () => ({ state: t10, dispatch: e }) => Px(t10, e);
var g9 = () => ({ state: t10, dispatch: e, tr: n }) => {
  try {
    const i = xd(t10.doc, t10.selection.$from.pos, -1);
    return i == null ? false : (n.join(i, 2), e && e(n), true);
  } catch {
    return false;
  }
};
var b9 = () => ({ state: t10, dispatch: e, tr: n }) => {
  try {
    const i = xd(t10.doc, t10.selection.$from.pos, 1);
    return i == null ? false : (n.join(i, 2), e && e(n), true);
  } catch {
    return false;
  }
};
var y9 = () => ({ state: t10, dispatch: e }) => c7(t10, e);
var v9 = () => ({ state: t10, dispatch: e }) => u7(t10, e);
function Kx() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : false;
}
function x9(t10) {
  const e = t10.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let i, s, r, o;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = true;
    else if (/^a(lt)?$/i.test(l))
      i = true;
    else if (/^(c|ctrl|control)$/i.test(l))
      s = true;
    else if (/^s(hift)?$/i.test(l))
      r = true;
    else if (/^mod$/i.test(l))
      ym() || Kx() ? o = true : s = true;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return i && (n = `Alt-${n}`), s && (n = `Ctrl-${n}`), o && (n = `Meta-${n}`), r && (n = `Shift-${n}`), n;
}
var k9 = (t10) => ({ editor: e, view: n, tr: i, dispatch: s }) => {
  const r = x9(t10).split(/-(?!$)/), o = r.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), a = new KeyboardEvent("keydown", {
    key: o === "Space" ? " " : o,
    altKey: r.includes("Alt"),
    ctrlKey: r.includes("Ctrl"),
    metaKey: r.includes("Meta"),
    shiftKey: r.includes("Shift"),
    bubbles: true,
    cancelable: true
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, a));
  });
  return l == null || l.steps.forEach((c) => {
    const u = c.map(i.mapping);
    u && s && i.maybeStep(u);
  }), true;
};
function cl(t10, e, n = {}) {
  const { from: i, to: s, empty: r } = t10.selection, o = e ? Kt(e, t10.schema) : null, a = [];
  t10.doc.nodesBetween(i, s, (d, f) => {
    if (d.isText)
      return;
    const h10 = Math.max(i, f), p = Math.min(s, f + d.nodeSize);
    a.push({
      node: d,
      from: h10,
      to: p
    });
  });
  const l = s - i, c = a.filter((d) => o ? o.name === d.node.type.name : true).filter((d) => lu(d.node.attrs, n, { strict: false }));
  return r ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l;
}
var S9 = (t10, e = {}) => ({ state: n, dispatch: i }) => {
  const s = Kt(t10, n.schema);
  return cl(n, s, e) ? h7(n, i) : false;
};
var w9 = () => ({ state: t10, dispatch: e }) => Fx(t10, e);
var C9 = (t10) => ({ state: e, dispatch: n }) => {
  const i = Kt(t10, e.schema);
  return O7(i)(e, n);
};
var O9 = () => ({ state: t10, dispatch: e }) => $x(t10, e);
function Nd(t10, e) {
  return e.nodes[t10] ? "node" : e.marks[t10] ? "mark" : null;
}
function db(t10, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t10).reduce((i, s) => (n.includes(s) || (i[s] = t10[s]), i), {});
}
var E9 = (t10, e) => ({ tr: n, state: i, dispatch: s }) => {
  let r = null, o = null;
  const a = Nd(typeof t10 == "string" ? t10 : t10.name, i.schema);
  return a ? (a === "node" && (r = Kt(t10, i.schema)), a === "mark" && (o = lr(t10, i.schema)), s && n.selection.ranges.forEach((l) => {
    i.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
      r && r === c.type && n.setNodeMarkup(u, void 0, db(c.attrs, e)), o && c.marks.length && c.marks.forEach((d) => {
        o === d.type && n.addMark(u, u + c.nodeSize, o.create(db(d.attrs, e)));
      });
    });
  }), true) : false;
};
var M9 = () => ({ tr: t10, dispatch: e }) => (e && t10.scrollIntoView(), true);
var T9 = () => ({ tr: t10, dispatch: e }) => {
  if (e) {
    const n = new Yn(t10.doc);
    t10.setSelection(n);
  }
  return true;
};
var A9 = () => ({ state: t10, dispatch: e }) => Lx(t10, e);
var _9 = () => ({ state: t10, dispatch: e }) => Dx(t10, e);
var N9 = () => ({ state: t10, dispatch: e }) => b7(t10, e);
var L9 = () => ({ state: t10, dispatch: e }) => x7(t10, e);
var I9 = () => ({ state: t10, dispatch: e }) => v7(t10, e);
function Bh(t10, e, n = {}, i = {}) {
  return cu(t10, e, {
    slice: false,
    parseOptions: n,
    errorOnInvalidContent: i.errorOnInvalidContent
  });
}
var P9 = (t10, e = false, n = {}, i = {}) => ({ editor: s, tr: r, dispatch: o, commands: a }) => {
  var l, c;
  const { doc: u } = r;
  if (n.preserveWhitespace !== "full") {
    const d = Bh(t10, s.schema, n, {
      errorOnInvalidContent: (l = i.errorOnInvalidContent) !== null && l !== void 0 ? l : s.options.enableContentCheck
    });
    return o && r.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !e), true;
  }
  return o && r.setMeta("preventUpdate", !e), a.insertContentAt({ from: 0, to: u.content.size }, t10, {
    parseOptions: n,
    errorOnInvalidContent: (c = i.errorOnInvalidContent) !== null && c !== void 0 ? c : s.options.enableContentCheck
  });
};
function Yx(t10, e) {
  const n = lr(e, t10.schema), { from: i, to: s, empty: r } = t10.selection, o = [];
  r ? (t10.storedMarks && o.push(...t10.storedMarks), o.push(...t10.selection.$head.marks())) : t10.doc.nodesBetween(i, s, (l) => {
    o.push(...l.marks);
  });
  const a = o.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function D9(t10, e) {
  const n = new q2(t10);
  return e.forEach((i) => {
    i.steps.forEach((s) => {
      n.step(s);
    });
  }), n;
}
function $9(t10) {
  for (let e = 0; e < t10.edgeCount; e += 1) {
    const { type: n } = t10.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function R9(t10, e, n) {
  const i = [];
  return t10.nodesBetween(e.from, e.to, (s, r) => {
    n(s) && i.push({
      node: s,
      pos: r
    });
  }), i;
}
function F9(t10, e) {
  for (let n = t10.depth; n > 0; n -= 1) {
    const i = t10.node(n);
    if (e(i))
      return {
        pos: n > 0 ? t10.before(n) : 0,
        start: t10.start(n),
        depth: n,
        node: i
      };
  }
}
function vm(t10) {
  return (e) => F9(e.$from, t10);
}
function Gx(t10, e) {
  const n = {
    from: 0,
    to: t10.content.size
  };
  return Hx(t10, n, e);
}
function V9(t10, e) {
  const n = Kt(e, t10.schema), { from: i, to: s } = t10.selection, r = [];
  t10.doc.nodesBetween(i, s, (a) => {
    r.push(a);
  });
  const o = r.reverse().find((a) => a.type.name === n.name);
  return o ? { ...o.attrs } : {};
}
function Jx(t10, e) {
  const n = Nd(typeof e == "string" ? e : e.name, t10.schema);
  return n === "node" ? V9(t10, e) : n === "mark" ? Yx(t10, e) : {};
}
function B9(t10, e = JSON.stringify) {
  const n = {};
  return t10.filter((i) => {
    const s = e(i);
    return Object.prototype.hasOwnProperty.call(n, s) ? false : n[s] = true;
  });
}
function z9(t10) {
  const e = B9(t10);
  return e.length === 1 ? e : e.filter((n, i) => !e.filter((r, o) => o !== i).some((r) => n.oldRange.from >= r.oldRange.from && n.oldRange.to <= r.oldRange.to && n.newRange.from >= r.newRange.from && n.newRange.to <= r.newRange.to));
}
function j9(t10) {
  const { mapping: e, steps: n } = t10, i = [];
  return e.maps.forEach((s, r) => {
    const o = [];
    if (s.ranges.length)
      s.forEach((a, l) => {
        o.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[r];
      if (a === void 0 || l === void 0)
        return;
      o.push({ from: a, to: l });
    }
    o.forEach(({ from: a, to: l }) => {
      const c = e.slice(r).map(a, -1), u = e.slice(r).map(l), d = e.invert().map(c, -1), f = e.invert().map(u);
      i.push({
        oldRange: {
          from: d,
          to: f
        },
        newRange: {
          from: c,
          to: u
        }
      });
    });
  }), z9(i);
}
function xm(t10, e, n) {
  const i = [];
  return t10 === e ? n.resolve(t10).marks().forEach((s) => {
    const r = n.resolve(t10), o = gm(r, s.type);
    o && i.push({
      mark: s,
      ...o
    });
  }) : n.nodesBetween(t10, e, (s, r) => {
    !s || (s == null ? void 0 : s.nodeSize) === void 0 || i.push(...s.marks.map((o) => ({
      from: r,
      to: r + s.nodeSize,
      mark: o
    })));
  }), i;
}
function Oc(t10, e, n) {
  return Object.fromEntries(Object.entries(n).filter(([i]) => {
    const s = t10.find((r) => r.type === e && r.name === i);
    return s ? s.attribute.keepOnSplit : false;
  }));
}
function zh(t10, e, n = {}) {
  const { empty: i, ranges: s } = t10.selection, r = e ? lr(e, t10.schema) : null;
  if (i)
    return !!(t10.storedMarks || t10.selection.$from.marks()).filter((d) => r ? r.name === d.type.name : true).find((d) => lu(d.attrs, n, { strict: false }));
  let o = 0;
  const a = [];
  if (s.forEach(({ $from: d, $to: f }) => {
    const h10 = d.pos, p = f.pos;
    t10.doc.nodesBetween(h10, p, (g, m) => {
      if (!g.isText && !g.marks.length)
        return;
      const b = Math.max(h10, m), x = Math.min(p, m + g.nodeSize), k = x - b;
      o += k, a.push(...g.marks.map((v) => ({
        mark: v,
        from: b,
        to: x
      })));
    });
  }), o === 0)
    return false;
  const l = a.filter((d) => r ? r.name === d.mark.type.name : true).filter((d) => lu(d.mark.attrs, n, { strict: false })).reduce((d, f) => d + f.to - f.from, 0), c = a.filter((d) => r ? d.mark.type !== r && d.mark.type.excludes(r) : true).reduce((d, f) => d + f.to - f.from, 0);
  return (l > 0 ? l + c : l) >= o;
}
function H9(t10, e, n = {}) {
  if (!e)
    return cl(t10, null, n) || zh(t10, null, n);
  const i = Nd(e, t10.schema);
  return i === "node" ? cl(t10, e, n) : i === "mark" ? zh(t10, e, n) : false;
}
function fb(t10, e) {
  const { nodeExtensions: n } = Td(e), i = n.find((o) => o.name === t10);
  if (!i)
    return false;
  const s = {
    name: i.name,
    options: i.options,
    storage: i.storage
  }, r = qe(we(i, "group", s));
  return typeof r != "string" ? false : r.split(" ").includes("list");
}
function Ld(t10, { checkChildren: e = true, ignoreWhitespace: n = false } = {}) {
  var i;
  if (n) {
    if (t10.type.name === "hardBreak")
      return true;
    if (t10.isText)
      return /^\s*$/m.test((i = t10.text) !== null && i !== void 0 ? i : "");
  }
  if (t10.isText)
    return !t10.text;
  if (t10.isAtom || t10.isLeaf)
    return false;
  if (t10.content.childCount === 0)
    return true;
  if (e) {
    let s = true;
    return t10.content.forEach((r) => {
      s !== false && (Ld(r, { ignoreWhitespace: n, checkChildren: e }) || (s = false));
    }), s;
  }
  return false;
}
function Xx(t10) {
  return t10 instanceof Pe;
}
function Qx(t10, e, n) {
  const s = t10.state.doc.content.size, r = hs(e, 0, s), o = hs(n, 0, s), a = t10.coordsAtPos(r), l = t10.coordsAtPos(o, -1), c = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), f = Math.max(a.right, l.right), h10 = f - d, p = u - c, b = {
    top: c,
    bottom: u,
    left: d,
    right: f,
    width: h10,
    height: p,
    x: d,
    y: c
  };
  return {
    ...b,
    toJSON: () => b
  };
}
function W9(t10, e, n) {
  var i;
  const { selection: s } = e;
  let r = null;
  if (bm(s) && (r = s.$cursor), r) {
    const a = (i = t10.storedMarks) !== null && i !== void 0 ? i : r.marks();
    return !!n.isInSet(a) || !a.some((l) => l.type.excludes(n));
  }
  const { ranges: o } = s;
  return o.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? t10.doc.inlineContent && t10.doc.type.allowsMarkType(n) : false;
    return t10.doc.nodesBetween(a.pos, l.pos, (u, d, f) => {
      if (c)
        return false;
      if (u.isInline) {
        const h10 = !f || f.type.allowsMarkType(n), p = !!n.isInSet(u.marks) || !u.marks.some((g) => g.type.excludes(n));
        c = h10 && p;
      }
      return !c;
    }), c;
  });
}
var U9 = (t10, e = {}) => ({ tr: n, state: i, dispatch: s }) => {
  const { selection: r } = n, { empty: o, ranges: a } = r, l = lr(t10, i.schema);
  if (s)
    if (o) {
      const c = Yx(i, l);
      n.addStoredMark(l.create({
        ...c,
        ...e
      }));
    } else
      a.forEach((c) => {
        const u = c.$from.pos, d = c.$to.pos;
        i.doc.nodesBetween(u, d, (f, h10) => {
          const p = Math.max(h10, u), g = Math.min(h10 + f.nodeSize, d);
          f.marks.find((b) => b.type === l) ? f.marks.forEach((b) => {
            l === b.type && n.addMark(p, g, l.create({
              ...b.attrs,
              ...e
            }));
          }) : n.addMark(p, g, l.create(e));
        });
      });
  return W9(i, n, l);
};
var q9 = (t10, e) => ({ tr: n }) => (n.setMeta(t10, e), true);
var K9 = (t10, e = {}) => ({ state: n, dispatch: i, chain: s }) => {
  const r = Kt(t10, n.schema);
  let o;
  return n.selection.$anchor.sameParent(n.selection.$head) && (o = n.selection.$anchor.parent.attrs), r.isTextblock ? s().command(({ commands: a }) => ob(r, { ...o, ...e })(n) ? true : a.clearNodes()).command(({ state: a }) => ob(r, { ...o, ...e })(a, i)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), false);
};
var Y9 = (t10) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: i } = e, s = hs(t10, 0, i.content.size), r = Pe.create(i, s);
    e.setSelection(r);
  }
  return true;
};
var G9 = (t10) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: i } = e, { from: s, to: r } = typeof t10 == "number" ? { from: t10, to: t10 } : t10, o = Be.atStart(i).from, a = Be.atEnd(i).to, l = hs(s, o, a), c = hs(r, o, a), u = Be.create(i, l, c);
    e.setSelection(u);
  }
  return true;
};
var J9 = (t10) => ({ state: e, dispatch: n }) => {
  const i = Kt(t10, e.schema);
  return T7(i)(e, n);
};
function hb(t10, e) {
  const n = t10.storedMarks || t10.selection.$to.parentOffset && t10.selection.$from.marks();
  if (n) {
    const i = n.filter((s) => e == null ? void 0 : e.includes(s.type.name));
    t10.tr.ensureMarks(i);
  }
}
var X9 = ({ keepMarks: t10 = true } = {}) => ({ tr: e, state: n, dispatch: i, editor: s }) => {
  const { selection: r, doc: o } = e, { $from: a, $to: l } = r, c = s.extensionManager.attributes, u = Oc(c, a.node().type.name, a.node().attrs);
  if (r instanceof Pe && r.node.isBlock)
    return !a.parentOffset || !bs(o, a.pos) ? false : (i && (t10 && hb(n, s.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), true);
  if (!a.parent.isBlock)
    return false;
  const d = l.parentOffset === l.parent.content.size, f = a.depth === 0 ? void 0 : $9(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let h10 = d && f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0, p = bs(e.doc, e.mapping.map(a.pos), 1, h10);
  if (!h10 && !p && bs(e.doc, e.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (p = true, h10 = f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0), i) {
    if (p && (r instanceof Be && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, h10), f && !d && !a.parentOffset && a.parent.type !== f)) {
      const g = e.mapping.map(a.before()), m = e.doc.resolve(g);
      a.node(-1).canReplaceWith(m.index(), m.index() + 1, f) && e.setNodeMarkup(e.mapping.map(a.before()), f);
    }
    t10 && hb(n, s.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return p;
};
var Q9 = (t10, e = {}) => ({ tr: n, state: i, dispatch: s, editor: r }) => {
  var o;
  const a = Kt(t10, i.schema), { $from: l, $to: c } = i.selection, u = i.selection.node;
  if (u && u.isBlock || l.depth < 2 || !l.sameParent(c))
    return false;
  const d = l.node(-1);
  if (d.type !== a)
    return false;
  const f = r.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return false;
    if (s) {
      let b = ce.empty;
      const x = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let M = l.depth - x; M >= l.depth - 3; M -= 1)
        b = ce.from(l.node(M).copy(b));
      const k = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, v = {
        ...Oc(f, l.node().type.name, l.node().attrs),
        ...e
      }, S = ((o = a.contentMatch.defaultType) === null || o === void 0 ? void 0 : o.createAndFill(v)) || void 0;
      b = b.append(ce.from(a.createAndFill(null, S) || void 0));
      const w = l.before(l.depth - (x - 1));
      n.replace(w, l.after(-k), new ke(b, 4 - x, 0));
      let E = -1;
      n.doc.nodesBetween(w, n.doc.content.size, (M, N) => {
        if (E > -1)
          return false;
        M.isTextblock && M.content.size === 0 && (E = N + 1);
      }), E > -1 && n.setSelection(Be.near(n.doc.resolve(E))), n.scrollIntoView();
    }
    return true;
  }
  const h10 = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null, p = {
    ...Oc(f, d.type.name, d.attrs),
    ...e
  }, g = {
    ...Oc(f, l.node().type.name, l.node().attrs),
    ...e
  };
  n.delete(l.pos, c.pos);
  const m = h10 ? [
    { type: a, attrs: p },
    { type: h10, attrs: g }
  ] : [{ type: a, attrs: p }];
  if (!bs(n.doc, l.pos, 2))
    return false;
  if (s) {
    const { selection: b, storedMarks: x } = i, { splittableMarks: k } = r.extensionManager, v = x || b.$to.parentOffset && b.$from.marks();
    if (n.split(l.pos, 2, m).scrollIntoView(), !v || !s)
      return true;
    const S = v.filter((w) => k.includes(w.type.name));
    n.ensureMarks(S);
  }
  return true;
};
var xf = (t10, e) => {
  const n = vm((o) => o.type === e)(t10.selection);
  if (!n)
    return true;
  const i = t10.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (i === void 0)
    return true;
  const s = t10.doc.nodeAt(i);
  return n.node.type === (s == null ? void 0 : s.type) && or(t10.doc, n.pos) && t10.join(n.pos), true;
};
var kf = (t10, e) => {
  const n = vm((o) => o.type === e)(t10.selection);
  if (!n)
    return true;
  const i = t10.doc.resolve(n.start).after(n.depth);
  if (i === void 0)
    return true;
  const s = t10.doc.nodeAt(i);
  return n.node.type === (s == null ? void 0 : s.type) && or(t10.doc, i) && t10.join(i), true;
};
var Z9 = (t10, e, n, i = {}) => ({ editor: s, tr: r, state: o, dispatch: a, chain: l, commands: c, can: u }) => {
  const { extensions: d, splittableMarks: f } = s.extensionManager, h10 = Kt(t10, o.schema), p = Kt(e, o.schema), { selection: g, storedMarks: m } = o, { $from: b, $to: x } = g, k = b.blockRange(x), v = m || g.$to.parentOffset && g.$from.marks();
  if (!k)
    return false;
  const S = vm((w) => fb(w.type.name, d))(g);
  if (k.depth >= 1 && S && k.depth - S.depth <= 1) {
    if (S.node.type === h10)
      return c.liftListItem(p);
    if (fb(S.node.type.name, d) && h10.validContent(S.node.content) && a)
      return l().command(() => (r.setNodeMarkup(S.pos, h10), true)).command(() => xf(r, h10)).command(() => kf(r, h10)).run();
  }
  return !n || !v || !a ? l().command(() => u().wrapInList(h10, i) ? true : c.clearNodes()).wrapInList(h10, i).command(() => xf(r, h10)).command(() => kf(r, h10)).run() : l().command(() => {
    const w = u().wrapInList(h10, i), E = v.filter((M) => f.includes(M.type.name));
    return r.ensureMarks(E), w ? true : c.clearNodes();
  }).wrapInList(h10, i).command(() => xf(r, h10)).command(() => kf(r, h10)).run();
};
var eF = (t10, e = {}, n = {}) => ({ state: i, commands: s }) => {
  const { extendEmptyMarkRange: r = false } = n, o = lr(t10, i.schema);
  return zh(i, o, e) ? s.unsetMark(o, { extendEmptyMarkRange: r }) : s.setMark(o, e);
};
var tF = (t10, e, n = {}) => ({ state: i, commands: s }) => {
  const r = Kt(t10, i.schema), o = Kt(e, i.schema), a = cl(i, r, n);
  let l;
  return i.selection.$anchor.sameParent(i.selection.$head) && (l = i.selection.$anchor.parent.attrs), a ? s.setNode(o, l) : s.setNode(r, { ...l, ...n });
};
var nF = (t10, e = {}) => ({ state: n, commands: i }) => {
  const s = Kt(t10, n.schema);
  return cl(n, s, e) ? i.lift(s) : i.wrapIn(s, e);
};
var iF = () => ({ state: t10, dispatch: e }) => {
  const n = t10.plugins;
  for (let i = 0; i < n.length; i += 1) {
    const s = n[i];
    let r;
    if (s.spec.isInputRules && (r = s.getState(t10))) {
      if (e) {
        const o = t10.tr, a = r.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          o.step(a.steps[l].invert(a.docs[l]));
        if (r.text) {
          const l = o.doc.resolve(r.from).marks();
          o.replaceWith(r.from, r.to, t10.schema.text(r.text, l));
        } else
          o.delete(r.from, r.to);
      }
      return true;
    }
  }
  return false;
};
var sF = () => ({ tr: t10, dispatch: e }) => {
  const { selection: n } = t10, { empty: i, ranges: s } = n;
  return i || e && s.forEach((r) => {
    t10.removeMark(r.$from.pos, r.$to.pos);
  }), true;
};
var rF = (t10, e = {}) => ({ tr: n, state: i, dispatch: s }) => {
  var r;
  const { extendEmptyMarkRange: o = false } = e, { selection: a } = n, l = lr(t10, i.schema), { $from: c, empty: u, ranges: d } = a;
  if (!s)
    return true;
  if (u && o) {
    let { from: f, to: h10 } = a;
    const p = (r = c.marks().find((m) => m.type === l)) === null || r === void 0 ? void 0 : r.attrs, g = gm(c, l, p);
    g && (f = g.from, h10 = g.to), n.removeMark(f, h10, l);
  } else
    d.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return n.removeStoredMark(l), true;
};
var oF = (t10, e = {}) => ({ tr: n, state: i, dispatch: s }) => {
  let r = null, o = null;
  const a = Nd(typeof t10 == "string" ? t10 : t10.name, i.schema);
  return a ? (a === "node" && (r = Kt(t10, i.schema)), a === "mark" && (o = lr(t10, i.schema)), s && n.selection.ranges.forEach((l) => {
    const c = l.$from.pos, u = l.$to.pos;
    let d, f, h10, p;
    n.selection.empty ? i.doc.nodesBetween(c, u, (g, m) => {
      r && r === g.type && (h10 = Math.max(m, c), p = Math.min(m + g.nodeSize, u), d = m, f = g);
    }) : i.doc.nodesBetween(c, u, (g, m) => {
      m < c && r && r === g.type && (h10 = Math.max(m, c), p = Math.min(m + g.nodeSize, u), d = m, f = g), m >= c && m <= u && (r && r === g.type && n.setNodeMarkup(m, void 0, {
        ...g.attrs,
        ...e
      }), o && g.marks.length && g.marks.forEach((b) => {
        if (o === b.type) {
          const x = Math.max(m, c), k = Math.min(m + g.nodeSize, u);
          n.addMark(x, k, o.create({
            ...b.attrs,
            ...e
          }));
        }
      }));
    }), f && (d !== void 0 && n.setNodeMarkup(d, void 0, {
      ...f.attrs,
      ...e
    }), o && f.marks.length && f.marks.forEach((g) => {
      o === g.type && n.addMark(h10, p, o.create({
        ...g.attrs,
        ...e
      }));
    }));
  }), true) : false;
};
var aF = (t10, e = {}) => ({ state: n, dispatch: i }) => {
  const s = Kt(t10, n.schema);
  return k7(s, e)(n, i);
};
var lF = (t10, e = {}) => ({ state: n, dispatch: i }) => {
  const s = Kt(t10, n.schema);
  return S7(s, e)(n, i);
};
var cF = Object.freeze({
  __proto__: null,
  blur: U7,
  clearContent: q7,
  clearNodes: K7,
  command: Y7,
  createParagraphNear: G7,
  cut: J7,
  deleteCurrentNode: X7,
  deleteNode: Q7,
  deleteRange: Z7,
  deleteSelection: e9,
  enter: t9,
  exitCode: n9,
  extendMarkRange: i9,
  first: s9,
  focus: o9,
  forEach: a9,
  insertContent: l9,
  insertContentAt: d9,
  joinBackward: p9,
  joinDown: h9,
  joinForward: m9,
  joinItemBackward: g9,
  joinItemForward: b9,
  joinTextblockBackward: y9,
  joinTextblockForward: v9,
  joinUp: f9,
  keyboardShortcut: k9,
  lift: S9,
  liftEmptyBlock: w9,
  liftListItem: C9,
  newlineInCode: O9,
  resetAttributes: E9,
  scrollIntoView: M9,
  selectAll: T9,
  selectNodeBackward: A9,
  selectNodeForward: _9,
  selectParentNode: N9,
  selectTextblockEnd: L9,
  selectTextblockStart: I9,
  setContent: P9,
  setMark: U9,
  setMeta: q9,
  setNode: K9,
  setNodeSelection: Y9,
  setTextSelection: G9,
  sinkListItem: J9,
  splitBlock: X9,
  splitListItem: Q9,
  toggleList: Z9,
  toggleMark: eF,
  toggleNode: tF,
  toggleWrap: nF,
  undoInputRule: iF,
  unsetAllMarks: sF,
  unsetMark: rF,
  updateAttributes: oF,
  wrapIn: aF,
  wrapInList: lF
});
var uF = Vt.create({
  name: "commands",
  addCommands() {
    return {
      ...cF
    };
  }
});
var dF = Vt.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new It({
        key: new Zt("tiptapDrop"),
        props: {
          handleDrop: (t10, e, n, i) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: n,
              moved: i
            });
          }
        }
      })
    ];
  }
});
var fF = Vt.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new It({
        key: new Zt("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var hF = Vt.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t10 } = this;
    return [
      new It({
        key: new Zt("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t10.isFocused = true;
              const i = t10.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", false);
              return e.dispatch(i), false;
            },
            blur: (e, n) => {
              t10.isFocused = false;
              const i = t10.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", false);
              return e.dispatch(i), false;
            }
          }
        }
      })
    ];
  }
});
var pF = Vt.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t10 = () => this.editor.commands.first(({ commands: o }) => [
      () => o.undoInputRule(),
      // maybe convert first text block node to default node
      () => o.command(({ tr: a }) => {
        const { selection: l, doc: c } = a, { empty: u, $anchor: d } = l, { pos: f, parent: h10 } = d, p = d.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : d, g = p.parent.type.spec.isolating, m = d.pos - d.parentOffset, b = g && p.parent.childCount === 1 ? m === d.pos : je.atStart(c).from === f;
        return !u || !h10.type.isTextblock || h10.textContent.length || !b || b && d.parent.type.name === "paragraph" ? false : o.clearNodes();
      }),
      () => o.deleteSelection(),
      () => o.joinBackward(),
      () => o.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: o }) => [
      () => o.deleteSelection(),
      () => o.deleteCurrentNode(),
      () => o.joinForward(),
      () => o.selectNodeForward()
    ]), i = {
      Enter: () => this.editor.commands.first(({ commands: o }) => [
        () => o.newlineInCode(),
        () => o.createParagraphNear(),
        () => o.liftEmptyBlock(),
        () => o.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t10,
      "Mod-Backspace": t10,
      "Shift-Backspace": t10,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, s = {
      ...i
    }, r = {
      ...i,
      "Ctrl-h": t10,
      "Alt-Backspace": t10,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return ym() || Kx() ? r : s;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new It({
        key: new Zt("clearDocument"),
        appendTransaction: (t10, e, n) => {
          if (t10.some((g) => g.getMeta("composition")))
            return;
          const i = t10.some((g) => g.docChanged) && !e.doc.eq(n.doc), s = t10.some((g) => g.getMeta("preventClearDocument"));
          if (!i || s)
            return;
          const { empty: r, from: o, to: a } = e.selection, l = je.atStart(e.doc).from, c = je.atEnd(e.doc).to;
          if (r || !(o === l && a === c) || !Ld(n.doc))
            return;
          const f = n.tr, h10 = Ed({
            state: n,
            transaction: f
          }), { commands: p } = new Md({
            editor: this.editor,
            state: h10
          });
          if (p.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
});
var mF = Vt.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new It({
        key: new Zt("tiptapPaste"),
        props: {
          handlePaste: (t10, e, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: n
            });
          }
        }
      })
    ];
  }
});
var gF = Vt.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new It({
        key: new Zt("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var Or = class _Or {
  get name() {
    return this.node.type.name;
  }
  constructor(e, n, i = false, s = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = i, this.resolvedPos = e, this.editor = n, this.currentNode = s;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, i = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, i = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: i }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new _Or(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new _Or(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new _Or(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, i) => {
      const s = n.isBlock && !n.isTextblock, r = n.isAtom && !n.isText, o = this.pos + i + (r ? 0 : 1), a = this.resolvedPos.doc.resolve(o);
      if (!s && a.depth <= this.depth)
        return;
      const l = new _Or(a, this.editor, s, s ? n : null);
      s && (l.actualDepth = this.depth + 1), e.push(new _Or(a, this.editor, s, s ? n : null));
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let i = null, s = this.parent;
    for (; s && !i; ) {
      if (s.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const r = s.node.attrs, o = Object.keys(n);
          for (let a = 0; a < o.length; a += 1) {
            const l = o[a];
            if (r[l] !== n[l])
              break;
          }
        } else
          i = s;
      s = s.parent;
    }
    return i;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, true)[0] || null;
  }
  querySelectorAll(e, n = {}, i = false) {
    let s = [];
    if (!this.children || this.children.length === 0)
      return s;
    const r = Object.keys(n);
    return this.children.forEach((o) => {
      i && s.length > 0 || (o.node.type.name === e && r.every((l) => n[l] === o.node.attrs[l]) && s.push(o), !(i && s.length > 0) && (s = s.concat(o.querySelectorAll(e, n, i))));
    }), s;
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(n);
  }
};
var bF = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function yF(t10, e, n) {
  const i = document.querySelector("style[data-tiptap-style]");
  if (i !== null)
    return i;
  const s = document.createElement("style");
  return e && s.setAttribute("nonce", e), s.setAttribute("data-tiptap-style", ""), s.innerHTML = t10, document.getElementsByTagName("head")[0].appendChild(s), s;
}
var vF = class extends A7 {
  constructor(e = {}) {
    super(), this.isFocused = false, this.isInitialized = false, this.extensionStorage = {}, this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: n }) => {
        throw n;
      },
      onPaste: () => null,
      onDrop: () => null
    }, this.isCapturingTransaction = false, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: n, slice: i, moved: s }) => this.options.onDrop(n, i, s)), this.on("paste", ({ event: n, slice: i }) => this.options.onPaste(n, i)), window.setTimeout(() => {
      this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = true);
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && document && (this.css = yF(bF, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(e = {}) {
    this.options = {
      ...this.options,
      ...e
    }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(e, n = true) {
    this.setOptions({ editable: e }), n && this.emit("update", { editor: this, transaction: this.state.tr });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(e, n) {
    const i = jx(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e], s = this.state.reconfigure({ plugins: i });
    return this.view.updateState(s), s;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(e) {
    if (this.isDestroyed)
      return;
    const n = this.state.plugins;
    let i = n;
    if ([].concat(e).forEach((r) => {
      const o = typeof r == "string" ? `${r}$` : r.key;
      i = n.filter((a) => !a.key.startsWith(o));
    }), n.length === i.length)
      return;
    const s = this.state.reconfigure({
      plugins: i
    });
    return this.view.updateState(s), s;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var e, n;
    const s = [...this.options.enableCoreExtensions ? [
      fF,
      W7.configure({
        blockSeparator: (n = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || n === void 0 ? void 0 : n.blockSeparator
      }),
      uF,
      hF,
      pF,
      gF,
      dF,
      mF
    ].filter((r) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[r.name] !== false : true) : [], ...this.options.extensions].filter((r) => ["extension", "node", "mark"].includes(r == null ? void 0 : r.type));
    this.extensionManager = new xo(s, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new Md({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var e;
    let n;
    try {
      n = Bh(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (o) {
      if (!(o instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(o.message))
        throw o;
      this.emit("contentError", {
        editor: this,
        error: o,
        disableCollaboration: () => {
          this.storage.collaboration && (this.storage.collaboration.isDisabled = true), this.options.extensions = this.options.extensions.filter((a) => a.name !== "collaboration"), this.createExtensionManager();
        }
      }), n = Bh(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
    }
    const i = Ux(n, this.options.autofocus);
    this.view = new ZR(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: vo.create({
        doc: n,
        selection: i || void 0
      })
    });
    const s = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(s), this.createNodeViews(), this.prependClass();
    const r = this.view.dom;
    r.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(e) {
    this.isCapturingTransaction = true, e(), this.isCapturingTransaction = false;
    const n = this.capturedTransaction;
    return this.capturedTransaction = null, n;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(e) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = e;
        return;
      }
      e.steps.forEach((o) => {
        var a;
        return (a = this.capturedTransaction) === null || a === void 0 ? void 0 : a.step(o);
      });
      return;
    }
    const n = this.state.apply(e), i = !this.state.selection.eq(n.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction: e,
      nextState: n
    }), this.view.updateState(n), this.emit("transaction", {
      editor: this,
      transaction: e
    }), i && this.emit("selectionUpdate", {
      editor: this,
      transaction: e
    });
    const s = e.getMeta("focus"), r = e.getMeta("blur");
    s && this.emit("focus", {
      editor: this,
      event: s.event,
      transaction: e
    }), r && this.emit("blur", {
      editor: this,
      event: r.event,
      transaction: e
    }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", {
      editor: this,
      transaction: e
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(e) {
    return Jx(this.state, e);
  }
  isActive(e, n) {
    const i = typeof e == "string" ? e : null, s = typeof e == "string" ? n : e;
    return H9(this.state, i, s);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return hm(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(e) {
    const { blockSeparator: n = `

`, textSerializers: i = {} } = e || {};
    return Gx(this.state.doc, {
      blockSeparator: n,
      textSerializers: {
        ...mm(this.schema),
        ...i
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return Ld(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    if (this.emit("destroy"), this.view) {
      const e = this.view.dom;
      e && e.editor && delete e.editor, this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var e;
    return !(!((e = this.view) === null || e === void 0) && e.docView);
  }
  $node(e, n) {
    var i;
    return ((i = this.$doc) === null || i === void 0 ? void 0 : i.querySelector(e, n)) || null;
  }
  $nodes(e, n) {
    var i;
    return ((i = this.$doc) === null || i === void 0 ? void 0 : i.querySelectorAll(e, n)) || null;
  }
  $pos(e) {
    const n = this.state.doc.resolve(e);
    return new Or(n, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function Jr(t10) {
  return new Ad({
    find: t10.find,
    handler: ({ state: e, range: n, match: i }) => {
      const s = qe(t10.getAttributes, void 0, i);
      if (s === false || s === null)
        return null;
      const { tr: r } = e, o = i[i.length - 1], a = i[0];
      if (o) {
        const l = a.search(/\S/), c = n.from + a.indexOf(o), u = c + o.length;
        if (xm(n.from, n.to, e.doc).filter((h10) => h10.mark.type.excluded.find((g) => g === t10.type && g !== h10.mark.type)).filter((h10) => h10.to > c).length)
          return null;
        u < n.to && r.delete(u, n.to), c > n.from && r.delete(n.from + l, c);
        const f = n.from + l + o.length;
        r.addMark(n.from + l, f, t10.type.create(s || {})), r.removeStoredMark(t10.type);
      }
    }
  });
}
function Id(t10) {
  return new Ad({
    find: t10.find,
    handler: ({ state: e, range: n, match: i }) => {
      const s = qe(t10.getAttributes, void 0, i) || {}, { tr: r } = e, o = n.from;
      let a = n.to;
      const l = t10.type.create(s);
      if (i[1]) {
        const c = i[0].lastIndexOf(i[1]);
        let u = o + c;
        u > a ? u = a : a = u + i[1].length;
        const d = i[0][i[0].length - 1];
        r.insertText(d, o + i[0].length - 1), r.replaceWith(u, a, l);
      } else if (i[0]) {
        const c = t10.type.isInline ? o : o - 1;
        r.insert(c, t10.type.create(s)).delete(r.mapping.map(o), r.mapping.map(a));
      }
      r.scrollIntoView();
    }
  });
}
function jh(t10) {
  return new Ad({
    find: t10.find,
    handler: ({ state: e, range: n, match: i }) => {
      const s = e.doc.resolve(n.from), r = qe(t10.getAttributes, void 0, i) || {};
      if (!s.node(-1).canReplaceWith(s.index(-1), s.indexAfter(-1), t10.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t10.type, r);
    }
  });
}
function ul(t10) {
  return new Ad({
    find: t10.find,
    handler: ({ state: e, range: n, match: i, chain: s }) => {
      const r = qe(t10.getAttributes, void 0, i) || {}, o = e.tr.delete(n.from, n.to), l = o.doc.resolve(n.from).blockRange(), c = l && Xp(l, t10.type, r);
      if (!c)
        return null;
      if (o.wrap(l, c), t10.keepMarks && t10.editor) {
        const { selection: d, storedMarks: f } = e, { splittableMarks: h10 } = t10.editor.extensionManager, p = f || d.$to.parentOffset && d.$from.marks();
        if (p) {
          const g = p.filter((m) => h10.includes(m.type.name));
          o.ensureMarks(g);
        }
      }
      if (t10.keepAttributes) {
        const d = t10.type.name === "bulletList" || t10.type.name === "orderedList" ? "listItem" : "taskList";
        s().updateAttributes(d, r).run();
      }
      const u = o.doc.resolve(n.from - 1).nodeBefore;
      u && u.type === t10.type && or(o.doc, n.from - 1) && (!t10.joinPredicate || t10.joinPredicate(i, u)) && o.join(n.from - 1);
    }
  });
}
var Rn = class Hh {
  constructor(e = {}) {
    this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = {
      name: this.name,
      defaultOptions: {}
    }, this.config = {
      ...this.config,
      ...e
    }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = qe(we(this, "addOptions", {
      name: this.name
    }))), this.storage = qe(we(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(e = {}) {
    return new Hh(e);
  }
  configure(e = {}) {
    const n = this.extend({
      ...this.config,
      addOptions: () => _d(this.options, e)
    });
    return n.name = this.name, n.parent = this.parent, n;
  }
  extend(e = {}) {
    const n = new Hh(e);
    return n.parent = this, this.child = n, n.name = e.name ? e.name : n.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`), n.options = qe(we(n, "addOptions", {
      name: n.name
    })), n.storage = qe(we(n, "addStorage", {
      name: n.name,
      options: n.options
    })), n;
  }
};
function ir(t10) {
  return new F7({
    find: t10.find,
    handler: ({ state: e, range: n, match: i, pasteEvent: s }) => {
      const r = qe(t10.getAttributes, void 0, i, s);
      if (r === false || r === null)
        return null;
      const { tr: o } = e, a = i[i.length - 1], l = i[0];
      let c = n.to;
      if (a) {
        const u = l.search(/\S/), d = n.from + l.indexOf(a), f = d + a.length;
        if (xm(n.from, n.to, e.doc).filter((p) => p.mark.type.excluded.find((m) => m === t10.type && m !== p.mark.type)).filter((p) => p.to > d).length)
          return null;
        f < n.to && o.delete(f, n.to), d > n.from && o.delete(n.from + u, d), c = n.from + u + a.length, o.addMark(n.from + u, c, t10.type.create(r || {})), o.removeStoredMark(t10.type);
      }
    }
  });
}
var xF = Vt.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (t10) => t10.length,
      wordCounter: (t10) => t10.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (t10) => {
      const e = (t10 == null ? void 0 : t10.node) || this.editor.state.doc;
      if (((t10 == null ? void 0 : t10.mode) || this.options.mode) === "textSize") {
        const i = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(i);
      }
      return e.nodeSize;
    }, this.storage.words = (t10) => {
      const e = (t10 == null ? void 0 : t10.node) || this.editor.state.doc, n = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    let t10 = false;
    return [
      new It({
        key: new Zt("characterCount"),
        appendTransaction: (e, n, i) => {
          if (t10)
            return;
          const s = this.options.limit;
          if (s == null || s === 0) {
            t10 = true;
            return;
          }
          const r = this.storage.characters({ node: i.doc });
          if (r > s) {
            const o = r - s, a = 0, l = o;
            console.warn(`[CharacterCount] Initial content exceeded limit of ${s} characters. Content was automatically trimmed.`);
            const c = i.tr.deleteRange(a, l);
            return t10 = true, c;
          }
          t10 = true;
        },
        filterTransaction: (e, n) => {
          const i = this.options.limit;
          if (!e.docChanged || i === 0 || i === null || i === void 0)
            return true;
          const s = this.storage.characters({ node: n.doc }), r = this.storage.characters({ node: e.doc });
          if (r <= i || s > i && r > i && r <= s)
            return true;
          if (s > i && r > i && r > s || !e.getMeta("paste"))
            return false;
          const a = e.selection.$head.pos, l = r - i, c = a - l, u = a;
          return e.deleteRange(c, u), !(this.storage.characters({ node: e.doc }) > i);
        }
      })
    ];
  }
});
var kF = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/;
var SF = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
var wF = xi.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t10) => t10.getAttribute("data-color") || t10.style.backgroundColor,
        renderHTML: (t10) => t10.color ? {
          "data-color": t10.color,
          style: `background-color: ${t10.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["mark", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addCommands() {
    return {
      setHighlight: (t10) => ({ commands: e }) => e.setMark(this.name, t10),
      toggleHighlight: (t10) => ({ commands: e }) => e.toggleMark(this.name, t10),
      unsetHighlight: () => ({ commands: t10 }) => t10.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      Jr({
        find: kF,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ir({
        find: SF,
        type: this.type
      })
    ];
  }
});
var CF = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var OF = Rn.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["img", Nt(this.options.HTMLAttributes, t10)];
  },
  addCommands() {
    return {
      setImage: (t10) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t10
      })
    };
  },
  addInputRules() {
    return [
      Id({
        find: CF,
        type: this.type,
        getAttributes: (t10) => {
          const [, , e, n, i] = t10;
          return { src: n, alt: e, title: i };
        }
      })
    ];
  }
});
var EF = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var MF = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2";
var Vo = (t10, e) => {
  for (const n in e)
    t10[n] = e[n];
  return t10;
};
var Wh = "numeric";
var Uh = "ascii";
var qh = "alpha";
var Fa = "asciinumeric";
var ka = "alphanumeric";
var Kh = "domain";
var Zx = "emoji";
var TF = "scheme";
var AF = "slashscheme";
var Sf = "whitespace";
function _F(t10, e) {
  return t10 in e || (e[t10] = []), e[t10];
}
function Ar(t10, e, n) {
  e[Wh] && (e[Fa] = true, e[ka] = true), e[Uh] && (e[Fa] = true, e[qh] = true), e[Fa] && (e[ka] = true), e[qh] && (e[ka] = true), e[ka] && (e[Kh] = true), e[Zx] && (e[Kh] = true);
  for (const i in e) {
    const s = _F(i, n);
    s.indexOf(t10) < 0 && s.push(t10);
  }
}
function NF(t10, e) {
  const n = {};
  for (const i in e)
    e[i].indexOf(t10) >= 0 && (n[i] = true);
  return n;
}
function An(t10 = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t10;
}
An.groups = {};
An.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t10) {
    const e = this, n = e.j[t10];
    if (n)
      return n;
    for (let i = 0; i < e.jr.length; i++) {
      const s = e.jr[i][0], r = e.jr[i][1];
      if (r && s.test(t10))
        return r;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t10, e = false) {
    return e ? t10 in this.j : !!this.go(t10);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t10, e, n, i) {
    for (let s = 0; s < t10.length; s++)
      this.tt(t10[s], e, n, i);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t10, e, n, i) {
    i = i || An.groups;
    let s;
    return e && e.j ? s = e : (s = new An(e), n && i && Ar(e, n, i)), this.jr.push([t10, s]), s;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t10, e, n, i) {
    let s = this;
    const r = t10.length;
    if (!r)
      return s;
    for (let o = 0; o < r - 1; o++)
      s = s.tt(t10[o]);
    return s.tt(t10[r - 1], e, n, i);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t10, e, n, i) {
    i = i || An.groups;
    const s = this;
    if (e && e.j)
      return s.j[t10] = e, e;
    const r = e;
    let o, a = s.go(t10);
    if (a ? (o = new An(), Vo(o.j, a.j), o.jr.push.apply(o.jr, a.jr), o.jd = a.jd, o.t = a.t) : o = new An(), r) {
      if (i)
        if (o.t && typeof o.t == "string") {
          const l = Vo(NF(o.t, i), n);
          Ar(r, l, i);
        } else n && Ar(r, n, i);
      o.t = r;
    }
    return s.j[t10] = o, o;
  }
};
var He = (t10, e, n, i, s) => t10.ta(e, n, i, s);
var Et = (t10, e, n, i, s) => t10.tr(e, n, i, s);
var pb = (t10, e, n, i, s) => t10.ts(e, n, i, s);
var fe = (t10, e, n, i, s) => t10.tt(e, n, i, s);
var is = "WORD";
var Yh = "UWORD";
var ek = "ASCIINUMERICAL";
var tk = "ALPHANUMERICAL";
var dl = "LOCALHOST";
var Gh = "TLD";
var Jh = "UTLD";
var Ec = "SCHEME";
var po = "SLASH_SCHEME";
var km = "NUM";
var Xh = "WS";
var Sm = "NL";
var Va = "OPENBRACE";
var Ba = "CLOSEBRACE";
var uu = "OPENBRACKET";
var du = "CLOSEBRACKET";
var fu = "OPENPAREN";
var hu = "CLOSEPAREN";
var pu = "OPENANGLEBRACKET";
var mu = "CLOSEANGLEBRACKET";
var gu = "FULLWIDTHLEFTPAREN";
var bu = "FULLWIDTHRIGHTPAREN";
var yu = "LEFTCORNERBRACKET";
var vu = "RIGHTCORNERBRACKET";
var xu = "LEFTWHITECORNERBRACKET";
var ku = "RIGHTWHITECORNERBRACKET";
var Su = "FULLWIDTHLESSTHAN";
var wu = "FULLWIDTHGREATERTHAN";
var Cu = "AMPERSAND";
var wm = "APOSTROPHE";
var Ou = "ASTERISK";
var Is = "AT";
var Eu = "BACKSLASH";
var Mu = "BACKTICK";
var Tu = "CARET";
var $s = "COLON";
var Cm = "COMMA";
var Au = "DOLLAR";
var Mi = "DOT";
var _u = "EQUALS";
var Om = "EXCLAMATION";
var ni = "HYPHEN";
var za = "PERCENT";
var Nu = "PIPE";
var Lu = "PLUS";
var Iu = "POUND";
var ja = "QUERY";
var Em = "QUOTE";
var nk = "FULLWIDTHMIDDLEDOT";
var Mm = "SEMI";
var Ti = "SLASH";
var Ha = "TILDE";
var Pu = "UNDERSCORE";
var ik = "EMOJI";
var Du = "SYM";
var sk = Object.freeze({
  __proto__: null,
  WORD: is,
  UWORD: Yh,
  ASCIINUMERICAL: ek,
  ALPHANUMERICAL: tk,
  LOCALHOST: dl,
  TLD: Gh,
  UTLD: Jh,
  SCHEME: Ec,
  SLASH_SCHEME: po,
  NUM: km,
  WS: Xh,
  NL: Sm,
  OPENBRACE: Va,
  CLOSEBRACE: Ba,
  OPENBRACKET: uu,
  CLOSEBRACKET: du,
  OPENPAREN: fu,
  CLOSEPAREN: hu,
  OPENANGLEBRACKET: pu,
  CLOSEANGLEBRACKET: mu,
  FULLWIDTHLEFTPAREN: gu,
  FULLWIDTHRIGHTPAREN: bu,
  LEFTCORNERBRACKET: yu,
  RIGHTCORNERBRACKET: vu,
  LEFTWHITECORNERBRACKET: xu,
  RIGHTWHITECORNERBRACKET: ku,
  FULLWIDTHLESSTHAN: Su,
  FULLWIDTHGREATERTHAN: wu,
  AMPERSAND: Cu,
  APOSTROPHE: wm,
  ASTERISK: Ou,
  AT: Is,
  BACKSLASH: Eu,
  BACKTICK: Mu,
  CARET: Tu,
  COLON: $s,
  COMMA: Cm,
  DOLLAR: Au,
  DOT: Mi,
  EQUALS: _u,
  EXCLAMATION: Om,
  HYPHEN: ni,
  PERCENT: za,
  PIPE: Nu,
  PLUS: Lu,
  POUND: Iu,
  QUERY: ja,
  QUOTE: Em,
  FULLWIDTHMIDDLEDOT: nk,
  SEMI: Mm,
  SLASH: Ti,
  TILDE: Ha,
  UNDERSCORE: Pu,
  EMOJI: ik,
  SYM: Du
});
var Qi = /[a-z]/;
var aa = new RegExp("\\p{L}", "u");
var wf = new RegExp("\\p{Emoji}", "u");
var Zi = /\d/;
var Cf = /\s/;
var mb = "\r";
var Of = `
`;
var LF = "️";
var IF = "‍";
var Ef = "￼";
var Jl = null;
var Xl = null;
function PF(t10 = []) {
  const e = {};
  An.groups = e;
  const n = new An();
  Jl == null && (Jl = gb(EF)), Xl == null && (Xl = gb(MF)), fe(n, "'", wm), fe(n, "{", Va), fe(n, "}", Ba), fe(n, "[", uu), fe(n, "]", du), fe(n, "(", fu), fe(n, ")", hu), fe(n, "<", pu), fe(n, ">", mu), fe(n, "（", gu), fe(n, "）", bu), fe(n, "「", yu), fe(n, "」", vu), fe(n, "『", xu), fe(n, "』", ku), fe(n, "＜", Su), fe(n, "＞", wu), fe(n, "&", Cu), fe(n, "*", Ou), fe(n, "@", Is), fe(n, "`", Mu), fe(n, "^", Tu), fe(n, ":", $s), fe(n, ",", Cm), fe(n, "$", Au), fe(n, ".", Mi), fe(n, "=", _u), fe(n, "!", Om), fe(n, "-", ni), fe(n, "%", za), fe(n, "|", Nu), fe(n, "+", Lu), fe(n, "#", Iu), fe(n, "?", ja), fe(n, '"', Em), fe(n, "/", Ti), fe(n, ";", Mm), fe(n, "~", Ha), fe(n, "_", Pu), fe(n, "\\", Eu), fe(n, "・", nk);
  const i = Et(n, Zi, km, {
    [Wh]: true
  });
  Et(i, Zi, i);
  const s = Et(i, Qi, ek, {
    [Fa]: true
  }), r = Et(i, aa, tk, {
    [ka]: true
  }), o = Et(n, Qi, is, {
    [Uh]: true
  });
  Et(o, Zi, s), Et(o, Qi, o), Et(s, Zi, s), Et(s, Qi, s);
  const a = Et(n, aa, Yh, {
    [qh]: true
  });
  Et(a, Qi), Et(a, Zi, r), Et(a, aa, a), Et(r, Zi, r), Et(r, Qi), Et(r, aa, r);
  const l = fe(n, Of, Sm, {
    [Sf]: true
  }), c = fe(n, mb, Xh, {
    [Sf]: true
  }), u = Et(n, Cf, Xh, {
    [Sf]: true
  });
  fe(n, Ef, u), fe(c, Of, l), fe(c, Ef, u), Et(c, Cf, u), fe(u, mb), fe(u, Of), Et(u, Cf, u), fe(u, Ef, u);
  const d = Et(n, wf, ik, {
    [Zx]: true
  });
  fe(d, "#"), Et(d, wf, d), fe(d, LF, d);
  const f = fe(d, IF);
  fe(f, "#"), Et(f, wf, d);
  const h10 = [[Qi, o], [Zi, s]], p = [[Qi, null], [aa, a], [Zi, r]];
  for (let g = 0; g < Jl.length; g++)
    Ms(n, Jl[g], Gh, is, h10);
  for (let g = 0; g < Xl.length; g++)
    Ms(n, Xl[g], Jh, Yh, p);
  Ar(Gh, {
    tld: true,
    ascii: true
  }, e), Ar(Jh, {
    utld: true,
    alpha: true
  }, e), Ms(n, "file", Ec, is, h10), Ms(n, "mailto", Ec, is, h10), Ms(n, "http", po, is, h10), Ms(n, "https", po, is, h10), Ms(n, "ftp", po, is, h10), Ms(n, "ftps", po, is, h10), Ar(Ec, {
    scheme: true,
    ascii: true
  }, e), Ar(po, {
    slashscheme: true,
    ascii: true
  }, e), t10 = t10.sort((g, m) => g[0] > m[0] ? 1 : -1);
  for (let g = 0; g < t10.length; g++) {
    const m = t10[g][0], x = t10[g][1] ? {
      [TF]: true
    } : {
      [AF]: true
    };
    m.indexOf("-") >= 0 ? x[Kh] = true : Qi.test(m) ? Zi.test(m) ? x[Fa] = true : x[Uh] = true : x[Wh] = true, pb(n, m, m, x);
  }
  return pb(n, "localhost", dl, {
    ascii: true
  }), n.jd = new An(Du), {
    start: n,
    tokens: Vo({
      groups: e
    }, sk)
  };
}
function rk(t10, e) {
  const n = DF(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), i = n.length, s = [];
  let r = 0, o = 0;
  for (; o < i; ) {
    let a = t10, l = null, c = 0, u = null, d = -1, f = -1;
    for (; o < i && (l = a.go(n[o])); )
      a = l, a.accepts() ? (d = 0, f = 0, u = a) : d >= 0 && (d += n[o].length, f++), c += n[o].length, r += n[o].length, o++;
    r -= d, o -= f, c -= d, s.push({
      t: u.t,
      // token type/name
      v: e.slice(r - c, r),
      // string value
      s: r - c,
      // start index
      e: r
      // end index (excluding)
    });
  }
  return s;
}
function DF(t10) {
  const e = [], n = t10.length;
  let i = 0;
  for (; i < n; ) {
    let s = t10.charCodeAt(i), r, o = s < 55296 || s > 56319 || i + 1 === n || (r = t10.charCodeAt(i + 1)) < 56320 || r > 57343 ? t10[i] : t10.slice(i, i + 2);
    e.push(o), i += o.length;
  }
  return e;
}
function Ms(t10, e, n, i, s) {
  let r;
  const o = e.length;
  for (let a = 0; a < o - 1; a++) {
    const l = e[a];
    t10.j[l] ? r = t10.j[l] : (r = new An(i), r.jr = s.slice(), t10.j[l] = r), t10 = r;
  }
  return r = new An(n), r.jr = s.slice(), t10.j[e[o - 1]] = r, r;
}
function gb(t10) {
  const e = [], n = [];
  let i = 0, s = "0123456789";
  for (; i < t10.length; ) {
    let r = 0;
    for (; s.indexOf(t10[i + r]) >= 0; )
      r++;
    if (r > 0) {
      e.push(n.join(""));
      for (let o = parseInt(t10.substring(i, i + r), 10); o > 0; o--)
        n.pop();
      i += r;
    } else
      n.push(t10[i]), i++;
  }
  return e;
}
var fl = {
  defaultProtocol: "http",
  events: null,
  format: bb,
  formatHref: bb,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Tm(t10, e = null) {
  let n = Vo({}, fl);
  t10 && (n = Vo(n, t10 instanceof Tm ? t10.o : t10));
  const i = n.ignoreTags, s = [];
  for (let r = 0; r < i.length; r++)
    s.push(i[r].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = s;
}
Tm.prototype = {
  o: fl,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t10) {
    return t10;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t10) {
    return this.get("validate", t10.toString(), t10);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t10, e, n) {
    const i = e != null;
    let s = this.o[t10];
    return s && (typeof s == "object" ? (s = n.t in s ? s[n.t] : fl[t10], typeof s == "function" && i && (s = s(e, n))) : typeof s == "function" && i && (s = s(e, n.t, n)), s);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t10, e, n) {
    let i = this.o[t10];
    return typeof i == "function" && e != null && (i = i(e, n.t, n)), i;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t10) {
    const e = t10.render(this);
    return (this.get("render", null, t10) || this.defaultRender)(e, t10.t, t10);
  }
};
function bb(t10) {
  return t10;
}
function ok(t10, e) {
  this.t = "token", this.v = t10, this.tk = e;
}
ok.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t10) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t10) {
    const e = this.toString(), n = t10.get("truncate", e, this), i = t10.get("format", e, this);
    return n && i.length > n ? i.substring(0, n) + "…" : i;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t10) {
    return t10.get("formatHref", this.toHref(t10.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t10 = fl.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t10),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t10) {
    return {
      type: this.t,
      value: this.toFormattedString(t10),
      isLink: this.isLink,
      href: this.toFormattedHref(t10),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t10) {
    return t10.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t10) {
    const e = this, n = this.toHref(t10.get("defaultProtocol")), i = t10.get("formatHref", n, this), s = t10.get("tagName", n, e), r = this.toFormattedString(t10), o = {}, a = t10.get("className", n, e), l = t10.get("target", n, e), c = t10.get("rel", n, e), u = t10.getObj("attributes", n, e), d = t10.getObj("events", n, e);
    return o.href = i, a && (o.class = a), l && (o.target = l), c && (o.rel = c), u && Vo(o, u), {
      tagName: s,
      attributes: o,
      content: r,
      eventListeners: d
    };
  }
};
function Pd(t10, e) {
  class n extends ok {
    constructor(s, r) {
      super(s, r), this.t = t10;
    }
  }
  for (const i in e)
    n.prototype[i] = e[i];
  return n.t = t10, n;
}
var yb = Pd("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
var vb = Pd("text");
var $F = Pd("nl");
var Ql = Pd("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t10 = fl.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t10}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t10 = this.tk;
    return t10.length >= 2 && t10[0].t !== dl && t10[1].t === $s;
  }
});
var ei = (t10) => new An(t10);
function RF({
  groups: t10
}) {
  const e = t10.domain.concat([Cu, Ou, Is, Eu, Mu, Tu, Au, _u, ni, km, za, Nu, Lu, Iu, Ti, Du, Ha, Pu]), n = [$s, Cm, Mi, Om, za, ja, Em, Mm, pu, mu, Va, Ba, du, uu, fu, hu, gu, bu, yu, vu, xu, ku, Su, wu], i = [Cu, wm, Ou, Eu, Mu, Tu, Au, _u, ni, Va, Ba, za, Nu, Lu, Iu, ja, Ti, Du, Ha, Pu], s = ei(), r = fe(s, Ha);
  He(r, i, r), He(r, t10.domain, r);
  const o = ei(), a = ei(), l = ei();
  He(s, t10.domain, o), He(s, t10.scheme, a), He(s, t10.slashscheme, l), He(o, i, r), He(o, t10.domain, o);
  const c = fe(o, Is);
  fe(r, Is, c), fe(a, Is, c), fe(l, Is, c);
  const u = fe(r, Mi);
  He(u, i, r), He(u, t10.domain, r);
  const d = ei();
  He(c, t10.domain, d), He(d, t10.domain, d);
  const f = fe(d, Mi);
  He(f, t10.domain, d);
  const h10 = ei(yb);
  He(f, t10.tld, h10), He(f, t10.utld, h10), fe(c, dl, h10);
  const p = fe(d, ni);
  fe(p, ni, p), He(p, t10.domain, d), He(h10, t10.domain, d), fe(h10, Mi, f), fe(h10, ni, p);
  const g = fe(h10, $s);
  He(g, t10.numeric, yb);
  const m = fe(o, ni), b = fe(o, Mi);
  fe(m, ni, m), He(m, t10.domain, o), He(b, i, r), He(b, t10.domain, o);
  const x = ei(Ql);
  He(b, t10.tld, x), He(b, t10.utld, x), He(x, t10.domain, o), He(x, i, r), fe(x, Mi, b), fe(x, ni, m), fe(x, Is, c);
  const k = fe(x, $s), v = ei(Ql);
  He(k, t10.numeric, v);
  const S = ei(Ql), w = ei();
  He(S, e, S), He(S, n, w), He(w, e, S), He(w, n, w), fe(x, Ti, S), fe(v, Ti, S);
  const E = fe(a, $s), M = fe(l, $s), N = fe(M, Ti), V = fe(N, Ti);
  He(a, t10.domain, o), fe(a, Mi, b), fe(a, ni, m), He(l, t10.domain, o), fe(l, Mi, b), fe(l, ni, m), He(E, t10.domain, S), fe(E, Ti, S), fe(E, ja, S), He(V, t10.domain, S), He(V, e, S), fe(V, Ti, S);
  const Y = [
    [Va, Ba],
    // {}
    [uu, du],
    // []
    [fu, hu],
    // ()
    [pu, mu],
    // <>
    [gu, bu],
    // （）
    [yu, vu],
    // 「」
    [xu, ku],
    // 『』
    [Su, wu]
    // ＜＞
  ];
  for (let F = 0; F < Y.length; F++) {
    const [re, z] = Y[F], W = fe(S, re);
    fe(w, re, W), fe(W, z, S);
    const C = ei(Ql);
    He(W, e, C);
    const O = ei();
    He(W, n), He(C, e, C), He(C, n, O), He(O, e, C), He(O, n, O), fe(C, z, S), fe(O, z, S);
  }
  return fe(s, dl, x), fe(s, Sm, $F), {
    start: s,
    tokens: sk
  };
}
function FF(t10, e, n) {
  let i = n.length, s = 0, r = [], o = [];
  for (; s < i; ) {
    let a = t10, l = null, c = null, u = 0, d = null, f = -1;
    for (; s < i && !(l = a.go(n[s].t)); )
      o.push(n[s++]);
    for (; s < i && (c = l || a.go(n[s].t)); )
      l = null, a = c, a.accepts() ? (f = 0, d = a) : f >= 0 && f++, s++, u++;
    if (f < 0)
      s -= u, s < i && (o.push(n[s]), s++);
    else {
      o.length > 0 && (r.push(Mf(vb, e, o)), o = []), s -= f, u -= f;
      const h10 = d.t, p = n.slice(s - u, s);
      r.push(Mf(h10, e, p));
    }
  }
  return o.length > 0 && r.push(Mf(vb, e, o)), r;
}
function Mf(t10, e, n) {
  const i = n[0].s, s = n[n.length - 1].e, r = e.slice(i, s);
  return new t10(r, n);
}
var VF = typeof console < "u" && console && console.warn || (() => {
});
var BF = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
var mt = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function zF() {
  return An.groups = {}, mt.scanner = null, mt.parser = null, mt.tokenQueue = [], mt.pluginQueue = [], mt.customSchemes = [], mt.initialized = false, mt;
}
function xb(t10, e = false) {
  if (mt.initialized && VF(`linkifyjs: already initialized - will not register custom scheme "${t10}" ${BF}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t10))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  mt.customSchemes.push([t10, e]);
}
function jF() {
  mt.scanner = PF(mt.customSchemes);
  for (let t10 = 0; t10 < mt.tokenQueue.length; t10++)
    mt.tokenQueue[t10][1]({
      scanner: mt.scanner
    });
  mt.parser = RF(mt.scanner.tokens);
  for (let t10 = 0; t10 < mt.pluginQueue.length; t10++)
    mt.pluginQueue[t10][1]({
      scanner: mt.scanner,
      parser: mt.parser
    });
  return mt.initialized = true, mt;
}
function Am(t10) {
  return mt.initialized || jF(), FF(mt.parser.start, t10, rk(mt.scanner.start, t10));
}
Am.scan = rk;
function ak(t10, e = null, n = null) {
  if (e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const i = new Tm(n), s = Am(t10), r = [];
  for (let o = 0; o < s.length; o++) {
    const a = s[o];
    a.isLink && (!e || a.t === e) && i.check(a) && r.push(a.toFormattedObject(i));
  }
  return r;
}
function HF(t10) {
  return t10.length === 1 ? t10[0].isLink : t10.length === 3 && t10[1].isLink ? ["()", "[]"].includes(t10[0].value + t10[2].value) : false;
}
function WF(t10) {
  return new It({
    key: new Zt("autolink"),
    appendTransaction: (e, n, i) => {
      const s = e.some((c) => c.docChanged) && !n.doc.eq(i.doc), r = e.some((c) => c.getMeta("preventAutolink"));
      if (!s || r)
        return;
      const { tr: o } = i, a = D9(n.doc, [...e]);
      if (j9(a).forEach(({ newRange: c }) => {
        const u = R9(i.doc, c, (h10) => h10.isTextblock);
        let d, f;
        if (u.length > 1 ? (d = u[0], f = i.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : u.length && i.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") && (d = u[0], f = i.doc.textBetween(d.pos, c.to, void 0, " ")), d && f) {
          const h10 = f.split(" ").filter((b) => b !== "");
          if (h10.length <= 0)
            return false;
          const p = h10[h10.length - 1], g = d.pos + f.lastIndexOf(p);
          if (!p)
            return false;
          const m = Am(p).map((b) => b.toObject(t10.defaultProtocol));
          if (!HF(m))
            return false;
          m.filter((b) => b.isLink).map((b) => ({
            ...b,
            from: g + b.start + 1,
            to: g + b.end + 1
          })).filter((b) => i.schema.marks.code ? !i.doc.rangeHasMark(b.from, b.to, i.schema.marks.code) : true).filter((b) => t10.validate(b.value)).filter((b) => t10.shouldAutoLink(b.value)).forEach((b) => {
            xm(b.from, b.to, i.doc).some((x) => x.mark.type === t10.type) || o.addMark(b.from, b.to, t10.type.create({
              href: b.href
            }));
          });
        }
      }), !!o.steps.length)
        return o;
    }
  });
}
function UF(t10) {
  return new It({
    key: new Zt("handleClickLink"),
    props: {
      handleClick: (e, n, i) => {
        var s, r;
        if (i.button !== 0 || !e.editable)
          return false;
        let o = i.target;
        const a = [];
        for (; o.nodeName !== "DIV"; )
          a.push(o), o = o.parentNode;
        if (!a.find((f) => f.nodeName === "A"))
          return false;
        const l = Jx(e.state, t10.type.name), c = i.target, u = (s = c == null ? void 0 : c.href) !== null && s !== void 0 ? s : l.href, d = (r = c == null ? void 0 : c.target) !== null && r !== void 0 ? r : l.target;
        return c && u ? (window.open(u, d), true) : false;
      }
    }
  });
}
function qF(t10) {
  return new It({
    key: new Zt("handlePasteLink"),
    props: {
      handlePaste: (e, n, i) => {
        const { state: s } = e, { selection: r } = s, { empty: o } = r;
        if (o)
          return false;
        let a = "";
        i.content.forEach((c) => {
          a += c.textContent;
        });
        const l = ak(a, { defaultProtocol: t10.defaultProtocol }).find((c) => c.isLink && c.value === a);
        return !a || !l ? false : t10.editor.commands.setMark(t10.type, {
          href: l.href
        });
      }
    }
  });
}
var KF = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function mr(t10, e) {
  const n = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ];
  return e && e.forEach((i) => {
    const s = typeof i == "string" ? i : i.scheme;
    s && n.push(s);
  }), !t10 || t10.replace(KF, "").match(new RegExp(
    // eslint-disable-next-line no-useless-escape
    `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
    "i"
  ));
}
var YF = xi.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  exitable: true,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t10) => {
      if (typeof t10 == "string") {
        xb(t10);
        return;
      }
      xb(t10.scheme, t10.optionalSlashes);
    });
  },
  onDestroy() {
    zF();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t10, e) => !!mr(t10, e.protocols),
      validate: (t10) => !!t10,
      shouldAutoLink: (t10) => !!t10
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t10) {
          return t10.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t10) => {
          const e = t10.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (n) => !!mr(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? false : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return this.options.isAllowedUri(t10.href, {
      defaultValidate: (e) => !!mr(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", Nt(this.options.HTMLAttributes, t10), 0] : [
      "a",
      Nt(this.options.HTMLAttributes, { ...t10, href: "" }),
      0
    ];
  },
  addCommands() {
    return {
      setLink: (t10) => ({ chain: e }) => {
        const { href: n } = t10;
        return this.options.isAllowedUri(n, {
          defaultValidate: (i) => !!mr(i, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().setMark(this.name, t10).setMeta("preventAutolink", true).run() : false;
      },
      toggleLink: (t10) => ({ chain: e }) => {
        const { href: n } = t10;
        return this.options.isAllowedUri(n, {
          defaultValidate: (i) => !!mr(i, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().toggleMark(this.name, t10, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run() : false;
      },
      unsetLink: () => ({ chain: t10 }) => t10().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run()
    };
  },
  addPasteRules() {
    return [
      ir({
        find: (t10) => {
          const e = [];
          if (t10) {
            const { protocols: n, defaultProtocol: i } = this.options, s = ak(t10).filter((r) => r.isLink && this.options.isAllowedUri(r.value, {
              defaultValidate: (o) => !!mr(o, n),
              protocols: n,
              defaultProtocol: i
            }));
            s.length && s.forEach((r) => e.push({
              text: r.value,
              data: {
                href: r.href
              },
              index: r.start
            }));
          }
          return e;
        },
        type: this.type,
        getAttributes: (t10) => {
          var e;
          return {
            href: (e = t10.data) === null || e === void 0 ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t10 = [], { protocols: e, defaultProtocol: n } = this.options;
    return this.options.autolink && t10.push(WF({
      type: this.type,
      defaultProtocol: this.options.defaultProtocol,
      validate: (i) => this.options.isAllowedUri(i, {
        defaultValidate: (s) => !!mr(s, e),
        protocols: e,
        defaultProtocol: n
      }),
      shouldAutoLink: this.options.shouldAutoLink
    })), this.options.openOnClick === true && t10.push(UF({
      type: this.type
    })), this.options.linkOnPaste && t10.push(qF({
      editor: this.editor,
      defaultProtocol: this.options.defaultProtocol,
      type: this.type
    })), t10;
  }
});
var GF = Vt.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new It({
        key: new Zt("placeholder"),
        props: {
          decorations: ({ doc: t10, selection: e }) => {
            const n = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: i } = e, s = [];
            if (!n)
              return null;
            const r = this.editor.isEmpty;
            return t10.descendants((o, a) => {
              const l = i >= a && i <= a + o.nodeSize, c = !o.isLeaf && Ld(o);
              if ((l || !this.options.showOnlyCurrent) && c) {
                const u = [this.options.emptyNodeClass];
                r && u.push(this.options.emptyEditorClass);
                const d = Un.node(a, a + o.nodeSize, {
                  class: u.join(" "),
                  "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: o,
                    pos: a,
                    hasAnchor: l
                  }) : this.options.placeholder
                });
                s.push(d);
              }
              return this.options.includeChildren;
            }), $t.create(t10, s);
          }
        }
      })
    ];
  }
});
var JF = Vt.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t10) => {
              const e = t10.style.textAlign;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t10) => t10.textAlign ? { style: `text-align: ${t10.textAlign}` } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t10) => ({ commands: e }) => this.options.alignments.includes(t10) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t10 })).every((n) => n) : false,
      unsetTextAlign: () => ({ commands: t10 }) => this.options.types.map((e) => t10.resetAttributes(e, "textAlign")).every((e) => e)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
var XF = xi.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (t10) => t10.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["u", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t10 }) => t10.setMark(this.name),
      toggleUnderline: () => ({ commands: t10 }) => t10.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t10 }) => t10.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
var QF = /^\s*>\s$/;
var ZF = Rn.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["blockquote", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t10 }) => t10.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t10 }) => t10.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t10 }) => t10.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      ul({
        find: QF,
        type: this.type
      })
    ];
  }
});
var eV = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var tV = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var nV = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var iV = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var sV = xi.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t10) => t10.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t10) => t10.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t10) => /^(bold(er)?|[5-9]\d{2,})$/.test(t10) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["strong", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: t10 }) => t10.setMark(this.name),
      toggleBold: () => ({ commands: t10 }) => t10.toggleMark(this.name),
      unsetBold: () => ({ commands: t10 }) => t10.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      Jr({
        find: eV,
        type: this.type
      }),
      Jr({
        find: nV,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ir({
        find: tV,
        type: this.type
      }),
      ir({
        find: iV,
        type: this.type
      })
    ];
  }
});
var rV = "listItem";
var kb = "textStyle";
var Sb = /^\s*([-+*])\s$/;
var oV = Rn.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["ul", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t10, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(rV, this.editor.getAttributes(kb)).run() : t10.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t10 = ul({
      find: Sb,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t10 = ul({
      find: Sb,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(kb),
      editor: this.editor
    })), [
      t10
    ];
  }
});
var aV = /(^|[^`])`([^`]+)`(?!`)/;
var lV = /(^|[^`])`([^`]+)`(?!`)/g;
var cV = xi.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [
      { tag: "code" }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["code", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands: t10 }) => t10.setMark(this.name),
      toggleCode: () => ({ commands: t10 }) => t10.toggleMark(this.name),
      unsetCode: () => ({ commands: t10 }) => t10.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      Jr({
        find: aV,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ir({
        find: lV,
        type: this.type
      })
    ];
  }
});
var uV = /^```([a-z]+)?[\s\n]$/;
var dV = /^~~~([a-z]+)?[\s\n]$/;
var fV = Rn.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (t10) => {
          var e;
          const { languageClassPrefix: n } = this.options, r = [...((e = t10.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter((o) => o.startsWith(n)).map((o) => o.replace(n, ""))[0];
          return r || null;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t10, HTMLAttributes: e }) {
    return [
      "pre",
      Nt(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t10.attrs.language ? this.options.languageClassPrefix + t10.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (t10) => ({ commands: e }) => e.setNode(this.name, t10),
      toggleCodeBlock: (t10) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t10)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t10, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t10 || e.parent.type.name !== this.name ? false : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : false;
      },
      // exit node on triple enter
      Enter: ({ editor: t10 }) => {
        if (!this.options.exitOnTripleEnter)
          return false;
        const { state: e } = t10, { selection: n } = e, { $from: i, empty: s } = n;
        if (!s || i.parent.type !== this.type)
          return false;
        const r = i.parentOffset === i.parent.nodeSize - 2, o = i.parent.textContent.endsWith(`

`);
        return !r || !o ? false : t10.chain().command(({ tr: a }) => (a.delete(i.pos - 2, i.pos), true)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t10 }) => {
        if (!this.options.exitOnArrowDown)
          return false;
        const { state: e } = t10, { selection: n, doc: i } = e, { $from: s, empty: r } = n;
        if (!r || s.parent.type !== this.type || !(s.parentOffset === s.parent.nodeSize - 2))
          return false;
        const a = s.after();
        return a === void 0 ? false : i.nodeAt(a) ? t10.commands.command(({ tr: c }) => (c.setSelection(je.near(i.resolve(a))), true)) : t10.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      jh({
        find: uV,
        type: this.type,
        getAttributes: (t10) => ({
          language: t10[1]
        })
      }),
      jh({
        find: dV,
        type: this.type,
        getAttributes: (t10) => ({
          language: t10[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new It({
        key: new Zt("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t10, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return false;
            const n = e.clipboardData.getData("text/plain"), i = e.clipboardData.getData("vscode-editor-data"), s = i ? JSON.parse(i) : void 0, r = s == null ? void 0 : s.mode;
            if (!n || !r)
              return false;
            const { tr: o, schema: a } = t10.state, l = a.text(n.replace(/\r\n?/g, `
`));
            return o.replaceSelectionWith(this.type.create({ language: r }, l)), o.selection.$from.parent.type !== this.type && o.setSelection(Be.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.setMeta("paste", true), t10.dispatch(o), true;
          }
        }
      })
    ];
  }
});
var hV = Rn.create({
  name: "doc",
  topNode: true,
  content: "block+"
});
function pV(t10 = {}) {
  return new It({
    view(e) {
      return new mV(e, t10);
    }
  });
}
var mV = class {
  constructor(e, n) {
    var i;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (i = n.width) !== null && i !== void 0 ? i : 1, this.color = n.color === false ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((s) => {
      let r = (o) => {
        this[s](o);
      };
      return e.dom.addEventListener(s, r), { name: s, handler: r };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, i;
    if (n) {
      let a = e.nodeBefore, l = e.nodeAfter;
      if (a || l) {
        let c = this.editorView.nodeDOM(this.cursorPos - (a ? a.nodeSize : 0));
        if (c) {
          let u = c.getBoundingClientRect(), d = a ? u.bottom : u.top;
          a && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), i = { left: u.left, right: u.right, top: d - this.width / 2, bottom: d + this.width / 2 };
        }
      }
    }
    if (!i) {
      let a = this.editorView.coordsAtPos(this.cursorPos);
      i = { left: a.left - this.width / 2, right: a.left + this.width / 2, top: a.top, bottom: a.bottom };
    }
    let s = this.editorView.dom.offsetParent;
    this.element || (this.element = s.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let r, o;
    if (!s || s == document.body && getComputedStyle(s).position == "static")
      r = -pageXOffset, o = -pageYOffset;
    else {
      let a = s.getBoundingClientRect();
      r = a.left - s.scrollLeft, o = a.top - s.scrollTop;
    }
    this.element.style.left = i.left - r + "px", this.element.style.top = i.top - o + "px", this.element.style.width = i.right - i.left + "px", this.element.style.height = i.bottom - i.top + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), i = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), s = i && i.type.spec.disableDropCursor, r = typeof s == "function" ? s(this.editorView, n, e) : s;
    if (n && !r) {
      let o = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = z2(this.editorView.state.doc, o, this.editorView.dragging.slice);
        a != null && (o = a);
      }
      this.setCursor(o), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null);
  }
};
var gV = Vt.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      pV(this.options)
    ];
  }
});
var Tt = class _Tt extends je {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let i = e.resolve(n.map(this.head));
    return _Tt.valid(i) ? new _Tt(i) : je.near(i);
  }
  content() {
    return ke.empty;
  }
  eq(e) {
    return e instanceof _Tt && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new _Tt(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new _m(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !bV(e) || !yV(e))
      return false;
    let i = n.type.spec.allowGapCursor;
    if (i != null)
      return i;
    let s = n.contentMatchAt(e.index()).defaultType;
    return s && s.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, i = false) {
    e: for (; ; ) {
      if (!i && _Tt.valid(e))
        return e;
      let s = e.pos, r = null;
      for (let o = e.depth; ; o--) {
        let a = e.node(o);
        if (n > 0 ? e.indexAfter(o) < a.childCount : e.index(o) > 0) {
          r = a.child(n > 0 ? e.indexAfter(o) : e.index(o) - 1);
          break;
        } else if (o == 0)
          return null;
        s += n;
        let l = e.doc.resolve(s);
        if (_Tt.valid(l))
          return l;
      }
      for (; ; ) {
        let o = n > 0 ? r.firstChild : r.lastChild;
        if (!o) {
          if (r.isAtom && !r.isText && !Pe.isSelectable(r)) {
            e = e.doc.resolve(s + r.nodeSize * n), i = false;
            continue e;
          }
          break;
        }
        r = o, s += n;
        let a = e.doc.resolve(s);
        if (_Tt.valid(a))
          return a;
      }
      return null;
    }
  }
};
Tt.prototype.visible = false;
Tt.findFrom = Tt.findGapCursorFrom;
je.jsonID("gapcursor", Tt);
var _m = class __m {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new __m(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return Tt.valid(n) ? new Tt(n) : je.near(n);
  }
};
function bV(t10) {
  for (let e = t10.depth; e >= 0; e--) {
    let n = t10.index(e), i = t10.node(e);
    if (n == 0) {
      if (i.type.spec.isolating)
        return true;
      continue;
    }
    for (let s = i.child(n - 1); ; s = s.lastChild) {
      if (s.childCount == 0 && !s.inlineContent || s.isAtom || s.type.spec.isolating)
        return true;
      if (s.inlineContent)
        return false;
    }
  }
  return true;
}
function yV(t10) {
  for (let e = t10.depth; e >= 0; e--) {
    let n = t10.indexAfter(e), i = t10.node(e);
    if (n == i.childCount) {
      if (i.type.spec.isolating)
        return true;
      continue;
    }
    for (let s = i.child(n); ; s = s.firstChild) {
      if (s.childCount == 0 && !s.inlineContent || s.isAtom || s.type.spec.isolating)
        return true;
      if (s.inlineContent)
        return false;
    }
  }
  return true;
}
function vV() {
  return new It({
    props: {
      decorations: wV,
      createSelectionBetween(t10, e, n) {
        return e.pos == n.pos && Tt.valid(n) ? new Tt(n) : null;
      },
      handleClick: kV,
      handleKeyDown: xV,
      handleDOMEvents: { beforeinput: SV }
    }
  });
}
var xV = Tx({
  ArrowLeft: Zl("horiz", -1),
  ArrowRight: Zl("horiz", 1),
  ArrowUp: Zl("vert", -1),
  ArrowDown: Zl("vert", 1)
});
function Zl(t10, e) {
  const n = t10 == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(i, s, r) {
    let o = i.selection, a = e > 0 ? o.$to : o.$from, l = o.empty;
    if (o instanceof Be) {
      if (!r.endOfTextblock(n) || a.depth == 0)
        return false;
      l = false, a = i.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let c = Tt.findGapCursorFrom(a, e, l);
    return c ? (s && s(i.tr.setSelection(new Tt(c))), true) : false;
  };
}
function kV(t10, e, n) {
  if (!t10 || !t10.editable)
    return false;
  let i = t10.state.doc.resolve(e);
  if (!Tt.valid(i))
    return false;
  let s = t10.posAtCoords({ left: n.clientX, top: n.clientY });
  return s && s.inside > -1 && Pe.isSelectable(t10.state.doc.nodeAt(s.inside)) ? false : (t10.dispatch(t10.state.tr.setSelection(new Tt(i))), true);
}
function SV(t10, e) {
  if (e.inputType != "insertCompositionText" || !(t10.state.selection instanceof Tt))
    return false;
  let { $from: n } = t10.state.selection, i = n.parent.contentMatchAt(n.index()).findWrapping(t10.state.schema.nodes.text);
  if (!i)
    return false;
  let s = ce.empty;
  for (let o = i.length - 1; o >= 0; o--)
    s = ce.from(i[o].createAndFill(null, s));
  let r = t10.state.tr.replace(n.pos, n.pos, new ke(s, 0, 0));
  return r.setSelection(Be.near(r.doc.resolve(n.pos + 1))), t10.dispatch(r), false;
}
function wV(t10) {
  if (!(t10.selection instanceof Tt))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", $t.create(t10.doc, [Un.widget(t10.selection.head, e, { key: "gapcursor" })]);
}
var CV = Vt.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [
      vV()
    ];
  },
  extendNodeSchema(t10) {
    var e;
    const n = {
      name: t10.name,
      options: t10.options,
      storage: t10.storage
    };
    return {
      allowGapCursor: (e = qe(we(t10, "allowGapCursor", n))) !== null && e !== void 0 ? e : null
    };
  }
});
var OV = Rn.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  linebreakReplacement: true,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["br", Nt(this.options.HTMLAttributes, t10)];
  },
  renderText() {
    return `
`;
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t10, chain: e, state: n, editor: i }) => t10.first([
        () => t10.exitCode(),
        () => t10.command(() => {
          const { selection: s, storedMarks: r } = n;
          if (s.$from.parent.type.spec.isolating)
            return false;
          const { keepMarks: o } = this.options, { splittableMarks: a } = i.extensionManager, l = r || s.$to.parentOffset && s.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: u }) => {
            if (u && l && o) {
              const d = l.filter((f) => a.includes(f.type.name));
              c.ensureMarks(d);
            }
            return true;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});
var EV = Rn.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t10) => ({
      tag: `h${t10}`,
      attrs: { level: t10 }
    }));
  },
  renderHTML({ node: t10, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t10.attrs.level) ? t10.attrs.level : this.options.levels[0]}`, Nt(this.options.HTMLAttributes, e), 0];
  },
  addCommands() {
    return {
      setHeading: (t10) => ({ commands: e }) => this.options.levels.includes(t10.level) ? e.setNode(this.name, t10) : false,
      toggleHeading: (t10) => ({ commands: e }) => this.options.levels.includes(t10.level) ? e.toggleNode(this.name, "paragraph", t10) : false
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((t10, e) => ({
      ...t10,
      [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((t10) => jh({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t10}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t10
      }
    }));
  }
});
var $u = 200;
var qt = function() {
};
qt.prototype.append = function(e) {
  return e.length ? (e = qt.from(e), !this.length && e || e.length < $u && this.leafAppend(e) || this.length < $u && e.leafPrepend(this) || this.appendInner(e)) : this;
};
qt.prototype.prepend = function(e) {
  return e.length ? qt.from(e).append(this) : this;
};
qt.prototype.appendInner = function(e) {
  return new MV(this, e);
};
qt.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? qt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
qt.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
qt.prototype.forEach = function(e, n, i) {
  n === void 0 && (n = 0), i === void 0 && (i = this.length), n <= i ? this.forEachInner(e, n, i, 0) : this.forEachInvertedInner(e, n, i, 0);
};
qt.prototype.map = function(e, n, i) {
  n === void 0 && (n = 0), i === void 0 && (i = this.length);
  var s = [];
  return this.forEach(function(r, o) {
    return s.push(e(r, o));
  }, n, i), s;
};
qt.from = function(e) {
  return e instanceof qt ? e : e && e.length ? new lk(e) : qt.empty;
};
var lk = function(t10) {
  function e(i) {
    t10.call(this), this.values = i;
  }
  t10 && (e.__proto__ = t10), e.prototype = Object.create(t10 && t10.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: true }, depth: { configurable: true } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(s, r) {
    return s == 0 && r == this.length ? this : new e(this.values.slice(s, r));
  }, e.prototype.getInner = function(s) {
    return this.values[s];
  }, e.prototype.forEachInner = function(s, r, o, a) {
    for (var l = r; l < o; l++)
      if (s(this.values[l], a + l) === false)
        return false;
  }, e.prototype.forEachInvertedInner = function(s, r, o, a) {
    for (var l = r - 1; l >= o; l--)
      if (s(this.values[l], a + l) === false)
        return false;
  }, e.prototype.leafAppend = function(s) {
    if (this.length + s.length <= $u)
      return new e(this.values.concat(s.flatten()));
  }, e.prototype.leafPrepend = function(s) {
    if (this.length + s.length <= $u)
      return new e(s.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
}(qt);
qt.empty = new lk([]);
var MV = function(t10) {
  function e(n, i) {
    t10.call(this), this.left = n, this.right = i, this.length = n.length + i.length, this.depth = Math.max(n.depth, i.depth) + 1;
  }
  return t10 && (e.__proto__ = t10), e.prototype = Object.create(t10 && t10.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  }, e.prototype.forEachInner = function(i, s, r, o) {
    var a = this.left.length;
    if (s < a && this.left.forEachInner(i, s, Math.min(r, a), o) === false || r > a && this.right.forEachInner(i, Math.max(s - a, 0), Math.min(this.length, r) - a, o + a) === false)
      return false;
  }, e.prototype.forEachInvertedInner = function(i, s, r, o) {
    var a = this.left.length;
    if (s > a && this.right.forEachInvertedInner(i, s - a, Math.max(r, a) - a, o + a) === false || r < a && this.left.forEachInvertedInner(i, Math.min(s, a), r, o) === false)
      return false;
  }, e.prototype.sliceInner = function(i, s) {
    if (i == 0 && s == this.length)
      return this;
    var r = this.left.length;
    return s <= r ? this.left.slice(i, s) : i >= r ? this.right.slice(i - r, s - r) : this.left.slice(i, r).append(this.right.slice(0, s - r));
  }, e.prototype.leafAppend = function(i) {
    var s = this.right.leafAppend(i);
    if (s)
      return new e(this.left, s);
  }, e.prototype.leafPrepend = function(i) {
    var s = this.left.leafPrepend(i);
    if (s)
      return new e(s, this.right);
  }, e.prototype.appendInner = function(i) {
    return this.left.depth >= Math.max(this.right.depth, i.depth) + 1 ? new e(this.left, new e(this.right, i)) : new e(this, i);
  }, e;
}(qt);
var TV = 500;
var mi = class _mi {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let i = this.items.length;
    for (; ; i--)
      if (this.items.get(i - 1).selection) {
        --i;
        break;
      }
    let s, r;
    n && (s = this.remapping(i, this.items.length), r = s.maps.length);
    let o = e.tr, a, l, c = [], u = [];
    return this.items.forEach((d, f) => {
      if (!d.step) {
        s || (s = this.remapping(i, f + 1), r = s.maps.length), r--, u.push(d);
        return;
      }
      if (s) {
        u.push(new Ai(d.map));
        let h10 = d.step.map(s.slice(r)), p;
        h10 && o.maybeStep(h10).doc && (p = o.mapping.maps[o.mapping.maps.length - 1], c.push(new Ai(p, void 0, void 0, c.length + u.length))), r--, p && s.appendMap(p, r);
      } else
        o.maybeStep(d.step);
      if (d.selection)
        return a = s ? d.selection.map(s.slice(r)) : d.selection, l = new _mi(this.items.slice(0, i).append(u.reverse().concat(c)), this.eventCount - 1), false;
    }, this.items.length, 0), { remaining: l, transform: o, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, i, s) {
    let r = [], o = this.eventCount, a = this.items, l = !s && a.length ? a.get(a.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let d = e.steps[u].invert(e.docs[u]), f = new Ai(e.mapping.maps[u], d, n), h10;
      (h10 = l && l.merge(f)) && (f = h10, u ? r.pop() : a = a.slice(0, a.length - 1)), r.push(f), n && (o++, n = void 0), s || (l = f);
    }
    let c = o - i.depth;
    return c > _V && (a = AV(a, c), o -= c), new _mi(a.append(r), o);
  }
  remapping(e, n) {
    let i = new sl();
    return this.items.forEach((s, r) => {
      let o = s.mirrorOffset != null && r - s.mirrorOffset >= e ? i.maps.length - s.mirrorOffset : void 0;
      i.appendMap(s.map, o);
    }, e, n), i;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new _mi(this.items.append(e.map((n) => new Ai(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let i = [], s = Math.max(0, this.items.length - n), r = e.mapping, o = e.steps.length, a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, s);
    let l = n;
    this.items.forEach((f) => {
      let h10 = r.getMirror(--l);
      if (h10 == null)
        return;
      o = Math.min(o, h10);
      let p = r.maps[h10];
      if (f.step) {
        let g = e.steps[h10].invert(e.docs[h10]), m = f.selection && f.selection.map(r.slice(l + 1, h10));
        m && a++, i.push(new Ai(p, g, m));
      } else
        i.push(new Ai(p));
    }, s);
    let c = [];
    for (let f = n; f < o; f++)
      c.push(new Ai(r.maps[f]));
    let u = this.items.slice(0, s).append(c).append(i), d = new _mi(u, a);
    return d.emptyItemCount() > TV && (d = d.compress(this.items.length - i.length)), d;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), i = n.maps.length, s = [], r = 0;
    return this.items.forEach((o, a) => {
      if (a >= e)
        s.push(o), o.selection && r++;
      else if (o.step) {
        let l = o.step.map(n.slice(i)), c = l && l.getMap();
        if (i--, c && n.appendMap(c, i), l) {
          let u = o.selection && o.selection.map(n.slice(i));
          u && r++;
          let d = new Ai(c.invert(), l, u), f, h10 = s.length - 1;
          (f = s.length && s[h10].merge(d)) ? s[h10] = f : s.push(d);
        }
      } else o.map && i--;
    }, this.items.length, 0), new _mi(qt.from(s.reverse()), r);
  }
};
mi.empty = new mi(qt.empty, 0);
function AV(t10, e) {
  let n;
  return t10.forEach((i, s) => {
    if (i.selection && e-- == 0)
      return n = s, false;
  }), t10.slice(n);
}
var Ai = class _Ai {
  constructor(e, n, i, s) {
    this.map = e, this.step = n, this.selection = i, this.mirrorOffset = s;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new _Ai(n.getMap().invert(), n, this.selection);
    }
  }
};
var Ps = class {
  constructor(e, n, i, s, r) {
    this.done = e, this.undone = n, this.prevRanges = i, this.prevTime = s, this.prevComposition = r;
  }
};
var _V = 20;
function NV(t10, e, n, i) {
  let s = n.getMeta(Vr), r;
  if (s)
    return s.historyState;
  n.getMeta(PV) && (t10 = new Ps(t10.done, t10.undone, null, 0, -1));
  let o = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t10;
  if (o && o.getMeta(Vr))
    return o.getMeta(Vr).redo ? new Ps(t10.done.addTransform(n, void 0, i, Mc(e)), t10.undone, wb(n.mapping.maps), t10.prevTime, t10.prevComposition) : new Ps(t10.done, t10.undone.addTransform(n, void 0, i, Mc(e)), null, t10.prevTime, t10.prevComposition);
  if (n.getMeta("addToHistory") !== false && !(o && o.getMeta("addToHistory") === false)) {
    let a = n.getMeta("composition"), l = t10.prevTime == 0 || !o && t10.prevComposition != a && (t10.prevTime < (n.time || 0) - i.newGroupDelay || !LV(n, t10.prevRanges)), c = o ? Tf(t10.prevRanges, n.mapping) : wb(n.mapping.maps);
    return new Ps(t10.done.addTransform(n, l ? e.selection.getBookmark() : void 0, i, Mc(e)), mi.empty, c, n.time, a ?? t10.prevComposition);
  } else return (r = n.getMeta("rebased")) ? new Ps(t10.done.rebased(n, r), t10.undone.rebased(n, r), Tf(t10.prevRanges, n.mapping), t10.prevTime, t10.prevComposition) : new Ps(t10.done.addMaps(n.mapping.maps), t10.undone.addMaps(n.mapping.maps), Tf(t10.prevRanges, n.mapping), t10.prevTime, t10.prevComposition);
}
function LV(t10, e) {
  if (!e)
    return false;
  if (!t10.docChanged)
    return true;
  let n = false;
  return t10.mapping.maps[0].forEach((i, s) => {
    for (let r = 0; r < e.length; r += 2)
      i <= e[r + 1] && s >= e[r] && (n = true);
  }), n;
}
function wb(t10) {
  let e = [];
  for (let n = t10.length - 1; n >= 0 && e.length == 0; n--)
    t10[n].forEach((i, s, r, o) => e.push(r, o));
  return e;
}
function Tf(t10, e) {
  if (!t10)
    return null;
  let n = [];
  for (let i = 0; i < t10.length; i += 2) {
    let s = e.map(t10[i], 1), r = e.map(t10[i + 1], -1);
    s <= r && n.push(s, r);
  }
  return n;
}
function IV(t10, e, n) {
  let i = Mc(e), s = Vr.get(e).spec.config, r = (n ? t10.undone : t10.done).popEvent(e, i);
  if (!r)
    return null;
  let o = r.selection.resolve(r.transform.doc), a = (n ? t10.done : t10.undone).addTransform(r.transform, e.selection.getBookmark(), s, i), l = new Ps(n ? a : r.remaining, n ? r.remaining : a, null, 0, -1);
  return r.transform.setSelection(o).setMeta(Vr, { redo: n, historyState: l });
}
var Af = false;
var Cb = null;
function Mc(t10) {
  let e = t10.plugins;
  if (Cb != e) {
    Af = false, Cb = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        Af = true;
        break;
      }
  }
  return Af;
}
var Vr = new Zt("history");
var PV = new Zt("closeHistory");
function DV(t10 = {}) {
  return t10 = {
    depth: t10.depth || 100,
    newGroupDelay: t10.newGroupDelay || 500
  }, new It({
    key: Vr,
    state: {
      init() {
        return new Ps(mi.empty, mi.empty, null, 0, -1);
      },
      apply(e, n, i) {
        return NV(n, i, e, t10);
      }
    },
    config: t10,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let i = n.inputType, s = i == "historyUndo" ? uk : i == "historyRedo" ? dk : null;
          return s ? (n.preventDefault(), s(e.state, e.dispatch)) : false;
        }
      }
    }
  });
}
function ck(t10, e) {
  return (n, i) => {
    let s = Vr.getState(n);
    if (!s || (t10 ? s.undone : s.done).eventCount == 0)
      return false;
    if (i) {
      let r = IV(s, n, t10);
      r && i(e ? r.scrollIntoView() : r);
    }
    return true;
  };
}
var uk = ck(false, true);
var dk = ck(true, true);
var $V = Vt.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t10, dispatch: e }) => uk(t10, e),
      redo: () => ({ state: t10, dispatch: e }) => dk(t10, e)
    };
  },
  addProseMirrorPlugins() {
    return [
      DV(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
});
var RV = Rn.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["hr", Nt(this.options.HTMLAttributes, t10)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t10, state: e }) => {
        const { selection: n } = e, { $from: i, $to: s } = n, r = t10();
        return i.parentOffset === 0 ? r.insertContentAt({
          from: Math.max(i.pos - 1, 0),
          to: s.pos
        }, {
          type: this.name
        }) : Xx(n) ? r.insertContentAt(s.pos, {
          type: this.name
        }) : r.insertContent({ type: this.name }), r.command(({ tr: o, dispatch: a }) => {
          var l;
          if (a) {
            const { $to: c } = o.selection, u = c.end();
            if (c.nodeAfter)
              c.nodeAfter.isTextblock ? o.setSelection(Be.create(o.doc, c.pos + 1)) : c.nodeAfter.isBlock ? o.setSelection(Pe.create(o.doc, c.pos)) : o.setSelection(Be.create(o.doc, c.pos));
            else {
              const d = (l = c.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create();
              d && (o.insert(u, d), o.setSelection(Be.create(o.doc, u + 1)));
            }
            o.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      Id({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});
var FV = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var VV = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var BV = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var zV = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var jV = xi.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t10) => t10.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t10) => t10.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["em", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t10 }) => t10.setMark(this.name),
      toggleItalic: () => ({ commands: t10 }) => t10.toggleMark(this.name),
      unsetItalic: () => ({ commands: t10 }) => t10.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      Jr({
        find: FV,
        type: this.type
      }),
      Jr({
        find: BV,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ir({
        find: VV,
        type: this.type
      }),
      ir({
        find: zV,
        type: this.type
      })
    ];
  }
});
var HV = Rn.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["li", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var WV = "listItem";
var Ob = "textStyle";
var Eb = /^(\d+)\.\s$/;
var UV = Rn.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t10) => t10.hasAttribute("start") ? parseInt(t10.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: void 0,
        parseHTML: (t10) => t10.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    const { start: e, ...n } = t10;
    return e === 1 ? ["ol", Nt(this.options.HTMLAttributes, n), 0] : ["ol", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t10, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(WV, this.editor.getAttributes(Ob)).run() : t10.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t10 = ul({
      find: Eb,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t10 = ul({
      find: Eb,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes(Ob) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [
      t10
    ];
  }
});
var qV = Rn.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["p", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t10 }) => t10.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
var KV = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
var YV = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
var GV = xi.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (t10) => t10.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["s", Nt(this.options.HTMLAttributes, t10), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands: t10 }) => t10.setMark(this.name),
      toggleStrike: () => ({ commands: t10 }) => t10.toggleMark(this.name),
      unsetStrike: () => ({ commands: t10 }) => t10.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      Jr({
        find: KV,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      ir({
        find: YV,
        type: this.type
      })
    ];
  }
});
var JV = Rn.create({
  name: "text",
  group: "inline"
});
var XV = Vt.create({
  name: "starterKit",
  addExtensions() {
    var t10, e, n, i, s, r, o, a, l, c, u, d, f, h10, p, g, m, b;
    const x = [];
    return this.options.bold !== false && x.push(sV.configure((t10 = this.options) === null || t10 === void 0 ? void 0 : t10.bold)), this.options.blockquote !== false && x.push(ZF.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)), this.options.bulletList !== false && x.push(oV.configure((n = this.options) === null || n === void 0 ? void 0 : n.bulletList)), this.options.code !== false && x.push(cV.configure((i = this.options) === null || i === void 0 ? void 0 : i.code)), this.options.codeBlock !== false && x.push(fV.configure((s = this.options) === null || s === void 0 ? void 0 : s.codeBlock)), this.options.document !== false && x.push(hV.configure((r = this.options) === null || r === void 0 ? void 0 : r.document)), this.options.dropcursor !== false && x.push(gV.configure((o = this.options) === null || o === void 0 ? void 0 : o.dropcursor)), this.options.gapcursor !== false && x.push(CV.configure((a = this.options) === null || a === void 0 ? void 0 : a.gapcursor)), this.options.hardBreak !== false && x.push(OV.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)), this.options.heading !== false && x.push(EV.configure((c = this.options) === null || c === void 0 ? void 0 : c.heading)), this.options.history !== false && x.push($V.configure((u = this.options) === null || u === void 0 ? void 0 : u.history)), this.options.horizontalRule !== false && x.push(RV.configure((d = this.options) === null || d === void 0 ? void 0 : d.horizontalRule)), this.options.italic !== false && x.push(jV.configure((f = this.options) === null || f === void 0 ? void 0 : f.italic)), this.options.listItem !== false && x.push(HV.configure((h10 = this.options) === null || h10 === void 0 ? void 0 : h10.listItem)), this.options.orderedList !== false && x.push(UV.configure((p = this.options) === null || p === void 0 ? void 0 : p.orderedList)), this.options.paragraph !== false && x.push(qV.configure((g = this.options) === null || g === void 0 ? void 0 : g.paragraph)), this.options.strike !== false && x.push(GV.configure((m = this.options) === null || m === void 0 ? void 0 : m.strike)), this.options.text !== false && x.push(JV.configure((b = this.options) === null || b === void 0 ? void 0 : b.text)), x;
  }
});
var Pn = "top";
var di = "bottom";
var fi = "right";
var Dn = "left";
var Nm = "auto";
var Pl = [Pn, di, fi, Dn];
var Bo = "start";
var hl = "end";
var QV = "clippingParents";
var fk = "viewport";
var la = "popper";
var ZV = "reference";
var Mb = Pl.reduce(function(t10, e) {
  return t10.concat([e + "-" + Bo, e + "-" + hl]);
}, []);
var hk = [].concat(Pl, [Nm]).reduce(function(t10, e) {
  return t10.concat([e, e + "-" + Bo, e + "-" + hl]);
}, []);
var eB = "beforeRead";
var tB = "read";
var nB = "afterRead";
var iB = "beforeMain";
var sB = "main";
var rB = "afterMain";
var oB = "beforeWrite";
var aB = "write";
var lB = "afterWrite";
var cB = [eB, tB, nB, iB, sB, rB, oB, aB, lB];
function Gi(t10) {
  return t10 ? (t10.nodeName || "").toLowerCase() : null;
}
function Jn(t10) {
  if (t10 == null)
    return window;
  if (t10.toString() !== "[object Window]") {
    var e = t10.ownerDocument;
    return e && e.defaultView || window;
  }
  return t10;
}
function Xr(t10) {
  var e = Jn(t10).Element;
  return t10 instanceof e || t10 instanceof Element;
}
function ci(t10) {
  var e = Jn(t10).HTMLElement;
  return t10 instanceof e || t10 instanceof HTMLElement;
}
function Lm(t10) {
  if (typeof ShadowRoot > "u")
    return false;
  var e = Jn(t10).ShadowRoot;
  return t10 instanceof e || t10 instanceof ShadowRoot;
}
function uB(t10) {
  var e = t10.state;
  Object.keys(e.elements).forEach(function(n) {
    var i = e.styles[n] || {}, s = e.attributes[n] || {}, r = e.elements[n];
    !ci(r) || !Gi(r) || (Object.assign(r.style, i), Object.keys(s).forEach(function(o) {
      var a = s[o];
      a === false ? r.removeAttribute(o) : r.setAttribute(o, a === true ? "" : a);
    }));
  });
}
function dB(t10) {
  var e = t10.state, n = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(i) {
      var s = e.elements[i], r = e.attributes[i] || {}, o = Object.keys(e.styles.hasOwnProperty(i) ? e.styles[i] : n[i]), a = o.reduce(function(l, c) {
        return l[c] = "", l;
      }, {});
      !ci(s) || !Gi(s) || (Object.assign(s.style, a), Object.keys(r).forEach(function(l) {
        s.removeAttribute(l);
      }));
    });
  };
}
var pk = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: uB,
  effect: dB,
  requires: ["computeStyles"]
};
function zi(t10) {
  return t10.split("-")[0];
}
var Br = Math.max;
var Ru = Math.min;
var zo = Math.round;
function Qh() {
  var t10 = navigator.userAgentData;
  return t10 != null && t10.brands && Array.isArray(t10.brands) ? t10.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function mk() {
  return !/^((?!chrome|android).)*safari/i.test(Qh());
}
function jo(t10, e, n) {
  e === void 0 && (e = false), n === void 0 && (n = false);
  var i = t10.getBoundingClientRect(), s = 1, r = 1;
  e && ci(t10) && (s = t10.offsetWidth > 0 && zo(i.width) / t10.offsetWidth || 1, r = t10.offsetHeight > 0 && zo(i.height) / t10.offsetHeight || 1);
  var o = Xr(t10) ? Jn(t10) : window, a = o.visualViewport, l = !mk() && n, c = (i.left + (l && a ? a.offsetLeft : 0)) / s, u = (i.top + (l && a ? a.offsetTop : 0)) / r, d = i.width / s, f = i.height / r;
  return {
    width: d,
    height: f,
    top: u,
    right: c + d,
    bottom: u + f,
    left: c,
    x: c,
    y: u
  };
}
function Im(t10) {
  var e = jo(t10), n = t10.offsetWidth, i = t10.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - i) <= 1 && (i = e.height), {
    x: t10.offsetLeft,
    y: t10.offsetTop,
    width: n,
    height: i
  };
}
function gk(t10, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t10.contains(e))
    return true;
  if (n && Lm(n)) {
    var i = e;
    do {
      if (i && t10.isSameNode(i))
        return true;
      i = i.parentNode || i.host;
    } while (i);
  }
  return false;
}
function ks(t10) {
  return Jn(t10).getComputedStyle(t10);
}
function fB(t10) {
  return ["table", "td", "th"].indexOf(Gi(t10)) >= 0;
}
function cr(t10) {
  return ((Xr(t10) ? t10.ownerDocument : (
    // $FlowFixMe[prop-missing]
    t10.document
  )) || window.document).documentElement;
}
function Dd(t10) {
  return Gi(t10) === "html" ? t10 : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    t10.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    t10.parentNode || // DOM Element detected
    (Lm(t10) ? t10.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    cr(t10)
  );
}
function Tb(t10) {
  return !ci(t10) || // https://github.com/popperjs/popper-core/issues/837
  ks(t10).position === "fixed" ? null : t10.offsetParent;
}
function hB(t10) {
  var e = /firefox/i.test(Qh()), n = /Trident/i.test(Qh());
  if (n && ci(t10)) {
    var i = ks(t10);
    if (i.position === "fixed")
      return null;
  }
  var s = Dd(t10);
  for (Lm(s) && (s = s.host); ci(s) && ["html", "body"].indexOf(Gi(s)) < 0; ) {
    var r = ks(s);
    if (r.transform !== "none" || r.perspective !== "none" || r.contain === "paint" || ["transform", "perspective"].indexOf(r.willChange) !== -1 || e && r.willChange === "filter" || e && r.filter && r.filter !== "none")
      return s;
    s = s.parentNode;
  }
  return null;
}
function Dl(t10) {
  for (var e = Jn(t10), n = Tb(t10); n && fB(n) && ks(n).position === "static"; )
    n = Tb(n);
  return n && (Gi(n) === "html" || Gi(n) === "body" && ks(n).position === "static") ? e : n || hB(t10) || e;
}
function Pm(t10) {
  return ["top", "bottom"].indexOf(t10) >= 0 ? "x" : "y";
}
function Wa(t10, e, n) {
  return Br(t10, Ru(e, n));
}
function pB(t10, e, n) {
  var i = Wa(t10, e, n);
  return i > n ? n : i;
}
function bk() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function yk(t10) {
  return Object.assign({}, bk(), t10);
}
function vk(t10, e) {
  return e.reduce(function(n, i) {
    return n[i] = t10, n;
  }, {});
}
var mB = function(e, n) {
  return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
    placement: n.placement
  })) : e, yk(typeof e != "number" ? e : vk(e, Pl));
};
function gB(t10) {
  var e, n = t10.state, i = t10.name, s = t10.options, r = n.elements.arrow, o = n.modifiersData.popperOffsets, a = zi(n.placement), l = Pm(a), c = [Dn, fi].indexOf(a) >= 0, u = c ? "height" : "width";
  if (!(!r || !o)) {
    var d = mB(s.padding, n), f = Im(r), h10 = l === "y" ? Pn : Dn, p = l === "y" ? di : fi, g = n.rects.reference[u] + n.rects.reference[l] - o[l] - n.rects.popper[u], m = o[l] - n.rects.reference[l], b = Dl(r), x = b ? l === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, k = g / 2 - m / 2, v = d[h10], S = x - f[u] - d[p], w = x / 2 - f[u] / 2 + k, E = Wa(v, w, S), M = l;
    n.modifiersData[i] = (e = {}, e[M] = E, e.centerOffset = E - w, e);
  }
}
function bB(t10) {
  var e = t10.state, n = t10.options, i = n.element, s = i === void 0 ? "[data-popper-arrow]" : i;
  s != null && (typeof s == "string" && (s = e.elements.popper.querySelector(s), !s) || gk(e.elements.popper, s) && (e.elements.arrow = s));
}
var yB = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: gB,
  effect: bB,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function Ho(t10) {
  return t10.split("-")[1];
}
var vB = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function xB(t10, e) {
  var n = t10.x, i = t10.y, s = e.devicePixelRatio || 1;
  return {
    x: zo(n * s) / s || 0,
    y: zo(i * s) / s || 0
  };
}
function Ab(t10) {
  var e, n = t10.popper, i = t10.popperRect, s = t10.placement, r = t10.variation, o = t10.offsets, a = t10.position, l = t10.gpuAcceleration, c = t10.adaptive, u = t10.roundOffsets, d = t10.isFixed, f = o.x, h10 = f === void 0 ? 0 : f, p = o.y, g = p === void 0 ? 0 : p, m = typeof u == "function" ? u({
    x: h10,
    y: g
  }) : {
    x: h10,
    y: g
  };
  h10 = m.x, g = m.y;
  var b = o.hasOwnProperty("x"), x = o.hasOwnProperty("y"), k = Dn, v = Pn, S = window;
  if (c) {
    var w = Dl(n), E = "clientHeight", M = "clientWidth";
    if (w === Jn(n) && (w = cr(n), ks(w).position !== "static" && a === "absolute" && (E = "scrollHeight", M = "scrollWidth")), w = w, s === Pn || (s === Dn || s === fi) && r === hl) {
      v = di;
      var N = d && w === S && S.visualViewport ? S.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        w[E]
      );
      g -= N - i.height, g *= l ? 1 : -1;
    }
    if (s === Dn || (s === Pn || s === di) && r === hl) {
      k = fi;
      var V = d && w === S && S.visualViewport ? S.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        w[M]
      );
      h10 -= V - i.width, h10 *= l ? 1 : -1;
    }
  }
  var Y = Object.assign({
    position: a
  }, c && vB), F = u === true ? xB({
    x: h10,
    y: g
  }, Jn(n)) : {
    x: h10,
    y: g
  };
  if (h10 = F.x, g = F.y, l) {
    var re;
    return Object.assign({}, Y, (re = {}, re[v] = x ? "0" : "", re[k] = b ? "0" : "", re.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + h10 + "px, " + g + "px)" : "translate3d(" + h10 + "px, " + g + "px, 0)", re));
  }
  return Object.assign({}, Y, (e = {}, e[v] = x ? g + "px" : "", e[k] = b ? h10 + "px" : "", e.transform = "", e));
}
function kB(t10) {
  var e = t10.state, n = t10.options, i = n.gpuAcceleration, s = i === void 0 ? true : i, r = n.adaptive, o = r === void 0 ? true : r, a = n.roundOffsets, l = a === void 0 ? true : a, c = {
    placement: zi(e.placement),
    variation: Ho(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: s,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Ab(Object.assign({}, c, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: o,
    roundOffsets: l
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Ab(Object.assign({}, c, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: false,
    roundOffsets: l
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
var SB = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: kB,
  data: {}
};
var ec = {
  passive: true
};
function wB(t10) {
  var e = t10.state, n = t10.instance, i = t10.options, s = i.scroll, r = s === void 0 ? true : s, o = i.resize, a = o === void 0 ? true : o, l = Jn(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return r && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, ec);
  }), a && l.addEventListener("resize", n.update, ec), function() {
    r && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, ec);
    }), a && l.removeEventListener("resize", n.update, ec);
  };
}
var CB = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function() {
  },
  effect: wB,
  data: {}
};
var OB = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Tc(t10) {
  return t10.replace(/left|right|bottom|top/g, function(e) {
    return OB[e];
  });
}
var EB = {
  start: "end",
  end: "start"
};
function _b(t10) {
  return t10.replace(/start|end/g, function(e) {
    return EB[e];
  });
}
function Dm(t10) {
  var e = Jn(t10), n = e.pageXOffset, i = e.pageYOffset;
  return {
    scrollLeft: n,
    scrollTop: i
  };
}
function $m(t10) {
  return jo(cr(t10)).left + Dm(t10).scrollLeft;
}
function MB(t10, e) {
  var n = Jn(t10), i = cr(t10), s = n.visualViewport, r = i.clientWidth, o = i.clientHeight, a = 0, l = 0;
  if (s) {
    r = s.width, o = s.height;
    var c = mk();
    (c || !c && e === "fixed") && (a = s.offsetLeft, l = s.offsetTop);
  }
  return {
    width: r,
    height: o,
    x: a + $m(t10),
    y: l
  };
}
function TB(t10) {
  var e, n = cr(t10), i = Dm(t10), s = (e = t10.ownerDocument) == null ? void 0 : e.body, r = Br(n.scrollWidth, n.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0), o = Br(n.scrollHeight, n.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0), a = -i.scrollLeft + $m(t10), l = -i.scrollTop;
  return ks(s || n).direction === "rtl" && (a += Br(n.clientWidth, s ? s.clientWidth : 0) - r), {
    width: r,
    height: o,
    x: a,
    y: l
  };
}
function Rm(t10) {
  var e = ks(t10), n = e.overflow, i = e.overflowX, s = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + s + i);
}
function xk(t10) {
  return ["html", "body", "#document"].indexOf(Gi(t10)) >= 0 ? t10.ownerDocument.body : ci(t10) && Rm(t10) ? t10 : xk(Dd(t10));
}
function Ua(t10, e) {
  var n;
  e === void 0 && (e = []);
  var i = xk(t10), s = i === ((n = t10.ownerDocument) == null ? void 0 : n.body), r = Jn(i), o = s ? [r].concat(r.visualViewport || [], Rm(i) ? i : []) : i, a = e.concat(o);
  return s ? a : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    a.concat(Ua(Dd(o)))
  );
}
function Zh(t10) {
  return Object.assign({}, t10, {
    left: t10.x,
    top: t10.y,
    right: t10.x + t10.width,
    bottom: t10.y + t10.height
  });
}
function AB(t10, e) {
  var n = jo(t10, false, e === "fixed");
  return n.top = n.top + t10.clientTop, n.left = n.left + t10.clientLeft, n.bottom = n.top + t10.clientHeight, n.right = n.left + t10.clientWidth, n.width = t10.clientWidth, n.height = t10.clientHeight, n.x = n.left, n.y = n.top, n;
}
function Nb(t10, e, n) {
  return e === fk ? Zh(MB(t10, n)) : Xr(e) ? AB(e, n) : Zh(TB(cr(t10)));
}
function _B(t10) {
  var e = Ua(Dd(t10)), n = ["absolute", "fixed"].indexOf(ks(t10).position) >= 0, i = n && ci(t10) ? Dl(t10) : t10;
  return Xr(i) ? e.filter(function(s) {
    return Xr(s) && gk(s, i) && Gi(s) !== "body";
  }) : [];
}
function NB(t10, e, n, i) {
  var s = e === "clippingParents" ? _B(t10) : [].concat(e), r = [].concat(s, [n]), o = r[0], a = r.reduce(function(l, c) {
    var u = Nb(t10, c, i);
    return l.top = Br(u.top, l.top), l.right = Ru(u.right, l.right), l.bottom = Ru(u.bottom, l.bottom), l.left = Br(u.left, l.left), l;
  }, Nb(t10, o, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function kk(t10) {
  var e = t10.reference, n = t10.element, i = t10.placement, s = i ? zi(i) : null, r = i ? Ho(i) : null, o = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
  switch (s) {
    case Pn:
      l = {
        x: o,
        y: e.y - n.height
      };
      break;
    case di:
      l = {
        x: o,
        y: e.y + e.height
      };
      break;
    case fi:
      l = {
        x: e.x + e.width,
        y: a
      };
      break;
    case Dn:
      l = {
        x: e.x - n.width,
        y: a
      };
      break;
    default:
      l = {
        x: e.x,
        y: e.y
      };
  }
  var c = s ? Pm(s) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (r) {
      case Bo:
        l[c] = l[c] - (e[u] / 2 - n[u] / 2);
        break;
      case hl:
        l[c] = l[c] + (e[u] / 2 - n[u] / 2);
        break;
    }
  }
  return l;
}
function pl(t10, e) {
  e === void 0 && (e = {});
  var n = e, i = n.placement, s = i === void 0 ? t10.placement : i, r = n.strategy, o = r === void 0 ? t10.strategy : r, a = n.boundary, l = a === void 0 ? QV : a, c = n.rootBoundary, u = c === void 0 ? fk : c, d = n.elementContext, f = d === void 0 ? la : d, h10 = n.altBoundary, p = h10 === void 0 ? false : h10, g = n.padding, m = g === void 0 ? 0 : g, b = yk(typeof m != "number" ? m : vk(m, Pl)), x = f === la ? ZV : la, k = t10.rects.popper, v = t10.elements[p ? x : f], S = NB(Xr(v) ? v : v.contextElement || cr(t10.elements.popper), l, u, o), w = jo(t10.elements.reference), E = kk({
    reference: w,
    element: k,
    placement: s
  }), M = Zh(Object.assign({}, k, E)), N = f === la ? M : w, V = {
    top: S.top - N.top + b.top,
    bottom: N.bottom - S.bottom + b.bottom,
    left: S.left - N.left + b.left,
    right: N.right - S.right + b.right
  }, Y = t10.modifiersData.offset;
  if (f === la && Y) {
    var F = Y[s];
    Object.keys(V).forEach(function(re) {
      var z = [fi, di].indexOf(re) >= 0 ? 1 : -1, W = [Pn, di].indexOf(re) >= 0 ? "y" : "x";
      V[re] += F[W] * z;
    });
  }
  return V;
}
function LB(t10, e) {
  e === void 0 && (e = {});
  var n = e, i = n.placement, s = n.boundary, r = n.rootBoundary, o = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = l === void 0 ? hk : l, u = Ho(i), d = u ? a ? Mb : Mb.filter(function(p) {
    return Ho(p) === u;
  }) : Pl, f = d.filter(function(p) {
    return c.indexOf(p) >= 0;
  });
  f.length === 0 && (f = d);
  var h10 = f.reduce(function(p, g) {
    return p[g] = pl(t10, {
      placement: g,
      boundary: s,
      rootBoundary: r,
      padding: o
    })[zi(g)], p;
  }, {});
  return Object.keys(h10).sort(function(p, g) {
    return h10[p] - h10[g];
  });
}
function IB(t10) {
  if (zi(t10) === Nm)
    return [];
  var e = Tc(t10);
  return [_b(t10), e, _b(e)];
}
function PB(t10) {
  var e = t10.state, n = t10.options, i = t10.name;
  if (!e.modifiersData[i]._skip) {
    for (var s = n.mainAxis, r = s === void 0 ? true : s, o = n.altAxis, a = o === void 0 ? true : o, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, f = n.altBoundary, h10 = n.flipVariations, p = h10 === void 0 ? true : h10, g = n.allowedAutoPlacements, m = e.options.placement, b = zi(m), x = b === m, k = l || (x || !p ? [Tc(m)] : IB(m)), v = [m].concat(k).reduce(function(xe, Te) {
      return xe.concat(zi(Te) === Nm ? LB(e, {
        placement: Te,
        boundary: u,
        rootBoundary: d,
        padding: c,
        flipVariations: p,
        allowedAutoPlacements: g
      }) : Te);
    }, []), S = e.rects.reference, w = e.rects.popper, E = /* @__PURE__ */ new Map(), M = true, N = v[0], V = 0; V < v.length; V++) {
      var Y = v[V], F = zi(Y), re = Ho(Y) === Bo, z = [Pn, di].indexOf(F) >= 0, W = z ? "width" : "height", C = pl(e, {
        placement: Y,
        boundary: u,
        rootBoundary: d,
        altBoundary: f,
        padding: c
      }), O = z ? re ? fi : Dn : re ? di : Pn;
      S[W] > w[W] && (O = Tc(O));
      var _ = Tc(O), T = [];
      if (r && T.push(C[F] <= 0), a && T.push(C[O] <= 0, C[_] <= 0), T.every(function(xe) {
        return xe;
      })) {
        N = Y, M = false;
        break;
      }
      E.set(Y, T);
    }
    if (M)
      for (var H = p ? 3 : 1, Q = function(Te) {
        var L = v.find(function(K) {
          var B = E.get(K);
          if (B)
            return B.slice(0, Te).every(function(X) {
              return X;
            });
        });
        if (L)
          return N = L, "break";
      }, ae = H; ae > 0; ae--) {
        var pe = Q(ae);
        if (pe === "break") break;
      }
    e.placement !== N && (e.modifiersData[i]._skip = true, e.placement = N, e.reset = true);
  }
}
var DB = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: PB,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function Lb(t10, e, n) {
  return n === void 0 && (n = {
    x: 0,
    y: 0
  }), {
    top: t10.top - e.height - n.y,
    right: t10.right - e.width + n.x,
    bottom: t10.bottom - e.height + n.y,
    left: t10.left - e.width - n.x
  };
}
function Ib(t10) {
  return [Pn, fi, di, Dn].some(function(e) {
    return t10[e] >= 0;
  });
}
function $B(t10) {
  var e = t10.state, n = t10.name, i = e.rects.reference, s = e.rects.popper, r = e.modifiersData.preventOverflow, o = pl(e, {
    elementContext: "reference"
  }), a = pl(e, {
    altBoundary: true
  }), l = Lb(o, i), c = Lb(a, s, r), u = Ib(l), d = Ib(c);
  e.modifiersData[n] = {
    referenceClippingOffsets: l,
    popperEscapeOffsets: c,
    isReferenceHidden: u,
    hasPopperEscaped: d
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": u,
    "data-popper-escaped": d
  });
}
var RB = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: $B
};
function FB(t10, e, n) {
  var i = zi(t10), s = [Dn, Pn].indexOf(i) >= 0 ? -1 : 1, r = typeof n == "function" ? n(Object.assign({}, e, {
    placement: t10
  })) : n, o = r[0], a = r[1];
  return o = o || 0, a = (a || 0) * s, [Dn, fi].indexOf(i) >= 0 ? {
    x: a,
    y: o
  } : {
    x: o,
    y: a
  };
}
function VB(t10) {
  var e = t10.state, n = t10.options, i = t10.name, s = n.offset, r = s === void 0 ? [0, 0] : s, o = hk.reduce(function(u, d) {
    return u[d] = FB(d, e.rects, r), u;
  }, {}), a = o[e.placement], l = a.x, c = a.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[i] = o;
}
var BB = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: VB
};
function zB(t10) {
  var e = t10.state, n = t10.name;
  e.modifiersData[n] = kk({
    reference: e.rects.reference,
    element: e.rects.popper,
    placement: e.placement
  });
}
var jB = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: zB,
  data: {}
};
function HB(t10) {
  return t10 === "x" ? "y" : "x";
}
function WB(t10) {
  var e = t10.state, n = t10.options, i = t10.name, s = n.mainAxis, r = s === void 0 ? true : s, o = n.altAxis, a = o === void 0 ? false : o, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, f = n.tether, h10 = f === void 0 ? true : f, p = n.tetherOffset, g = p === void 0 ? 0 : p, m = pl(e, {
    boundary: l,
    rootBoundary: c,
    padding: d,
    altBoundary: u
  }), b = zi(e.placement), x = Ho(e.placement), k = !x, v = Pm(b), S = HB(v), w = e.modifiersData.popperOffsets, E = e.rects.reference, M = e.rects.popper, N = typeof g == "function" ? g(Object.assign({}, e.rects, {
    placement: e.placement
  })) : g, V = typeof N == "number" ? {
    mainAxis: N,
    altAxis: N
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, N), Y = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, F = {
    x: 0,
    y: 0
  };
  if (w) {
    if (r) {
      var re, z = v === "y" ? Pn : Dn, W = v === "y" ? di : fi, C = v === "y" ? "height" : "width", O = w[v], _ = O + m[z], T = O - m[W], H = h10 ? -M[C] / 2 : 0, Q = x === Bo ? E[C] : M[C], ae = x === Bo ? -M[C] : -E[C], pe = e.elements.arrow, xe = h10 && pe ? Im(pe) : {
        width: 0,
        height: 0
      }, Te = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : bk(), L = Te[z], K = Te[W], B = Wa(0, E[C], xe[C]), X = k ? E[C] / 2 - H - B - L - V.mainAxis : Q - B - L - V.mainAxis, be = k ? -E[C] / 2 + H + B + K + V.mainAxis : ae + B + K + V.mainAxis, Ce = e.elements.arrow && Dl(e.elements.arrow), Oe = Ce ? v === "y" ? Ce.clientTop || 0 : Ce.clientLeft || 0 : 0, Ue = (re = Y == null ? void 0 : Y[v]) != null ? re : 0, J = O + X - Ue - Oe, Fe = O + be - Ue, xt = Wa(h10 ? Ru(_, J) : _, O, h10 ? Br(T, Fe) : T);
      w[v] = xt, F[v] = xt - O;
    }
    if (a) {
      var Ct, Pt = v === "x" ? Pn : Dn, un = v === "x" ? di : fi, I = w[S], $ = S === "y" ? "height" : "width", ne = I + m[Pt], Se = I - m[un], Ze = [Pn, Dn].indexOf(b) !== -1, Qe = (Ct = Y == null ? void 0 : Y[S]) != null ? Ct : 0, Ye = Ze ? ne : I - E[$] - M[$] - Qe + V.altAxis, Z = Ze ? I + E[$] + M[$] - Qe - V.altAxis : Se, ue = h10 && Ze ? pB(Ye, I, Z) : Wa(h10 ? Ye : ne, I, h10 ? Z : Se);
      w[S] = ue, F[S] = ue - I;
    }
    e.modifiersData[i] = F;
  }
}
var UB = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: WB,
  requiresIfExists: ["offset"]
};
function qB(t10) {
  return {
    scrollLeft: t10.scrollLeft,
    scrollTop: t10.scrollTop
  };
}
function KB(t10) {
  return t10 === Jn(t10) || !ci(t10) ? Dm(t10) : qB(t10);
}
function YB(t10) {
  var e = t10.getBoundingClientRect(), n = zo(e.width) / t10.offsetWidth || 1, i = zo(e.height) / t10.offsetHeight || 1;
  return n !== 1 || i !== 1;
}
function GB(t10, e, n) {
  n === void 0 && (n = false);
  var i = ci(e), s = ci(e) && YB(e), r = cr(e), o = jo(t10, s, n), a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = {
    x: 0,
    y: 0
  };
  return (i || !i && !n) && ((Gi(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Rm(r)) && (a = KB(e)), ci(e) ? (l = jo(e, true), l.x += e.clientLeft, l.y += e.clientTop) : r && (l.x = $m(r))), {
    x: o.left + a.scrollLeft - l.x,
    y: o.top + a.scrollTop - l.y,
    width: o.width,
    height: o.height
  };
}
function JB(t10) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), i = [];
  t10.forEach(function(r) {
    e.set(r.name, r);
  });
  function s(r) {
    n.add(r.name);
    var o = [].concat(r.requires || [], r.requiresIfExists || []);
    o.forEach(function(a) {
      if (!n.has(a)) {
        var l = e.get(a);
        l && s(l);
      }
    }), i.push(r);
  }
  return t10.forEach(function(r) {
    n.has(r.name) || s(r);
  }), i;
}
function XB(t10) {
  var e = JB(t10);
  return cB.reduce(function(n, i) {
    return n.concat(e.filter(function(s) {
      return s.phase === i;
    }));
  }, []);
}
function QB(t10) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t10());
      });
    })), e;
  };
}
function ZB(t10) {
  var e = t10.reduce(function(n, i) {
    var s = n[i.name];
    return n[i.name] = s ? Object.assign({}, s, i, {
      options: Object.assign({}, s.options, i.options),
      data: Object.assign({}, s.data, i.data)
    }) : i, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var Pb = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function Db() {
  for (var t10 = arguments.length, e = new Array(t10), n = 0; n < t10; n++)
    e[n] = arguments[n];
  return !e.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function ez(t10) {
  t10 === void 0 && (t10 = {});
  var e = t10, n = e.defaultModifiers, i = n === void 0 ? [] : n, s = e.defaultOptions, r = s === void 0 ? Pb : s;
  return function(a, l, c) {
    c === void 0 && (c = r);
    var u = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, Pb, r),
      modifiersData: {},
      elements: {
        reference: a,
        popper: l
      },
      attributes: {},
      styles: {}
    }, d = [], f = false, h10 = {
      state: u,
      setOptions: function(b) {
        var x = typeof b == "function" ? b(u.options) : b;
        g(), u.options = Object.assign({}, r, u.options, x), u.scrollParents = {
          reference: Xr(a) ? Ua(a) : a.contextElement ? Ua(a.contextElement) : [],
          popper: Ua(l)
        };
        var k = XB(ZB([].concat(i, u.options.modifiers)));
        return u.orderedModifiers = k.filter(function(v) {
          return v.enabled;
        }), p(), h10.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!f) {
          var b = u.elements, x = b.reference, k = b.popper;
          if (Db(x, k)) {
            u.rects = {
              reference: GB(x, Dl(k), u.options.strategy === "fixed"),
              popper: Im(k)
            }, u.reset = false, u.placement = u.options.placement, u.orderedModifiers.forEach(function(V) {
              return u.modifiersData[V.name] = Object.assign({}, V.data);
            });
            for (var v = 0; v < u.orderedModifiers.length; v++) {
              if (u.reset === true) {
                u.reset = false, v = -1;
                continue;
              }
              var S = u.orderedModifiers[v], w = S.fn, E = S.options, M = E === void 0 ? {} : E, N = S.name;
              typeof w == "function" && (u = w({
                state: u,
                options: M,
                name: N,
                instance: h10
              }) || u);
            }
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: QB(function() {
        return new Promise(function(m) {
          h10.forceUpdate(), m(u);
        });
      }),
      destroy: function() {
        g(), f = true;
      }
    };
    if (!Db(a, l))
      return h10;
    h10.setOptions(c).then(function(m) {
      !f && c.onFirstUpdate && c.onFirstUpdate(m);
    });
    function p() {
      u.orderedModifiers.forEach(function(m) {
        var b = m.name, x = m.options, k = x === void 0 ? {} : x, v = m.effect;
        if (typeof v == "function") {
          var S = v({
            state: u,
            name: b,
            instance: h10,
            options: k
          }), w = function() {
          };
          d.push(S || w);
        }
      });
    }
    function g() {
      d.forEach(function(m) {
        return m();
      }), d = [];
    }
    return h10;
  };
}
var tz = [CB, jB, SB, pk, BB, DB, UB, yB, RB];
var nz = ez({
  defaultModifiers: tz
});
var iz = "tippy-box";
var Sk = "tippy-content";
var sz = "tippy-backdrop";
var wk = "tippy-arrow";
var Ck = "tippy-svg-arrow";
var kr = {
  passive: true,
  capture: true
};
var Ok = function() {
  return document.body;
};
function rz(t10, e) {
  return {}.hasOwnProperty.call(t10, e);
}
function _f(t10, e, n) {
  if (Array.isArray(t10)) {
    var i = t10[e];
    return i ?? (Array.isArray(n) ? n[e] : n);
  }
  return t10;
}
function Fm(t10, e) {
  var n = {}.toString.call(t10);
  return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function Ek(t10, e) {
  return typeof t10 == "function" ? t10.apply(void 0, e) : t10;
}
function $b(t10, e) {
  if (e === 0)
    return t10;
  var n;
  return function(i) {
    clearTimeout(n), n = setTimeout(function() {
      t10(i);
    }, e);
  };
}
function oz(t10, e) {
  var n = Object.assign({}, t10);
  return e.forEach(function(i) {
    delete n[i];
  }), n;
}
function az(t10) {
  return t10.split(/\s+/).filter(Boolean);
}
function mo(t10) {
  return [].concat(t10);
}
function Rb(t10, e) {
  t10.indexOf(e) === -1 && t10.push(e);
}
function lz(t10) {
  return t10.filter(function(e, n) {
    return t10.indexOf(e) === n;
  });
}
function cz(t10) {
  return t10.split("-")[0];
}
function Fu(t10) {
  return [].slice.call(t10);
}
function Fb(t10) {
  return Object.keys(t10).reduce(function(e, n) {
    return t10[n] !== void 0 && (e[n] = t10[n]), e;
  }, {});
}
function qa() {
  return document.createElement("div");
}
function ml(t10) {
  return ["Element", "Fragment"].some(function(e) {
    return Fm(t10, e);
  });
}
function uz(t10) {
  return Fm(t10, "NodeList");
}
function dz(t10) {
  return Fm(t10, "MouseEvent");
}
function fz(t10) {
  return !!(t10 && t10._tippy && t10._tippy.reference === t10);
}
function hz(t10) {
  return ml(t10) ? [t10] : uz(t10) ? Fu(t10) : Array.isArray(t10) ? t10 : Fu(document.querySelectorAll(t10));
}
function Nf(t10, e) {
  t10.forEach(function(n) {
    n && (n.style.transitionDuration = e + "ms");
  });
}
function Vb(t10, e) {
  t10.forEach(function(n) {
    n && n.setAttribute("data-state", e);
  });
}
function pz(t10) {
  var e, n = mo(t10), i = n[0];
  return i != null && (e = i.ownerDocument) != null && e.body ? i.ownerDocument : document;
}
function mz(t10, e) {
  var n = e.clientX, i = e.clientY;
  return t10.every(function(s) {
    var r = s.popperRect, o = s.popperState, a = s.props, l = a.interactiveBorder, c = cz(o.placement), u = o.modifiersData.offset;
    if (!u)
      return true;
    var d = c === "bottom" ? u.top.y : 0, f = c === "top" ? u.bottom.y : 0, h10 = c === "right" ? u.left.x : 0, p = c === "left" ? u.right.x : 0, g = r.top - i + d > l, m = i - r.bottom - f > l, b = r.left - n + h10 > l, x = n - r.right - p > l;
    return g || m || b || x;
  });
}
function Lf(t10, e, n) {
  var i = e + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(s) {
    t10[i](s, n);
  });
}
function Bb(t10, e) {
  for (var n = e; n; ) {
    var i;
    if (t10.contains(n))
      return true;
    n = n.getRootNode == null || (i = n.getRootNode()) == null ? void 0 : i.host;
  }
  return false;
}
var Ni = {
  isTouch: false
};
var zb = 0;
function gz() {
  Ni.isTouch || (Ni.isTouch = true, window.performance && document.addEventListener("mousemove", Mk));
}
function Mk() {
  var t10 = performance.now();
  t10 - zb < 20 && (Ni.isTouch = false, document.removeEventListener("mousemove", Mk)), zb = t10;
}
function bz() {
  var t10 = document.activeElement;
  if (fz(t10)) {
    var e = t10._tippy;
    t10.blur && !e.state.isVisible && t10.blur();
  }
}
function yz() {
  document.addEventListener("touchstart", gz, kr), window.addEventListener("blur", bz);
}
var vz = typeof window < "u" && typeof document < "u";
var xz = vz ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function lo(t10) {
  var e = t10 === "destroy" ? "n already-" : " ";
  return [t10 + "() was called on a" + e + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function jb(t10) {
  var e = /[ \t]{2,}/g, n = /^[ \t]*/gm;
  return t10.replace(e, " ").replace(n, "").trim();
}
function kz(t10) {
  return jb(`
  %ctippy.js

  %c` + jb(t10) + `

  %c👷‍ This is a development-only message. It will be removed in production.
  `);
}
function Tk(t10) {
  return [
    kz(t10),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var gl;
Sz();
function Sz() {
  gl = /* @__PURE__ */ new Set();
}
function ls(t10, e) {
  if (t10 && !gl.has(e)) {
    var n;
    gl.add(e), (n = console).warn.apply(n, Tk(e));
  }
}
function ep(t10, e) {
  if (t10 && !gl.has(e)) {
    var n;
    gl.add(e), (n = console).error.apply(n, Tk(e));
  }
}
function wz(t10) {
  var e = !t10, n = Object.prototype.toString.call(t10) === "[object Object]" && !t10.addEventListener;
  ep(e, ["tippy() was passed", "`" + String(t10) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), ep(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var Ak = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var Cz = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var Wn = Object.assign({
  appendTo: Ok,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function() {
  },
  onBeforeUpdate: function() {
  },
  onCreate: function() {
  },
  onDestroy: function() {
  },
  onHidden: function() {
  },
  onHide: function() {
  },
  onMount: function() {
  },
  onShow: function() {
  },
  onShown: function() {
  },
  onTrigger: function() {
  },
  onUntrigger: function() {
  },
  onClickOutside: function() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, Ak, Cz);
var Oz = Object.keys(Wn);
var Ez = function(e) {
  Nk(e, []);
  var n = Object.keys(e);
  n.forEach(function(i) {
    Wn[i] = e[i];
  });
};
function _k(t10) {
  var e = t10.plugins || [], n = e.reduce(function(i, s) {
    var r = s.name, o = s.defaultValue;
    if (r) {
      var a;
      i[r] = t10[r] !== void 0 ? t10[r] : (a = Wn[r]) != null ? a : o;
    }
    return i;
  }, {});
  return Object.assign({}, t10, n);
}
function Mz(t10, e) {
  var n = e ? Object.keys(_k(Object.assign({}, Wn, {
    plugins: e
  }))) : Oz, i = n.reduce(function(s, r) {
    var o = (t10.getAttribute("data-tippy-" + r) || "").trim();
    if (!o)
      return s;
    if (r === "content")
      s[r] = o;
    else
      try {
        s[r] = JSON.parse(o);
      } catch {
        s[r] = o;
      }
    return s;
  }, {});
  return i;
}
function Hb(t10, e) {
  var n = Object.assign({}, e, {
    content: Ek(e.content, [t10])
  }, e.ignoreAttributes ? {} : Mz(t10, e.plugins));
  return n.aria = Object.assign({}, Wn.aria, n.aria), n.aria = {
    expanded: n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
    content: n.aria.content === "auto" ? e.interactive ? null : "describedby" : n.aria.content
  }, n;
}
function Nk(t10, e) {
  t10 === void 0 && (t10 = {}), e === void 0 && (e = []);
  var n = Object.keys(t10);
  n.forEach(function(i) {
    var s = oz(Wn, Object.keys(Ak)), r = !rz(s, i);
    r && (r = e.filter(function(o) {
      return o.name === i;
    }).length === 0), ls(r, ["`" + i + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", `

`, `All props: https://atomiks.github.io/tippyjs/v6/all-props/
`, "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var Tz = function() {
  return "innerHTML";
};
function tp(t10, e) {
  t10[Tz()] = e;
}
function Wb(t10) {
  var e = qa();
  return t10 === true ? e.className = wk : (e.className = Ck, ml(t10) ? e.appendChild(t10) : tp(e, t10)), e;
}
function Ub(t10, e) {
  ml(e.content) ? (tp(t10, ""), t10.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? tp(t10, e.content) : t10.textContent = e.content);
}
function np(t10) {
  var e = t10.firstElementChild, n = Fu(e.children);
  return {
    box: e,
    content: n.find(function(i) {
      return i.classList.contains(Sk);
    }),
    arrow: n.find(function(i) {
      return i.classList.contains(wk) || i.classList.contains(Ck);
    }),
    backdrop: n.find(function(i) {
      return i.classList.contains(sz);
    })
  };
}
function Lk(t10) {
  var e = qa(), n = qa();
  n.className = iz, n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1");
  var i = qa();
  i.className = Sk, i.setAttribute("data-state", "hidden"), Ub(i, t10.props), e.appendChild(n), n.appendChild(i), s(t10.props, t10.props);
  function s(r, o) {
    var a = np(e), l = a.box, c = a.content, u = a.arrow;
    o.theme ? l.setAttribute("data-theme", o.theme) : l.removeAttribute("data-theme"), typeof o.animation == "string" ? l.setAttribute("data-animation", o.animation) : l.removeAttribute("data-animation"), o.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof o.maxWidth == "number" ? o.maxWidth + "px" : o.maxWidth, o.role ? l.setAttribute("role", o.role) : l.removeAttribute("role"), (r.content !== o.content || r.allowHTML !== o.allowHTML) && Ub(c, t10.props), o.arrow ? u ? r.arrow !== o.arrow && (l.removeChild(u), l.appendChild(Wb(o.arrow))) : l.appendChild(Wb(o.arrow)) : u && l.removeChild(u);
  }
  return {
    popper: e,
    onUpdate: s
  };
}
Lk.$$tippy = true;
var Az = 1;
var tc = [];
var If = [];
function _z(t10, e) {
  var n = Hb(t10, Object.assign({}, Wn, _k(Fb(e)))), i, s, r, o = false, a = false, l = false, c = false, u, d, f, h10 = [], p = $b(J, n.interactiveDebounce), g, m = Az++, b = null, x = lz(n.plugins), k = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  }, v = {
    // properties
    id: m,
    reference: t10,
    popper: qa(),
    popperInstance: b,
    props: n,
    state: k,
    plugins: x,
    // methods
    clearDelayTimeouts: Ye,
    setProps: Z,
    setContent: ue,
    show: Xe,
    hide: ht,
    hideWithInteractivity: U,
    enable: Ze,
    disable: Qe,
    unmount: q,
    destroy: se
  };
  if (!n.render)
    return ep(true, "render() function has not been supplied."), v;
  var S = n.render(v), w = S.popper, E = S.onUpdate;
  w.setAttribute("data-tippy-root", ""), w.id = "tippy-" + v.id, v.popper = w, t10._tippy = v, w._tippy = v;
  var M = x.map(function(R) {
    return R.fn(v);
  }), N = t10.hasAttribute("aria-expanded");
  return Ce(), H(), O(), _("onCreate", [v]), n.showOnCreate && ne(), w.addEventListener("mouseenter", function() {
    v.props.interactive && v.state.isVisible && v.clearDelayTimeouts();
  }), w.addEventListener("mouseleave", function() {
    v.props.interactive && v.props.trigger.indexOf("mouseenter") >= 0 && z().addEventListener("mousemove", p);
  }), v;
  function V() {
    var R = v.props.touch;
    return Array.isArray(R) ? R : [R, 0];
  }
  function Y() {
    return V()[0] === "hold";
  }
  function F() {
    var R;
    return !!((R = v.props.render) != null && R.$$tippy);
  }
  function re() {
    return g || t10;
  }
  function z() {
    var R = re().parentNode;
    return R ? pz(R) : document;
  }
  function W() {
    return np(w);
  }
  function C(R) {
    return v.state.isMounted && !v.state.isVisible || Ni.isTouch || u && u.type === "focus" ? 0 : _f(v.props.delay, R ? 0 : 1, Wn.delay);
  }
  function O(R) {
    R === void 0 && (R = false), w.style.pointerEvents = v.props.interactive && !R ? "" : "none", w.style.zIndex = "" + v.props.zIndex;
  }
  function _(R, ie, de) {
    if (de === void 0 && (de = true), M.forEach(function(_e) {
      _e[R] && _e[R].apply(_e, ie);
    }), de) {
      var ye;
      (ye = v.props)[R].apply(ye, ie);
    }
  }
  function T() {
    var R = v.props.aria;
    if (R.content) {
      var ie = "aria-" + R.content, de = w.id, ye = mo(v.props.triggerTarget || t10);
      ye.forEach(function(_e) {
        var Ge = _e.getAttribute(ie);
        if (v.state.isVisible)
          _e.setAttribute(ie, Ge ? Ge + " " + de : de);
        else {
          var rt = Ge && Ge.replace(de, "").trim();
          rt ? _e.setAttribute(ie, rt) : _e.removeAttribute(ie);
        }
      });
    }
  }
  function H() {
    if (!(N || !v.props.aria.expanded)) {
      var R = mo(v.props.triggerTarget || t10);
      R.forEach(function(ie) {
        v.props.interactive ? ie.setAttribute("aria-expanded", v.state.isVisible && ie === re() ? "true" : "false") : ie.removeAttribute("aria-expanded");
      });
    }
  }
  function Q() {
    z().removeEventListener("mousemove", p), tc = tc.filter(function(R) {
      return R !== p;
    });
  }
  function ae(R) {
    if (!(Ni.isTouch && (l || R.type === "mousedown"))) {
      var ie = R.composedPath && R.composedPath()[0] || R.target;
      if (!(v.props.interactive && Bb(w, ie))) {
        if (mo(v.props.triggerTarget || t10).some(function(de) {
          return Bb(de, ie);
        })) {
          if (Ni.isTouch || v.state.isVisible && v.props.trigger.indexOf("click") >= 0)
            return;
        } else
          _("onClickOutside", [v, R]);
        v.props.hideOnClick === true && (v.clearDelayTimeouts(), v.hide(), a = true, setTimeout(function() {
          a = false;
        }), v.state.isMounted || L());
      }
    }
  }
  function pe() {
    l = true;
  }
  function xe() {
    l = false;
  }
  function Te() {
    var R = z();
    R.addEventListener("mousedown", ae, true), R.addEventListener("touchend", ae, kr), R.addEventListener("touchstart", xe, kr), R.addEventListener("touchmove", pe, kr);
  }
  function L() {
    var R = z();
    R.removeEventListener("mousedown", ae, true), R.removeEventListener("touchend", ae, kr), R.removeEventListener("touchstart", xe, kr), R.removeEventListener("touchmove", pe, kr);
  }
  function K(R, ie) {
    X(R, function() {
      !v.state.isVisible && w.parentNode && w.parentNode.contains(w) && ie();
    });
  }
  function B(R, ie) {
    X(R, ie);
  }
  function X(R, ie) {
    var de = W().box;
    function ye(_e) {
      _e.target === de && (Lf(de, "remove", ye), ie());
    }
    if (R === 0)
      return ie();
    Lf(de, "remove", d), Lf(de, "add", ye), d = ye;
  }
  function be(R, ie, de) {
    de === void 0 && (de = false);
    var ye = mo(v.props.triggerTarget || t10);
    ye.forEach(function(_e) {
      _e.addEventListener(R, ie, de), h10.push({
        node: _e,
        eventType: R,
        handler: ie,
        options: de
      });
    });
  }
  function Ce() {
    Y() && (be("touchstart", Ue, {
      passive: true
    }), be("touchend", Fe, {
      passive: true
    })), az(v.props.trigger).forEach(function(R) {
      if (R !== "manual")
        switch (be(R, Ue), R) {
          case "mouseenter":
            be("mouseleave", Fe);
            break;
          case "focus":
            be(xz ? "focusout" : "blur", xt);
            break;
          case "focusin":
            be("focusout", xt);
            break;
        }
    });
  }
  function Oe() {
    h10.forEach(function(R) {
      var ie = R.node, de = R.eventType, ye = R.handler, _e = R.options;
      ie.removeEventListener(de, ye, _e);
    }), h10 = [];
  }
  function Ue(R) {
    var ie, de = false;
    if (!(!v.state.isEnabled || Ct(R) || a)) {
      var ye = ((ie = u) == null ? void 0 : ie.type) === "focus";
      u = R, g = R.currentTarget, H(), !v.state.isVisible && dz(R) && tc.forEach(function(_e) {
        return _e(R);
      }), R.type === "click" && (v.props.trigger.indexOf("mouseenter") < 0 || o) && v.props.hideOnClick !== false && v.state.isVisible ? de = true : ne(R), R.type === "click" && (o = !de), de && !ye && Se(R);
    }
  }
  function J(R) {
    var ie = R.target, de = re().contains(ie) || w.contains(ie);
    if (!(R.type === "mousemove" && de)) {
      var ye = $().concat(w).map(function(_e) {
        var Ge, rt = _e._tippy, nt = (Ge = rt.popperInstance) == null ? void 0 : Ge.state;
        return nt ? {
          popperRect: _e.getBoundingClientRect(),
          popperState: nt,
          props: n
        } : null;
      }).filter(Boolean);
      mz(ye, R) && (Q(), Se(R));
    }
  }
  function Fe(R) {
    var ie = Ct(R) || v.props.trigger.indexOf("click") >= 0 && o;
    if (!ie) {
      if (v.props.interactive) {
        v.hideWithInteractivity(R);
        return;
      }
      Se(R);
    }
  }
  function xt(R) {
    v.props.trigger.indexOf("focusin") < 0 && R.target !== re() || v.props.interactive && R.relatedTarget && w.contains(R.relatedTarget) || Se(R);
  }
  function Ct(R) {
    return Ni.isTouch ? Y() !== R.type.indexOf("touch") >= 0 : false;
  }
  function Pt() {
    un();
    var R = v.props, ie = R.popperOptions, de = R.placement, ye = R.offset, _e = R.getReferenceClientRect, Ge = R.moveTransition, rt = F() ? np(w).arrow : null, nt = _e ? {
      getBoundingClientRect: _e,
      contextElement: _e.contextElement || re()
    } : t10, Bt = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function(Si) {
        var wi = Si.state;
        if (F()) {
          var ia = W(), pr = ia.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(Os) {
            Os === "placement" ? pr.setAttribute("data-placement", wi.placement) : wi.attributes.popper["data-popper-" + Os] ? pr.setAttribute("data-" + Os, "") : pr.removeAttribute("data-" + Os);
          }), wi.attributes.popper = {};
        }
      }
    }, Ot = [{
      name: "offset",
      options: {
        offset: ye
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !Ge
      }
    }, Bt];
    F() && rt && Ot.push({
      name: "arrow",
      options: {
        element: rt,
        padding: 3
      }
    }), Ot.push.apply(Ot, (ie == null ? void 0 : ie.modifiers) || []), v.popperInstance = nz(nt, w, Object.assign({}, ie, {
      placement: de,
      onFirstUpdate: f,
      modifiers: Ot
    }));
  }
  function un() {
    v.popperInstance && (v.popperInstance.destroy(), v.popperInstance = null);
  }
  function I() {
    var R = v.props.appendTo, ie, de = re();
    v.props.interactive && R === Ok || R === "parent" ? ie = de.parentNode : ie = Ek(R, [de]), ie.contains(w) || ie.appendChild(w), v.state.isMounted = true, Pt(), ls(v.props.interactive && R === Wn.appendTo && de.nextElementSibling !== w, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", `

`, "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", `

`, "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", `

`, "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
  }
  function $() {
    return Fu(w.querySelectorAll("[data-tippy-root]"));
  }
  function ne(R) {
    v.clearDelayTimeouts(), R && _("onTrigger", [v, R]), Te();
    var ie = C(true), de = V(), ye = de[0], _e = de[1];
    Ni.isTouch && ye === "hold" && _e && (ie = _e), ie ? i = setTimeout(function() {
      v.show();
    }, ie) : v.show();
  }
  function Se(R) {
    if (v.clearDelayTimeouts(), _("onUntrigger", [v, R]), !v.state.isVisible) {
      L();
      return;
    }
    if (!(v.props.trigger.indexOf("mouseenter") >= 0 && v.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(R.type) >= 0 && o)) {
      var ie = C(false);
      ie ? s = setTimeout(function() {
        v.state.isVisible && v.hide();
      }, ie) : r = requestAnimationFrame(function() {
        v.hide();
      });
    }
  }
  function Ze() {
    v.state.isEnabled = true;
  }
  function Qe() {
    v.hide(), v.state.isEnabled = false;
  }
  function Ye() {
    clearTimeout(i), clearTimeout(s), cancelAnimationFrame(r);
  }
  function Z(R) {
    if (ls(v.state.isDestroyed, lo("setProps")), !v.state.isDestroyed) {
      _("onBeforeUpdate", [v, R]), Oe();
      var ie = v.props, de = Hb(t10, Object.assign({}, ie, Fb(R), {
        ignoreAttributes: true
      }));
      v.props = de, Ce(), ie.interactiveDebounce !== de.interactiveDebounce && (Q(), p = $b(J, de.interactiveDebounce)), ie.triggerTarget && !de.triggerTarget ? mo(ie.triggerTarget).forEach(function(ye) {
        ye.removeAttribute("aria-expanded");
      }) : de.triggerTarget && t10.removeAttribute("aria-expanded"), H(), O(), E && E(ie, de), v.popperInstance && (Pt(), $().forEach(function(ye) {
        requestAnimationFrame(ye._tippy.popperInstance.forceUpdate);
      })), _("onAfterUpdate", [v, R]);
    }
  }
  function ue(R) {
    v.setProps({
      content: R
    });
  }
  function Xe() {
    ls(v.state.isDestroyed, lo("show"));
    var R = v.state.isVisible, ie = v.state.isDestroyed, de = !v.state.isEnabled, ye = Ni.isTouch && !v.props.touch, _e = _f(v.props.duration, 0, Wn.duration);
    if (!(R || ie || de || ye) && !re().hasAttribute("disabled") && (_("onShow", [v], false), v.props.onShow(v) !== false)) {
      if (v.state.isVisible = true, F() && (w.style.visibility = "visible"), O(), Te(), v.state.isMounted || (w.style.transition = "none"), F()) {
        var Ge = W(), rt = Ge.box, nt = Ge.content;
        Nf([rt, nt], 0);
      }
      f = function() {
        var Ot;
        if (!(!v.state.isVisible || c)) {
          if (c = true, w.offsetHeight, w.style.transition = v.props.moveTransition, F() && v.props.animation) {
            var en = W(), Si = en.box, wi = en.content;
            Nf([Si, wi], _e), Vb([Si, wi], "visible");
          }
          T(), H(), Rb(If, v), (Ot = v.popperInstance) == null || Ot.forceUpdate(), _("onMount", [v]), v.props.animation && F() && B(_e, function() {
            v.state.isShown = true, _("onShown", [v]);
          });
        }
      }, I();
    }
  }
  function ht() {
    ls(v.state.isDestroyed, lo("hide"));
    var R = !v.state.isVisible, ie = v.state.isDestroyed, de = !v.state.isEnabled, ye = _f(v.props.duration, 1, Wn.duration);
    if (!(R || ie || de) && (_("onHide", [v], false), v.props.onHide(v) !== false)) {
      if (v.state.isVisible = false, v.state.isShown = false, c = false, o = false, F() && (w.style.visibility = "hidden"), Q(), L(), O(true), F()) {
        var _e = W(), Ge = _e.box, rt = _e.content;
        v.props.animation && (Nf([Ge, rt], ye), Vb([Ge, rt], "hidden"));
      }
      T(), H(), v.props.animation ? F() && K(ye, v.unmount) : v.unmount();
    }
  }
  function U(R) {
    ls(v.state.isDestroyed, lo("hideWithInteractivity")), z().addEventListener("mousemove", p), Rb(tc, p), p(R);
  }
  function q() {
    ls(v.state.isDestroyed, lo("unmount")), v.state.isVisible && v.hide(), v.state.isMounted && (un(), $().forEach(function(R) {
      R._tippy.unmount();
    }), w.parentNode && w.parentNode.removeChild(w), If = If.filter(function(R) {
      return R !== v;
    }), v.state.isMounted = false, _("onHidden", [v]));
  }
  function se() {
    ls(v.state.isDestroyed, lo("destroy")), !v.state.isDestroyed && (v.clearDelayTimeouts(), v.unmount(), Oe(), delete t10._tippy, v.state.isDestroyed = true, _("onDestroy", [v]));
  }
}
function Qo(t10, e) {
  e === void 0 && (e = {});
  var n = Wn.plugins.concat(e.plugins || []);
  wz(t10), Nk(e, n), yz();
  var i = Object.assign({}, e, {
    plugins: n
  }), s = hz(t10);
  if (true) {
    var r = ml(i.content), o = s.length > 1;
    ls(r && o, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", `

`, "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", `

`, `1) content: element.innerHTML
`, "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var a = s.reduce(function(l, c) {
    var u = c && _z(c, i);
    return u && l.push(u), l;
  }, []);
  return ml(t10) ? a[0] : a;
}
Qo.defaultProps = Wn;
Qo.setDefaultProps = Ez;
Qo.currentInput = Ni;
Object.assign({}, pk, {
  effect: function(e) {
    var n = e.state, i = {
      popper: {
        position: n.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(n.elements.popper.style, i.popper), n.styles = i, n.elements.arrow && Object.assign(n.elements.arrow.style, i.arrow);
  }
});
Qo.setDefaultProps({
  render: Lk
});
var Nz = class {
  constructor({ editor: e, element: n, view: i, tippyOptions: s = {}, updateDelay: r = 250, shouldShow: o }) {
    this.preventHide = false, this.shouldShow = ({ view: a, state: l, from: c, to: u }) => {
      const { doc: d, selection: f } = l, { empty: h10 } = f, p = !d.textBetween(c, u).length && bm(l.selection), g = this.element.contains(document.activeElement);
      return !(!(a.hasFocus() || g) || h10 || p || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = true;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: a }) => {
      var l;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      a != null && a.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(a.relatedTarget)) || (a == null ? void 0 : a.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (a) => {
      this.blurHandler({ event: a });
    }, this.handleDebouncedUpdate = (a, l) => {
      const c = !(l != null && l.selection.eq(a.state.selection)), u = !(l != null && l.doc.eq(a.state.doc));
      !c && !u || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(a, c, u, l);
      }, this.updateDelay));
    }, this.updateHandler = (a, l, c, u) => {
      var d, f, h10;
      const { state: p, composing: g } = a, { selection: m } = p;
      if (g || !l && !c)
        return;
      this.createTooltip();
      const { ranges: x } = m, k = Math.min(...x.map((w) => w.$from.pos)), v = Math.max(...x.map((w) => w.$to.pos));
      if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, {
        editor: this.editor,
        element: this.element,
        view: a,
        state: p,
        oldState: u,
        from: k,
        to: v
      }))) {
        this.hide();
        return;
      }
      (f = this.tippy) === null || f === void 0 || f.setProps({
        getReferenceClientRect: ((h10 = this.tippyOptions) === null || h10 === void 0 ? void 0 : h10.getReferenceClientRect) || (() => {
          if (Xx(p.selection)) {
            let w = a.nodeDOM(k);
            if (w) {
              const E = w.dataset.nodeViewWrapper ? w : w.querySelector("[data-node-view-wrapper]");
              if (E && (w = E.firstChild), w)
                return w.getBoundingClientRect();
            }
          }
          return Qx(a, k, v);
        })
      }), this.show();
    }, this.editor = e, this.element = n, this.view = i, this.updateDelay = r, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = s, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Qo(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    const { state: i } = e, s = i.selection.from !== i.selection.to;
    if (this.updateDelay > 0 && s) {
      this.handleDebouncedUpdate(e, n);
      return;
    }
    const r = !(n != null && n.selection.eq(e.state.selection)), o = !(n != null && n.doc.eq(e.state.doc));
    this.updateHandler(e, r, o, n);
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
};
var Ik = (t10) => new It({
  key: typeof t10.pluginKey == "string" ? new Zt(t10.pluginKey) : t10.pluginKey,
  view: (e) => new Nz({ view: e, ...t10 })
});
Vt.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      Ik({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
var Lz = class {
  getTextContent(e) {
    return Gx(e, { textSerializers: mm(this.editor.schema) });
  }
  constructor({ editor: e, element: n, view: i, tippyOptions: s = {}, shouldShow: r }) {
    this.preventHide = false, this.shouldShow = ({ view: o, state: a }) => {
      const { selection: l } = a, { $anchor: c, empty: u } = l, d = c.depth === 1, f = c.parent.isTextblock && !c.parent.type.spec.code && !c.parent.textContent && c.parent.childCount === 0 && !this.getTextContent(c.parent);
      return !(!o.hasFocus() || !u || !d || !f || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = true;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: o }) => {
      var a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      o != null && o.relatedTarget && (!((a = this.element.parentNode) === null || a === void 0) && a.contains(o.relatedTarget)) || (o == null ? void 0 : o.relatedTarget) !== this.editor.view.dom && this.hide();
    }, this.tippyBlurHandler = (o) => {
      this.blurHandler({ event: o });
    }, this.editor = e, this.element = n, this.view = i, r && (this.shouldShow = r), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = s, this.element.remove(), this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: e } = this.editor.options, n = !!e.parentElement;
    this.tippy || !n || (this.tippy = Qo(e, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "right",
      hideOnClick: "toggle",
      ...this.tippyOptions
    }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler));
  }
  update(e, n) {
    var i, s, r;
    const { state: o } = e, { doc: a, selection: l } = o, { from: c, to: u } = l;
    if (n && n.doc.eq(a) && n.selection.eq(l))
      return;
    if (this.createTooltip(), !((i = this.shouldShow) === null || i === void 0 ? void 0 : i.call(this, {
      editor: this.editor,
      view: e,
      state: o,
      oldState: n
    }))) {
      this.hide();
      return;
    }
    (s = this.tippy) === null || s === void 0 || s.setProps({
      getReferenceClientRect: ((r = this.tippyOptions) === null || r === void 0 ? void 0 : r.getReferenceClientRect) || (() => Qx(e, c, u))
    }), this.show();
  }
  show() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.show();
  }
  hide() {
    var e;
    (e = this.tippy) === null || e === void 0 || e.hide();
  }
  destroy() {
    var e, n;
    !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (n = this.tippy) === null || n === void 0 || n.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler);
  }
};
var Pk = (t10) => new It({
  key: typeof t10.pluginKey == "string" ? new Zt(t10.pluginKey) : t10.pluginKey,
  view: (e) => new Lz({ view: e, ...t10 })
});
Vt.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "floatingMenu",
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      Pk({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
defineComponent({
  name: "BubbleMenu",
  props: {
    pluginKey: {
      type: [String, Object],
      default: "bubbleMenu"
    },
    editor: {
      type: Object,
      required: true
    },
    updateDelay: {
      type: Number,
      default: void 0
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t10, { slots: e }) {
    const n = ref(null);
    return onMounted(() => {
      const { updateDelay: i, editor: s, pluginKey: r, shouldShow: o, tippyOptions: a } = t10;
      s.registerPlugin(Ik({
        updateDelay: i,
        editor: s,
        element: n.value,
        pluginKey: r,
        shouldShow: o,
        tippyOptions: a
      }));
    }), onBeforeUnmount(() => {
      const { pluginKey: i, editor: s } = t10;
      s.unregisterPlugin(i);
    }), () => {
      var i;
      return h("div", { ref: n }, (i = e.default) === null || i === void 0 ? void 0 : i.call(e));
    };
  }
});
function qb(t10) {
  return customRef((e, n) => ({
    get() {
      return e(), t10;
    },
    set(i) {
      t10 = i, requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          n();
        });
      });
    }
  }));
}
var Iz = class extends vF {
  constructor(e = {}) {
    return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = qb(this.view.state), this.reactiveExtensionStorage = qb(this.extensionStorage), this.on("beforeTransaction", ({ nextState: n }) => {
      this.reactiveState.value = n, this.reactiveExtensionStorage.value = this.extensionStorage;
    }), markRaw(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(e, n) {
    const i = super.registerPlugin(e, n);
    return this.reactiveState && (this.reactiveState.value = i), i;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(e) {
    const n = super.unregisterPlugin(e);
    return this.reactiveState && n && (this.reactiveState.value = n), n;
  }
};
var Pz = defineComponent({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(t10) {
    const e = ref(), n = getCurrentInstance();
    return watchEffect(() => {
      const i = t10.editor;
      i && i.options.element && e.value && nextTick(() => {
        if (!e.value || !i.options.element.firstChild)
          return;
        const s = unref(e.value);
        e.value.append(...i.options.element.childNodes), i.contentComponent = n.ctx._, n && (i.appContext = {
          ...n.appContext,
          // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
          // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
          // @ts-expect-error forward instance's 'provides' into appContext
          provides: n.provides
        }), i.setOptions({
          element: s
        }), i.createNodeViews();
      });
    }), onBeforeUnmount(() => {
      const i = t10.editor;
      i && (i.contentComponent = null, i.appContext = null);
    }), { rootEl: e };
  },
  render() {
    return h("div", {
      ref: (t10) => {
        this.rootEl = t10;
      }
    });
  }
});
defineComponent({
  name: "FloatingMenu",
  props: {
    pluginKey: {
      // TODO: TypeScript breaks :(
      // type: [String, Object as PropType<Exclude<FloatingMenuPluginProps['pluginKey'], string>>],
      type: null,
      default: "floatingMenu"
    },
    editor: {
      type: Object,
      required: true
    },
    tippyOptions: {
      type: Object,
      default: () => ({})
    },
    shouldShow: {
      type: Function,
      default: null
    }
  },
  setup(t10, { slots: e }) {
    const n = ref(null);
    return onMounted(() => {
      const { pluginKey: i, editor: s, tippyOptions: r, shouldShow: o } = t10;
      s.registerPlugin(Pk({
        pluginKey: i,
        editor: s,
        element: n.value,
        tippyOptions: r,
        shouldShow: o
      }));
    }), onBeforeUnmount(() => {
      const { pluginKey: i, editor: s } = t10;
      s.unregisterPlugin(i);
    }), () => {
      var i;
      return h("div", { ref: n }, (i = e.default) === null || i === void 0 ? void 0 : i.call(e));
    };
  }
});
defineComponent({
  name: "NodeViewContent",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  render() {
    return h(this.as, {
      style: {
        whiteSpace: "pre-wrap"
      },
      "data-node-view-content": ""
    });
  }
});
defineComponent({
  name: "NodeViewWrapper",
  props: {
    as: {
      type: String,
      default: "div"
    }
  },
  inject: ["onDragStart", "decorationClasses"],
  render() {
    var t10, e;
    return h(this.as, {
      // @ts-ignore
      class: this.decorationClasses,
      style: {
        whiteSpace: "normal"
      },
      "data-node-view-wrapper": "",
      // @ts-ignore (https://github.com/vuejs/vue-next/issues/3031)
      onDragstart: this.onDragStart
    }, (e = (t10 = this.$slots).default) === null || e === void 0 ? void 0 : e.call(t10));
  }
});
var Dz = (t10 = {}) => {
  const e = shallowRef();
  return onMounted(() => {
    e.value = new Iz(t10);
  }), onBeforeUnmount(() => {
    var n, i, s;
    const r = (n = e.value) === null || n === void 0 ? void 0 : n.options.element, o = r == null ? void 0 : r.cloneNode(true);
    (i = r == null ? void 0 : r.parentNode) === null || i === void 0 || i.replaceChild(o, r), (s = e.value) === null || s === void 0 || s.destroy();
  }), e;
};
function $d(t10) {
  return getCurrentScope() ? (onScopeDispose(t10), true) : false;
}
function $l(t10) {
  return typeof t10 == "function" ? t10() : unref(t10);
}
var Dk = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var $z = (t10) => t10 != null;
var Rz = Object.prototype.toString;
var Fz = (t10) => Rz.call(t10) === "[object Object]";
var Vz = () => {
};
function Bz(t10) {
  return getCurrentInstance();
}
function Vm(t10, e = true, n) {
  Bz() ? onMounted(t10, n) : e ? t10() : nextTick(t10);
}
var Rl = Dk ? window : void 0;
var zz = Dk ? window.document : void 0;
function Di(t10) {
  var e;
  const n = $l(t10);
  return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
function Kb(...t10) {
  let e, n, i, s;
  if (typeof t10[0] == "string" || Array.isArray(t10[0]) ? ([n, i, s] = t10, e = Rl) : [e, n, i, s] = t10, !e)
    return Vz;
  Array.isArray(n) || (n = [n]), Array.isArray(i) || (i = [i]);
  const r = [], o = () => {
    r.forEach((u) => u()), r.length = 0;
  }, a = (u, d, f, h10) => (u.addEventListener(d, f, h10), () => u.removeEventListener(d, f, h10)), l = watch(
    () => [Di(e), $l(s)],
    ([u, d]) => {
      if (o(), !u)
        return;
      const f = Fz(d) ? { ...d } : d;
      r.push(
        ...n.flatMap((h10) => i.map((p) => a(u, h10, p, f)))
      );
    },
    { immediate: true, flush: "post" }
  ), c = () => {
    l(), o();
  };
  return $d(c), c;
}
function jz() {
  const t10 = ref(false), e = getCurrentInstance();
  return e && onMounted(() => {
    t10.value = true;
  }, e), t10;
}
function Bm(t10) {
  const e = jz();
  return computed(() => (e.value, !!t10()));
}
function $k(t10, e, n = {}) {
  const { window: i = Rl, ...s } = n;
  let r;
  const o = Bm(() => i && "MutationObserver" in i), a = () => {
    r && (r.disconnect(), r = void 0);
  }, l = computed(() => {
    const f = $l(t10), h10 = (Array.isArray(f) ? f : [f]).map(Di).filter($z);
    return new Set(h10);
  }), c = watch(
    () => l.value,
    (f) => {
      a(), o.value && f.size && (r = new MutationObserver(e), f.forEach((h10) => r.observe(h10, s)));
    },
    { immediate: true, flush: "post" }
  ), u = () => r == null ? void 0 : r.takeRecords(), d = () => {
    c(), a();
  };
  return $d(d), {
    isSupported: o,
    stop: d,
    takeRecords: u
  };
}
function ip(t10, e = {}) {
  const { window: n = Rl } = e, i = Bm(() => n && "matchMedia" in n && typeof n.matchMedia == "function");
  let s;
  const r = ref(false), o = (c) => {
    r.value = c.matches;
  }, a = () => {
    s && ("removeEventListener" in s ? s.removeEventListener("change", o) : s.removeListener(o));
  }, l = watchEffect(() => {
    i.value && (a(), s = n.matchMedia($l(t10)), "addEventListener" in s ? s.addEventListener("change", o) : s.addListener(o), r.value = s.matches);
  });
  return $d(() => {
    l(), a(), s = void 0;
  }), r;
}
function Rk(t10, e, n = {}) {
  const { window: i = Rl, ...s } = n;
  let r;
  const o = Bm(() => i && "ResizeObserver" in i), a = () => {
    r && (r.disconnect(), r = void 0);
  }, l = computed(() => {
    const d = $l(t10);
    return Array.isArray(d) ? d.map((f) => Di(f)) : [Di(d)];
  }), c = watch(
    l,
    (d) => {
      if (a(), o.value && i) {
        r = new ResizeObserver(e);
        for (const f of d)
          f && r.observe(f, s);
      }
    },
    { immediate: true, flush: "post" }
  ), u = () => {
    a(), c();
  };
  return $d(u), {
    isSupported: o,
    stop: u
  };
}
function Hz(t10, e = {}) {
  const {
    reset: n = true,
    windowResize: i = true,
    windowScroll: s = true,
    immediate: r = true,
    updateTiming: o = "sync"
  } = e, a = ref(0), l = ref(0), c = ref(0), u = ref(0), d = ref(0), f = ref(0), h10 = ref(0), p = ref(0);
  function g() {
    const b = Di(t10);
    if (!b) {
      n && (a.value = 0, l.value = 0, c.value = 0, u.value = 0, d.value = 0, f.value = 0, h10.value = 0, p.value = 0);
      return;
    }
    const x = b.getBoundingClientRect();
    a.value = x.height, l.value = x.bottom, c.value = x.left, u.value = x.right, d.value = x.top, f.value = x.width, h10.value = x.x, p.value = x.y;
  }
  function m() {
    o === "sync" ? g() : o === "next-frame" && requestAnimationFrame(() => g());
  }
  return Rk(t10, m), watch(() => Di(t10), (b) => !b && m()), $k(t10, m, {
    attributeFilter: ["style", "class"]
  }), s && Kb("scroll", m, { capture: true, passive: true }), i && Kb("resize", m, { passive: true }), Vm(() => {
    r && m();
  }), {
    height: a,
    bottom: l,
    left: c,
    right: u,
    top: d,
    width: f,
    x: h10,
    y: p,
    update: m
  };
}
function Wz(t10, e = { width: 0, height: 0 }, n = {}) {
  const { window: i = Rl, box: s = "content-box" } = n, r = computed(() => {
    var d, f;
    return (f = (d = Di(t10)) == null ? void 0 : d.namespaceURI) == null ? void 0 : f.includes("svg");
  }), o = ref(e.width), a = ref(e.height), { stop: l } = Rk(
    t10,
    ([d]) => {
      const f = s === "border-box" ? d.borderBoxSize : s === "content-box" ? d.contentBoxSize : d.devicePixelContentBoxSize;
      if (i && r.value) {
        const h10 = Di(t10);
        if (h10) {
          const p = h10.getBoundingClientRect();
          o.value = p.width, a.value = p.height;
        }
      } else if (f) {
        const h10 = Array.isArray(f) ? f : [f];
        o.value = h10.reduce((p, { inlineSize: g }) => p + g, 0), a.value = h10.reduce((p, { blockSize: g }) => p + g, 0);
      } else
        o.value = d.contentRect.width, a.value = d.contentRect.height;
    },
    n
  );
  Vm(() => {
    const d = Di(t10);
    d && (o.value = "offsetWidth" in d ? d.offsetWidth : e.width, a.value = "offsetHeight" in d ? d.offsetHeight : e.height);
  });
  const c = watch(
    () => Di(t10),
    (d) => {
      o.value = d ? e.width : 0, a.value = d ? e.height : 0;
    }
  );
  function u() {
    l(), c();
  }
  return {
    width: o,
    height: a,
    stop: u
  };
}
function zm(t10 = {}) {
  const {
    document: e = zz,
    selector: n = "html",
    observe: i = false,
    initialValue: s = "ltr"
  } = t10;
  function r() {
    var a, l;
    return (l = (a = e == null ? void 0 : e.querySelector(n)) == null ? void 0 : a.getAttribute("dir")) != null ? l : s;
  }
  const o = ref(r());
  return Vm(() => o.value = r()), i && e && $k(
    e.querySelector(n),
    () => o.value = r(),
    { attributes: true }
  ), computed({
    get() {
      return o.value;
    },
    set(a) {
      var l, c;
      o.value = a, e && (o.value ? (l = e.querySelector(n)) == null || l.setAttribute("dir", o.value) : (c = e.querySelector(n)) == null || c.removeAttribute("dir"));
    }
  });
}
function Fk(t10, e) {
  const { containerStyle: n, wrapperProps: i, scrollTo: s, calculateRange: r, currentList: o, containerRef: a } = "itemHeight" in e ? Kz(e, t10) : qz(e, t10);
  return {
    list: o,
    scrollTo: s,
    containerProps: {
      ref: a,
      onScroll: () => {
        r();
      },
      style: n
    },
    wrapperProps: i
  };
}
function Vk(t10) {
  const e = ref(null), n = Wz(e), i = ref([]), s = shallowRef(t10);
  return { state: ref({ start: 0, end: 10 }), source: s, currentList: i, size: n, containerRef: e };
}
function Bk(t10, e, n) {
  return (i) => {
    if (typeof n == "number")
      return Math.ceil(i / n);
    const { start: s = 0 } = t10.value;
    let r = 0, o = 0;
    for (let a = s; a < e.value.length; a++) {
      const l = n(a);
      if (r += l, o = a, r > i)
        break;
    }
    return o - s;
  };
}
function zk(t10, e) {
  return (n) => {
    if (typeof e == "number")
      return Math.floor(n / e) + 1;
    let i = 0, s = 0;
    for (let r = 0; r < t10.value.length; r++) {
      const o = e(r);
      if (i += o, i >= n) {
        s = r;
        break;
      }
    }
    return s + 1;
  };
}
function jk(t10, e, n, i, { containerRef: s, state: r, currentList: o, source: a }) {
  return () => {
    const l = s.value;
    if (l) {
      const c = n(t10 === "vertical" ? l.scrollTop : l.scrollLeft), u = i(t10 === "vertical" ? l.clientHeight : l.clientWidth), d = c - e, f = c + u + e;
      r.value = {
        start: d < 0 ? 0 : d,
        end: f > a.value.length ? a.value.length : f
      }, o.value = a.value.slice(r.value.start, r.value.end).map((h10, p) => ({
        data: h10,
        index: p + r.value.start
      }));
    }
  };
}
function Hk(t10, e) {
  return (n) => typeof t10 == "number" ? n * t10 : e.value.slice(0, n).reduce((s, r, o) => s + t10(o), 0);
}
function Wk(t10, e, n, i) {
  watch([t10.width, t10.height, e, n], () => {
    i();
  });
}
function Uk(t10, e) {
  return computed(() => typeof t10 == "number" ? e.value.length * t10 : e.value.reduce((n, i, s) => n + t10(s), 0));
}
var Uz = {
  horizontal: "scrollLeft",
  vertical: "scrollTop"
};
function qk(t10, e, n, i) {
  return (s) => {
    i.value && (i.value[Uz[t10]] = n(s), e());
  };
}
function qz(t10, e) {
  const n = Vk(e), { state: i, source: s, currentList: r, size: o, containerRef: a } = n, l = { overflowX: "auto" }, { itemWidth: c, overscan: u = 5 } = t10, d = Bk(i, s, c), f = zk(s, c), h10 = jk("horizontal", u, f, d, n), p = Hk(c, s), g = computed(() => p(i.value.start)), m = Uk(c, s);
  Wk(o, e, a, h10);
  const b = qk("horizontal", h10, p, a), x = computed(() => ({
    style: {
      height: "100%",
      width: `${m.value - g.value}px`,
      marginLeft: `${g.value}px`,
      display: "flex"
    }
  }));
  return {
    scrollTo: b,
    calculateRange: h10,
    wrapperProps: x,
    containerStyle: l,
    currentList: r,
    containerRef: a
  };
}
function Kz(t10, e) {
  const n = Vk(e), { state: i, source: s, currentList: r, size: o, containerRef: a } = n, l = { overflowY: "auto" }, { itemHeight: c, overscan: u = 5 } = t10, d = Bk(i, s, c), f = zk(s, c), h10 = jk("vertical", u, f, d, n), p = Hk(c, s), g = computed(() => p(i.value.start)), m = Uk(c, s);
  Wk(o, e, a, h10);
  const b = qk("vertical", h10, p, a), x = computed(() => ({
    style: {
      width: "100%",
      height: `${m.value - g.value}px`,
      marginTop: `${g.value}px`
    }
  }));
  return {
    calculateRange: h10,
    scrollTo: b,
    containerStyle: l,
    wrapperProps: x,
    currentList: r,
    containerRef: a
  };
}
var Kk = /(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Yz = Rn.create({
  name: "audio",
  addOptions() {
    return {
      inline: false,
      HTMLAttributes: {
        class: "mn-editor-audio"
      }
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      controls: {
        default: true
      },
      alt: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "audio[src]"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["audio", Nt(this.options.HTMLAttributes, t10)];
  },
  addCommands() {
    return {
      setAudio: (t10) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t10
      })
    };
  },
  addInputRules() {
    return [
      Id({
        find: Kk,
        type: this.type,
        getAttributes: (t10) => {
          const [, , e, n] = t10;
          return { src: e, controls: n };
        }
      })
    ];
  }
});
var Gz = Rn.create({
  name: "video",
  addOptions() {
    return {
      inline: false,
      HTMLAttributes: {
        class: "mn-editor-video"
      }
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      controls: {
        default: true
      },
      alt: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "video[src]"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t10 }) {
    return ["video", Nt(this.options.HTMLAttributes, t10)];
  },
  addCommands() {
    return {
      setVideo: (t10) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t10
      })
    };
  },
  addInputRules() {
    return [
      Id({
        find: Kk,
        type: this.type,
        getAttributes: (t10) => {
          const [, , e, n] = t10;
          return { src: e, controls: n };
        }
      })
    ];
  }
});
var Jz = ["aria-labelledby"];
var Xz = ["id"];
var Qz = { class: "mn-dialog-content" };
var Zz = {
  key: 1,
  class: "mn-dialog-actions"
};
var ej = Object.assign({ name: "mn-dialog" }, {
  __name: "dialog",
  props: {
    label: {
      type: String,
      required: true
    },
    type: {
      type: String,
      validator: (t10) => ["success", "warning", "danger"].includes(String(t10))
    },
    size: {
      type: String,
      default: "medium",
      validator: (t10) => ["small", "medium", "large", "wide"].includes(String(t10))
    },
    icon: {
      type: String,
      default: "sparkles"
    },
    open: Boolean,
    strict: Boolean,
    labelless: Boolean,
    iconless: Boolean
  },
  emits: ["close"],
  setup(t10, { emit: e }) {
    const n = useId(), i = inject("minuit"), s = useSlots(), r = e, o = t10, a = ref(null), l = ref(!!s.actions);
    function c() {
      switch (o.type) {
        case "success":
          return "far circle-check";
        case "warning":
          return "far triangle-exclamation";
        case "danger":
          return "far circle-exclamation";
        default:
          return o.icon;
      }
    }
    function u(f) {
      f.target === a.value && d();
    }
    function d() {
      r("close");
    }
    return onMounted(() => {
      a.value.addEventListener("close", d), !o.strict && a.value.addEventListener("click", u);
    }), onUnmounted(() => {
      var f, h10;
      (f = a.value) == null || f.removeEventListener("close", d), !o.strict && ((h10 = a.value) == null || h10.removeEventListener("click", u));
    }), watch(
      () => o.open,
      (f) => {
        var h10, p;
        return f ? (h10 = a.value) == null ? void 0 : h10.showModal() : (p = a.value) == null ? void 0 : p.close();
      },
      { immediate: true }
    ), watch(
      () => o.strict,
      (f) => {
        var h10, p;
        f ? (h10 = a.value) == null || h10.removeEventListener("click", u) : (p = a.value) == null || p.addEventListener("click", u);
      }
    ), (f, h10) => (openBlock(), createElementBlock("dialog", {
      ref_key: "dialogRef",
      ref: a,
      class: normalizeClass(["mn-dialog", t10.size]),
      "aria-labelledby": `${unref(n)}-label`
    }, [
      createBaseVNode("span", {
        id: `${unref(n)}-label`,
        class: "invisible"
      }, toDisplayString(`${t10.type || ""} ${t10.label}`), 9, Xz),
      createBaseVNode("header", {
        class: normalizeClass(["mn-dialog-header", { invisible: t10.labelless }])
      }, [
        t10.type || !t10.iconless ? (openBlock(), createBlock(o0, {
          key: 0,
          tag: "h2",
          "aria-hidden": "true"
        }, {
          default: withCtx(() => [
            createVNode(ft, {
              class: "mn-dialog-icon",
              color: t10.type || "accent",
              label: t10.type,
              icon: c()
            }, null, 8, ["color", "label", "icon"])
          ]),
          _: 1
        })) : createCommentVNode("", true),
        createVNode(o0, {
          tag: "h2",
          "aria-hidden": "true"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(Ie)(t10.label)), 1)
          ]),
          _: 1
        })
      ], 2),
      t10.strict ? createCommentVNode("", true) : (openBlock(), createBlock(me, {
        key: 0,
        class: "mn-dialog-close-btn",
        variant: "text",
        color: "neutral",
        icon: "xmark",
        label: unref(i).t("close"),
        labelless: "",
        onClick: d
      }, null, 8, ["label"])),
      createBaseVNode("div", Qz, [
        renderSlot(f.$slots, "default", {}, void 0, true)
      ]),
      l.value ? (openBlock(), createElementBlock("footer", Zz, [
        renderSlot(f.$slots, "actions", {}, void 0, true)
      ])) : createCommentVNode("", true)
    ], 10, Jz));
  }
});
var nc = Me(ej, [["__scopeId", "data-v-da7c3681"]]);
var tj = Object.assign({ name: "mn-container" }, {
  __name: "container",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    size: {
      type: String,
      validator: (t10) => ["small", "medium", "large", "wide", "fluid"].includes(String(t10))
    },
    flow: {
      type: String,
      default: "column",
      validator: (t10) => ["column", "row", "row-between", "row-end", "grid", "grid-center"].includes(String(t10))
    },
    columns: {
      type: String,
      default: "1fr"
    },
    gap: {
      type: String,
      default: "var(--size-4)"
    },
    surface: Boolean,
    centered: Boolean
  },
  setup(t10) {
    return useCssVars((e) => ({
      "7968d06d": t10.gap,
      "42ca35f4": t10.columns
    })), (e, n) => (openBlock(), createBlock(resolveDynamicComponent(t10.tag), {
      class: normalizeClass(["mn-container", [t10.size, t10.flow, { "-surface": t10.surface, "-centered": t10.centered }]])
    }, {
      default: withCtx(() => [
        renderSlot(e.$slots, "default", {}, void 0, true)
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var nj = Me(tj, [["__scopeId", "data-v-663a9817"]]);
var ij = ["autocomplete"];
var sj = { class: "mn-form-errors-list" };
var rj = Object.assign({ name: "mn-form" }, {
  __name: "form",
  props: {
    modelValue: {
      type: Object,
      default: () => ({})
    },
    errors: Boolean,
    autocomplete: Boolean,
    horizontal: Boolean
  },
  emits: ["update:modelValue", "submit"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = e, s = t10, r = ref(false), { errorBag: o, setValues: a, handleSubmit: l, handleReset: c, meta: u } = EE({
      initialValues: s.modelValue
    }), d = _E();
    function f(b) {
      var k, v;
      const x = document.querySelector(`[name="${b}"]`);
      return x.type === "radio" ? ((v = document.querySelector(`label[for="${(k = x.closest(".mn-radio-group")) == null ? void 0 : k.id}"] > span`)) == null ? void 0 : v.innerHTML) || b : document.querySelector(`label[for="${x == null ? void 0 : x.id}"] > span`).innerHTML || b;
    }
    function h10(b) {
      const x = document.querySelector(`[name="${b}"]`);
      x == null || x.scrollIntoView({ behavior: "smooth" });
    }
    function p() {
      i("update:modelValue", d.value);
    }
    function g(b) {
      b.preventDefault(), r.value = false, c();
    }
    async function m(b) {
      b.preventDefault(), r.value = true, await l((k) => i("submit", { ...k }))();
      const x = document.querySelector(".mn-form-errors");
      x == null || x.scrollIntoView({ behavior: "smooth" });
    }
    return onMounted(() => {
      a(s.modelValue, false), i("update:modelValue", d.value);
    }), watch(
      () => s.modelValue,
      (b) => {
        a(b, false);
      },
      { deep: true }
    ), (b, x) => (openBlock(), createElementBlock("form", {
      class: normalizeClass(["mn-form", { "-horizontal": t10.horizontal }]),
      autocomplete: t10.autocomplete ? "on" : "off",
      novalidate: "",
      onChange: p,
      onSubmit: m,
      onReset: g
    }, [
      t10.errors && r.value && Object.keys(unref(o)).length ? (openBlock(), createBlock(nj, {
        key: 0,
        class: "mn-form-errors",
        gap: "var(--size-2)",
        surface: "",
        role: "alert"
      }, {
        default: withCtx(() => [
          createVNode(ui, null, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(n).t("formHasErrors")), 1)
            ]),
            _: 1
          }),
          createBaseVNode("ul", sj, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(o), (k, v) => (openBlock(), createElementBlock(Fragment, {
              key: JSON.stringify(v)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(k, (S) => (openBlock(), createElementBlock("li", {
                class: "mn-form-errors-item",
                key: S
              }, [
                createVNode(me, {
                  class: "mn-form-errors-button",
                  label: f(v),
                  color: "danger",
                  inline: "",
                  onClick: (w) => h10(v)
                }, null, 8, ["label", "onClick"]),
                createVNode(ui, null, {
                  default: withCtx(() => [
                    x[0] || (x[0] = createBaseVNode("span", { class: "invisible" }, ":", -1)),
                    x[1] || (x[1] = createBaseVNode("span", { "aria-hidden": "true" }, "-", -1)),
                    createTextVNode(" " + toDisplayString(S), 1)
                  ]),
                  _: 2
                }, 1024)
              ]))), 128))
            ], 64))), 128))
          ])
        ]),
        _: 1
      })) : createCommentVNode("", true),
      renderSlot(b.$slots, "default", {}, void 0, true)
    ], 42, ij));
  }
});
var _r = Me(rj, [["__scopeId", "data-v-e272cc35"]]);
var oj = ["id", "title"];
var aj = {
  key: 0,
  class: "mn-input-start"
};
var lj = {
  key: 0,
  class: "mn-input-prefix"
};
var cj = ["type", "value", "id", "name", "autofocus", "autocomplete", "placeholder", "disabled", "inputmode", "aria-describedby", "aria-required"];
var uj = {
  key: 1,
  class: "mn-input-end"
};
var dj = {
  key: 1,
  class: "mn-input-suffix"
};
var fj = Object.assign({ name: "mn-input" }, {
  __name: "input",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: [String, Number],
      default: null
    },
    type: {
      type: String,
      default: "text",
      validator: (t10) => ["text", "email", "password", "number", "tel", "url", "date", "time"].includes(String(t10))
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    hint: String,
    placeholder: String,
    tooltip: String,
    prefix: String,
    suffix: String,
    prefixIcon: String,
    suffixIcon: String,
    prefixMirror: Boolean,
    suffixMirror: Boolean,
    autocomplete: String,
    autofocus: Boolean,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = e, s = t10, r = useId(), o = ref(s.type), a = ref(s.type === "password"), l = toRef(s, "name"), c = toRef(s, "rules"), { value: u, errors: d, handleChange: f, meta: h10 } = Sn(l, c, {
      initialValue: s.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    });
    function p() {
      switch (s.type) {
        case "email":
          return "email";
        case "number":
          return "numeric";
        case "tel":
          return "tel";
        case "url":
          return "url";
        default:
          return "text";
      }
    }
    function g() {
      o.value = a.value ? "text" : "password", a.value = !a.value;
    }
    function m(b) {
      i("update:modelValue", s.type === "number" ? Number(b.target.value) : b.target.value), b.type === "input" && i("input", b, s.type === "number" ? Number(b.target.value) : b.target.value), b.type === "change" && (i("change", b, s.type === "number" ? Number(b.target.value) : b.target.value), f(s.type === "number" ? Number(b.target.value) : b.target.value));
    }
    return watch(
      () => s.type,
      (b) => {
        o.value = b, a.value = b === "password";
      }
    ), (b, x) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-input", { "-hidden": t10.hidden, "-disabled": t10.disabled }]),
      id: t10.name,
      title: t10.labelless ? t10.label : null
    }, [
      createVNode(Ft, {
        class: normalizeClass(["mn-input-label", { invisible: t10.labelless }]),
        label: t10.label,
        tooltip: t10.tooltip,
        for: unref(r)
      }, null, 8, ["class", "label", "tooltip", "for"]),
      createBaseVNode("div", {
        class: normalizeClass(["mn-input-shell", { "-invalid": unref(d).length }])
      }, [
        t10.prefix || t10.prefixIcon ? (openBlock(), createElementBlock("div", aj, [
          t10.prefix ? (openBlock(), createElementBlock("span", lj, toDisplayString(t10.prefix), 1)) : t10.prefixIcon ? (openBlock(), createBlock(ft, {
            key: 1,
            class: "mn-input-prefix",
            color: "neutral",
            icon: t10.prefixIcon,
            mirror: t10.prefixMirror
          }, null, 8, ["icon", "mirror"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("input", {
          class: "mn-input-field",
          type: o.value,
          value: unref(u),
          id: unref(r),
          name: t10.name,
          autofocus: t10.autofocus,
          autocomplete: t10.autocomplete,
          placeholder: t10.placeholder,
          disabled: t10.disabled,
          inputmode: p(),
          "aria-describedby": `${unref(r)}-error ${unref(r)}-hint`,
          "aria-required": t10.rules.includes("required") || null,
          onInput: m,
          onChange: m
        }, null, 40, cj),
        t10.type === "password" || t10.suffix || t10.suffixIcon ? (openBlock(), createElementBlock("div", uj, [
          t10.type === "password" ? (openBlock(), createBlock(me, {
            key: 0,
            class: "mn-input-button",
            variant: "muted",
            color: "neutral",
            fluid: "",
            labelless: "",
            icon: a.value ? "far eye-slash" : "far eye",
            label: a.value ? unref(n).t("showPassword") : unref(n).t("hidePassword"),
            disabled: t10.disabled,
            onClick: g
          }, null, 8, ["icon", "label", "disabled"])) : t10.suffix ? (openBlock(), createElementBlock("span", dj, toDisplayString(t10.suffix), 1)) : t10.suffixIcon ? (openBlock(), createBlock(ft, {
            key: 2,
            class: "mn-input-suffix",
            color: "neutral",
            icon: t10.suffixIcon,
            mirror: t10.suffixMirror
          }, null, 8, ["icon", "mirror"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 2),
      unref(d).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(d), (k) => (openBlock(), createBlock($n, {
        key: k,
        id: `${unref(r)}-error`,
        message: k
      }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
      t10.hint ? (openBlock(), createBlock(ln, {
        key: 1,
        id: `${unref(r)}-hint`,
        class: "mn-input-hint",
        label: t10.hint
      }, null, 8, ["id", "label"])) : createCommentVNode("", true)
    ], 10, oj));
  }
});
var Nr = Me(fj, [["__scopeId", "data-v-5956032c"]]);
var hj = ["value", "id", "rows", "name", "placeholder", "disabled", "aria-describedby", "aria-required", "title"];
var pj = {
  key: 0,
  class: "mn-textarea-count"
};
var mj = { class: "invisible" };
var gj = { "aria-hidden": "true" };
var bj = Object.assign({ name: "mn-textarea" }, {
  __name: "textarea",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: String,
      default: null
    },
    rows: {
      type: Number,
      default: 5
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    hint: String,
    placeholder: String,
    tooltip: String,
    count: Boolean,
    smart: Boolean,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = e, s = t10, r = useId(), o = toRef(s, "name"), a = toRef(s, "rules"), { value: l, errors: c, handleChange: u, meta: d } = Sn(o, a, {
      initialValue: s.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    });
    function f(p) {
      p.rows = "none", p.style.minHeight = `calc(${p.scrollHeight}px + var(--size-2))`;
    }
    function h10(p) {
      s.smart && p.target.scrollHeight > p.target.clientHeight && f(p.target), i("update:modelValue", p.target.value), p.type === "input" && (i("input", p, p.target.value), u(p.target.value, false)), p.type === "change" && (i("change", p, p.target.value), u(p.target.value));
    }
    return (p, g) => {
      var m, b;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["mn-textarea", { "-hidden": t10.hidden, "-disabled": t10.disabled, "-smart": t10.smart }])
      }, [
        createVNode(Ft, {
          class: normalizeClass(["mn-textarea-label", { invisible: t10.labelless }]),
          label: t10.label,
          tooltip: t10.tooltip,
          for: unref(r)
        }, null, 8, ["class", "label", "tooltip", "for"]),
        createBaseVNode("div", {
          class: normalizeClass(["mn-textarea-shell", { "-invalid": unref(c).length }])
        }, [
          createBaseVNode("textarea", {
            class: "mn-textarea-field",
            value: unref(l),
            id: unref(r),
            rows: t10.rows,
            name: t10.name,
            placeholder: unref(Ie)(t10.placeholder),
            disabled: t10.disabled,
            "aria-describedby": `${unref(r)}-error ${unref(r)}-hint`,
            "aria-required": t10.rules.includes("required") || null,
            title: t10.labelless ? t10.label : null,
            onInput: h10,
            onChange: h10
          }, null, 40, hj),
          t10.count || t10.rules.includes("maxchar") ? (openBlock(), createElementBlock("div", pj, [
            createBaseVNode("span", mj, toDisplayString(((m = unref(l)) == null ? void 0 : m.length) || 0) + " " + toDisplayString(unref(n).t("characters")), 1),
            createBaseVNode("span", gj, toDisplayString(((b = unref(l)) == null ? void 0 : b.length) || 0), 1)
          ])) : createCommentVNode("", true)
        ], 2),
        unref(c).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(c), (x) => (openBlock(), createBlock($n, {
          key: x,
          id: `${unref(r)}-error`,
          message: x
        }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
        t10.hint ? (openBlock(), createBlock(ln, {
          key: 1,
          id: `${unref(r)}-hint`,
          class: "mn-textarea-hint",
          label: t10.hint
        }, null, 8, ["id", "label"])) : createCommentVNode("", true)
      ], 2);
    };
  }
});
var yj = Me(bj, [["__scopeId", "data-v-b7ce77d0"]]);
var vj = ["title"];
var xj = ["aria-labelledby", "aria-controls"];
var kj = ["id"];
var Sj = {
  key: 0,
  class: "mn-editor-count"
};
var wj = { class: "invisible" };
var Cj = { "aria-hidden": "true" };
var Oj = Object.assign({ name: "mn-editor" }, {
  __name: "editor",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: String,
      default: null
    },
    name: {
      type: String,
      default: ""
    },
    rules: {
      type: String,
      default: ""
    },
    hint: String,
    placeholder: String,
    tooltip: String,
    count: Boolean,
    custom: Boolean,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue", "input", "change", "pick"],
  setup(t10, { expose: e, emit: n }) {
    const i = inject("minuit"), s = n, r = t10, o = useId(), a = zm(), l = toRef(r, "name"), c = toRef(r, "rules"), u = ref(false), d = ref(false), f = ref(false), h10 = ref(false), p = ref(""), g = ref({}), { value: m, errors: b, handleChange: x, meta: k } = Sn(l, c, {
      initialValue: r.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    }), v = Dz({
      content: r.modelValue,
      extensions: [
        xF.configure(),
        GF.configure({ placeholder: r.placeholder }),
        XV.configure({ bulletList: { HTMLAttributes: { class: "mn-editor-list" } } }),
        XF,
        wF.configure({ HTMLAttributes: { class: "mn-editor-highlight" } }),
        YF.configure({ HTMLAttributes: { class: "mn-editor-link", target: null } }),
        JF.configure({ types: ["heading", "paragraph"], alignments: ["left", "center", "right"] }),
        OF.configure({ HTMLAttributes: { class: "mn-editor-image" } }),
        Gz,
        Yz
      ],
      editable: !r.disabled,
      parseOptions: { preserveWhitespace: "full" },
      onUpdate: ({ editor: _ }) => {
        s("update:modelValue", _.getHTML()), s("input", _.getHTML());
      },
      onBlur: ({ editor: _ }) => {
        s("change", _.getHTML()), x(_.getHTML());
      }
    });
    function S(_) {
      Array.from(_.parentElement.querySelectorAll("button")).forEach((H) => H.setAttribute("tabindex", "-1")), _.setAttribute("tabindex", "0"), _.focus();
    }
    function w(_, T) {
      const H = Array.from(_.target.parentElement.querySelectorAll("button"));
      if (T === "previous") {
        const Q = _.target.previousElementSibling;
        (Q == null ? void 0 : Q.type) === "button" ? S(Q) : S(H[H.length - 1]);
      } else if (T === "next") {
        const Q = _.target.nextElementSibling;
        (Q == null ? void 0 : Q.type) === "button" ? S(Q) : S(H[0]);
      }
    }
    function E(_) {
      _.key === "ArrowLeft" ? a.value === "ltr" ? w(_, "previous") : w(_, "next") : _.key === "ArrowRight" && (a.value === "ltr" ? w(_, "next") : w(_, "previous"));
    }
    function M(_, T) {
      S(_.currentTarget), T === "bold" ? v.value.chain().focus().toggleMark("bold").run() : T === "italic" ? v.value.chain().focus().toggleMark("italic").run() : T === "underline" ? v.value.chain().focus().toggleUnderline().run() : T === "highlight" ? v.value.chain().focus().toggleHighlight().run() : T === "title" ? v.value.chain().focus().toggleHeading({ level: 2 }).run() : T === "list" ? v.value.chain().focus().toggleBulletList().run() : T === "link" && (v.value.isActive("link") ? v.value.chain().focus().extendMarkRange("link").unsetLink().run() : (p.value = v.value.getAttributes("link").href || "", u.value = true));
    }
    function N() {
      p.value && (v.value.commands.toggleLink({ href: p.value }), u.value = false);
    }
    function V(_, T) {
      S(_.currentTarget), v.value.commands.setTextAlign(T);
    }
    function Y(_, T) {
      S(_.currentTarget), r.custom ? s("pick", T) : T === "image" ? d.value = true : T === "video" ? f.value = true : h10.value = true;
    }
    function F(_) {
      var H, Q, ae;
      const T = { src: ((Q = (H = _.sources) == null ? void 0 : H.desktop) == null ? void 0 : Q.url) || ((ae = _ == null ? void 0 : _.original) == null ? void 0 : ae.url) || _.url, alt: _.alt || "" };
      v.value.chain().focus().setImage({ src: T.src, alt: T.alt }).run();
    }
    function re(_) {
      var H, Q, ae;
      const T = { src: ((Q = (H = _.sources) == null ? void 0 : H.desktop) == null ? void 0 : Q.url) || ((ae = _ == null ? void 0 : _.original) == null ? void 0 : ae.url) || _.url };
      v.value.chain().focus().setVideo({ src: T.src, alt: T.alt }).run();
    }
    function z(_) {
      var H, Q, ae;
      const T = { src: ((Q = (H = _.sources) == null ? void 0 : H.desktop) == null ? void 0 : Q.url) || ((ae = _ == null ? void 0 : _.original) == null ? void 0 : ae.url) || _.url };
      v.value.chain().focus().setAudio({ src: T.src, alt: T.alt }).run();
    }
    function W() {
      d.value = false, f.value = false, h10.value = false, g.value = {};
    }
    function C(_) {
      S(_.currentTarget), v.value.commands.undo();
    }
    function O(_) {
      S(_.currentTarget), v.value.commands.redo();
    }
    return e({ insertImage: F, insertVideo: re, insertAudio: z }), watch(
      () => m.value,
      (_) => v.value.getHTML() !== _ && v.value.commands.setContent(_, false)
    ), watch(
      () => r.disabled,
      (_) => v.value.setOptions({ editable: !_ })
    ), watch(
      () => r.placeholder,
      (_) => {
        v.value.options.extensions.find((T) => T.name === "placeholder").options.placeholder = _, v.value.setOptions({ extensions: v.value.options.extensions });
      }
    ), onMounted(() => {
      v.value.setOptions({ editorProps: { attributes: { id: o } } });
    }), onBeforeUnmount(() => v.value.destroy()), (_, T) => {
      var H, Q, ae, pe, xe, Te, L, K, B, X, be, Ce, Oe, Ue;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["mn-editor", { "-hidden": t10.hidden, "-disabled": t10.disabled }]),
        title: t10.labelless ? t10.label : null
      }, [
        createVNode(nc, {
          open: u.value,
          label: unref(i).t("insertLink"),
          onClose: T[2] || (T[2] = (J) => u.value = false)
        }, {
          actions: withCtx(() => [
            createVNode(me, {
              label: unref(i).t("cancel"),
              variant: "muted",
              onClick: T[1] || (T[1] = (J) => u.value = false)
            }, null, 8, ["label"]),
            createVNode(me, {
              label: unref(i).t("insertLink"),
              form: `${unref(o)}-form-link`,
              type: "submit"
            }, null, 8, ["label", "form"])
          ]),
          default: withCtx(() => [
            createVNode(_r, {
              onSubmit: N,
              id: `${unref(o)}-form-link`
            }, {
              default: withCtx(() => [
                createVNode(Nr, {
                  label: unref(i).t("URL"),
                  type: "url",
                  name: "mn-editor-link-url",
                  rules: "url",
                  modelValue: p.value,
                  "onUpdate:modelValue": T[0] || (T[0] = (J) => p.value = J)
                }, null, 8, ["label", "modelValue"])
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 1
        }, 8, ["open", "label"]),
        createVNode(nc, {
          open: d.value,
          label: unref(i).t("insertMedia"),
          onClose: T[7] || (T[7] = (J) => d.value = false)
        }, {
          actions: withCtx(() => [
            createVNode(me, {
              label: unref(i).t("cancel"),
              variant: "muted",
              onClick: T[6] || (T[6] = (J) => d.value = false)
            }, null, 8, ["label"]),
            createVNode(me, {
              label: unref(i).t("insertMedia"),
              form: `${unref(o)}-form-image`,
              type: "submit"
            }, null, 8, ["label", "form"])
          ]),
          default: withCtx(() => [
            createVNode(_r, {
              onSubmit: T[5] || (T[5] = (J) => {
                F(g.value), W();
              }),
              id: `${unref(o)}-form-image`
            }, {
              default: withCtx(() => [
                createVNode(Nr, {
                  label: unref(i).t("URL"),
                  name: "mn-editor-media-url",
                  rules: "url",
                  modelValue: g.value.url,
                  "onUpdate:modelValue": T[3] || (T[3] = (J) => g.value.url = J)
                }, null, 8, ["label", "modelValue"]),
                createVNode(yj, {
                  label: `${unref(i).t("altText")} (${unref(i).t("optional")})`,
                  name: "mn-editor-media-alt",
                  rows: 3,
                  modelValue: g.value.alt,
                  "onUpdate:modelValue": T[4] || (T[4] = (J) => g.value.alt = J)
                }, null, 8, ["label", "modelValue"])
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 1
        }, 8, ["open", "label"]),
        createVNode(nc, {
          open: f.value,
          label: unref(i).t("insertMedia"),
          onClose: T[11] || (T[11] = (J) => f.value = false)
        }, {
          actions: withCtx(() => [
            createVNode(me, {
              label: unref(i).t("cancel"),
              variant: "muted",
              onClick: T[10] || (T[10] = (J) => f.value = false)
            }, null, 8, ["label"]),
            createVNode(me, {
              label: unref(i).t("insertMedia"),
              form: `${unref(o)}-form-video`,
              type: "submit"
            }, null, 8, ["label", "form"])
          ]),
          default: withCtx(() => [
            createVNode(_r, {
              onSubmit: T[9] || (T[9] = (J) => {
                re(g.value), W();
              }),
              id: `${unref(o)}-form-video`
            }, {
              default: withCtx(() => [
                createVNode(Nr, {
                  label: unref(i).t("URL"),
                  name: "mn-editor-media-url",
                  rules: "url",
                  modelValue: g.value.url,
                  "onUpdate:modelValue": T[8] || (T[8] = (J) => g.value.url = J)
                }, null, 8, ["label", "modelValue"])
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 1
        }, 8, ["open", "label"]),
        createVNode(nc, {
          open: h10.value,
          label: unref(i).t("insertMedia"),
          onClose: T[15] || (T[15] = (J) => h10.value = false)
        }, {
          actions: withCtx(() => [
            createVNode(me, {
              label: unref(i).t("cancel"),
              variant: "muted",
              onClick: T[14] || (T[14] = (J) => h10.value = false)
            }, null, 8, ["label"]),
            createVNode(me, {
              label: unref(i).t("insertMedia"),
              form: `${unref(o)}-form-audio`,
              type: "submit"
            }, null, 8, ["label", "form"])
          ]),
          default: withCtx(() => [
            createVNode(_r, {
              onSubmit: T[13] || (T[13] = (J) => {
                z(g.value), W();
              }),
              id: `${unref(o)}-form-audio`
            }, {
              default: withCtx(() => [
                createVNode(Nr, {
                  label: unref(i).t("URL"),
                  name: "mn-editor-media-url",
                  rules: "url",
                  modelValue: g.value.url,
                  "onUpdate:modelValue": T[12] || (T[12] = (J) => g.value.url = J)
                }, null, 8, ["label", "modelValue"])
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 1
        }, 8, ["open", "label"]),
        createVNode(Ft, {
          class: normalizeClass(["mn-editor-label", { invisible: t10.labelless }]),
          label: t10.label,
          tooltip: t10.tooltip,
          for: unref(o)
        }, null, 8, ["class", "label", "tooltip", "for"]),
        createBaseVNode("div", {
          class: normalizeClass(["mn-editor-shell", { "-invalid": unref(b).length }])
        }, [
          createBaseVNode("div", {
            class: "mn-editor-toolbar",
            role: "toolbar",
            "aria-labelledby": `${unref(o)}-toolbar`,
            "aria-controls": unref(o),
            onKeydown: E
          }, [
            createBaseVNode("span", {
              id: `${unref(o)}-toolbar`,
              hidden: ""
            }, toDisplayString(unref(i).t("toolbar")), 9, kj),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("makeBold"),
              "aria-pressed": (H = unref(v)) == null ? void 0 : H.isActive("bold"),
              icon: "far bold",
              labelless: "",
              color: "neutral",
              tabindex: "0",
              disabled: t10.disabled,
              onClick: T[16] || (T[16] = (J) => M(J, "bold"))
            }, null, 8, ["label", "aria-pressed", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("makeItalic"),
              "aria-pressed": (Q = unref(v)) == null ? void 0 : Q.isActive("italic"),
              icon: "far italic",
              labelless: "",
              color: "neutral",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[17] || (T[17] = (J) => M(J, "italic"))
            }, null, 8, ["label", "aria-pressed", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("underline"),
              "aria-pressed": (ae = unref(v)) == null ? void 0 : ae.isActive("underline"),
              icon: "far underline",
              labelless: "",
              color: "neutral",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[18] || (T[18] = (J) => M(J, "underline"))
            }, null, 8, ["label", "aria-pressed", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("highlight"),
              "aria-pressed": (pe = unref(v)) == null ? void 0 : pe.isActive("highlight"),
              icon: "far highlighter-line",
              labelless: "",
              color: "neutral",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[19] || (T[19] = (J) => M(J, "highlight"))
            }, null, 8, ["label", "aria-pressed", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("insertTitle"),
              "aria-pressed": (xe = unref(v)) == null ? void 0 : xe.isActive("heading"),
              icon: "far text-size",
              labelless: "",
              color: "neutral",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[20] || (T[20] = (J) => M(J, "title"))
            }, null, 8, ["label", "aria-pressed", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("insertLink"),
              "aria-pressed": (Te = unref(v)) == null ? void 0 : Te.isActive("link"),
              icon: "far link",
              labelless: "",
              color: "neutral",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[21] || (T[21] = (J) => M(J, "link"))
            }, null, 8, ["label", "aria-pressed", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("insertList"),
              "aria-pressed": (L = unref(v)) == null ? void 0 : L.isActive("bulletList"),
              icon: "list-ul",
              labelless: "",
              mirror: "",
              color: "neutral",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[22] || (T[22] = (J) => M(J, "list"))
            }, null, 8, ["label", "aria-pressed", "disabled"]),
            createVNode(me, {
              variant: "text",
              "aria-pressed": (K = unref(v)) == null ? void 0 : K.isActive({ textAlign: "left" }),
              label: unref(i).t("alignStart"),
              icon: "far align-left",
              labelless: "",
              color: "neutral",
              mirror: "",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[23] || (T[23] = (J) => V(J, "left"))
            }, null, 8, ["aria-pressed", "label", "disabled"]),
            createVNode(me, {
              variant: "text",
              "aria-pressed": (B = unref(v)) == null ? void 0 : B.isActive({ textAlign: "center" }),
              label: unref(i).t("alignCenter"),
              icon: "far align-center",
              labelless: "",
              color: "neutral",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[24] || (T[24] = (J) => V(J, "center"))
            }, null, 8, ["aria-pressed", "label", "disabled"]),
            createVNode(me, {
              variant: "text",
              "aria-pressed": (X = unref(v)) == null ? void 0 : X.isActive({ textAlign: "right" }),
              label: unref(i).t("alignEnd"),
              icon: "far align-right",
              labelless: "",
              color: "neutral",
              mirror: "",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[25] || (T[25] = (J) => V(J, "right"))
            }, null, 8, ["aria-pressed", "label", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("insertImage"),
              icon: "far image",
              labelless: "",
              color: "neutral",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[26] || (T[26] = (J) => Y(J, "image"))
            }, null, 8, ["label", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("insertVideo"),
              icon: "far film",
              labelless: "",
              color: "neutral",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[27] || (T[27] = (J) => Y(J, "video"))
            }, null, 8, ["label", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("insertAudio"),
              icon: "music",
              labelless: "",
              color: "neutral",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[28] || (T[28] = (J) => Y(J, "audio"))
            }, null, 8, ["label", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("undo"),
              icon: "arrow-rotate-left",
              labelless: "",
              color: "neutral",
              mirror: "",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[29] || (T[29] = (J) => C(J))
            }, null, 8, ["label", "disabled"]),
            createVNode(me, {
              variant: "text",
              label: unref(i).t("redo"),
              icon: "arrow-rotate-right",
              labelless: "",
              color: "neutral",
              mirror: "",
              tabindex: "-1",
              disabled: t10.disabled,
              onClick: T[30] || (T[30] = (J) => O(J))
            }, null, 8, ["label", "disabled"])
          ], 40, xj),
          createVNode(unref(Pz), {
            class: "mn-editor-field",
            id: unref(o),
            name: t10.name,
            editor: unref(v),
            "aria-describedby": `${unref(o)}-error ${unref(o)}-hint`
          }, null, 8, ["id", "name", "editor", "aria-describedby"]),
          t10.count || t10.rules.includes("maxchar") ? (openBlock(), createElementBlock("div", Sj, [
            createBaseVNode("span", wj, toDisplayString(((Ce = (be = unref(v)) == null ? void 0 : be.storage.characterCount) == null ? void 0 : Ce.characters()) || 0) + " " + toDisplayString(unref(i).t("characters")), 1),
            createBaseVNode("span", Cj, toDisplayString(((Ue = (Oe = unref(v)) == null ? void 0 : Oe.storage.characterCount) == null ? void 0 : Ue.characters()) || 0), 1)
          ])) : createCommentVNode("", true)
        ], 2),
        unref(b).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(b), (J) => (openBlock(), createBlock($n, {
          key: J,
          id: `${unref(o)}-error`,
          message: J
        }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
        t10.hint ? (openBlock(), createBlock(ln, {
          key: 1,
          id: `${unref(o)}-hint`,
          class: "mn-editor-hint",
          label: t10.hint
        }, null, 8, ["id", "label"])) : createCommentVNode("", true)
      ], 10, vj);
    };
  }
});
var wZ = Me(Oj, [["__scopeId", "data-v-553691d2"]]);
var Ej = ["id"];
var Mj = ["src"];
var Tj = ["title", "id", "name", "capture", "disabled", "aria-describedby", "aria-required"];
var Aj = ["title", "id", "name", "capture", "disabled", "multiple", "aria-describedby", "aria-required"];
var _j = ["aria-labelledby"];
var Nj = ["id"];
var Lj = { class: "invisible" };
var Ij = { class: "ellipsis" };
var Pj = ["title", "id", "name", "capture", "disabled", "multiple", "aria-describedby", "aria-required"];
var Dj = ["aria-labelledby"];
var $j = ["id"];
var Rj = { class: "invisible" };
var Fj = { class: "ellipsis" };
var Vj = ["aria-labelledby"];
var Bj = ["id"];
var zj = Object.assign({ name: "mn-file" }, {
  __name: "file",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: [Array, Object],
      default: null
    },
    variant: {
      type: String,
      validator: (t10) => ["thumbnail", "dropzone", "list", "preview"].includes(String(t10))
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    width: {
      type: String,
      default: "calc(var(--size-20) * 1.5)"
    },
    height: {
      type: String,
      default: "calc(var(--size-20) * 1.5)"
    },
    ratio: String,
    hint: String,
    tooltip: String,
    capture: String,
    custom: Boolean,
    multiple: Boolean,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue", "input", "change", "pick"],
  setup(t10, { emit: e }) {
    useCssVars((k) => ({
      "1aba3032": t10.width,
      "19fc2332": t10.ratio ? "auto" : t10.height,
      "1a705277": t10.ratio
    }));
    const n = inject("minuit"), i = e, s = t10, r = useId(), o = ref(null), a = ref(false), l = toRef(s, "name"), c = toRef(s, "rules"), { value: u, errors: d, handleChange: f, meta: h10 } = Sn(l, c, {
      initialValue: s.modelValue ? Array.isArray(s.modelValue) ? s.modelValue : [s.modelValue] : s.multiple ? [] : null,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    }), p = computed(() => Array.isArray(u.value) ? u.value : u.value ? Array(u.value) : []);
    function g(k) {
      k.preventDefault(), i("pick");
    }
    function m(k) {
      let v = s.multiple ? [...u.value].filter((S) => S.name !== k) : null;
      b({ type: "change", target: { files: v } });
    }
    function b(k) {
      const v = k.target.files;
      let S = [];
      if (s.multiple)
        for (let w of v)
          !S.find((E) => E.name === w.name) && S.push(w);
      else
        S = [v == null ? void 0 : v[0]];
      if (v != null && v.length && s.variant === "thumbnail" && !s.multiple) {
        const w = new FileReader();
        w.readAsDataURL(S[0]), w.onload = () => {
          const E = document.querySelector(`#${r}-thumbnail .mn-file-thumbnail-img`);
          E.src = String(w.result);
        };
      }
      f(s.multiple ? S : S[0] || null), i("update:modelValue", s.multiple ? S : S[0] || null), k.type === "input" && i("input", k, s.multiple ? S : S[0] || null), k.type === "change" && i("change", k, s.multiple ? S : S[0] || null);
    }
    function x(k) {
      if (k.preventDefault(), k.stopPropagation(), k.type === "drop") {
        a.value = false;
        const v = k.target.classList.contains("mn-file-input") ? k.target : k.target.querySelector(".mn-file-input");
        if (v) {
          const S = k.dataTransfer.files;
          S.length && (v.files = S, b({ type: "change", target: { files: S } }));
        }
      }
    }
    return onMounted(() => {
      o.value.addEventListener("drop", (k) => x(k)), o.value.addEventListener("dragover", (k) => x(k));
    }), onUnmounted(() => {
      var k, v;
      (k = o.value) == null || k.removeEventListener("drop", (S) => x(S)), (v = o.value) == null || v.removeEventListener("dragover", (S) => x(S));
    }), watch(
      () => s.variant,
      (k) => {
        var v;
        if ((v = u.value) != null && v.length && k === "thumbnail" && !s.multiple)
          if (s.custom) {
            const S = document.querySelector(`#${r}-thumbnail .mn-file-thumbnail-img`);
            S.src = u.value[0].original.url;
          } else {
            const S = new FileReader();
            S.readAsDataURL(u.value[0]), S.onload = () => {
              const w = document.querySelector(`#${r}-thumbnail .mn-file-thumbnail-img`);
              w.src = String(S.result);
            };
          }
      }
    ), (k, v) => {
      var S, w, E, M, N, V, Y;
      return openBlock(), createElementBlock("div", {
        ref_key: "fileEl",
        ref: o,
        class: normalizeClass(["mn-file", { "-hidden": t10.hidden, "-disabled": t10.disabled }])
      }, [
        createVNode(Ft, {
          class: normalizeClass(["mn-file-label", { invisible: t10.labelless }]),
          label: t10.label,
          tooltip: t10.tooltip,
          for: unref(r)
        }, null, 8, ["class", "label", "tooltip", "for"]),
        createBaseVNode("div", {
          class: normalizeClass(["mn-file-shell", { "-dropzone": t10.variant === "dropzone", "-thumbnail": t10.variant === "thumbnail", "-invalid": unref(d).length }])
        }, [
          t10.variant === "thumbnail" && !t10.multiple ? (openBlock(), createElementBlock("div", {
            key: 0,
            id: `${unref(r)}-thumbnail`,
            class: normalizeClass(["mn-file-thumbnail", { "-dragging": a.value }])
          }, [
            createBaseVNode("img", {
              class: normalizeClass(["mn-file-thumbnail-img", { invisible: !p.value[0] }]),
              src: ((w = (S = p.value[0]) == null ? void 0 : S.original) == null ? void 0 : w.url) || ((E = p.value[0]) == null ? void 0 : E.src) || null,
              alt: ""
            }, null, 10, Mj),
            createVNode(ft, {
              class: normalizeClass(["mn-file-thumbnail-icon", { "-update": !!unref(u) }]),
              icon: "arrow-up-from-bracket"
            }, null, 8, ["class"]),
            createBaseVNode("input", {
              type: "file",
              class: "mn-file-input",
              title: t10.labelless ? t10.label : "",
              id: unref(r),
              name: t10.name,
              capture: t10.capture,
              disabled: t10.disabled,
              "aria-describedby": `${unref(r)}-error ${unref(r)}-hint`,
              "aria-required": t10.rules.includes("required") || null,
              onDragenter: v[0] || (v[0] = (F) => a.value = true),
              onDragleave: v[1] || (v[1] = (F) => a.value = false),
              onChange: b,
              onClick: v[2] || (v[2] = (F) => t10.custom ? g(F) : null)
            }, null, 40, Tj),
            t10.variant === "thumbnail" && ((M = p.value) != null && M.length) ? (openBlock(), createBlock(me, {
              key: 0,
              variant: "muted",
              color: "neutral",
              label: unref(n).t("remove"),
              labelless: "",
              icon: "xmark",
              onClick: v[3] || (v[3] = (F) => m(unref(u).name))
            }, null, 8, ["label"])) : createCommentVNode("", true)
          ], 10, Ej)) : t10.variant === "dropzone" ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(["mn-file-dropzone", { "-dragging": a.value }])
          }, [
            createVNode(ft, {
              class: "mn-file-dropzone-icon",
              icon: a.value ? "inbox" : "far inbox"
            }, null, 8, ["icon"]),
            createBaseVNode("input", {
              type: "file",
              class: "mn-file-input",
              title: t10.labelless ? t10.label : "",
              id: unref(r),
              name: t10.name,
              capture: t10.capture,
              disabled: t10.disabled,
              multiple: t10.multiple,
              "aria-describedby": `${unref(r)}-error ${unref(r)}-hint`,
              "aria-required": t10.rules.includes("required") || null,
              onDragenter: v[4] || (v[4] = (F) => a.value = true),
              onDragleave: v[5] || (v[5] = (F) => a.value = false),
              onChange: b,
              onClick: v[6] || (v[6] = (F) => t10.custom ? g(F) : null)
            }, null, 40, Aj),
            (N = p.value) != null && N.length ? (openBlock(), createElementBlock("ul", {
              key: 0,
              class: "mn-file-list",
              "aria-labelledby": `${unref(r)}-uploaded-list`
            }, [
              createBaseVNode("span", {
                id: `${unref(r)}-uploaded-list`,
                hidden: ""
              }, toDisplayString(unref(n).t("uploadedFiles")), 9, Nj),
              (openBlock(true), createElementBlock(Fragment, null, renderList(p.value, (F) => (openBlock(), createElementBlock("li", {
                key: `${unref(r)}-dropzone-${JSON.stringify(F)}`,
                class: "mn-file-list-file"
              }, [
                createVNode(me, {
                  variant: "text",
                  label: unref(n).t("remove"),
                  labelless: "",
                  icon: "xmark",
                  onClick: (re) => m(F.name)
                }, null, 8, ["label", "onClick"]),
                createBaseVNode("span", Lj, toDisplayString(F.mimetype || F.type), 1),
                createBaseVNode("span", Ij, toDisplayString(F.name), 1),
                createBaseVNode("span", null, "(" + toDisplayString(unref(Na)(F.size)) + ")", 1)
              ]))), 128))
            ], 8, _j)) : createCommentVNode("", true)
          ], 2)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createVNode(me, {
              tabindex: "-1",
              "aria-hidden": "true",
              class: normalizeClass(["mn-file-button", { "-dragging": a.value }]),
              color: "neutral",
              variant: "muted",
              label: unref(n).t("upload"),
              icon: "arrow-up-from-bracket",
              labelless: ""
            }, null, 8, ["class", "label"]),
            createBaseVNode("input", {
              type: "file",
              class: "mn-file-input",
              title: t10.labelless ? t10.label : "",
              id: unref(r),
              name: t10.name,
              capture: t10.capture,
              disabled: t10.disabled,
              multiple: t10.multiple,
              "aria-describedby": `${unref(r)}-error ${unref(r)}-hint`,
              "aria-required": t10.rules.includes("required") || null,
              onDragenter: v[7] || (v[7] = (F) => a.value = true),
              onDragleave: v[8] || (v[8] = (F) => a.value = false),
              onChange: b,
              onClick: v[9] || (v[9] = (F) => t10.custom ? g(F) : null)
            }, null, 40, Pj)
          ], 64))
        ], 2),
        unref(d).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(d), (F) => (openBlock(), createBlock($n, {
          key: F,
          id: `${unref(r)}-error`,
          message: F
        }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
        t10.hint ? (openBlock(), createBlock(ln, {
          key: 1,
          class: "mn-file-hint",
          id: `${unref(r)}-hint`,
          label: t10.hint
        }, null, 8, ["id", "label"])) : createCommentVNode("", true),
        t10.variant === "list" && ((V = p.value) != null && V.length) ? (openBlock(), createElementBlock("ul", {
          key: 2,
          class: "mn-file-list",
          "aria-labelledby": `${unref(r)}-uploaded-list`
        }, [
          createBaseVNode("span", {
            id: `${unref(r)}-uploaded-list`,
            hidden: ""
          }, toDisplayString(unref(n).t("uploadedFiles")), 9, $j),
          (openBlock(true), createElementBlock(Fragment, null, renderList(p.value, (F) => (openBlock(), createElementBlock("li", {
            key: `${unref(r)}-list-${JSON.stringify(F)}`,
            class: "mn-file-list-file"
          }, [
            createVNode(me, {
              variant: "text",
              label: unref(n).t("remove"),
              labelless: "",
              icon: "xmark",
              onClick: (re) => m(F.name)
            }, null, 8, ["label", "onClick"]),
            createBaseVNode("span", Rj, toDisplayString(F.mimetype || F.type), 1),
            createBaseVNode("span", Fj, toDisplayString(F.name), 1),
            createBaseVNode("span", null, "(" + toDisplayString(unref(Na)(F.size)) + ")", 1)
          ]))), 128))
        ], 8, Dj)) : createCommentVNode("", true),
        t10.variant === "preview" && ((Y = p.value) != null && Y.length) ? (openBlock(), createElementBlock("ul", {
          key: 3,
          class: "mn-file-preview",
          "aria-labelledby": `${unref(r)}-uploaded-preview`
        }, [
          createBaseVNode("span", {
            id: `${unref(r)}-uploaded-preview`,
            hidden: ""
          }, toDisplayString(unref(n).t("uploadedFiles")), 9, Bj),
          (openBlock(true), createElementBlock(Fragment, null, renderList(p.value, (F) => (openBlock(), createElementBlock("li", {
            key: `${unref(r)}-preview-${JSON.stringify(F)}`
          }, [
            createVNode(nD, {
              file: F,
              footer: "",
              removable: "",
              onRemove: (re) => m(F.name)
            }, null, 8, ["file", "onRemove"])
          ]))), 128))
        ], 8, Vj)) : createCommentVNode("", true)
      ], 2);
    };
  }
});
var CZ = Me(zj, [["__scopeId", "data-v-59b8ed49"]]);
function jj(t10) {
  return t10 && t10.__esModule && Object.prototype.hasOwnProperty.call(t10, "default") ? t10.default : t10;
}
var Yk = { exports: {} };
(function(t10) {
  (function(e) {
    t10.exports ? t10.exports = e() : window.intlTelInput = e();
  })(() => {
    var e = (() => {
      var n = Object.defineProperty, i = Object.getOwnPropertyDescriptor, s = Object.getOwnPropertyNames, r = Object.prototype.hasOwnProperty, o = (C, O) => {
        for (var _ in O)
          n(C, _, { get: O[_], enumerable: true });
      }, a = (C, O, _, T) => {
        if (O && typeof O == "object" || typeof O == "function")
          for (let H of s(O))
            !r.call(C, H) && H !== _ && n(C, H, { get: () => O[H], enumerable: !(T = i(O, H)) || T.enumerable });
        return C;
      }, l = (C) => a(n({}, "__esModule", { value: true }), C), c = {};
      o(c, {
        Iti: () => F,
        default: () => W
      });
      var u = [
        [
          "af",
          // Afghanistan
          "93"
        ],
        [
          "ax",
          // Åland Islands
          "358",
          1,
          ["18"]
        ],
        [
          "al",
          // Albania
          "355"
        ],
        [
          "dz",
          // Algeria
          "213"
        ],
        [
          "as",
          // American Samoa
          "1",
          5,
          ["684"]
        ],
        [
          "ad",
          // Andorra
          "376"
        ],
        [
          "ao",
          // Angola
          "244"
        ],
        [
          "ai",
          // Anguilla
          "1",
          6,
          ["264"]
        ],
        [
          "ag",
          // Antigua and Barbuda
          "1",
          7,
          ["268"]
        ],
        [
          "ar",
          // Argentina
          "54"
        ],
        [
          "am",
          // Armenia
          "374"
        ],
        [
          "aw",
          // Aruba
          "297"
        ],
        [
          "ac",
          // Ascension Island
          "247"
        ],
        [
          "au",
          // Australia
          "61",
          0
        ],
        [
          "at",
          // Austria
          "43"
        ],
        [
          "az",
          // Azerbaijan
          "994"
        ],
        [
          "bs",
          // Bahamas
          "1",
          8,
          ["242"]
        ],
        [
          "bh",
          // Bahrain
          "973"
        ],
        [
          "bd",
          // Bangladesh
          "880"
        ],
        [
          "bb",
          // Barbados
          "1",
          9,
          ["246"]
        ],
        [
          "by",
          // Belarus
          "375"
        ],
        [
          "be",
          // Belgium
          "32"
        ],
        [
          "bz",
          // Belize
          "501"
        ],
        [
          "bj",
          // Benin
          "229"
        ],
        [
          "bm",
          // Bermuda
          "1",
          10,
          ["441"]
        ],
        [
          "bt",
          // Bhutan
          "975"
        ],
        [
          "bo",
          // Bolivia
          "591"
        ],
        [
          "ba",
          // Bosnia and Herzegovina
          "387"
        ],
        [
          "bw",
          // Botswana
          "267"
        ],
        [
          "br",
          // Brazil
          "55"
        ],
        [
          "io",
          // British Indian Ocean Territory
          "246"
        ],
        [
          "vg",
          // British Virgin Islands
          "1",
          11,
          ["284"]
        ],
        [
          "bn",
          // Brunei
          "673"
        ],
        [
          "bg",
          // Bulgaria
          "359"
        ],
        [
          "bf",
          // Burkina Faso
          "226"
        ],
        [
          "bi",
          // Burundi
          "257"
        ],
        [
          "kh",
          // Cambodia
          "855"
        ],
        [
          "cm",
          // Cameroon
          "237"
        ],
        [
          "ca",
          // Canada
          "1",
          1,
          ["204", "226", "236", "249", "250", "263", "289", "306", "343", "354", "365", "367", "368", "382", "387", "403", "416", "418", "428", "431", "437", "438", "450", "584", "468", "474", "506", "514", "519", "548", "579", "581", "584", "587", "604", "613", "639", "647", "672", "683", "705", "709", "742", "753", "778", "780", "782", "807", "819", "825", "867", "873", "879", "902", "905"]
        ],
        [
          "cv",
          // Cape Verde
          "238"
        ],
        [
          "bq",
          // Caribbean Netherlands
          "599",
          1,
          ["3", "4", "7"]
        ],
        [
          "ky",
          // Cayman Islands
          "1",
          12,
          ["345"]
        ],
        [
          "cf",
          // Central African Republic
          "236"
        ],
        [
          "td",
          // Chad
          "235"
        ],
        [
          "cl",
          // Chile
          "56"
        ],
        [
          "cn",
          // China
          "86"
        ],
        [
          "cx",
          // Christmas Island
          "61",
          2,
          ["89164"]
        ],
        [
          "cc",
          // Cocos (Keeling) Islands
          "61",
          1,
          ["89162"]
        ],
        [
          "co",
          // Colombia
          "57"
        ],
        [
          "km",
          // Comoros
          "269"
        ],
        [
          "cg",
          // Congo (Brazzaville)
          "242"
        ],
        [
          "cd",
          // Congo (Kinshasa)
          "243"
        ],
        [
          "ck",
          // Cook Islands
          "682"
        ],
        [
          "cr",
          // Costa Rica
          "506"
        ],
        [
          "ci",
          // Côte d'Ivoire
          "225"
        ],
        [
          "hr",
          // Croatia
          "385"
        ],
        [
          "cu",
          // Cuba
          "53"
        ],
        [
          "cw",
          // Curaçao
          "599",
          0
        ],
        [
          "cy",
          // Cyprus
          "357"
        ],
        [
          "cz",
          // Czech Republic
          "420"
        ],
        [
          "dk",
          // Denmark
          "45"
        ],
        [
          "dj",
          // Djibouti
          "253"
        ],
        [
          "dm",
          // Dominica
          "1",
          13,
          ["767"]
        ],
        [
          "do",
          // Dominican Republic
          "1",
          2,
          ["809", "829", "849"]
        ],
        [
          "ec",
          // Ecuador
          "593"
        ],
        [
          "eg",
          // Egypt
          "20"
        ],
        [
          "sv",
          // El Salvador
          "503"
        ],
        [
          "gq",
          // Equatorial Guinea
          "240"
        ],
        [
          "er",
          // Eritrea
          "291"
        ],
        [
          "ee",
          // Estonia
          "372"
        ],
        [
          "sz",
          // Eswatini
          "268"
        ],
        [
          "et",
          // Ethiopia
          "251"
        ],
        [
          "fk",
          // Falkland Islands (Malvinas)
          "500"
        ],
        [
          "fo",
          // Faroe Islands
          "298"
        ],
        [
          "fj",
          // Fiji
          "679"
        ],
        [
          "fi",
          // Finland
          "358",
          0
        ],
        [
          "fr",
          // France
          "33"
        ],
        [
          "gf",
          // French Guiana
          "594"
        ],
        [
          "pf",
          // French Polynesia
          "689"
        ],
        [
          "ga",
          // Gabon
          "241"
        ],
        [
          "gm",
          // Gambia
          "220"
        ],
        [
          "ge",
          // Georgia
          "995"
        ],
        [
          "de",
          // Germany
          "49"
        ],
        [
          "gh",
          // Ghana
          "233"
        ],
        [
          "gi",
          // Gibraltar
          "350"
        ],
        [
          "gr",
          // Greece
          "30"
        ],
        [
          "gl",
          // Greenland
          "299"
        ],
        [
          "gd",
          // Grenada
          "1",
          14,
          ["473"]
        ],
        [
          "gp",
          // Guadeloupe
          "590",
          0
        ],
        [
          "gu",
          // Guam
          "1",
          15,
          ["671"]
        ],
        [
          "gt",
          // Guatemala
          "502"
        ],
        [
          "gg",
          // Guernsey
          "44",
          1,
          ["1481", "7781", "7839", "7911"]
        ],
        [
          "gn",
          // Guinea
          "224"
        ],
        [
          "gw",
          // Guinea-Bissau
          "245"
        ],
        [
          "gy",
          // Guyana
          "592"
        ],
        [
          "ht",
          // Haiti
          "509"
        ],
        [
          "hn",
          // Honduras
          "504"
        ],
        [
          "hk",
          // Hong Kong SAR China
          "852"
        ],
        [
          "hu",
          // Hungary
          "36"
        ],
        [
          "is",
          // Iceland
          "354"
        ],
        [
          "in",
          // India
          "91"
        ],
        [
          "id",
          // Indonesia
          "62"
        ],
        [
          "ir",
          // Iran
          "98"
        ],
        [
          "iq",
          // Iraq
          "964"
        ],
        [
          "ie",
          // Ireland
          "353"
        ],
        [
          "im",
          // Isle of Man
          "44",
          2,
          ["1624", "74576", "7524", "7924", "7624"]
        ],
        [
          "il",
          // Israel
          "972"
        ],
        [
          "it",
          // Italy
          "39",
          0
        ],
        [
          "jm",
          // Jamaica
          "1",
          4,
          ["876", "658"]
        ],
        [
          "jp",
          // Japan
          "81"
        ],
        [
          "je",
          // Jersey
          "44",
          3,
          ["1534", "7509", "7700", "7797", "7829", "7937"]
        ],
        [
          "jo",
          // Jordan
          "962"
        ],
        [
          "kz",
          // Kazakhstan
          "7",
          1,
          ["33", "7"]
        ],
        [
          "ke",
          // Kenya
          "254"
        ],
        [
          "ki",
          // Kiribati
          "686"
        ],
        [
          "xk",
          // Kosovo
          "383"
        ],
        [
          "kw",
          // Kuwait
          "965"
        ],
        [
          "kg",
          // Kyrgyzstan
          "996"
        ],
        [
          "la",
          // Laos
          "856"
        ],
        [
          "lv",
          // Latvia
          "371"
        ],
        [
          "lb",
          // Lebanon
          "961"
        ],
        [
          "ls",
          // Lesotho
          "266"
        ],
        [
          "lr",
          // Liberia
          "231"
        ],
        [
          "ly",
          // Libya
          "218"
        ],
        [
          "li",
          // Liechtenstein
          "423"
        ],
        [
          "lt",
          // Lithuania
          "370"
        ],
        [
          "lu",
          // Luxembourg
          "352"
        ],
        [
          "mo",
          // Macao SAR China
          "853"
        ],
        [
          "mg",
          // Madagascar
          "261"
        ],
        [
          "mw",
          // Malawi
          "265"
        ],
        [
          "my",
          // Malaysia
          "60"
        ],
        [
          "mv",
          // Maldives
          "960"
        ],
        [
          "ml",
          // Mali
          "223"
        ],
        [
          "mt",
          // Malta
          "356"
        ],
        [
          "mh",
          // Marshall Islands
          "692"
        ],
        [
          "mq",
          // Martinique
          "596"
        ],
        [
          "mr",
          // Mauritania
          "222"
        ],
        [
          "mu",
          // Mauritius
          "230"
        ],
        [
          "yt",
          // Mayotte
          "262",
          1,
          ["269", "639"]
        ],
        [
          "mx",
          // Mexico
          "52"
        ],
        [
          "fm",
          // Micronesia
          "691"
        ],
        [
          "md",
          // Moldova
          "373"
        ],
        [
          "mc",
          // Monaco
          "377"
        ],
        [
          "mn",
          // Mongolia
          "976"
        ],
        [
          "me",
          // Montenegro
          "382"
        ],
        [
          "ms",
          // Montserrat
          "1",
          16,
          ["664"]
        ],
        [
          "ma",
          // Morocco
          "212",
          0
        ],
        [
          "mz",
          // Mozambique
          "258"
        ],
        [
          "mm",
          // Myanmar (Burma)
          "95"
        ],
        [
          "na",
          // Namibia
          "264"
        ],
        [
          "nr",
          // Nauru
          "674"
        ],
        [
          "np",
          // Nepal
          "977"
        ],
        [
          "nl",
          // Netherlands
          "31"
        ],
        [
          "nc",
          // New Caledonia
          "687"
        ],
        [
          "nz",
          // New Zealand
          "64"
        ],
        [
          "ni",
          // Nicaragua
          "505"
        ],
        [
          "ne",
          // Niger
          "227"
        ],
        [
          "ng",
          // Nigeria
          "234"
        ],
        [
          "nu",
          // Niue
          "683"
        ],
        [
          "nf",
          // Norfolk Island
          "672"
        ],
        [
          "kp",
          // North Korea
          "850"
        ],
        [
          "mk",
          // North Macedonia
          "389"
        ],
        [
          "mp",
          // Northern Mariana Islands
          "1",
          17,
          ["670"]
        ],
        [
          "no",
          // Norway
          "47",
          0
        ],
        [
          "om",
          // Oman
          "968"
        ],
        [
          "pk",
          // Pakistan
          "92"
        ],
        [
          "pw",
          // Palau
          "680"
        ],
        [
          "ps",
          // Palestinian Territories
          "970"
        ],
        [
          "pa",
          // Panama
          "507"
        ],
        [
          "pg",
          // Papua New Guinea
          "675"
        ],
        [
          "py",
          // Paraguay
          "595"
        ],
        [
          "pe",
          // Peru
          "51"
        ],
        [
          "ph",
          // Philippines
          "63"
        ],
        [
          "pl",
          // Poland
          "48"
        ],
        [
          "pt",
          // Portugal
          "351"
        ],
        [
          "pr",
          // Puerto Rico
          "1",
          3,
          ["787", "939"]
        ],
        [
          "qa",
          // Qatar
          "974"
        ],
        [
          "re",
          // Réunion
          "262",
          0
        ],
        [
          "ro",
          // Romania
          "40"
        ],
        [
          "ru",
          // Russia
          "7",
          0
        ],
        [
          "rw",
          // Rwanda
          "250"
        ],
        [
          "ws",
          // Samoa
          "685"
        ],
        [
          "sm",
          // San Marino
          "378"
        ],
        [
          "st",
          // São Tomé & Príncipe
          "239"
        ],
        [
          "sa",
          // Saudi Arabia
          "966"
        ],
        [
          "sn",
          // Senegal
          "221"
        ],
        [
          "rs",
          // Serbia
          "381"
        ],
        [
          "sc",
          // Seychelles
          "248"
        ],
        [
          "sl",
          // Sierra Leone
          "232"
        ],
        [
          "sg",
          // Singapore
          "65"
        ],
        [
          "sx",
          // Sint Maarten
          "1",
          21,
          ["721"]
        ],
        [
          "sk",
          // Slovakia
          "421"
        ],
        [
          "si",
          // Slovenia
          "386"
        ],
        [
          "sb",
          // Solomon Islands
          "677"
        ],
        [
          "so",
          // Somalia
          "252"
        ],
        [
          "za",
          // South Africa
          "27"
        ],
        [
          "kr",
          // South Korea
          "82"
        ],
        [
          "ss",
          // South Sudan
          "211"
        ],
        [
          "es",
          // Spain
          "34"
        ],
        [
          "lk",
          // Sri Lanka
          "94"
        ],
        [
          "bl",
          // St. Barthélemy
          "590",
          1
        ],
        [
          "sh",
          // St. Helena
          "290"
        ],
        [
          "kn",
          // St. Kitts & Nevis
          "1",
          18,
          ["869"]
        ],
        [
          "lc",
          // St. Lucia
          "1",
          19,
          ["758"]
        ],
        [
          "mf",
          // St. Martin
          "590",
          2
        ],
        [
          "pm",
          // St. Pierre & Miquelon
          "508"
        ],
        [
          "vc",
          // St. Vincent & Grenadines
          "1",
          20,
          ["784"]
        ],
        [
          "sd",
          // Sudan
          "249"
        ],
        [
          "sr",
          // Suriname
          "597"
        ],
        [
          "sj",
          // Svalbard & Jan Mayen
          "47",
          1,
          ["79"]
        ],
        [
          "se",
          // Sweden
          "46"
        ],
        [
          "ch",
          // Switzerland
          "41"
        ],
        [
          "sy",
          // Syria
          "963"
        ],
        [
          "tw",
          // Taiwan
          "886"
        ],
        [
          "tj",
          // Tajikistan
          "992"
        ],
        [
          "tz",
          // Tanzania
          "255"
        ],
        [
          "th",
          // Thailand
          "66"
        ],
        [
          "tl",
          // Timor-Leste
          "670"
        ],
        [
          "tg",
          // Togo
          "228"
        ],
        [
          "tk",
          // Tokelau
          "690"
        ],
        [
          "to",
          // Tonga
          "676"
        ],
        [
          "tt",
          // Trinidad & Tobago
          "1",
          22,
          ["868"]
        ],
        [
          "tn",
          // Tunisia
          "216"
        ],
        [
          "tr",
          // Turkey
          "90"
        ],
        [
          "tm",
          // Turkmenistan
          "993"
        ],
        [
          "tc",
          // Turks & Caicos Islands
          "1",
          23,
          ["649"]
        ],
        [
          "tv",
          // Tuvalu
          "688"
        ],
        [
          "ug",
          // Uganda
          "256"
        ],
        [
          "ua",
          // Ukraine
          "380"
        ],
        [
          "ae",
          // United Arab Emirates
          "971"
        ],
        [
          "gb",
          // United Kingdom
          "44",
          0
        ],
        [
          "us",
          // United States
          "1",
          0
        ],
        [
          "uy",
          // Uruguay
          "598"
        ],
        [
          "vi",
          // U.S. Virgin Islands
          "1",
          24,
          ["340"]
        ],
        [
          "uz",
          // Uzbekistan
          "998"
        ],
        [
          "vu",
          // Vanuatu
          "678"
        ],
        [
          "va",
          // Vatican City
          "39",
          1,
          ["06698"]
        ],
        [
          "ve",
          // Venezuela
          "58"
        ],
        [
          "vn",
          // Vietnam
          "84"
        ],
        [
          "wf",
          // Wallis & Futuna
          "681"
        ],
        [
          "eh",
          // Western Sahara
          "212",
          1,
          ["5288", "5289"]
        ],
        [
          "ye",
          // Yemen
          "967"
        ],
        [
          "zm",
          // Zambia
          "260"
        ],
        [
          "zw",
          // Zimbabwe
          "263"
        ]
      ], d = [];
      for (let C = 0; C < u.length; C++) {
        const O = u[C];
        d[C] = {
          name: "",
          // this is now populated in the plugin
          iso2: O[0],
          dialCode: O[1],
          priority: O[2] || 0,
          areaCodes: O[3] || null,
          nodeById: {}
        };
      }
      var f = d, h10 = {
        ad: "Andorra",
        ae: "United Arab Emirates",
        af: "Afghanistan",
        ag: "Antigua & Barbuda",
        ai: "Anguilla",
        al: "Albania",
        am: "Armenia",
        ao: "Angola",
        ar: "Argentina",
        as: "American Samoa",
        at: "Austria",
        au: "Australia",
        aw: "Aruba",
        ax: "Åland Islands",
        az: "Azerbaijan",
        ba: "Bosnia & Herzegovina",
        bb: "Barbados",
        bd: "Bangladesh",
        be: "Belgium",
        bf: "Burkina Faso",
        bg: "Bulgaria",
        bh: "Bahrain",
        bi: "Burundi",
        bj: "Benin",
        bl: "St. Barthélemy",
        bm: "Bermuda",
        bn: "Brunei",
        bo: "Bolivia",
        bq: "Caribbean Netherlands",
        br: "Brazil",
        bs: "Bahamas",
        bt: "Bhutan",
        bw: "Botswana",
        by: "Belarus",
        bz: "Belize",
        ca: "Canada",
        cc: "Cocos (Keeling) Islands",
        cd: "Congo - Kinshasa",
        cf: "Central African Republic",
        cg: "Congo - Brazzaville",
        ch: "Switzerland",
        ci: "Côte d’Ivoire",
        ck: "Cook Islands",
        cl: "Chile",
        cm: "Cameroon",
        cn: "China",
        co: "Colombia",
        cr: "Costa Rica",
        cu: "Cuba",
        cv: "Cape Verde",
        cw: "Curaçao",
        cx: "Christmas Island",
        cy: "Cyprus",
        cz: "Czechia",
        de: "Germany",
        dj: "Djibouti",
        dk: "Denmark",
        dm: "Dominica",
        do: "Dominican Republic",
        dz: "Algeria",
        ec: "Ecuador",
        ee: "Estonia",
        eg: "Egypt",
        eh: "Western Sahara",
        er: "Eritrea",
        es: "Spain",
        et: "Ethiopia",
        fi: "Finland",
        fj: "Fiji",
        fk: "Falkland Islands",
        fm: "Micronesia",
        fo: "Faroe Islands",
        fr: "France",
        ga: "Gabon",
        gb: "United Kingdom",
        gd: "Grenada",
        ge: "Georgia",
        gf: "French Guiana",
        gg: "Guernsey",
        gh: "Ghana",
        gi: "Gibraltar",
        gl: "Greenland",
        gm: "Gambia",
        gn: "Guinea",
        gp: "Guadeloupe",
        gq: "Equatorial Guinea",
        gr: "Greece",
        gt: "Guatemala",
        gu: "Guam",
        gw: "Guinea-Bissau",
        gy: "Guyana",
        hk: "Hong Kong SAR China",
        hn: "Honduras",
        hr: "Croatia",
        ht: "Haiti",
        hu: "Hungary",
        id: "Indonesia",
        ie: "Ireland",
        il: "Israel",
        im: "Isle of Man",
        in: "India",
        io: "British Indian Ocean Territory",
        iq: "Iraq",
        ir: "Iran",
        is: "Iceland",
        it: "Italy",
        je: "Jersey",
        jm: "Jamaica",
        jo: "Jordan",
        jp: "Japan",
        ke: "Kenya",
        kg: "Kyrgyzstan",
        kh: "Cambodia",
        ki: "Kiribati",
        km: "Comoros",
        kn: "St. Kitts & Nevis",
        kp: "North Korea",
        kr: "South Korea",
        kw: "Kuwait",
        ky: "Cayman Islands",
        kz: "Kazakhstan",
        la: "Laos",
        lb: "Lebanon",
        lc: "St. Lucia",
        li: "Liechtenstein",
        lk: "Sri Lanka",
        lr: "Liberia",
        ls: "Lesotho",
        lt: "Lithuania",
        lu: "Luxembourg",
        lv: "Latvia",
        ly: "Libya",
        ma: "Morocco",
        mc: "Monaco",
        md: "Moldova",
        me: "Montenegro",
        mf: "St. Martin",
        mg: "Madagascar",
        mh: "Marshall Islands",
        mk: "North Macedonia",
        ml: "Mali",
        mm: "Myanmar (Burma)",
        mn: "Mongolia",
        mo: "Macao SAR China",
        mp: "Northern Mariana Islands",
        mq: "Martinique",
        mr: "Mauritania",
        ms: "Montserrat",
        mt: "Malta",
        mu: "Mauritius",
        mv: "Maldives",
        mw: "Malawi",
        mx: "Mexico",
        my: "Malaysia",
        mz: "Mozambique",
        na: "Namibia",
        nc: "New Caledonia",
        ne: "Niger",
        nf: "Norfolk Island",
        ng: "Nigeria",
        ni: "Nicaragua",
        nl: "Netherlands",
        no: "Norway",
        np: "Nepal",
        nr: "Nauru",
        nu: "Niue",
        nz: "New Zealand",
        om: "Oman",
        pa: "Panama",
        pe: "Peru",
        pf: "French Polynesia",
        pg: "Papua New Guinea",
        ph: "Philippines",
        pk: "Pakistan",
        pl: "Poland",
        pm: "St. Pierre & Miquelon",
        pr: "Puerto Rico",
        ps: "Palestinian Territories",
        pt: "Portugal",
        pw: "Palau",
        py: "Paraguay",
        qa: "Qatar",
        re: "Réunion",
        ro: "Romania",
        rs: "Serbia",
        ru: "Russia",
        rw: "Rwanda",
        sa: "Saudi Arabia",
        sb: "Solomon Islands",
        sc: "Seychelles",
        sd: "Sudan",
        se: "Sweden",
        sg: "Singapore",
        sh: "St. Helena",
        si: "Slovenia",
        sj: "Svalbard & Jan Mayen",
        sk: "Slovakia",
        sl: "Sierra Leone",
        sm: "San Marino",
        sn: "Senegal",
        so: "Somalia",
        sr: "Suriname",
        ss: "South Sudan",
        st: "São Tomé & Príncipe",
        sv: "El Salvador",
        sx: "Sint Maarten",
        sy: "Syria",
        sz: "Eswatini",
        tc: "Turks & Caicos Islands",
        td: "Chad",
        tg: "Togo",
        th: "Thailand",
        tj: "Tajikistan",
        tk: "Tokelau",
        tl: "Timor-Leste",
        tm: "Turkmenistan",
        tn: "Tunisia",
        to: "Tonga",
        tr: "Turkey",
        tt: "Trinidad & Tobago",
        tv: "Tuvalu",
        tw: "Taiwan",
        tz: "Tanzania",
        ua: "Ukraine",
        ug: "Uganda",
        us: "United States",
        uy: "Uruguay",
        uz: "Uzbekistan",
        va: "Vatican City",
        vc: "St. Vincent & Grenadines",
        ve: "Venezuela",
        vg: "British Virgin Islands",
        vi: "U.S. Virgin Islands",
        vn: "Vietnam",
        vu: "Vanuatu",
        wf: "Wallis & Futuna",
        ws: "Samoa",
        ye: "Yemen",
        yt: "Mayotte",
        za: "South Africa",
        zm: "Zambia",
        zw: "Zimbabwe"
      }, p = h10, g = {
        selectedCountryAriaLabel: "Selected country",
        noCountrySelected: "No country selected",
        countryListAriaLabel: "List of countries",
        searchPlaceholder: "Search",
        zeroSearchResults: "No results found",
        oneSearchResult: "1 result found",
        multipleSearchResults: "${count} results found",
        // additional countries (not supported by country-list library)
        ac: "Ascension Island",
        xk: "Kosovo"
      }, m = g, b = { ...p, ...m }, x = b;
      for (let C = 0; C < f.length; C++)
        f[C].name = x[f[C].iso2];
      var k = 0, v = {
        //* Whether or not to allow the dropdown.
        allowDropdown: true,
        //* Add a placeholder in the input with an example number for the selected country.
        autoPlaceholder: "polite",
        //* Modify the parentClass.
        containerClass: "",
        //* The order of the countries in the dropdown. Defaults to alphabetical.
        countryOrder: null,
        //* Add a country search input at the top of the dropdown.
        countrySearch: true,
        //* Modify the auto placeholder.
        customPlaceholder: null,
        //* Append menu to specified element.
        dropdownContainer: null,
        //* Don't display these countries.
        excludeCountries: [],
        //* Fix the dropdown width to the input width (rather than being as wide as the longest country name).
        fixDropdownWidth: true,
        //* Format the number as the user types
        formatAsYouType: true,
        //* Format the input value during initialisation and on setNumber.
        formatOnDisplay: true,
        //* geoIp lookup function.
        geoIpLookup: null,
        //* Inject a hidden input with the name returned from this function, and on submit, populate it with the result of getNumber.
        hiddenInput: null,
        //* Internationalise the plugin text e.g. search input placeholder, country names.
        i18n: {},
        //* Initial country.
        initialCountry: "",
        //* Specify the path to the libphonenumber script to enable validation/formatting.
        loadUtilsOnInit: "",
        //* National vs international formatting for numbers e.g. placeholders and displaying existing numbers.
        nationalMode: true,
        //* Display only these countries.
        onlyCountries: [],
        //* Number type to use for placeholders.
        placeholderNumberType: "MOBILE",
        //* Show flags - for both the selected country, and in the country dropdown
        showFlags: true,
        //* Display the international dial code next to the selected flag.
        separateDialCode: false,
        //* Only allow certain chars e.g. a plus followed by numeric digits, and cap at max valid length.
        strictMode: false,
        //* Use full screen popup instead of dropdown for country list.
        useFullscreenPopup: typeof navigator < "u" && typeof window < "u" ? (
          //* We cannot just test screen size as some smartphones/website meta tags will report desktop resolutions.
          //* Note: to target Android Mobiles (and not Tablets), we must find 'Android' and 'Mobile'
          /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || window.innerWidth <= 500
        ) : false,
        //* Deprecated! Use `loadUtilsOnInit` instead.
        utilsScript: "",
        //* The number type to enforce during validation.
        validationNumberType: "MOBILE"
      }, S = [
        "800",
        "822",
        "833",
        "844",
        "855",
        "866",
        "877",
        "880",
        "881",
        "882",
        "883",
        "884",
        "885",
        "886",
        "887",
        "888",
        "889"
      ], w = (C) => C.replace(/\D/g, ""), E = (C = "") => C.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase(), M = (C) => {
        const O = w(C);
        if (O.charAt(0) === "1") {
          const _ = O.substr(1, 3);
          return S.indexOf(_) !== -1;
        }
        return false;
      }, N = (C, O, _, T) => {
        if (_ === 0 && !T)
          return 0;
        let H = 0;
        for (let Q = 0; Q < O.length; Q++) {
          if (/[+0-9]/.test(O[Q]) && H++, H === C && !T)
            return Q + 1;
          if (T && H === C + 1)
            return Q;
        }
        return O.length;
      }, V = (C, O, _) => {
        const T = document.createElement(C);
        return O && Object.entries(O).forEach(([H, Q]) => T.setAttribute(H, Q)), _ && _.appendChild(T), T;
      }, Y = (C, ...O) => {
        const { instances: _ } = z;
        Object.values(_).forEach((T) => T[C](...O));
      }, F = class {
        constructor(C, O = {}) {
          this.id = k++, this.telInput = C, this.highlightedItem = null, this.options = Object.assign({}, v, O), this.hadInitialPlaceholder = !!C.getAttribute("placeholder");
        }
        //* Can't be private as it's called from intlTelInput convenience wrapper.
        _init() {
          this.options.useFullscreenPopup && (this.options.fixDropdownWidth = false), this.options.onlyCountries.length === 1 && (this.options.initialCountry = this.options.onlyCountries[0]), this.options.separateDialCode && (this.options.nationalMode = false), this.options.allowDropdown && !this.options.showFlags && !this.options.separateDialCode && (this.options.nationalMode = false), this.options.useFullscreenPopup && !this.options.dropdownContainer && (this.options.dropdownContainer = document.body), this.isAndroid = typeof navigator < "u" ? /Android/i.test(navigator.userAgent) : false, this.isRTL = !!this.telInput.closest("[dir=rtl]");
          const C = this.options.allowDropdown || this.options.separateDialCode;
          this.showSelectedCountryOnLeft = this.isRTL ? !C : C, this.options.separateDialCode && (this.isRTL ? this.originalPaddingRight = this.telInput.style.paddingRight : this.originalPaddingLeft = this.telInput.style.paddingLeft), this.options.i18n = { ...x, ...this.options.i18n };
          const O = new Promise((T, H) => {
            this.resolveAutoCountryPromise = T, this.rejectAutoCountryPromise = H;
          }), _ = new Promise((T, H) => {
            this.resolveUtilsScriptPromise = T, this.rejectUtilsScriptPromise = H;
          });
          this.promise = Promise.all([O, _]), this.selectedCountryData = {}, this._processCountryData(), this._generateMarkup(), this._setInitialState(), this._initListeners(), this._initRequests();
        }
        //********************
        //*  PRIVATE METHODS
        //********************
        //* Prepare all of the country data, including onlyCountries, excludeCountries, countryOrder options.
        _processCountryData() {
          this._processAllCountries(), this._processDialCodes(), this._translateCountryNames(), this._sortCountries();
        }
        //* Sort countries by countryOrder option (if present), then name.
        _sortCountries() {
          this.options.countryOrder && (this.options.countryOrder = this.options.countryOrder.map((C) => C.toLowerCase())), this.countries.sort((C, O) => {
            const { countryOrder: _ } = this.options;
            if (_) {
              const T = _.indexOf(C.iso2), H = _.indexOf(O.iso2), Q = T > -1, ae = H > -1;
              if (Q || ae)
                return Q && ae ? T - H : Q ? -1 : 1;
            }
            return C.name.localeCompare(O.name);
          });
        }
        //* Add a dial code to this.dialCodeToIso2Map.
        _addToDialCodeMap(C, O, _) {
          O.length > this.dialCodeMaxLen && (this.dialCodeMaxLen = O.length), this.dialCodeToIso2Map.hasOwnProperty(O) || (this.dialCodeToIso2Map[O] = []);
          for (let H = 0; H < this.dialCodeToIso2Map[O].length; H++)
            if (this.dialCodeToIso2Map[O][H] === C)
              return;
          const T = _ !== void 0 ? _ : this.dialCodeToIso2Map[O].length;
          this.dialCodeToIso2Map[O][T] = C;
        }
        //* Process onlyCountries or excludeCountries array if present.
        _processAllCountries() {
          const { onlyCountries: C, excludeCountries: O } = this.options;
          if (C.length) {
            const _ = C.map(
              (T) => T.toLowerCase()
            );
            this.countries = f.filter(
              (T) => _.indexOf(T.iso2) > -1
            );
          } else if (O.length) {
            const _ = O.map(
              (T) => T.toLowerCase()
            );
            this.countries = f.filter(
              (T) => _.indexOf(T.iso2) === -1
            );
          } else
            this.countries = f;
        }
        //* Translate Countries by object literal provided on config.
        _translateCountryNames() {
          for (let C = 0; C < this.countries.length; C++) {
            const O = this.countries[C].iso2.toLowerCase();
            this.options.i18n.hasOwnProperty(O) && (this.countries[C].name = this.options.i18n[O]);
          }
        }
        //* Generate this.dialCodes and this.dialCodeToIso2Map.
        _processDialCodes() {
          this.dialCodes = {}, this.dialCodeMaxLen = 0, this.dialCodeToIso2Map = {};
          for (let C = 0; C < this.countries.length; C++) {
            const O = this.countries[C];
            this.dialCodes[O.dialCode] || (this.dialCodes[O.dialCode] = true), this._addToDialCodeMap(O.iso2, O.dialCode, O.priority);
          }
          for (let C = 0; C < this.countries.length; C++) {
            const O = this.countries[C];
            if (O.areaCodes) {
              const _ = this.dialCodeToIso2Map[O.dialCode][0];
              for (let T = 0; T < O.areaCodes.length; T++) {
                const H = O.areaCodes[T];
                for (let Q = 1; Q < H.length; Q++) {
                  const ae = O.dialCode + H.substr(0, Q);
                  this._addToDialCodeMap(_, ae), this._addToDialCodeMap(O.iso2, ae);
                }
                this._addToDialCodeMap(O.iso2, O.dialCode + H);
              }
            }
          }
        }
        //* Generate all of the markup for the plugin: the selected country overlay, and the dropdown.
        _generateMarkup() {
          var B;
          this.telInput.classList.add("iti__tel-input"), !this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete")) && this.telInput.setAttribute("autocomplete", "off");
          const {
            allowDropdown: C,
            separateDialCode: O,
            showFlags: _,
            containerClass: T,
            hiddenInput: H,
            dropdownContainer: Q,
            fixDropdownWidth: ae,
            useFullscreenPopup: pe,
            countrySearch: xe,
            i18n: Te
          } = this.options;
          let L = "iti";
          C && (L += " iti--allow-dropdown"), _ && (L += " iti--show-flags"), T && (L += ` ${T}`), pe || (L += " iti--inline-dropdown");
          const K = V("div", { class: L });
          if ((B = this.telInput.parentNode) == null || B.insertBefore(K, this.telInput), C || _ || O) {
            this.countryContainer = V(
              "div",
              { class: "iti__country-container" },
              K
            ), this.showSelectedCountryOnLeft ? this.countryContainer.style.left = "0px" : this.countryContainer.style.right = "0px", C ? (this.selectedCountry = V(
              "button",
              {
                type: "button",
                class: "iti__selected-country",
                "aria-expanded": "false",
                "aria-label": this.options.i18n.selectedCountryAriaLabel,
                "aria-haspopup": "true",
                "aria-controls": `iti-${this.id}__dropdown-content`,
                role: "combobox"
              },
              this.countryContainer
            ), this.telInput.disabled && this.selectedCountry.setAttribute("disabled", "true")) : this.selectedCountry = V(
              "div",
              { class: "iti__selected-country" },
              this.countryContainer
            );
            const X = V("div", { class: "iti__selected-country-primary" }, this.selectedCountry);
            if (this.selectedCountryInner = V("div", { class: "iti__flag" }, X), this.selectedCountryA11yText = V(
              "span",
              { class: "iti__a11y-text" },
              this.selectedCountryInner
            ), C && (this.dropdownArrow = V(
              "div",
              { class: "iti__arrow", "aria-hidden": "true" },
              X
            )), O && (this.selectedDialCode = V(
              "div",
              { class: "iti__selected-dial-code" },
              this.selectedCountry
            )), C) {
              const be = ae ? "" : "iti--flexible-dropdown-width";
              if (this.dropdownContent = V("div", {
                id: `iti-${this.id}__dropdown-content`,
                class: `iti__dropdown-content iti__hide ${be}`
              }), xe && (this.searchInput = V(
                "input",
                {
                  type: "text",
                  class: "iti__search-input",
                  placeholder: Te.searchPlaceholder,
                  role: "combobox",
                  "aria-expanded": "true",
                  "aria-label": Te.searchPlaceholder,
                  "aria-controls": `iti-${this.id}__country-listbox`,
                  "aria-autocomplete": "list",
                  autocomplete: "off"
                },
                this.dropdownContent
              ), this.searchResultsA11yText = V(
                "span",
                { class: "iti__a11y-text" },
                this.dropdownContent
              )), this.countryList = V(
                "ul",
                {
                  class: "iti__country-list",
                  id: `iti-${this.id}__country-listbox`,
                  role: "listbox",
                  "aria-label": Te.countryListAriaLabel
                },
                this.dropdownContent
              ), this._appendListItems(), xe && this._updateSearchResultsText(), Q) {
                let Ce = "iti iti--container";
                pe ? Ce += " iti--fullscreen-popup" : Ce += " iti--inline-dropdown", this.dropdown = V("div", { class: Ce }), this.dropdown.appendChild(this.dropdownContent);
              } else
                this.countryContainer.appendChild(this.dropdownContent);
            }
          }
          if (K.appendChild(this.telInput), this._updateInputPadding(), H) {
            const X = this.telInput.getAttribute("name") || "", be = H(X);
            be.phone && (this.hiddenInput = V("input", {
              type: "hidden",
              name: be.phone
            }), K.appendChild(this.hiddenInput)), be.country && (this.hiddenInputCountry = V("input", {
              type: "hidden",
              name: be.country
            }), K.appendChild(this.hiddenInputCountry));
          }
        }
        //* For each country: add a country list item <li> to the countryList <ul> container.
        _appendListItems() {
          for (let C = 0; C < this.countries.length; C++) {
            const O = this.countries[C], _ = C === 0 ? "iti__highlight" : "", T = V(
              "li",
              {
                id: `iti-${this.id}__item-${O.iso2}`,
                class: `iti__country ${_}`,
                tabindex: "-1",
                role: "option",
                "data-dial-code": O.dialCode,
                "data-country-code": O.iso2,
                "aria-selected": "false"
              },
              this.countryList
            );
            O.nodeById[this.id] = T;
            let H = "";
            this.options.showFlags && (H += `<div class='iti__flag iti__${O.iso2}'></div>`), H += `<span class='iti__country-name'>${O.name}</span>`, H += `<span class='iti__dial-code'>+${O.dialCode}</span>`, T.insertAdjacentHTML("beforeend", H);
          }
        }
        //* Set the initial state of the input value and the selected country by:
        //* 1. Extracting a dial code from the given number
        //* 2. Using explicit initialCountry
        _setInitialState(C = false) {
          const O = this.telInput.getAttribute("value"), _ = this.telInput.value, H = O && O.charAt(0) === "+" && (!_ || _.charAt(0) !== "+") ? O : _, Q = this._getDialCode(H), ae = M(H), { initialCountry: pe, geoIpLookup: xe } = this.options, Te = pe === "auto" && xe;
          if (Q && !ae)
            this._updateCountryFromNumber(H);
          else if (!Te || C) {
            const L = pe ? pe.toLowerCase() : "";
            L && this._getCountryData(L, true) ? this._setCountry(L) : Q && ae ? this._setCountry("us") : this._setCountry();
          }
          H && this._updateValFromNumber(H);
        }
        //* Initialise the main event listeners: input keyup, and click selected country.
        _initListeners() {
          this._initTelInputListeners(), this.options.allowDropdown && this._initDropdownListeners(), (this.hiddenInput || this.hiddenInputCountry) && this.telInput.form && this._initHiddenInputListener();
        }
        //* Update hidden input on form submit.
        _initHiddenInputListener() {
          var C;
          this._handleHiddenInputSubmit = () => {
            this.hiddenInput && (this.hiddenInput.value = this.getNumber()), this.hiddenInputCountry && (this.hiddenInputCountry.value = this.getSelectedCountryData().iso2 || "");
          }, (C = this.telInput.form) == null || C.addEventListener(
            "submit",
            this._handleHiddenInputSubmit
          );
        }
        //* initialise the dropdown listeners.
        _initDropdownListeners() {
          this._handleLabelClick = (O) => {
            this.dropdownContent.classList.contains("iti__hide") ? this.telInput.focus() : O.preventDefault();
          };
          const C = this.telInput.closest("label");
          C && C.addEventListener("click", this._handleLabelClick), this._handleClickSelectedCountry = () => {
            this.dropdownContent.classList.contains("iti__hide") && !this.telInput.disabled && !this.telInput.readOnly && this._openDropdown();
          }, this.selectedCountry.addEventListener("click", this._handleClickSelectedCountry), this._handleCountryContainerKeydown = (O) => {
            this.dropdownContent.classList.contains("iti__hide") && ["ArrowUp", "ArrowDown", " ", "Enter"].includes(O.key) && (O.preventDefault(), O.stopPropagation(), this._openDropdown()), O.key === "Tab" && this._closeDropdown();
          }, this.countryContainer.addEventListener(
            "keydown",
            this._handleCountryContainerKeydown
          );
        }
        //* Init many requests: utils script / geo ip lookup.
        _initRequests() {
          let { loadUtilsOnInit: C, utilsScript: O, initialCountry: _, geoIpLookup: T } = this.options;
          !C && O && (console.warn("intl-tel-input: The `utilsScript` option is deprecated and will be removed in a future release! Please use the `loadUtilsOnInit` option instead."), C = O), C && !z.utils ? (this._handlePageLoad = () => {
            var Q;
            window.removeEventListener("load", this._handlePageLoad), (Q = z.loadUtils(C)) == null || Q.catch(() => {
            });
          }, z.documentReady() ? this._handlePageLoad() : window.addEventListener("load", this._handlePageLoad)) : this.resolveUtilsScriptPromise(), _ === "auto" && T && !this.selectedCountryData.iso2 ? this._loadAutoCountry() : this.resolveAutoCountryPromise();
        }
        //* Perform the geo ip lookup.
        _loadAutoCountry() {
          z.autoCountry ? this.handleAutoCountry() : z.startedLoadingAutoCountry || (z.startedLoadingAutoCountry = true, typeof this.options.geoIpLookup == "function" && this.options.geoIpLookup(
            (C = "") => {
              const O = C.toLowerCase();
              O && this._getCountryData(O, true) ? (z.autoCountry = O, setTimeout(() => Y("handleAutoCountry"))) : (this._setInitialState(true), Y("rejectAutoCountryPromise"));
            },
            () => {
              this._setInitialState(true), Y("rejectAutoCountryPromise");
            }
          ));
        }
        _openDropdownWithPlus() {
          this._openDropdown(), this.searchInput.value = "+", this._filterCountries("", true);
        }
        //* Initialize the tel input listeners.
        _initTelInputListeners() {
          const { strictMode: C, formatAsYouType: O, separateDialCode: _, formatOnDisplay: T, allowDropdown: H, countrySearch: Q } = this.options;
          let ae = false;
          new RegExp("\\p{L}", "u").test(this.telInput.value) && (ae = true), this._handleInputEvent = (pe) => {
            if (this.isAndroid && (pe == null ? void 0 : pe.data) === "+" && _ && H && Q) {
              const K = this.telInput.selectionStart || 0, B = this.telInput.value.substring(0, K - 1), X = this.telInput.value.substring(K);
              this.telInput.value = B + X, this._openDropdownWithPlus();
              return;
            }
            this._updateCountryFromNumber(this.telInput.value) && this._triggerCountryChange();
            const xe = (pe == null ? void 0 : pe.data) && /[^+0-9]/.test(pe.data), Te = (pe == null ? void 0 : pe.inputType) === "insertFromPaste" && this.telInput.value;
            xe || Te && !C ? ae = true : /[^+0-9]/.test(this.telInput.value) || (ae = false);
            const L = (pe == null ? void 0 : pe.detail) && pe.detail.isSetNumber && !T;
            if (O && !ae && !L) {
              const K = this.telInput.selectionStart || 0, X = this.telInput.value.substring(0, K).replace(/[^+0-9]/g, "").length, be = (pe == null ? void 0 : pe.inputType) === "deleteContentForward", Ce = this._formatNumberAsYouType(), Oe = N(X, Ce, K, be);
              this.telInput.value = Ce, this.telInput.setSelectionRange(Oe, Oe);
            }
          }, this.telInput.addEventListener("input", this._handleInputEvent), (C || _) && (this._handleKeydownEvent = (pe) => {
            if (pe.key && pe.key.length === 1 && !pe.altKey && !pe.ctrlKey && !pe.metaKey) {
              if (_ && H && Q && pe.key === "+") {
                pe.preventDefault(), this._openDropdownWithPlus();
                return;
              }
              if (C) {
                const xe = this.telInput.value, Te = xe.charAt(0) === "+", L = !Te && this.telInput.selectionStart === 0 && pe.key === "+", K = /^[0-9]$/.test(pe.key), B = _ ? K : L || K, X = xe.slice(0, this.telInput.selectionStart) + pe.key + xe.slice(this.telInput.selectionEnd), be = this._getFullNumber(X), Ce = z.utils.getCoreNumber(be, this.selectedCountryData.iso2), Oe = this.maxCoreNumberLength && Ce.length > this.maxCoreNumberLength;
                let Ue = false;
                if (Te) {
                  const J = this.selectedCountryData.iso2;
                  Ue = this._getCountryFromNumber(be) !== J;
                }
                (!B || Oe && !Ue && !L) && pe.preventDefault();
              }
            }
          }, this.telInput.addEventListener("keydown", this._handleKeydownEvent));
        }
        //* Adhere to the input's maxlength attr.
        _cap(C) {
          const O = parseInt(this.telInput.getAttribute("maxlength") || "", 10);
          return O && C.length > O ? C.substr(0, O) : C;
        }
        //* Trigger a custom event on the input.
        _trigger(C, O = {}) {
          const _ = new CustomEvent(C, {
            bubbles: true,
            cancelable: true,
            detail: O
          });
          this.telInput.dispatchEvent(_);
        }
        //* Open the dropdown.
        _openDropdown() {
          const { fixDropdownWidth: C, countrySearch: O } = this.options;
          if (C && (this.dropdownContent.style.width = `${this.telInput.offsetWidth}px`), this.dropdownContent.classList.remove("iti__hide"), this.selectedCountry.setAttribute("aria-expanded", "true"), this._setDropdownPosition(), O) {
            const _ = this.countryList.firstElementChild;
            _ && (this._highlightListItem(_, false), this.countryList.scrollTop = 0), this.searchInput.focus();
          }
          this._bindDropdownListeners(), this.dropdownArrow.classList.add("iti__arrow--up"), this._trigger("open:countrydropdown");
        }
        //* Set the dropdown position
        _setDropdownPosition() {
          if (this.options.dropdownContainer && this.options.dropdownContainer.appendChild(this.dropdown), !this.options.useFullscreenPopup) {
            const C = this.telInput.getBoundingClientRect(), O = this.telInput.offsetHeight;
            this.options.dropdownContainer && (this.dropdown.style.top = `${C.top + O}px`, this.dropdown.style.left = `${C.left}px`, this._handleWindowScroll = () => this._closeDropdown(), window.addEventListener("scroll", this._handleWindowScroll));
          }
        }
        //* We only bind dropdown listeners when the dropdown is open.
        _bindDropdownListeners() {
          this._handleMouseoverCountryList = (T) => {
            var Q;
            const H = (Q = T.target) == null ? void 0 : Q.closest(".iti__country");
            H && this._highlightListItem(H, false);
          }, this.countryList.addEventListener(
            "mouseover",
            this._handleMouseoverCountryList
          ), this._handleClickCountryList = (T) => {
            var Q;
            const H = (Q = T.target) == null ? void 0 : Q.closest(".iti__country");
            H && this._selectListItem(H);
          }, this.countryList.addEventListener("click", this._handleClickCountryList);
          let C = true;
          this._handleClickOffToClose = () => {
            C || this._closeDropdown(), C = false;
          }, document.documentElement.addEventListener(
            "click",
            this._handleClickOffToClose
          );
          let O = "", _ = null;
          if (this._handleKeydownOnDropdown = (T) => {
            ["ArrowUp", "ArrowDown", "Enter", "Escape"].includes(T.key) && (T.preventDefault(), T.stopPropagation(), T.key === "ArrowUp" || T.key === "ArrowDown" ? this._handleUpDownKey(T.key) : T.key === "Enter" ? this._handleEnterKey() : T.key === "Escape" && this._closeDropdown()), !this.options.countrySearch && /^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(T.key) && (T.stopPropagation(), _ && clearTimeout(_), O += T.key.toLowerCase(), this._searchForCountry(O), _ = setTimeout(() => {
              O = "";
            }, 1e3));
          }, document.addEventListener("keydown", this._handleKeydownOnDropdown), this.options.countrySearch) {
            const T = () => {
              const Q = this.searchInput.value.trim();
              Q ? this._filterCountries(Q) : this._filterCountries("", true);
            };
            let H = null;
            this._handleSearchChange = () => {
              H && clearTimeout(H), H = setTimeout(() => {
                T(), H = null;
              }, 100);
            }, this.searchInput.addEventListener("input", this._handleSearchChange), this.searchInput.addEventListener("click", (Q) => Q.stopPropagation());
          }
        }
        //* Hidden search (countrySearch disabled): Find the first list item whose name starts with the query string.
        _searchForCountry(C) {
          for (let O = 0; O < this.countries.length; O++) {
            const _ = this.countries[O];
            if (_.name.substr(0, C.length).toLowerCase() === C) {
              const H = _.nodeById[this.id];
              this._highlightListItem(H, false), this._scrollTo(H);
              break;
            }
          }
        }
        //* Country search enabled: Filter the countries according to the search query.
        _filterCountries(C, O = false) {
          let _ = true;
          this.countryList.innerHTML = "";
          const T = E(C);
          for (let H = 0; H < this.countries.length; H++) {
            const Q = this.countries[H], ae = E(Q.name), pe = Q.name.split(/[^a-zA-ZÀ-ÿа-яА-Я]/).map((Te) => Te[0]).join("").toLowerCase(), xe = `+${Q.dialCode}`;
            if (O || ae.includes(T) || xe.includes(T) || Q.iso2.includes(T) || pe.includes(T)) {
              const Te = Q.nodeById[this.id];
              Te && this.countryList.appendChild(Te), _ && (this._highlightListItem(Te, false), _ = false);
            }
          }
          _ && this._highlightListItem(null, false), this.countryList.scrollTop = 0, this._updateSearchResultsText();
        }
        //* Update search results text (for a11y).
        _updateSearchResultsText() {
          const { i18n: C } = this.options, O = this.countryList.childElementCount;
          let _;
          O === 0 ? _ = C.zeroSearchResults : O === 1 ? _ = C.oneSearchResult : _ = C.multipleSearchResults.replace("${count}", O.toString()), this.searchResultsA11yText.textContent = _;
        }
        //* Highlight the next/prev item in the list (and ensure it is visible).
        _handleUpDownKey(C) {
          var _, T;
          let O = C === "ArrowUp" ? (_ = this.highlightedItem) == null ? void 0 : _.previousElementSibling : (T = this.highlightedItem) == null ? void 0 : T.nextElementSibling;
          !O && this.countryList.childElementCount > 1 && (O = C === "ArrowUp" ? this.countryList.lastElementChild : this.countryList.firstElementChild), O && (this._scrollTo(O), this._highlightListItem(O, false));
        }
        //* Select the currently highlighted item.
        _handleEnterKey() {
          this.highlightedItem && this._selectListItem(this.highlightedItem);
        }
        //* Update the input's value to the given val (format first if possible)
        //* NOTE: this is called from _setInitialState, handleUtils and setNumber.
        _updateValFromNumber(C) {
          let O = C;
          if (this.options.formatOnDisplay && z.utils && this.selectedCountryData) {
            const _ = this.options.nationalMode || O.charAt(0) !== "+" && !this.options.separateDialCode, { NATIONAL: T, INTERNATIONAL: H } = z.utils.numberFormat, Q = _ ? T : H;
            O = z.utils.formatNumber(
              O,
              this.selectedCountryData.iso2,
              Q
            );
          }
          O = this._beforeSetNumber(O), this.telInput.value = O;
        }
        //* Check if need to select a new country based on the given number
        //* Note: called from _setInitialState, keyup handler, setNumber.
        _updateCountryFromNumber(C) {
          const O = this._getCountryFromNumber(C);
          return O !== null ? this._setCountry(O) : false;
        }
        _getCountryFromNumber(C) {
          const O = C.indexOf("+");
          let _ = O ? C.substring(O) : C;
          const T = this.selectedCountryData.dialCode;
          _ && T === "1" && _.charAt(0) !== "+" && (_.charAt(0) !== "1" && (_ = `1${_}`), _ = `+${_}`), this.options.separateDialCode && T && _.charAt(0) !== "+" && (_ = `+${T}${_}`);
          const Q = this._getDialCode(_, true), ae = w(_);
          if (Q) {
            const pe = this.dialCodeToIso2Map[w(Q)], xe = pe.indexOf(this.selectedCountryData.iso2) !== -1 && ae.length <= Q.length - 1;
            if (!(T === "1" && M(ae)) && !xe) {
              for (let L = 0; L < pe.length; L++)
                if (pe[L])
                  return pe[L];
            }
          } else {
            if (_.charAt(0) === "+" && ae.length)
              return "";
            if ((!_ || _ === "+") && !this.selectedCountryData.iso2)
              return this.defaultCountry;
          }
          return null;
        }
        //* Remove highlighting from other list items and highlight the given item.
        _highlightListItem(C, O) {
          const _ = this.highlightedItem;
          if (_ && (_.classList.remove("iti__highlight"), _.setAttribute("aria-selected", "false")), this.highlightedItem = C, this.highlightedItem) {
            this.highlightedItem.classList.add("iti__highlight"), this.highlightedItem.setAttribute("aria-selected", "true");
            const T = this.highlightedItem.getAttribute("id") || "";
            this.selectedCountry.setAttribute("aria-activedescendant", T), this.options.countrySearch && this.searchInput.setAttribute("aria-activedescendant", T);
          }
          O && this.highlightedItem.focus();
        }
        //* Find the country data for the given iso2 code
        //* the ignoreOnlyCountriesOption is only used during init() while parsing the onlyCountries array
        _getCountryData(C, O) {
          for (let _ = 0; _ < this.countries.length; _++)
            if (this.countries[_].iso2 === C)
              return this.countries[_];
          if (O)
            return null;
          throw new Error(`No country data for '${C}'`);
        }
        //* Update the selected country, dial code (if separateDialCode), placeholder, title, and active list item.
        //* Note: called from _setInitialState, _updateCountryFromNumber, _selectListItem, setCountry.
        _setCountry(C) {
          const { separateDialCode: O, showFlags: _, i18n: T } = this.options, H = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
          if (this.selectedCountryData = C ? this._getCountryData(C, false) || {} : {}, this.selectedCountryData.iso2 && (this.defaultCountry = this.selectedCountryData.iso2), this.selectedCountryInner) {
            let Q = "", ae = "";
            C && _ ? (Q = `iti__flag iti__${C}`, ae = `${this.selectedCountryData.name} +${this.selectedCountryData.dialCode}`) : (Q = "iti__flag iti__globe", ae = T.noCountrySelected), this.selectedCountryInner.className = Q, this.selectedCountryA11yText.textContent = ae;
          }
          if (this._setSelectedCountryTitleAttribute(C, O), O) {
            const Q = this.selectedCountryData.dialCode ? `+${this.selectedCountryData.dialCode}` : "";
            this.selectedDialCode.innerHTML = Q, this._updateInputPadding();
          }
          return this._updatePlaceholder(), this._updateMaxLength(), H.iso2 !== C;
        }
        //* Update the input padding to make space for the selected country/dial code.
        _updateInputPadding() {
          if (this.selectedCountry) {
            const O = (this.selectedCountry.offsetWidth || this._getHiddenSelectedCountryWidth()) + 6;
            this.showSelectedCountryOnLeft ? this.telInput.style.paddingLeft = `${O}px` : this.telInput.style.paddingRight = `${O}px`;
          }
        }
        //* Update the maximum valid number length for the currently selected country.
        _updateMaxLength() {
          const { strictMode: C, placeholderNumberType: O, validationNumberType: _ } = this.options, { iso2: T } = this.selectedCountryData;
          if (C && z.utils)
            if (T) {
              const H = z.utils.numberType[O];
              let Q = z.utils.getExampleNumber(
                T,
                false,
                H,
                true
              ), ae = Q;
              for (; z.utils.isPossibleNumber(Q, T, _); )
                ae = Q, Q += "0";
              const pe = z.utils.getCoreNumber(ae, T);
              this.maxCoreNumberLength = pe.length, T === "by" && (this.maxCoreNumberLength = pe.length + 1);
            } else
              this.maxCoreNumberLength = null;
        }
        _setSelectedCountryTitleAttribute(C = null, O) {
          if (!this.selectedCountry)
            return;
          let _;
          C && !O ? _ = `${this.selectedCountryData.name}: +${this.selectedCountryData.dialCode}` : C ? _ = this.selectedCountryData.name : _ = "Unknown", this.selectedCountry.setAttribute("title", _);
        }
        //* When the input is in a hidden container during initialisation, we must inject some markup
        //* into the end of the DOM to calculate the correct offsetWidth.
        //* NOTE: this is only used when separateDialCode is enabled, so countryContainer and selectedCountry
        //* will definitely exist.
        _getHiddenSelectedCountryWidth() {
          if (this.telInput.parentNode) {
            const C = this.telInput.parentNode.cloneNode(false);
            C.style.visibility = "hidden", document.body.appendChild(C);
            const O = this.countryContainer.cloneNode();
            C.appendChild(O);
            const _ = this.selectedCountry.cloneNode(true);
            O.appendChild(_);
            const T = _.offsetWidth;
            return document.body.removeChild(C), T;
          }
          return 0;
        }
        //* Update the input placeholder to an example number from the currently selected country.
        _updatePlaceholder() {
          const {
            autoPlaceholder: C,
            placeholderNumberType: O,
            nationalMode: _,
            customPlaceholder: T
          } = this.options, H = C === "aggressive" || !this.hadInitialPlaceholder && C === "polite";
          if (z.utils && H) {
            const Q = z.utils.numberType[O];
            let ae = this.selectedCountryData.iso2 ? z.utils.getExampleNumber(
              this.selectedCountryData.iso2,
              _,
              Q
            ) : "";
            ae = this._beforeSetNumber(ae), typeof T == "function" && (ae = T(ae, this.selectedCountryData)), this.telInput.setAttribute("placeholder", ae);
          }
        }
        //* Called when the user selects a list item from the dropdown.
        _selectListItem(C) {
          const O = this._setCountry(
            C.getAttribute("data-country-code")
          );
          this._closeDropdown(), this._updateDialCode(C.getAttribute("data-dial-code")), this.telInput.focus(), O && this._triggerCountryChange();
        }
        //* Close the dropdown and unbind any listeners.
        _closeDropdown() {
          this.dropdownContent.classList.add("iti__hide"), this.selectedCountry.setAttribute("aria-expanded", "false"), this.selectedCountry.removeAttribute("aria-activedescendant"), this.highlightedItem && this.highlightedItem.setAttribute("aria-selected", "false"), this.options.countrySearch && this.searchInput.removeAttribute("aria-activedescendant"), this.dropdownArrow.classList.remove("iti__arrow--up"), document.removeEventListener("keydown", this._handleKeydownOnDropdown), this.options.countrySearch && this.searchInput.removeEventListener("input", this._handleSearchChange), document.documentElement.removeEventListener(
            "click",
            this._handleClickOffToClose
          ), this.countryList.removeEventListener(
            "mouseover",
            this._handleMouseoverCountryList
          ), this.countryList.removeEventListener("click", this._handleClickCountryList), this.options.dropdownContainer && (this.options.useFullscreenPopup || window.removeEventListener("scroll", this._handleWindowScroll), this.dropdown.parentNode && this.dropdown.parentNode.removeChild(this.dropdown)), this._handlePageLoad && window.removeEventListener("load", this._handlePageLoad), this._trigger("close:countrydropdown");
        }
        //* Check if an element is visible within it's container, else scroll until it is.
        _scrollTo(C) {
          const O = this.countryList, _ = document.documentElement.scrollTop, T = O.offsetHeight, H = O.getBoundingClientRect().top + _, Q = H + T, ae = C.offsetHeight, pe = C.getBoundingClientRect().top + _, xe = pe + ae, Te = pe - H + O.scrollTop;
          if (pe < H)
            O.scrollTop = Te;
          else if (xe > Q) {
            const L = T - ae;
            O.scrollTop = Te - L;
          }
        }
        //* Replace any existing dial code with the new one
        //* Note: called from _selectListItem and setCountry
        _updateDialCode(C) {
          const O = this.telInput.value, _ = `+${C}`;
          let T;
          if (O.charAt(0) === "+") {
            const H = this._getDialCode(O);
            H ? T = O.replace(H, _) : T = _, this.telInput.value = T;
          }
        }
        //* Try and extract a valid international dial code from a full telephone number.
        //* Note: returns the raw string inc plus character and any whitespace/dots etc.
        _getDialCode(C, O) {
          let _ = "";
          if (C.charAt(0) === "+") {
            let T = "";
            for (let H = 0; H < C.length; H++) {
              const Q = C.charAt(H);
              if (!isNaN(parseInt(Q, 10))) {
                if (T += Q, O)
                  this.dialCodeToIso2Map[T] && (_ = C.substr(0, H + 1));
                else if (this.dialCodes[T]) {
                  _ = C.substr(0, H + 1);
                  break;
                }
                if (T.length === this.dialCodeMaxLen)
                  break;
              }
            }
          }
          return _;
        }
        //* Get the input val, adding the dial code if separateDialCode is enabled.
        _getFullNumber(C) {
          const O = C || this.telInput.value.trim(), { dialCode: _ } = this.selectedCountryData;
          let T;
          const H = w(O);
          return this.options.separateDialCode && O.charAt(0) !== "+" && _ && H ? T = `+${_}` : T = "", T + O;
        }
        //* Remove the dial code if separateDialCode is enabled also cap the length if the input has a maxlength attribute
        _beforeSetNumber(C) {
          let O = C;
          if (this.options.separateDialCode) {
            let _ = this._getDialCode(O);
            if (_) {
              _ = `+${this.selectedCountryData.dialCode}`;
              const T = O[_.length] === " " || O[_.length] === "-" ? _.length + 1 : _.length;
              O = O.substr(T);
            }
          }
          return this._cap(O);
        }
        //* Trigger the 'countrychange' event.
        _triggerCountryChange() {
          this._trigger("countrychange");
        }
        //* Format the number as the user types.
        _formatNumberAsYouType() {
          const C = this._getFullNumber(), O = z.utils ? z.utils.formatNumberAsYouType(C, this.selectedCountryData.iso2) : C, { dialCode: _ } = this.selectedCountryData;
          return this.options.separateDialCode && this.telInput.value.charAt(0) !== "+" && O.includes(`+${_}`) ? (O.split(`+${_}`)[1] || "").trim() : O;
        }
        //**************************
        //*  SECRET PUBLIC METHODS
        //**************************
        //* This is called when the geoip call returns.
        handleAutoCountry() {
          this.options.initialCountry === "auto" && z.autoCountry && (this.defaultCountry = z.autoCountry, this.selectedCountryData.iso2 || this.selectedCountryInner.classList.contains("iti__globe") || this.setCountry(this.defaultCountry), this.resolveAutoCountryPromise());
        }
        //* This is called when the utils request completes.
        handleUtils() {
          z.utils && (this.telInput.value && this._updateValFromNumber(this.telInput.value), this.selectedCountryData.iso2 && (this._updatePlaceholder(), this._updateMaxLength())), this.resolveUtilsScriptPromise();
        }
        //********************
        //*  PUBLIC METHODS
        //********************
        //* Remove plugin.
        destroy() {
          var H, Q;
          const { allowDropdown: C, separateDialCode: O } = this.options;
          if (C) {
            this._closeDropdown(), this.selectedCountry.removeEventListener(
              "click",
              this._handleClickSelectedCountry
            ), this.countryContainer.removeEventListener(
              "keydown",
              this._handleCountryContainerKeydown
            );
            const ae = this.telInput.closest("label");
            ae && ae.removeEventListener("click", this._handleLabelClick);
          }
          const { form: _ } = this.telInput;
          this._handleHiddenInputSubmit && _ && _.removeEventListener("submit", this._handleHiddenInputSubmit), this.telInput.removeEventListener("input", this._handleInputEvent), this._handleKeydownEvent && this.telInput.removeEventListener("keydown", this._handleKeydownEvent), this.telInput.removeAttribute("data-intl-tel-input-id"), O && (this.isRTL ? this.telInput.style.paddingRight = this.originalPaddingRight : this.telInput.style.paddingLeft = this.originalPaddingLeft);
          const T = this.telInput.parentNode;
          (H = T == null ? void 0 : T.parentNode) == null || H.insertBefore(this.telInput, T), (Q = T == null ? void 0 : T.parentNode) == null || Q.removeChild(T), delete z.instances[this.id];
        }
        //* Get the extension from the current number.
        getExtension() {
          return z.utils ? z.utils.getExtension(
            this._getFullNumber(),
            this.selectedCountryData.iso2
          ) : "";
        }
        //* Format the number to the given format.
        getNumber(C) {
          if (z.utils) {
            const { iso2: O } = this.selectedCountryData;
            return z.utils.formatNumber(
              this._getFullNumber(),
              O,
              C
            );
          }
          return "";
        }
        //* Get the type of the entered number e.g. landline/mobile.
        getNumberType() {
          return z.utils ? z.utils.getNumberType(
            this._getFullNumber(),
            this.selectedCountryData.iso2
          ) : -99;
        }
        //* Get the country data for the currently selected country.
        getSelectedCountryData() {
          return this.selectedCountryData;
        }
        //* Get the validation error.
        getValidationError() {
          if (z.utils) {
            const { iso2: C } = this.selectedCountryData;
            return z.utils.getValidationError(this._getFullNumber(), C);
          }
          return -99;
        }
        //* Validate the input val
        isValidNumber() {
          if (!this.selectedCountryData.iso2)
            return false;
          const C = this._getFullNumber(), O = C.search(new RegExp("\\p{L}", "u"));
          if (O > -1) {
            const _ = C.substring(0, O), T = this._utilsIsPossibleNumber(_), H = this._utilsIsPossibleNumber(C);
            return T && H;
          }
          return this._utilsIsPossibleNumber(C);
        }
        _utilsIsPossibleNumber(C) {
          return z.utils ? z.utils.isPossibleNumber(C, this.selectedCountryData.iso2, this.options.validationNumberType) : null;
        }
        //* Validate the input val (precise)
        isValidNumberPrecise() {
          if (!this.selectedCountryData.iso2)
            return false;
          const C = this._getFullNumber(), O = C.search(new RegExp("\\p{L}", "u"));
          if (O > -1) {
            const _ = C.substring(0, O), T = this._utilsIsValidNumber(_), H = this._utilsIsValidNumber(C);
            return T && H;
          }
          return this._utilsIsValidNumber(C);
        }
        _utilsIsValidNumber(C) {
          return z.utils ? z.utils.isValidNumber(C, this.selectedCountryData.iso2) : null;
        }
        //* Update the selected country, and update the input val accordingly.
        setCountry(C) {
          const O = C == null ? void 0 : C.toLowerCase(), _ = this.selectedCountryData.iso2;
          (C && O !== _ || !C && _) && (this._setCountry(O), this._updateDialCode(this.selectedCountryData.dialCode), this._triggerCountryChange());
        }
        //* Set the input value and update the country.
        setNumber(C) {
          const O = this._updateCountryFromNumber(C);
          this._updateValFromNumber(C), O && this._triggerCountryChange(), this._trigger("input", { isSetNumber: true });
        }
        //* Set the placeholder number typ
        setPlaceholderNumberType(C) {
          this.options.placeholderNumberType = C, this._updatePlaceholder();
        }
        setDisabled(C) {
          this.telInput.disabled = C, C ? this.selectedCountry.setAttribute("disabled", "true") : this.selectedCountry.removeAttribute("disabled");
        }
      }, re = (C) => {
        if (!z.utils && !z.startedLoadingUtilsScript) {
          let O;
          if (typeof C == "string")
            O = import(
              /* webpackIgnore: true */
              /* @vite-ignore */
              C
            );
          else if (typeof C == "function")
            try {
              O = Promise.resolve(C());
            } catch (_) {
              return Promise.reject(_);
            }
          else
            return Promise.reject(new TypeError(`The argument passed to loadUtils must be a URL string or a function that returns a promise for the utilities module, not ${typeof C}`));
          return z.startedLoadingUtilsScript = true, O.then((_) => {
            const T = _ == null ? void 0 : _.default;
            if (!T || typeof T != "object")
              throw typeof C == "string" ? new TypeError(`The module loaded from ${C} did not set utils as its default export.`) : new TypeError("The loader function passed to loadUtils did not resolve to a module object with utils as its default export.");
            return z.utils = T, Y("handleUtils"), true;
          }).catch((_) => {
            throw Y("rejectUtilsScriptPromise", _), _;
          });
        }
        return null;
      }, z = Object.assign(
        (C, O) => {
          const _ = new F(C, O);
          return _._init(), C.setAttribute("data-intl-tel-input-id", _.id.toString()), z.instances[_.id] = _, _;
        },
        {
          defaults: v,
          //* Using a static var like this allows us to mock it in the tests.
          documentReady: () => document.readyState === "complete",
          //* Get the country data object.
          getCountryData: () => f,
          //* A getter for the plugin instance.
          getInstance: (C) => {
            const O = C.getAttribute("data-intl-tel-input-id");
            return O ? z.instances[O] : null;
          },
          //* A map from instance ID to instance object.
          instances: {},
          loadUtils: re,
          startedLoadingUtilsScript: false,
          startedLoadingAutoCountry: false,
          version: "24.8.2"
        }
      ), W = z;
      return l(c);
    })();
    return e.default;
  });
})(Yk);
var Hj = Yk.exports;
var Wj = jj(Hj);
var Uj = ["id", "title"];
var qj = ["value", "id", "name", "autocomplete", "disabled", "aria-describedby", "aria-required"];
var Kj = Object.assign({ name: "mn-phone" }, {
  __name: "phone",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: String,
      default: null
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    country: String,
    countries: Array,
    favorites: Array,
    excluded: Array,
    hint: String,
    tooltip: String,
    placeholder: String,
    autocomplete: String,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = e, s = t10, r = useId(), o = toRef(s, "name"), a = toRef(s, "rules"), l = ref(null), c = ref(null), { value: u, errors: d, handleChange: f, meta: h10 } = Sn(o, a, {
      initialValue: s.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    });
    function p(g) {
      g.type === "input" && i("input", g, g.target.value), g.type === "change" && (l.value.setNumber(l.value.getNumber()), i("change", g, g.target.value), f(g.target.value));
    }
    return onMounted(async () => {
      const { locales: g } = await import("./phone-CS-9OtUI-DHPVLBOQ.js");
      l.value = Wj(c.value, {
        strictMode: true,
        nationalMode: false,
        containerClass: "mn-phone-shell",
        i18n: n.value.locale ? g[n.value.locale] : null,
        initialCountry: s.country || "",
        onlyCountries: s.countries || [],
        countryOrder: s.favorites || null,
        excludeCountries: s.excluded || [],
        customPlaceholder: s.placeholder ? () => s.placeholder : null,
        loadUtilsOnInit: () => import("./utils-BlXizdvs-MRSSXK5P.js")
      });
    }), (g, m) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-phone", { "-hidden": t10.hidden, "-disabled": t10.disabled }]),
      id: t10.name,
      title: t10.labelless ? t10.label : null
    }, [
      createVNode(Ft, {
        class: normalizeClass(["mn-phone-label", { invisible: t10.labelless }]),
        label: t10.label,
        tooltip: t10.tooltip,
        for: unref(r)
      }, null, 8, ["class", "label", "tooltip", "for"]),
      createBaseVNode("input", {
        ref_key: "inputRef",
        ref: c,
        class: "mn-phone-field",
        type: "tel",
        value: unref(u),
        id: unref(r),
        name: t10.name,
        autocomplete: t10.autocomplete,
        disabled: t10.disabled,
        "aria-describedby": `${unref(r)}-error ${unref(r)}-hint`,
        "aria-required": t10.rules.includes("required") || null,
        onInput: p,
        onChange: p
      }, null, 40, qj),
      unref(d).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(d), (b) => (openBlock(), createBlock($n, {
        key: b,
        id: `${unref(r)}-error`,
        message: b
      }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
      t10.hint ? (openBlock(), createBlock(ln, {
        key: 1,
        id: `${unref(r)}-hint`,
        class: "mn-phone-hint",
        label: t10.hint
      }, null, 8, ["id", "label"])) : createCommentVNode("", true)
    ], 10, Uj));
  }
});
var OZ = Me(Kj, [["__scopeId", "data-v-95643e3e"]]);
var Yj = ["id", "aria-describedby", "title", "name"];
var Gj = {
  class: "mn-quantity-value",
  "aria-live": "polite",
  "aria-atomic": "true"
};
var Jj = Object.assign({ name: "mn-quantity" }, {
  __name: "quantity",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: Number,
      default: 0
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    hint: String,
    tooltip: String,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = e, s = t10, r = useId(), o = ref(null), a = toRef(s, "name"), l = toRef(s, "rules"), { value: c, errors: u, handleChange: d, meta: f } = Sn(a, l, {
      initialValue: s.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    }), h10 = ref(c.value);
    function p(m, b) {
      b === "decrement" ? h10.value > 0 && (h10.value -= 1) : o.value && h10.value < o.value ? h10.value += 1 : o.value || (h10.value += 1), i("update:modelValue", h10.value), i("input", m, h10.value), i("change", m, h10.value), d(h10.value);
    }
    function g(m, b) {
      p(m, b);
      let x = setTimeout(() => {
        let k = setInterval(() => p(m, b), 75);
        m.target.addEventListener("mouseup", () => clearInterval(k));
      }, 500);
      m.target.addEventListener("mouseup", () => clearTimeout(x));
    }
    return watch(
      () => s.rules,
      (m) => {
        m.includes("max") ? o.value = Number(m.split("max:")[1].split("|")[0]) : o.value = null;
      },
      { immediate: true }
    ), watch(
      () => c.value,
      (m) => {
        h10.value = m || 0;
      },
      { immediate: true }
    ), (m, b) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-quantity", { "-hidden": t10.hidden, "-disabled": t10.disabled }]),
      role: "group",
      id: unref(r),
      "aria-describedby": `${unref(r)}-error ${unref(r)}-hint`,
      title: t10.labelless ? t10.label : null,
      name: t10.name
    }, [
      createVNode(Ft, {
        class: normalizeClass(["mn-quantity-label", { invisible: t10.labelless }]),
        label: t10.label,
        tooltip: t10.tooltip,
        for: unref(r)
      }, null, 8, ["class", "label", "tooltip", "for"]),
      createBaseVNode("div", {
        class: normalizeClass(["mn-quantity-shell", { "-invalid": unref(u).length }])
      }, [
        createVNode(me, {
          class: "mn-quantity-button",
          variant: "muted",
          color: "neutral",
          label: unref(n).t("removeOne"),
          icon: "minus",
          labelless: "",
          disabled: t10.disabled || !h10.value,
          onMousedown: b[0] || (b[0] = (x) => g(x, "decrement"))
        }, null, 8, ["label", "disabled"]),
        createBaseVNode("span", Gj, toDisplayString(unref(c)), 1),
        createVNode(me, {
          class: "mn-quantity-button",
          variant: "muted",
          color: "neutral",
          label: unref(n).t("addOne"),
          icon: "plus",
          labelless: "",
          disabled: t10.disabled || o.value && h10.value >= o.value,
          onMousedown: b[1] || (b[1] = (x) => g(x, "increment"))
        }, null, 8, ["label", "disabled"])
      ], 2),
      unref(u).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(u), (x) => (openBlock(), createBlock($n, {
        key: x,
        id: `${unref(r)}-error`,
        message: x
      }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
      t10.hint ? (openBlock(), createBlock(ln, {
        key: 1,
        class: "mn-quantity-hint",
        id: `${unref(r)}-hint`,
        label: t10.hint
      }, null, 8, ["id", "label"])) : createCommentVNode("", true)
    ], 10, Yj));
  }
});
var Xj = Me(Jj, [["__scopeId", "data-v-fbe47650"]]);
var Qj = { class: "mn-picker-shell-main" };
var Zj = ["id", "name"];
var eH = {
  key: 0,
  class: "mn-picker-no-result",
  "aria-hidden": "true"
};
var tH = {
  key: 0,
  class: "mn-picker-preview-empty"
};
var nH = {
  key: 0,
  class: "mn-picker-preview-list-item"
};
var iH = Object.assign({ name: "mn-picker" }, {
  __name: "picker",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: Array,
      default: []
    },
    options: {
      type: [Array, Object],
      default: () => []
    },
    entry: {
      type: String,
      default: "children"
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    compareKey: {
      type: String,
      default: "_id"
    },
    variant: {
      type: String,
      validator: (t10) => ["list", "tags", "quantity"].includes(String(t10))
    },
    hint: String,
    tooltip: String,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean,
    formatIn: {
      type: Function,
      default: (t10) => t10
    },
    formatOut: {
      type: Function,
      default: (t10) => t10
    }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = e, s = t10, r = useId(), o = ref([]), a = ref(null), l = ref(""), c = toRef(s, "name"), u = toRef(s, "rules"), d = computed(() => Io(s.options, s.entry)), f = computed(() => l.value ? d.value.filter((E) => s.formatIn(E).toLowerCase().includes(l.value.toLowerCase())).sort((E, M) => {
      const N = s.formatIn(E).toLowerCase().startsWith(l.value.toLowerCase()), V = s.formatIn(M).toLowerCase().startsWith(l.value.toLowerCase());
      return N && !V ? -1 : !N && V ? 1 : 0;
    }) : d.value), { value: h10, errors: p, handleChange: g, meta: m } = Sn(c, u, {
      initialValue: s.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    }), { list: b, containerProps: x, wrapperProps: k } = Fk(f, { itemHeight: 40 });
    function v(w) {
      w.quantity < 1 && S(w, "remove");
    }
    function S(w, E) {
      let M = [];
      const N = E === "remove" ? s.variant === "quantity" ? w.item : w : w.data, V = E === "remove" ? d.value.findIndex((Y) => typeof N == "object" ? (N == null ? void 0 : N[s.compareKey]) === Y[s.compareKey] : N === s.formatOut(Y)) : w.index;
      o.value.includes(V) ? (s.variant === "quantity" ? M = h10.value.filter(
        (Y) => {
          var F;
          return typeof Y.item == "object" ? ((F = Y.item) == null ? void 0 : F[s.compareKey]) !== (N == null ? void 0 : N[s.compareKey]) : Y.item !== formatOut(N);
        }
      ) : M = h10.value.filter(
        (Y) => typeof Y == "object" ? (Y == null ? void 0 : Y[s.compareKey]) !== (N == null ? void 0 : N[s.compareKey]) : Y !== s.formatOut(N)
      ), o.value = o.value.filter((Y) => Y !== V)) : (s.variant === "quantity" ? M = [...h10.value, { item: s.formatOut(N), quantity: 1 }] : M = [...h10.value, s.formatOut(N)], o.value = [...o.value, V]), i("update:modelValue", M), i("input", M), i("change", M), g(M), h10.value = M;
    }
    return watch(
      () => h10.value,
      (w) => {
        w.length ? (o.value = [], w.forEach((E) => {
          const M = d.value.findIndex((N) => {
            var V;
            return s.variant === "quantity" ? typeof E.item == "object" ? ((V = E.item) == null ? void 0 : V[s.compareKey]) === N[s.compareKey] : E.item === s.formatOut(N) : typeof E == "object" ? (E == null ? void 0 : E[s.compareKey]) === N[s.compareKey] : E === s.formatOut(N);
          });
          M >= 0 && o.value.push(M);
        })) : o.value = [];
      },
      { immediate: true }
    ), (w, E) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-picker", { "-hidden": t10.hidden, "-disabled": t10.disabled }]),
      role: "group"
    }, [
      createVNode(Ft, {
        class: normalizeClass(["mn-picker-label", { invisible: t10.labelless }]),
        label: t10.label,
        tooltip: t10.tooltip,
        for: `${unref(r)}-list`
      }, null, 8, ["class", "label", "tooltip", "for"]),
      createBaseVNode("div", {
        class: normalizeClass(["mn-picker-shell", { "-invalid": unref(p).length, "-preview": t10.variant }])
      }, [
        createBaseVNode("div", Qj, [
          createVNode(_r, null, {
            default: withCtx(() => [
              createVNode(Nr, {
                ref_key: "searchRef",
                ref: a,
                name: "mn-search",
                autocomplete: "off",
                role: "combobox",
                "aria-expanded": "true",
                "aria-controls": `${unref(r)}-list`,
                "aria-autocomplete": "list",
                label: unref(n).t("search"),
                placeholder: unref(Ie)(unref(n).t("search")),
                disabled: t10.disabled,
                labelless: "",
                modelValue: l.value,
                "onUpdate:modelValue": E[0] || (E[0] = (M) => l.value = M)
              }, null, 8, ["aria-controls", "label", "placeholder", "disabled", "modelValue"])
            ]),
            _: 1
          }),
          createBaseVNode("div", {
            class: "mn-picker-list",
            id: `${unref(r)}-list`,
            name: t10.name
          }, [
            unref(b).length ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", eH, toDisplayString(unref(Ie)(unref(n).t("noresult"))), 1)),
            createBaseVNode("div", normalizeProps(guardReactiveProps(unref(x))), [
              createBaseVNode("ul", normalizeProps(guardReactiveProps(unref(k))), [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(b), (M) => (openBlock(), createElementBlock("li", {
                  key: M.index,
                  class: normalizeClass({ "-selected": o.value.includes(M.index) }),
                  style: { height: "40px" }
                }, [
                  createVNode(me, {
                    label: t10.formatIn(M.data),
                    variant: "text",
                    color: "neutral",
                    wide: "",
                    icon: "check",
                    "aria-pressed": o.value.includes(M.index),
                    disabled: t10.disabled,
                    onClick: (N) => S(M)
                  }, null, 8, ["label", "aria-pressed", "disabled", "onClick"])
                ], 2))), 128))
              ], 16)
            ], 16)
          ], 8, Zj)
        ]),
        t10.variant ? (openBlock(), createElementBlock("ul", {
          key: 0,
          class: normalizeClass(["mn-picker-preview", [t10.variant]])
        }, [
          unref(h10).length ? createCommentVNode("", true) : (openBlock(), createElementBlock("li", tH, [
            createVNode(ui, {
              muted: "",
              align: "center"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(Ie)(unref(n).t("empty"))), 1)
              ]),
              _: 1
            })
          ])),
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(h10), (M) => (openBlock(), createElementBlock("li", {
            key: `${unref(r)}-${JSON.stringify(M)}`
          }, [
            t10.variant === "list" || t10.variant === "quantity" ? (openBlock(), createElementBlock("div", nH, [
              renderSlot(w.$slots, "item", { item: M }, () => [
                createVNode(ui, null, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(Ie)(t10.formatIn(t10.variant === "quantity" ? M.item : M))), 1)
                  ]),
                  _: 2
                }, 1024)
              ], true),
              t10.variant === "quantity" ? (openBlock(), createBlock(_r, { key: 0 }, {
                default: withCtx(() => [
                  createVNode(Xj, {
                    label: "quantity",
                    disabled: t10.disabled,
                    name: "mn-quantity",
                    labelless: "",
                    modelValue: M.quantity,
                    "onUpdate:modelValue": (N) => M.quantity = N,
                    onChange: (N) => v(M)
                  }, null, 8, ["disabled", "modelValue", "onUpdate:modelValue", "onChange"])
                ]),
                _: 2
              }, 1024)) : createCommentVNode("", true),
              createVNode(me, {
                label: "remove",
                variant: "text",
                color: "neutral",
                icon: "xmark",
                labelless: "",
                disabled: t10.disabled,
                onClick: (N) => S(M, "remove")
              }, null, 8, ["disabled", "onClick"])
            ])) : createCommentVNode("", true),
            t10.variant === "tags" ? (openBlock(), createBlock(HP, {
              key: 1,
              label: unref(Ie)(t10.formatIn(M)),
              removable: !t10.disabled,
              onRemove: (N) => S(M, "remove")
            }, null, 8, ["label", "removable", "onRemove"])) : createCommentVNode("", true)
          ]))), 128))
        ], 2)) : createCommentVNode("", true)
      ], 2),
      unref(p).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(p), (M) => (openBlock(), createBlock($n, {
        key: M,
        id: `${unref(r)}-error`,
        message: M
      }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
      t10.hint ? (openBlock(), createBlock(ln, {
        key: 1,
        id: `${unref(r)}-hint`,
        class: "mn-picker-hint",
        label: t10.hint
      }, null, 8, ["id", "label"])) : createCommentVNode("", true)
    ], 2));
  }
});
var EZ = Me(iH, [["__scopeId", "data-v-50d95715"]]);
var sH = ["id", "aria-describedby", "aria-required", "title"];
var rH = { class: "mn-radio-group-option-button" };
var oH = ["name", "id", "checked", "value", "disabled", "onInput", "onChange"];
var aH = Object.assign({ name: "mn-radio-group" }, {
  __name: "radio-group",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: [String, Number, Array, Object],
      default: null
    },
    options: {
      type: [Array, Object],
      default: () => []
    },
    entry: {
      type: String,
      default: "children"
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    compareKey: {
      type: String,
      default: "_id"
    },
    hint: String,
    tooltip: String,
    hintKey: String,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean,
    formatIn: {
      type: Function,
      default: (t10) => t10
    },
    formatOut: {
      type: Function,
      default: (t10) => t10
    }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = e, i = t10, s = useId(), r = computed(() => Io(i.options, i.entry)), o = toRef(i, "name"), a = toRef(i, "rules"), { value: l, errors: c, handleChange: u, meta: d } = Sn(o, a, {
      initialValue: i.formatOut(i.modelValue),
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    });
    function f(p) {
      var g;
      return l.value ? typeof l.value == "object" ? (p == null ? void 0 : p[i.compareKey]) === ((g = l.value) == null ? void 0 : g[i.compareKey]) : i.formatOut(p) === l.value : false;
    }
    function h10(p, g) {
      n("update:modelValue", i.formatOut(g)), p.type === "input" && n("input", p, i.formatOut(g)), p.type === "change" && n("change", p, i.formatOut(g)), u(i.formatOut(g));
    }
    return (p, g) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-radio-group", { "-hidden": t10.hidden }]),
      role: "radiogroup",
      id: unref(s),
      "aria-describedby": `${unref(s)}-error ${unref(s)}-hint`,
      "aria-required": t10.rules.includes("required") || null,
      title: t10.labelless ? t10.label : null
    }, [
      createVNode(Ft, {
        class: normalizeClass(["mn-radio-group-label", { invisible: t10.labelless }]),
        label: t10.label,
        tooltip: t10.tooltip,
        for: unref(s)
      }, null, 8, ["class", "label", "tooltip", "for"]),
      createBaseVNode("div", {
        class: normalizeClass(["mn-radio-group-list", { "-invalid": unref(c).length }])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(r.value, (m, b) => (openBlock(), createElementBlock("div", {
          class: normalizeClass(["mn-radio-group-option", { "-disabled": t10.disabled }]),
          key: `${unref(s)}-${JSON.stringify(m)}`
        }, [
          createBaseVNode("div", rH, [
            createBaseVNode("input", {
              class: "mn-radio-group-option-input",
              type: "radio",
              name: t10.name || unref(s),
              id: `${unref(s)}-${b}`,
              checked: f(m),
              value: m,
              disabled: t10.disabled,
              onInput: (x) => h10(x, m),
              onChange: (x) => h10(x, m)
            }, null, 40, oH),
            createVNode(ft, {
              class: "mn-radio-group-option-checked",
              icon: "circle-dot"
            })
          ]),
          createVNode(Ft, {
            class: "mn-radio-group-option-label",
            label: unref(Ie)(t10.formatIn(m)),
            for: `${unref(s)}-${b}`
          }, null, 8, ["label", "for"]),
          m != null && m[t10.hintKey] ? (openBlock(), createBlock(ln, {
            key: 0,
            id: `${unref(s)}-${b}-hint`,
            class: "mn-radio-group-option-hint",
            label: m[t10.hintKey]
          }, null, 8, ["id", "label"])) : createCommentVNode("", true)
        ], 2))), 128))
      ], 2),
      unref(c).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(c), (m) => (openBlock(), createBlock($n, {
        key: m,
        id: `${unref(s)}-error`,
        message: m
      }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
      t10.hint ? (openBlock(), createBlock(ln, {
        key: 1,
        id: `${unref(s)}-hint`,
        class: "mn-radio-group-hint",
        label: t10.hint
      }, null, 8, ["id", "label"])) : createCommentVNode("", true)
    ], 10, sH));
  }
});
var MZ = Me(aH, [["__scopeId", "data-v-fa6231cf"]]);
var lH = ["id", "aria-describedby", "title", "name"];
var cH = {
  class: "invisible",
  "aria-live": "polite",
  "aria-atomic": "true"
};
var uH = Object.assign({ name: "mn-rating" }, {
  __name: "rating",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: Number,
      default: 0
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    hint: String,
    tooltip: String,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = e, s = t10, r = useId(), o = toRef(s, "name"), a = toRef(s, "rules"), { value: l, errors: c, handleChange: u, meta: d } = Sn(o, a, {
      initialValue: s.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    }), f = ref(l.value);
    function h10(m) {
      !s.disabled && (f.value = m);
    }
    function p() {
      !s.disabled && (f.value = l.value);
    }
    function g(m, b) {
      i("update:modelValue", b), m.type === "input" && i("input", m, b), m.type === "change" && i("change", m, b), u(b);
    }
    return watch(
      () => l.value,
      (m) => {
        !m && (f.value = 0);
      },
      { immediate: true }
    ), (m, b) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-rating", { "-hidden": t10.hidden, "-disabled": t10.disabled }]),
      role: "group",
      id: unref(r),
      "aria-describedby": `${unref(r)}-error ${unref(r)}-hint`,
      title: t10.labelless ? t10.label : null,
      name: t10.name
    }, [
      createVNode(Ft, {
        class: normalizeClass(["mn-rating-label", { invisible: t10.labelless }]),
        label: t10.label,
        tooltip: t10.tooltip,
        for: unref(r)
      }, null, 8, ["class", "label", "tooltip", "for"]),
      createBaseVNode("div", {
        class: normalizeClass(["mn-rating-shell", { "-invalid": unref(c).length }]),
        onMouseleave: p,
        onFocusout: p
      }, [
        createBaseVNode("span", cH, toDisplayString(f.value) + " on 5", 1),
        (openBlock(), createElementBlock(Fragment, null, renderList(5, (x) => createVNode(me, {
          class: normalizeClass(["mn-rating-button", { "-active": x <= f.value }]),
          "aria-pressed": x === f.value,
          label: `${x} ${unref(n).t("outOf")} 5`,
          disabled: t10.disabled,
          key: `${unref(r)}-${x}`,
          variant: "text",
          icon: "star",
          labelless: "",
          onFocusin: (k) => h10(x),
          onClick: (k) => g(k, x)
        }, null, 8, ["class", "aria-pressed", "label", "disabled", "onFocusin", "onClick"])), 64)),
        createVNode(me, {
          class: "mn-rating-reset",
          label: `0 ${unref(n).t("outOf")} 5`,
          disabled: t10.disabled,
          variant: "text",
          color: "neutral",
          icon: "xmark",
          labelless: "",
          onClick: b[0] || (b[0] = (x) => g(x, 0))
        }, null, 8, ["label", "disabled"])
      ], 34),
      unref(c).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(c), (x) => (openBlock(), createBlock($n, {
        key: x,
        id: `${unref(r)}-error`,
        message: x
      }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
      t10.hint ? (openBlock(), createBlock(ln, {
        key: 1,
        id: `${unref(r)}-hint`,
        class: "mn-rating-hint",
        label: t10.hint
      }, null, 8, ["id", "label"])) : createCommentVNode("", true)
    ], 10, lH));
  }
});
var TZ = Me(uH, [["__scopeId", "data-v-8684a690"]]);
var dH = ["id"];
var fH = { class: "invisible" };
var hH = ["id", "aria-activedescendant", "aria-labelledby"];
var pH = ["id"];
var mH = {
  key: 0,
  class: "mn-select-no-result",
  "aria-hidden": "true"
};
var gH = ["id", "aria-selected"];
var bH = { class: "mn-select-option-default" };
var yH = ["id", "aria-selected", "title", "onClick"];
var vH = { class: "mn-select-option-default" };
var xH = Object.assign({ name: "mn-select" }, {
  __name: "select",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: [String, Number, Array, Object],
      default: null
    },
    options: {
      type: [Array, Object],
      default: () => []
    },
    placeholder: {
      type: String,
      default: "-"
    },
    entry: {
      type: String,
      default: "children"
    },
    rules: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    compareKey: {
      type: String,
      default: "_id"
    },
    empty: String,
    hint: String,
    tooltip: String,
    searchable: Boolean,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean,
    formatIn: {
      type: Function,
      default: (t10) => t10
    },
    formatOut: {
      type: Function,
      default: (t10) => t10
    }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = e, s = t10, r = useId(), o = ref(false), a = ref(null), l = ref(null), c = ref(null), u = ref(""), d = ref(null), f = toRef(s, "name"), h10 = toRef(s, "rules"), { floatingStyles: p } = yd(a, l, {
      whileElementsMounted: pd,
      middleware: [md(8), bd(), gd({ padding: 8 })]
    }), g = computed(() => Io(s.options, s.entry)), m = computed(() => !s.searchable || !u.value ? g.value : g.value.filter((W) => s.formatIn(W).toLowerCase().includes(u.value.toLowerCase())).sort((W, C) => {
      const O = s.formatIn(W).toLowerCase().startsWith(u.value.toLowerCase()), _ = s.formatIn(C).toLowerCase().startsWith(u.value.toLowerCase());
      return O && !_ ? -1 : !O && _ ? 1 : 0;
    })), { value: b, errors: x, handleChange: k, meta: v } = Sn(f, h10, {
      initialValue: s.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    }), { list: S, containerProps: w, wrapperProps: E } = Fk(m, { itemHeight: 34 });
    function M(z) {
      if (!o.value) return;
      const W = z.target, C = document.getElementById(`${r}-button`);
      W === C || W.closest(`#${r}-button`) || W.closest(`#${r}-dropdown`) || (u.value = "", o.value = false);
    }
    function N() {
      o.value && (u.value = ""), o.value = !o.value;
    }
    function V(z) {
      if (!s.disabled)
        if (z.code === "Enter" || z.code === "Space" || z.code === "ArrowDown") {
          if (s.disabled) return;
          z.preventDefault(), N(), nextTick(() => {
            if (c.value ? document.querySelector(`#${r}-dropdown .mn-select-search input`).focus({ preventScroll: true }) : document.querySelector(`#${r}-dropdown`).focus({ preventScroll: true }), d.value === null)
              F("first");
            else {
              const W = document.getElementById(`${r}-option-${d.value}`);
              W && W.scrollIntoView({ block: "nearest" });
            }
          });
        } else if (z.code === "ArrowUp") {
          if (s.disabled) return;
          z.preventDefault(), N(), nextTick(() => {
            if (c.value ? document.querySelector(`#${r}-dropdown .mn-select-search input`).focus({ preventScroll: true }) : document.querySelector(`#${r}-dropdown`).focus({ preventScroll: true }), d.value === null)
              F("last");
            else {
              const W = document.getElementById(`${r}-option-${d.value}`);
              W && W.scrollIntoView({ block: "nearest" });
            }
          });
        } else
          F(z.key);
    }
    function Y(z) {
      z.metaKey || z.ctrlKey || (z.code === "Escape" && (z.preventDefault(), z.stopPropagation(), N(), nextTick(() => document.getElementById(`${r}-button`).focus({ preventScroll: true }))), z.code === "Enter" && (z.preventDefault(), z.stopPropagation(), re(z, d.value)), (z.code === "Home" || z.code === "PageUp") && (z.preventDefault(), z.stopPropagation(), F("first")), z.code === "ArrowUp" && (z.preventDefault(), z.stopPropagation(), F("previous")), z.code === "ArrowDown" && (z.preventDefault(), z.stopPropagation(), F("next")), (z.code === "End" || z.code === "PageDown") && (z.preventDefault(), z.stopPropagation(), F("last")), z.key.length === 1 && (z.preventDefault(), z.stopPropagation(), s.searchable ? (u.value += z.key, F("first")) : F(z.key)), z.code === "Tab" && (z.preventDefault(), z.stopPropagation(), u.value = "", N(), nextTick(() => document.getElementById(`${r}-button`).focus({ preventScroll: true }))));
    }
    function F(z) {
      if (s.disabled || !o.value) return;
      const W = Array.from(document.querySelectorAll(`#${r}-list li`));
      if (z === "first")
        s.empty ? d.value = null : d.value = 0;
      else if (z === "previous")
        s.empty ? d.value === null ? d.value = W.length - 2 : d.value === 0 ? d.value = null : d.value = d.value - 1 : d.value === 0 ? d.value = W.length - 1 : d.value = d.value - 1;
      else if (z === "next")
        s.empty ? d.value === null ? d.value = 0 : d.value === W.length - 2 ? d.value = null : d.value = d.value + 1 : d.value === W.length - 1 ? d.value = 0 : d.value = d.value + 1;
      else if (z === "last")
        s.empty ? d.value = W.length - 2 : d.value = W.length - 1;
      else {
        const O = W.findIndex((_) => _.textContent.trim().toLowerCase().startsWith(z.toLowerCase()));
        O >= 0 && (d.value = O);
      }
      const C = document.getElementById(`${r}-option-${d.value}`);
      C && C.scrollIntoView({ block: "nearest" });
    }
    function re(z, W) {
      d.value = W, b.value = typeof d.value == "number" ? s.formatOut(m.value[W]) : null, i("update:modelValue", b.value), i("input", z, b.value), i("change", z, b.value), k(b.value), N(), nextTick(() => document.getElementById(`${r}-button`).focus({ preventScroll: true }));
    }
    return watch(
      () => b.value,
      (z) => {
        if (z) {
          let W;
          typeof z == "object" ? W = m.value.findIndex((C) => (C == null ? void 0 : C[s.compareKey]) === (z == null ? void 0 : z[s.compareKey])) : W = m.value.findIndex((C) => s.formatOut(C) === z), W >= 0 && (d.value = W);
        } else
          d.value = null;
      },
      { immediate: true }
    ), onMounted(() => {
      window.addEventListener("click", M);
    }), onUnmounted(() => {
      window.removeEventListener("click", M);
    }), (z, W) => {
      var C;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["mn-select", { "-hidden": t10.hidden, "-disabled": t10.disabled }]),
        role: "group"
      }, [
        createVNode(Ft, {
          class: normalizeClass(["mn-select-label", { invisible: t10.labelless }]),
          label: t10.label,
          tooltip: t10.tooltip,
          for: `${unref(r)}-button`
        }, null, 8, ["class", "label", "tooltip", "for"]),
        createBaseVNode("div", {
          class: normalizeClass(["mn-select-shell", { "-invalid": unref(x).length }])
        }, [
          createVNode(me, {
            ref_key: "buttonRef",
            ref: a,
            class: "mn-select-button",
            variant: "muted",
            color: "neutral",
            wide: "",
            id: `${unref(r)}-button`,
            disabled: t10.disabled,
            icon: o.value ? "angle-up" : "angle-down",
            label: unref(Ie)(t10.formatIn((C = m.value) == null ? void 0 : C[d.value]) || unref(b)) || (t10.labelless ? unref(Ie)(t10.label) : unref(Ie)(t10.placeholder)),
            title: t10.labelless ? t10.label : null,
            name: t10.name,
            "aria-haspopup": "listbox",
            "aria-expanded": o.value,
            "aria-describedby": `${unref(r)}-error ${unref(r)}-hint`,
            onClick: N,
            onKeydown: V
          }, null, 8, ["id", "disabled", "icon", "label", "title", "name", "aria-expanded", "aria-describedby"]),
          createBaseVNode("div", {
            ref_key: "listRef",
            ref: l,
            id: `${unref(r)}-dropdown`,
            tabindex: "0",
            class: normalizeClass(["mn-select-dropdown", { "-hidden": !o.value }]),
            style: normalizeStyle(unref(p)),
            onKeydown: Y
          }, [
            t10.searchable ? (openBlock(), createBlock(_r, { key: 0 }, {
              default: withCtx(() => [
                createVNode(Nr, {
                  ref_key: "searchRef",
                  ref: c,
                  class: "mn-select-search",
                  name: "mn-search",
                  autocomplete: "off",
                  role: "combobox",
                  "aria-expanded": "true",
                  "aria-controls": `${unref(r)}-list`,
                  "aria-autocomplete": "list",
                  label: unref(n).t("search"),
                  placeholder: unref(Ie)(unref(n).t("search")),
                  disabled: t10.disabled,
                  labelless: "",
                  modelValue: u.value,
                  "onUpdate:modelValue": W[0] || (W[0] = (O) => u.value = O)
                }, null, 8, ["aria-controls", "label", "placeholder", "disabled", "modelValue"])
              ]),
              _: 1
            })) : createCommentVNode("", true),
            createBaseVNode("span", fH, toDisplayString(`${m.value.length} ${m.value.length > 1 ? unref(n).t("results") : unref(n).t("result")}`), 1),
            createBaseVNode("ul", {
              class: "mn-select-list",
              role: "listbox",
              id: `${unref(r)}-list`,
              "aria-activedescendant": typeof d.value == "number" ? `${unref(r)}-option-${d.value}` : null,
              "aria-labelledby": `${unref(r)}-list-label`
            }, [
              createBaseVNode("span", {
                id: `${unref(r)}-list-label`,
                hidden: ""
              }, toDisplayString(t10.label), 9, pH),
              unref(S).length ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", mH, toDisplayString(unref(Ie)(unref(n).t("noresult"))), 1)),
              t10.empty && unref(S).length ? (openBlock(), createElementBlock("li", {
                key: "null",
                class: normalizeClass(["mn-select-option mn-select-option-null", { "-active": d.value === null, "-first": !t10.searchable }]),
                role: "option",
                id: `${unref(r)}-option-null`,
                "aria-selected": d.value === null,
                onClick: W[1] || (W[1] = (O) => re(O, null))
              }, [
                createBaseVNode("span", bH, toDisplayString(unref(Ie)(t10.empty)), 1)
              ], 10, gH)) : createCommentVNode("", true),
              createBaseVNode("div", normalizeProps(guardReactiveProps(unref(w))), [
                createBaseVNode("div", normalizeProps(guardReactiveProps(unref(E))), [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(S), (O) => (openBlock(), createElementBlock("li", {
                    class: normalizeClass(["mn-select-option", {
                      "-active": O.index === d.value,
                      "-first": !t10.empty && !t10.searchable && O.index === 0,
                      "-last": O.index === unref(S).length - 1
                    }]),
                    role: "option",
                    key: O.index,
                    id: `${unref(r)}-option-${O.index}`,
                    "aria-selected": O.index === d.value,
                    title: unref(Ie)(t10.formatIn(O.data)),
                    style: { height: "34px" },
                    onClick: (_) => re(_, O.index)
                  }, [
                    renderSlot(z.$slots, "option", {
                      item: O.data
                    }, () => [
                      createBaseVNode("span", vH, toDisplayString(unref(Ie)(t10.formatIn(O.data))), 1)
                    ], true)
                  ], 10, yH))), 128))
                ], 16)
              ], 16)
            ], 8, hH)
          ], 46, dH)
        ], 2),
        unref(x).length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(x), (O) => (openBlock(), createBlock($n, {
          key: O,
          id: `${unref(r)}-error`,
          message: O
        }, null, 8, ["id", "message"]))), 128)) : createCommentVNode("", true),
        t10.hint ? (openBlock(), createBlock(ln, {
          key: 1,
          id: `${unref(r)}-hint`,
          class: "mn-select-hint",
          label: t10.hint
        }, null, 8, ["id", "label"])) : createCommentVNode("", true)
      ], 2);
    };
  }
});
var Yb = Me(xH, [["__scopeId", "data-v-1d80fd8a"]]);
var kH = Object.assign({ name: "mn-list" }, {
  __name: "list",
  props: {
    items: {
      type: Array,
      default: () => []
    },
    entry: {
      type: String,
      default: "children"
    },
    depth: {
      type: Number,
      default: 0
    },
    ordered: Boolean
  },
  setup(t10) {
    const e = ref(null);
    return (n, i) => (openBlock(), createBlock(resolveDynamicComponent(t10.ordered ? "ol" : "ul"), {
      ref_key: "listRef",
      ref: e,
      class: normalizeClass(["mn-list", { "-nested": !!t10.depth }])
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(t10.items, (s, r) => (openBlock(), createElementBlock("li", {
          key: JSON.stringify(s),
          class: "mn-list-item"
        }, [
          renderSlot(n.$slots, "item", {
            item: s,
            depth: t10.depth,
            parent: "root",
            rank: r + 1
          }, () => [
            createTextVNode(toDisplayString(s), 1)
          ]),
          s[t10.entry] ? (openBlock(), createBlock(Gk, {
            key: 0,
            items: s[t10.entry],
            entry: t10.entry,
            ordered: t10.ordered,
            depth: t10.depth + 1
          }, {
            item: withCtx(({ item: o, depth: a, rank: l }) => [
              renderSlot(n.$slots, "item", {
                item: o,
                depth: a,
                parent: s,
                rank: l
              }, () => [
                createTextVNode(toDisplayString(o), 1)
              ])
            ]),
            _: 2
          }, 1032, ["items", "entry", "ordered", "depth"])) : createCommentVNode("", true)
        ]))), 128))
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Gk = Me(kH, [["__scopeId", "data-v-9667651d"]]);
var SH = ["tabindex", "data-item", "data-rank", "data-parent", "onDragstart"];
var wH = { class: "mn-sorter-item-content" };
var CH = Object.assign({ name: "mn-sorter" }, {
  __name: "sorter",
  props: {
    label: {
      type: String,
      required: true
    },
    modelValue: {
      type: Array,
      default: () => []
    },
    entry: {
      type: String,
      default: "children"
    },
    name: {
      type: String,
      default: ""
    },
    hint: String,
    tooltip: String,
    labelless: Boolean,
    disabled: Boolean,
    hidden: Boolean
  },
  emits: ["update:modelValue"],
  setup(t10, { emit: e }) {
    const n = e, i = t10, s = useId(), r = ref(null), o = ref(null), a = ref(null), l = ref(null), c = ref(null), u = ref(null), d = ref(null), f = ref(null), h10 = ref(null), p = ref(null), g = ref(null), m = toRef(i, "name"), { value: b, meta: x } = Sn(m, "", {
      initialValue: i.modelValue,
      bails: false,
      syncVModel: true,
      validateOnValueUpdate: false
    });
    function k(M, N, V) {
      for (let Y = 0; Y < N.length; Y++) {
        let F = `${V}.${Y}`;
        if (JSON.stringify(N[Y]) === JSON.stringify(M))
          return N;
        if (N[Y][i.entry]) {
          const re = k(M, N[Y][i.entry], `${F}.${i.entry}`);
          if (re) return re;
        }
      }
    }
    function v(M, N, V, Y) {
      i.disabled || (d.value = M.target.closest("li"), d.value.classList.add("-vault"), f.value = Array.from(document.querySelectorAll(`#${s}-list [data-item]`)), h10.value = f.value.filter((F) => !d.value.contains(F)), p.value = f.value.findIndex((F) => JSON.stringify(N) === JSON.stringify(JSON.parse(F.dataset.item))), r.value = N, a.value = V, o.value = Y - 1);
    }
    function S(M) {
      var F;
      if (M.preventDefault(), i.disabled) return;
      const V = document.elementFromPoint(M.clientX, M.clientY).closest(".mn-sorter-item");
      !!V && !((F = d.value) != null && F.contains(V)) ? (l.value = JSON.parse(V.dataset.item), u.value = JSON.parse(V.dataset.parent), c.value = Number(V.dataset.rank) - 1) : (l.value = null, u.value = null, c.value = null);
    }
    function w() {
      if (i.disabled) return;
      const M = [...b.value];
      if (l.value) {
        if (a.value === "root")
          M.splice(o.value, 1);
        else {
          const N = k(r.value, M, "");
          N == null || N.splice(o.value, 1);
        }
        if (u.value === "root")
          M.splice(c.value, 0, r.value);
        else {
          const N = k(l.value, M, "");
          N == null || N.splice(c.value, 0, r.value);
        }
        n("update:modelValue", M);
      }
      f.value = null, h10.value = null, p.value = null, g.value = null, d.value.classList.remove("-vault"), d.value = null, r.value = null, a.value = null, o.value = null, l.value = null, u.value = null, c.value = null;
    }
    function E(M) {
      var N, V;
      if (!i.disabled) {
        if ((M.code === "Space" || M.code === "Enter") && (M.preventDefault(), r.value ? w() : v(M, JSON.parse(M.target.dataset.item), JSON.parse(M.target.dataset.parent), Number(M.target.dataset.rank))), M.code === "ArrowDown") {
          M.preventDefault(), typeof g.value == "number" && g.value < h10.value.length - 1 ? g.value++ : g.value = 0;
          const Y = h10.value[g.value];
          !!Y && !((N = d.value) != null && N.contains(Y)) ? (l.value = JSON.parse(Y.dataset.item), u.value = JSON.parse(Y.dataset.parent), c.value = Number(Y.dataset.rank) - 1) : (l.value = null, u.value = null, c.value = null);
        }
        M.code === "ArrowUp" && (M.preventDefault(), typeof g.value == "number" && g.value > 0 ? g.value-- : g.value = h10.value.length - 1, !!previous && !((V = d.value) != null && V.contains(previous)) ? (l.value = JSON.parse(previous.dataset.item), u.value = JSON.parse(previous.dataset.parent), c.value = Number(previous.dataset.rank) - 1) : (l.value = null, u.value = null, c.value = null)), M.code === "Escape" && (d.value.classList.remove("-vault"), d.value = null, r.value = null, a.value = null, o.value = null, l.value = null, u.value = null, c.value = null);
      }
    }
    return (M, N) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-sorter", { "-hidden": t10.hidden, "-disabled": t10.disabled }])
    }, [
      createVNode(Ft, {
        class: normalizeClass(["mn-sorter-label", { invisible: t10.labelless }]),
        label: t10.label,
        tooltip: t10.tooltip,
        for: `${unref(s)}-list`
      }, null, 8, ["class", "label", "tooltip", "for"]),
      createVNode(Gk, {
        id: `${unref(s)}-list`,
        items: unref(b),
        entry: t10.entry,
        ordered: "",
        "aria-describedby": `${unref(s)}-error ${unref(s)}-hint`,
        name: t10.name
      }, {
        item: withCtx(({ item: V, depth: Y, parent: F, rank: re }) => [
          createBaseVNode("div", {
            tabindex: t10.disabled ? -1 : 0,
            class: normalizeClass(["mn-sorter-item", { "-grabbed": JSON.stringify(r.value) === JSON.stringify(V), "-target": JSON.stringify(l.value) === JSON.stringify(V) }]),
            "data-item": JSON.stringify(V),
            "data-rank": re,
            "data-parent": JSON.stringify(F),
            draggable: "true",
            onKeydown: E,
            onDragstart: (z) => v(z, V, F, re),
            onDragover: S,
            onDragend: w
          }, [
            createVNode(ft, { icon: "grip-dots" }),
            createBaseVNode("div", wH, [
              renderSlot(M.$slots, "item", {
                item: V,
                rank: re,
                depth: Y
              }, () => [
                createTextVNode(toDisplayString(re) + " - " + toDisplayString(V), 1)
              ], true)
            ])
          ], 42, SH)
        ]),
        _: 3
      }, 8, ["id", "items", "entry", "aria-describedby", "name"]),
      t10.hint ? (openBlock(), createBlock(ln, {
        key: 0,
        id: `${unref(s)}-hint`,
        class: "mn-sorter-hint",
        label: t10.hint
      }, null, 8, ["id", "label"])) : createCommentVNode("", true)
    ], 2));
  }
});
var AZ = Me(CH, [["__scopeId", "data-v-0e642d5e"]]);
var OH = { class: "mn-carousel-viewport" };
var EH = ["aria-hidden"];
var MH = ["aria-hidden"];
var TH = ["aria-hidden"];
var AH = {
  key: 2,
  class: "mn-carousel-pagination"
};
var _H = {
  class: "invisible",
  "aria-live": "polite",
  "aria-atomic": "true"
};
var NH = Object.assign({ name: "mn-carousel" }, {
  __name: "carousel",
  props: {
    slides: {
      type: Array,
      default: () => []
    },
    breakpoints: {
      type: Object,
      default: null
    },
    align: {
      type: String,
      default: "center",
      validator: (t10) => ["start", "center", "end"].includes(String(t10))
    },
    ratio: String,
    shown: {
      type: Number,
      default: 1
    },
    scrolled: {
      type: Number,
      default: 1
    },
    autoplay: {
      type: Number,
      default: 0
    },
    transition: {
      type: Number,
      default: 300
    },
    cover: Boolean,
    infinite: Boolean,
    pagination: Boolean,
    navigation: Boolean
  },
  setup(t10) {
    useCssVars((L) => ({
      "21b4ae40": `${100 / m.shown}%`,
      "3fab9be3": m.ratio,
      "1d33c2f9": m.cover ? "cover" : "contain"
    }));
    const e = inject("minuit"), n = zm(), i = t10, s = useId(), r = ref(null), o = ref(false), a = ref(false), l = ref(false), c = ref(false), u = ref(0), d = ref(0), f = ref(0), h10 = ref(0), p = reactive(ref(0)), g = ref(0), m = reactive({
      align: i.align,
      ratio: i.ratio,
      shown: i.shown,
      scrolled: i.scrolled,
      autoplay: i.autoplay,
      transition: i.transition,
      cover: i.cover,
      infinite: i.infinite,
      pagination: i.pagination,
      navigation: i.navigation
    });
    let b = null, x = null;
    const k = computed(() => {
      let L = 0;
      return m.infinite || m.shown > i.slides.length || (m.align === "center" && (L = Math.floor((m.shown - 1) / 2)), m.align === "end" && (L = m.shown - 1)), L;
    }), v = computed(() => {
      let L = i.slides.length - 1;
      return m.infinite || (m.align === "start" && (L = i.slides.length - m.shown), m.align === "center" && (L = i.slides.length - Math.ceil((m.shown - 0.5) / 2))), L;
    }), S = computed(() => {
      let L = u.value;
      return m.align === "center" && (L -= (m.shown - 1) / 2), m.align === "end" && (L -= m.shown - 1), m.infinite ? L : Q({ val: L, max: i.slides.length - m.shown, min: 0 });
    }), w = computed(() => {
      const L = n.value === "rtl" ? -1 : 1, K = S.value * g.value * L;
      return {
        transform: `translateX(${p.value - K}px)`,
        transition: `${l.value ? m.transition : 0}ms`,
        margin: m.infinite ? `0 -${i.slides.length * g.value}px` : "",
        width: "100%"
      };
    });
    function E() {
      if (!i.breakpoints || !Object.keys(i.breakpoints).length) return;
      const L = Object.keys(i.breakpoints).map((B) => Number(B)).sort((B, X) => +X - +B);
      let K = {
        align: i.align,
        ratio: i.ratio,
        shown: i.shown,
        scrolled: i.scrolled,
        autoplay: i.autoplay,
        transition: i.transition,
        cover: i.cover,
        infinite: i.infinite,
        pagination: i.pagination,
        navigation: i.navigation
      };
      L.some((B) => {
        const X = window.matchMedia(`(min-width: ${B}px)`).matches;
        return X && (K = {
          ...K,
          ...i.breakpoints[B]
        }), X;
      }), M(K);
    }
    function M(L) {
      Object.entries(L).forEach(([K, B]) => m[K] = B);
    }
    const N = xe(() => {
      E(), V();
    }, 16);
    function V() {
      if (!r.value) return;
      const L = r.value.getBoundingClientRect();
      g.value = L.width / m.shown;
    }
    function Y() {
      i.slides.length <= 0 || m.infinite || (u.value = Q({ val: u.value, max: v.value, min: k.value }));
    }
    function F(L) {
      c.value = L.type === "touchstart", !c.value && L.preventDefault(), !(!c.value && L.button !== 0 || l.value) && (f.value = c.value ? L.touches[0].clientX : L.clientX, document.addEventListener(c.value ? "touchmove" : "mousemove", re, true), document.addEventListener(c.value ? "touchend" : "mouseup", z, true));
    }
    const re = pe((L) => {
      o.value = true, h10.value = c.value ? L.touches[0].clientX : L.clientX, p.value = h10.value - f.value;
    }, 16);
    function z() {
      const L = n.value === "rtl" ? -1 : 1, K = Math.sign(p.value) * 0.4, B = Math.round(p.value / g.value + K) * L;
      if (B && !c.value) {
        const X = (be) => {
          be.preventDefault(), window.removeEventListener("click", X);
        };
        window.addEventListener("click", X);
      }
      O(u.value - B), p.value = 0, o.value = false, document.removeEventListener(c.value ? "touchmove" : "mousemove", re, true), document.removeEventListener(c.value ? "touchend" : "mouseup", z, true);
    }
    function W() {
      !m.autoplay || m.autoplay <= 0 || (b = setInterval(() => {
        a.value || T();
      }, m.autoplay));
    }
    function C() {
      b && (clearInterval(b), b = null), W();
    }
    function O(L) {
      const K = m.infinite ? L : Q({ val: L, max: v.value, min: k.value });
      u.value === K || l.value || (l.value = true, d.value = u.value, u.value = K, x = setTimeout(() => {
        if (m.infinite) {
          const B = ae({ val: K, max: v.value, min: 0 });
          B !== u.value && (u.value = B);
        }
        l.value = false, C();
      }, m.transition));
    }
    function _() {
      O(u.value - m.scrolled);
    }
    function T() {
      O(u.value + m.scrolled);
    }
    function H(L) {
      const K = Math.floor(S.value), B = Math.ceil(S.value + m.shown - 1);
      return L >= K && L <= B;
    }
    function Q({ val: L, max: K, min: B }) {
      return K < B ? L : Math.min(Math.max(L, B), K);
    }
    function ae({ val: L, max: K, min: B = 0 }) {
      const X = K - B + 1;
      return ((L - B) % X + X) % X + B;
    }
    function pe(L, K) {
      let B;
      return function(...X) {
        const be = this;
        B || (L.apply(be, X), B = true, setTimeout(() => B = false, K));
      };
    }
    function xe(L, K) {
      let B;
      return function(...X) {
        B && clearTimeout(B), B = setTimeout(() => {
          L(...X), B = null;
        }, K);
      };
    }
    function Te() {
      E(), Y(), V(), C();
    }
    return Object.keys(i).forEach((L) => {
      watch(() => i[L], Te);
    }), onMounted(() => {
      nextTick(() => V()), setTimeout(() => V(), 1e3), E(), W(), window.addEventListener("resize", N, { passive: true });
    }), watchEffect(() => {
      m.align = i.align, m.shown = i.shown, m.scrolled = i.scrolled, m.autoplay = i.autoplay, m.transition = i.transition, m.infinite = i.infinite, m.pagination = i.pagination, m.navigation = i.navigation;
    }), onUnmounted(() => {
      b && clearInterval(b), x && clearTimeout(x), window.removeEventListener("resize", N);
    }), (L, K) => t10.slides.length ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref_key: "carouselRef",
      ref: r,
      class: normalizeClass(["mn-carousel", { "-dragging": o.value }]),
      onMouseenter: K[0] || (K[0] = (B) => a.value = true),
      onMouseleave: K[1] || (K[1] = (B) => a.value = false)
    }, [
      createBaseVNode("div", OH, [
        createBaseVNode("ol", {
          class: "mn-carousel-list",
          style: normalizeStyle(w.value),
          onMousedownCapture: F,
          onTouchstartPassiveCapture: F
        }, [
          m.infinite ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(t10.slides, (B, X) => (openBlock(), createElementBlock("li", {
            class: "mn-carousel-slide",
            key: `${unref(s)}-before-${JSON.stringify(B)}`,
            "aria-hidden": H(t10.slides.length + X * -1)
          }, [
            renderSlot(L.$slots, "slide", {
              item: B,
              index: X
            })
          ], 8, EH))), 128)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(t10.slides, (B, X) => (openBlock(), createElementBlock("li", {
            class: "mn-carousel-slide",
            key: `${unref(s)}-current-${JSON.stringify(B)}`,
            "aria-hidden": H(X)
          }, [
            renderSlot(L.$slots, "slide", {
              item: B,
              index: X
            })
          ], 8, MH))), 128)),
          m.infinite ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(t10.slides, (B, X) => (openBlock(), createElementBlock("li", {
            class: "mn-carousel-slide",
            key: `${unref(s)}-after-${JSON.stringify(B)}`,
            "aria-hidden": H(t10.slides.length + X)
          }, [
            renderSlot(L.$slots, "slide", {
              item: B,
              index: X
            })
          ], 8, TH))), 128)) : createCommentVNode("", true)
        ], 36)
      ]),
      m.navigation ? (openBlock(), createBlock(me, {
        key: 0,
        class: "mn-carousel-previous",
        variant: "text",
        color: "neutral",
        label: unref(e).t("previousSlide"),
        labelless: "",
        icon: "angle-left",
        mirror: "",
        disabled: !t10.infinite && u.value <= k.value,
        onClick: _
      }, null, 8, ["label", "disabled"])) : createCommentVNode("", true),
      m.navigation ? (openBlock(), createBlock(me, {
        key: 1,
        class: "mn-carousel-next",
        variant: "text",
        color: "neutral",
        label: unref(e).t("nextSlide"),
        labelless: "",
        icon: "angle-right",
        mirror: "",
        disabled: !t10.infinite && u.value >= v.value,
        onClick: T
      }, null, 8, ["label", "disabled"])) : createCommentVNode("", true),
      m.pagination ? (openBlock(), createElementBlock("ol", AH, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(t10.slides, (B, X) => (openBlock(), createElementBlock("li", {
          key: `${unref(s)}-pagination-${JSON.stringify(B)}`
        }, [
          createVNode(me, {
            label: `${unref(e).t("slide")} ${X + 1}`,
            class: normalizeClass([{ "-active": X === u.value }, "mn-carousel-pagination-item"]),
            variant: "text",
            color: "neutral",
            icon: "circle",
            labelless: "",
            pill: "",
            mirror: "",
            onClick: (be) => O(X)
          }, null, 8, ["label", "class", "onClick"])
        ]))), 128))
      ])) : createCommentVNode("", true),
      createBaseVNode("div", _H, [
        createBaseVNode("span", null, toDisplayString(`${unref(e).t("slide")} ${u.value + 1} ${unref(e).t("of")} ${t10.slides.length}`), 1)
      ])
    ], 34)) : createCommentVNode("", true);
  }
});
var _Z = Me(NH, [["__scopeId", "data-v-3e6d027c"]]);
var LH = ["id"];
var IH = ["id"];
var PH = ["id", "aria-labelledby"];
var DH = Object.assign({ name: "mn-context-menu" }, {
  __name: "context-menu",
  props: {
    label: {
      type: String,
      required: true
    },
    autoclose: Boolean
  },
  setup(t10) {
    const e = inject("minuit"), n = t10, i = useId(), s = ref(false), r = ref(null), o = ref(null), a = ref(null), l = ref({ x: 0, y: 0 }), c = computed(
      () => Array.from(document.querySelectorAll(`#${i}-menu :is([role="menuitemradio"], [role="menuitem"], [role="menuitemcheckbox"])`))
    ), { floatingStyles: u } = yd(r, o, {
      whileElementsMounted: pd,
      strategy: "fixed",
      placement: "bottom-start",
      middleware: [md(8), bd(), gd({ padding: 8 })]
    });
    function d(m) {
      if (!s.value) return;
      const b = m.target;
      m.type === "contextmenu" && b.closest(`#${i}-container`) || b.closest(`#${i}-menu`) && !n.autoclose || (s.value = false);
    }
    function f(m) {
      if (m.code === "Escape") {
        m.preventDefault(), s.value = false;
        return;
      }
      s.value = true, nextTick(() => {
        if (m.type === "contextmenu")
          l.value = { x: (m == null ? void 0 : m.clientX) || 0, y: (m == null ? void 0 : m.clientY) || 0 };
        else if (m.type === "keydown") {
          const b = r.value.getBoundingClientRect();
          l.value = {
            x: b.left + b.width / 2,
            y: b.top + b.height / 2
          };
        }
        l.value.x + o.value.offsetWidth > window.innerWidth && (l.value.x = window.innerWidth - o.value.offsetWidth - 8), l.value.y + o.value.offsetHeight > window.innerHeight && (l.value.y = window.innerHeight - o.value.offsetHeight - 8);
      });
    }
    function h10(m) {
      (m.code === "KeyC" || m.code === "ArrowDown") && (m.preventDefault(), f(m), nextTick(() => {
        if (o.value.focus({ preventScroll: true }), a.value === null) g("first");
        else {
          const b = c.value[a.value];
          b && b.scrollIntoView({ block: "nearest" });
        }
      })), m.code === "ArrowUp" && (m.preventDefault(), f(m), nextTick(() => {
        if (o.value.focus({ preventScroll: true }), a.value === null) g("last");
        else {
          const b = c.value[a.value];
          b && b.scrollIntoView({ block: "nearest" });
        }
      }));
    }
    function p(m) {
      if (!(m.metaKey || m.ctrlKey)) {
        if (m.code === "Escape" && (m.preventDefault(), f(m), nextTick(() => document.getElementById(`${i}-container`).focus({ preventScroll: true }))), m.code === "Enter" || m.code === "Space") {
          m.stopPropagation();
          const b = c.value[a.value];
          b && b.click(), n.autoclose && f(m);
        }
        (m.code === "Home" || m.code === "PageUp") && (m.preventDefault(), m.stopPropagation(), g("first")), m.code === "ArrowUp" && (m.preventDefault(), m.stopPropagation(), g("previous")), m.code === "ArrowDown" && (m.preventDefault(), m.stopPropagation(), g("next")), (m.code === "End" || m.code === "PageDown") && (m.preventDefault(), m.stopPropagation(), g("last")), m.code === "Tab" && (m.preventDefault(), m.stopPropagation(), f(m), nextTick(() => document.getElementById(`${i}-container`).focus({ preventScroll: true })));
      }
    }
    function g(m) {
      s.value && (m === "first" && (a.value = 0), m === "previous" && (a.value === 0 ? a.value = c.value.length - 1 : a.value--), m === "next" && (a.value === c.value.length - 1 ? a.value = 0 : a.value++), m === "last" && (a.value = c.value.length - 1), nextTick(() => {
        const b = c.value[a.value];
        b && b.scrollIntoView({ block: "nearest" }), b && b.focus();
      }));
    }
    return onMounted(() => {
      window.addEventListener("click", d), window.addEventListener("contextmenu", d);
    }), onUnmounted(() => {
      window.removeEventListener("click", d), window.removeEventListener("contextmenu", d);
    }), (m, b) => (openBlock(), createElementBlock("div", {
      ref_key: "triggerRef",
      ref: r,
      tabindex: "0",
      id: `${unref(i)}-container`,
      class: "mn-context-menu",
      onContextmenu: withModifiers(f, ["prevent"]),
      onKeydown: withModifiers(h10, ["alt"])
    }, [
      renderSlot(m.$slots, "trigger"),
      createBaseVNode("span", {
        id: `${unref(i)}-label`,
        hidden: ""
      }, toDisplayString(`${t10.label}, ${unref(e).t("openContextmenu")}`), 9, IH),
      createBaseVNode("div", {
        ref_key: "menuRef",
        ref: o,
        class: normalizeClass(["mn-context-menu-content", { "-hidden": !s.value }]),
        role: "menu",
        tabindex: "0",
        id: `${unref(i)}-menu`,
        "aria-labelledby": `${unref(i)}-label`,
        style: normalizeStyle({ ...unref(u), transform: `translate(${l.value.x}px, ${l.value.y}px)` }),
        onKeydown: p
      }, [
        renderSlot(m.$slots, "default")
      ], 46, PH)
    ], 40, LH));
  }
});
var $H = Me(DH, [["__scopeId", "data-v-af3a432f"]]);
var RH = ["name", "open"];
var FH = { class: "mn-details-summary" };
var VH = { class: "mn-details-summary-title" };
var BH = { class: "mn-details-content" };
var zH = Object.assign({ name: "mn-details" }, {
  __name: "details",
  props: {
    summary: {
      type: String,
      required: true
    },
    side: {
      type: String,
      default: "start",
      validator: (t10) => ["start", "end"].includes(String(t10))
    },
    name: String,
    open: Boolean
  },
  setup(t10) {
    const n = ref(t10.open);
    function i() {
      n.value = !n.value;
    }
    return (s, r) => (openBlock(), createElementBlock("details", {
      class: "mn-details",
      name: t10.name,
      open: t10.open,
      onToggle: i
    }, [
      createBaseVNode("summary", FH, [
        t10.side === "start" ? (openBlock(), createBlock(ft, {
          key: 0,
          class: "mn-details-summary-icon",
          color: "accent",
          icon: n.value ? "angle-down" : "angle-right",
          mirror: ""
        }, null, 8, ["icon"])) : createCommentVNode("", true),
        createBaseVNode("span", VH, toDisplayString(unref(Ie)(t10.summary)), 1),
        t10.side === "end" ? (openBlock(), createBlock(ft, {
          key: 1,
          class: "mn-details-summary-icon",
          color: "accent",
          icon: n.value ? "angle-up" : "angle-down"
        }, null, 8, ["icon"])) : createCommentVNode("", true)
      ]),
      createBaseVNode("div", BH, [
        renderSlot(s.$slots, "default", {}, void 0, true)
      ])
    ], 40, RH));
  }
});
var NZ = Me(zH, [["__scopeId", "data-v-58c91eb9"]]);
var jH = ["aria-labelledby"];
var HH = ["id"];
var WH = { class: "mn-lightbox-content" };
var UH = Object.assign({ name: "mn-lightbox" }, {
  __name: "lightbox",
  props: {
    slides: {
      type: Array,
      default: () => []
    },
    current: {
      type: Number,
      default: 0
    },
    open: Boolean
  },
  emits: ["close"],
  setup(t10, { emit: e }) {
    const n = useId(), i = inject("minuit"), s = e, r = t10, o = ref(null), a = ref(r.current);
    function l() {
      a.value > 0 && a.value--;
    }
    function c() {
      a.value < r.slides.length - 1 && a.value++;
    }
    function u() {
      a.value = 0, s("close");
    }
    return onMounted(() => {
      o.value.addEventListener("close", u);
    }), onUnmounted(() => {
      var d;
      (d = o.value) == null || d.removeEventListener("close", u);
    }), watch(
      () => r.open,
      (d) => {
        var f, h10;
        return d ? (f = o.value) == null ? void 0 : f.showModal() : (h10 = o.value) == null ? void 0 : h10.close();
      },
      { immediate: true }
    ), watch(() => r.current, (d) => a.value = d), (d, f) => {
      var h10, p;
      return openBlock(), createElementBlock("dialog", {
        ref_key: "lightboxRef",
        ref: o,
        class: "mn-lightbox",
        "data-theme": "dark",
        "aria-labelledby": `${unref(n)}-label`
      }, [
        createBaseVNode("span", {
          id: `${unref(n)}-label`,
          class: "invisible"
        }, toDisplayString(unref(i).t("lightbox")), 9, HH),
        createVNode(me, {
          class: "mn-lightbox-close-btn",
          variant: "text",
          color: "neutral",
          icon: "xmark",
          label: unref(i).t("close"),
          labelless: "",
          onClick: u
        }, null, 8, ["label"]),
        ((h10 = t10.slides) == null ? void 0 : h10.length) > 1 ? (openBlock(), createBlock(me, {
          key: 0,
          class: "mn-lightbox-previous",
          label: unref(i).t("previousSlide"),
          variant: "text",
          color: "neutral",
          icon: "angle-left",
          labelless: "",
          disabled: a.value === 0,
          onClick: l
        }, null, 8, ["label", "disabled"])) : createCommentVNode("", true),
        createBaseVNode("div", WH, [
          t10.slides.length ? renderSlot(d.$slots, "slide", {
            key: 0,
            item: t10.slides[a.value],
            index: a.value
          }, void 0, true) : createCommentVNode("", true)
        ]),
        ((p = t10.slides) == null ? void 0 : p.length) > 1 ? (openBlock(), createBlock(me, {
          key: 1,
          class: "mn-lightbox-next",
          label: unref(i).t("nextSlide"),
          variant: "text",
          color: "neutral",
          icon: "angle-right",
          labelless: "",
          disabled: a.value === t10.slides.length - 1,
          onClick: c
        }, null, 8, ["label", "disabled"])) : createCommentVNode("", true)
      ], 8, jH);
    };
  }
});
var qH = Me(UH, [["__scopeId", "data-v-328887bb"]]);
var KH = { class: "mn-gallery" };
var YH = ["id"];
var GH = Object.assign({ name: "mn-gallery" }, {
  __name: "gallery",
  props: {
    label: {
      type: String,
      required: true
    },
    items: {
      type: Array,
      default: () => []
    },
    ratio: {
      type: String,
      default: "1/1"
    },
    columns: {
      type: String,
      default: "repeat(auto-fill, minmax(200px, 1fr))"
    }
  },
  setup(t10) {
    useCssVars((o) => ({
      a76c4048: t10.columns
    }));
    const e = useId(), n = inject("minuit"), i = ref(false), s = ref(0);
    function r(o) {
      s.value = o, i.value = true;
    }
    return (o, a) => (openBlock(), createElementBlock("section", KH, [
      createBaseVNode("span", {
        id: `${unref(e)}-label`,
        class: "invisible"
      }, toDisplayString(t10.label), 9, YH),
      createVNode(qH, {
        open: i.value,
        slides: t10.items,
        current: s.value,
        onClose: a[0] || (a[0] = (l) => i.value = false)
      }, {
        slide: withCtx(({ item: l }) => [
          renderSlot(o.$slots, "preview", {
            item: l,
            index: o.i
          }, () => [
            createVNode(r0, {
              file: typeof l == "object" ? l : null,
              src: typeof l == "string" ? l : null,
              captionless: "",
              ratio: t10.ratio
            }, null, 8, ["file", "src", "ratio"])
          ], true)
        ]),
        _: 3
      }, 8, ["open", "slides", "current"]),
      (openBlock(true), createElementBlock(Fragment, null, renderList(t10.items, (l, c) => renderSlot(o.$slots, "slide", {
        key: JSON.stringify(l),
        item: l,
        index: c
      }, () => [
        createVNode(me, {
          label: unref(n).t("open"),
          onClick: (u) => r(c)
        }, {
          default: withCtx(() => [
            createVNode(r0, {
              file: typeof l == "object" ? l : null,
              src: typeof l == "string" ? l : null,
              alt: unref(n).t("open"),
              captionless: "",
              ratio: t10.ratio
            }, null, 8, ["file", "src", "alt", "ratio"])
          ]),
          _: 2
        }, 1032, ["label", "onClick"])
      ], true)), 128))
    ]));
  }
});
var LZ = Me(GH, [["__scopeId", "data-v-33385627"]]);
var JH = { class: "mn-table" };
var XH = {
  key: 0,
  class: "mn-table-filters"
};
var QH = ["aria-labelledby"];
var ZH = { class: "mn-table-filters-menu-list" };
var eW = ["id"];
var tW = { class: "mn-table-filter-container" };
var nW = { class: "mn-table-filter-container" };
var iW = ["aria-labelledby"];
var sW = ["id"];
var rW = { class: "mn-table-table" };
var oW = { class: "mn-table-head" };
var aW = { class: "mn-table-header" };
var lW = {
  key: 0,
  class: "mn-table-header-cell mn-table-select"
};
var cW = { class: "mn-table-cell-wrapper" };
var uW = {
  key: 1,
  class: "mn-table-header-cell mn-table-expand"
};
var dW = { class: "mn-table-cell-wrapper" };
var fW = { class: "invisible" };
var hW = ["hidden", "data-key", "onDragstart"];
var pW = { class: "mn-table-cell-wrapper" };
var mW = { class: "mn-table-column-menu-trigger" };
var gW = {
  key: 2,
  class: "mn-table-header-cell"
};
var bW = { class: "mn-table-cell-wrapper mn-table-actions" };
var yW = {
  key: 1,
  class: "invisible"
};
var vW = { class: "mn-table-body" };
var xW = ["data-row"];
var kW = {
  key: 0,
  class: "mn-table-row-cell mn-table-select"
};
var SW = { class: "mn-table-cell-wrapper" };
var wW = {
  key: 1,
  class: "mn-table-row-cell mn-table-expand"
};
var CW = { class: "mn-table-cell-wrapper" };
var OW = ["hidden"];
var EW = { class: "mn-table-cell-wrapper" };
var MW = {
  key: 2,
  class: "mn-table-row-cell"
};
var TW = { class: "mn-table-cell-wrapper mn-table-actions" };
var AW = ["data-row"];
var _W = ["colspan"];
var NW = { class: "mn-table-row-detail-container" };
var LW = { class: "mn-table-empty" };
var IW = Object.assign({ name: "mn-table" }, {
  __name: "table",
  props: {
    label: {
      type: String,
      required: true
    },
    columns: {
      type: Array,
      default: () => []
    },
    items: {
      type: Array,
      default: () => []
    },
    outsideQueries: {
      type: Array,
      default: () => []
    },
    selectionKey: {
      type: String,
      default: "_id"
    },
    limit: {
      type: Number,
      default: 15
    },
    pages: Number,
    selectable: Boolean,
    filterless: Boolean
  },
  emits: ["select"],
  setup(t10, { expose: e, emit: n }) {
    var Te;
    useCssVars((L) => ({
      "4289c07c": `${unref(V) - 2}px`
    }));
    const i = inject("minuit"), s = useSlots(), r = useRoute(), o = useRouter(), a = ip("(max-width: 1023px)");
    e({ updateQuery: O });
    const l = n, c = t10, u = ref(!!s.details), d = ref(!!s.actions), f = ref(!!s["actions-all"]), h10 = useId(), p = ref(null), g = ref(["limit", "asc", "desc", "page", "tab", ...c.outsideQueries]), m = ref(((Te = r == null ? void 0 : r.query) == null ? void 0 : Te.search) || ""), b = ref({ key: null, order: null }), x = ref([]), k = ref(
      localStorage[`${c.label} - columns`] ? JSON.parse(localStorage[`${c.label} - columns`]) : c.columns.filter((L) => !L.hidden).map((L) => L.key)
    ), v = ref(1), S = ref(localStorage[`${c.label} - limit`] ? JSON.parse(localStorage[`${c.label} - limit`]) : c.limit), w = ref(null), E = ref(null), M = ref(null), N = ref(null), { width: V } = Hz(N);
    function Y(L) {
      var K;
      L.target === p.value && ((K = p.value) == null || K.close());
    }
    const F = computed(() => {
      var K;
      if (c.pages)
        return c.items;
      const L = [...c.items];
      if (b.value.key && L.sort((B, X) => b.value.order === "up" ? W(B, b.value.key) > W(X, b.value.key) ? 1 : -1 : W(B, b.value.key) < W(X, b.value.key) ? 1 : -1), r && ((K = Object.keys(r == null ? void 0 : r.query)) != null && K.length))
        return L.filter((B) => {
          var X;
          return (X = Object.entries(r == null ? void 0 : r.query)) == null ? void 0 : X.every(([be, Ce]) => {
            var Oe, Ue, J;
            if (g.value.includes(be))
              return true;
            if (be === "search") {
              const Fe = c.columns.filter((xt) => xt.searchable).map((xt) => xt.key);
              return Fe.length ? Fe.some((xt) => {
                var Ct, Pt;
                return (Pt = (Ct = JSON.stringify(W(B, xt))) == null ? void 0 : Ct.toLowerCase()) == null ? void 0 : Pt.includes(Ce.toLowerCase());
              }) : k.value.some((xt) => {
                var Ct, Pt;
                return (Pt = (Ct = JSON.stringify(W(B, xt))) == null ? void 0 : Ct.toLowerCase()) == null ? void 0 : Pt.includes(Ce.toLowerCase());
              });
            } else {
              const Fe = W(B, be);
              return typeof Fe == "object" ? (Ue = (Oe = JSON.stringify(String(Fe))) == null ? void 0 : Oe.toLowerCase()) == null ? void 0 : Ue.includes(Ce.toLowerCase()) : ((J = JSON.stringify(String(Fe))) == null ? void 0 : J.toLowerCase()) === JSON.stringify(Ce).toLowerCase();
            }
          });
        });
      if (!r && m.value) {
        const B = c.columns.filter((X) => X.searchable).map((X) => X.key);
        return B.length ? L.filter((X) => B.some((be) => {
          var Ce, Oe;
          return (Oe = (Ce = JSON.stringify(W(X, be))) == null ? void 0 : Ce.toLowerCase()) == null ? void 0 : Oe.includes(m.value.toLowerCase());
        })) : L.filter((X) => k.value.some((be) => {
          var Ce, Oe;
          return (Oe = (Ce = JSON.stringify(W(X, be))) == null ? void 0 : Ce.toLowerCase()) == null ? void 0 : Oe.includes(m.value.toLowerCase());
        }));
      }
      return L;
    }), re = computed(() => c.pages ? c.pages : Math.ceil(F.value.length / S.value)), z = computed(() => {
      if (c.pages)
        return F.value;
      const L = (v.value - 1) * S.value;
      return F.value.slice(L, L + S.value);
    });
    function W(L, K) {
      return K ? K.split(".").reduce((B, X) => B == null ? void 0 : B[X], L) : L;
    }
    function C(L, K) {
      localStorage.setItem(`${c.label} - ${L}`, JSON.stringify(K));
    }
    function O(L, K) {
      const B = { ...r == null ? void 0 : r.query };
      L !== "page" && (v.value = 1), L === "sort" ? B.asc ? B.asc === K ? (delete B.asc, B.desc = K) : (B.desc && delete B.desc, B.asc = K) : B.desc ? B.desc === K ? delete B.desc : (delete B.desc, B.asc = K) : B.asc = K : L === "search" ? K ? (B.search = K, m.value = K) : (delete B.search, m.value = "") : K !== null ? (L === "page" && (v.value = K), B[L] = K) : delete B[L], o == null || o.push({ query: B });
    }
    function _(L) {
      O("sort", L), c.pages || (b.value.key === L ? b.value.order === "up" ? b.value.order = "down" : b.value = { key: null, order: null } : (b.value.key = L, b.value.order = "up"));
    }
    function T(L) {
      L === "all" ? x.value = x.value.length === z.value.length ? [] : z.value : x.value.some((K) => K[c.selectionKey] === L[c.selectionKey]) ? x.value = x.value.filter((K) => K[c.selectionKey] !== L[c.selectionKey]) : x.value.push(L), l("select", x.value);
    }
    function H(L) {
      w.value !== L ? w.value = L : w.value = null;
    }
    function Q(L) {
      if (k.value.includes(L)) {
        if (k.value.length === 1) return;
        k.value = k.value.filter((K) => K !== L);
      } else
        k.value.push(L);
      C("columns", k.value);
    }
    function ae(L) {
      E.value = { key: L, i: k.value.indexOf(L) };
    }
    function pe(L) {
      const B = document.elementFromPoint(L.clientX, L.clientY).closest(".mn-table-draggable");
      B && (M.value = { key: B.dataset.key, i: k.value.indexOf(B.dataset.key) });
    }
    function xe() {
      if (M.value.key !== E.value.key) {
        const L = [...k.value];
        L.splice(M.value.i, 0, L.splice(E.value.i, 1)[0]), k.value = L, C("columns", k.value);
      }
      E.value = null, M.value = null;
    }
    return watch(
      () => c.limit,
      (L) => {
        S.value = L;
      }
    ), watch(S, (L) => {
      C("limit", L);
    }), watch(
      () => r == null ? void 0 : r.query,
      (L) => {
        x.value = [], w.value = null;
      },
      { deep: true }
    ), onMounted(() => {
      var L, K, B, X, be, Ce, Oe, Ue;
      (L = r == null ? void 0 : r.query) != null && L.asc ? b.value = { key: (K = r == null ? void 0 : r.query) == null ? void 0 : K.asc, order: "up" } : (B = r == null ? void 0 : r.query) != null && B.desc ? b.value = { key: (X = r == null ? void 0 : r.query) == null ? void 0 : X.desc, order: "down" } : (be = r == null ? void 0 : r.query) != null && be.page ? v.value = Number((Ce = r == null ? void 0 : r.query) == null ? void 0 : Ce.page) : (Oe = r == null ? void 0 : r.query) != null && Oe.limit && (S.value = Number((Ue = r == null ? void 0 : r.query) == null ? void 0 : Ue.limit));
    }), (L, K) => (openBlock(), createElementBlock("div", JH, [
      t10.filterless ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", XH, [
        createVNode(Nr, {
          class: "mn-table-search",
          label: unref(i).t("search"),
          placeholder: unref(i).t("searchPlaceholder"),
          labelless: "",
          modelValue: m.value,
          "onUpdate:modelValue": K[0] || (K[0] = (B) => m.value = B),
          onInput: K[1] || (K[1] = (B, X) => O("search", X))
        }, null, 8, ["label", "placeholder", "modelValue"]),
        unref(a) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("dialog", {
            ref_key: "filtersMenuRef",
            ref: p,
            class: "mn-table-filters-menu",
            "aria-labelledby": `${unref(h10)}-filters-menu`,
            onClick: Y
          }, [
            createVNode(me, {
              class: "mn-table-filters-menu-close-btn",
              color: "neutral",
              label: unref(i).t("closeSecondarySidebar"),
              icon: "xmark",
              labelless: "",
              variant: "text",
              onClick: K[2] || (K[2] = (B) => {
                var X;
                return (X = p.value) == null ? void 0 : X.close();
              })
            }, null, 8, ["label"]),
            createBaseVNode("div", ZH, [
              createBaseVNode("h2", {
                id: `${unref(h10)}-filters-menu`
              }, toDisplayString(unref(Ie)(unref(i).t("filtersMenu"))), 9, eW),
              createVNode(Yb, {
                label: unref(i).t("itemsPerPage"),
                options: [t10.limit, t10.limit * 2, t10.limit * 3, t10.limit * 4],
                modelValue: S.value,
                "onUpdate:modelValue": K[3] || (K[3] = (B) => S.value = B),
                formatIn: (B) => `${B} ${unref(i).t("perPage")}`,
                onChange: K[4] || (K[4] = (B, X) => O("limit", X))
              }, null, 8, ["label", "options", "modelValue", "formatIn"]),
              createBaseVNode("div", tW, [
                renderSlot(L.$slots, "filters", {}, void 0, true)
              ])
            ])
          ], 8, QH),
          createVNode(me, {
            label: unref(i).t("filters"),
            variant: "muted",
            color: "neutral",
            icon: "far sliders",
            labelless: "",
            class: "mn-table-filters-toggle",
            onClick: K[5] || (K[5] = (B) => {
              var X;
              return (X = p.value) == null ? void 0 : X.showModal();
            })
          }, null, 8, ["label"])
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("div", nW, [
            renderSlot(L.$slots, "filters", {}, void 0, true)
          ]),
          createVNode(Yb, {
            label: unref(i).t("itemsPerPage"),
            options: [t10.limit, t10.limit * 2, t10.limit * 3, t10.limit * 4],
            modelValue: S.value,
            "onUpdate:modelValue": K[6] || (K[6] = (B) => S.value = B),
            formatIn: (B) => `${B} ${unref(i).t("perPage")}`,
            labelless: "",
            onChange: K[7] || (K[7] = (B, X) => O("limit", X))
          }, null, 8, ["label", "options", "modelValue", "formatIn"])
        ], 64))
      ])),
      createBaseVNode("section", {
        ref_key: "tableRef",
        ref: N,
        class: "mn-table-container",
        "aria-labelledby": `${unref(h10)}-label`
      }, [
        createBaseVNode("span", {
          id: `${unref(h10)}-label`,
          hidden: ""
        }, toDisplayString(t10.label), 9, sW),
        createBaseVNode("table", rW, [
          createBaseVNode("thead", oW, [
            createBaseVNode("tr", aW, [
              t10.selectable ? (openBlock(), createElementBlock("th", lW, [
                createBaseVNode("div", cW, [
                  createVNode(Jc, {
                    label: unref(i).t("selectAllRows"),
                    labelless: "",
                    modelValue: z.value.length && x.value.length === z.value.length,
                    indeterminate: x.value.length > 0 && x.value.length < z.value.length,
                    disabled: !z.value.length,
                    onChange: K[8] || (K[8] = (B) => T("all"))
                  }, null, 8, ["label", "modelValue", "indeterminate", "disabled"])
                ])
              ])) : createCommentVNode("", true),
              u.value ? (openBlock(), createElementBlock("th", uW, [
                createBaseVNode("div", dW, [
                  createBaseVNode("span", fW, toDisplayString(unref(i).t("showDetails")), 1)
                ])
              ])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList([...t10.columns].sort((B, X) => k.value.indexOf(B.key) - k.value.indexOf(X.key)), (B, X) => {
                var be, Ce;
                return openBlock(), createElementBlock("th", {
                  class: normalizeClass(["mn-table-header-cell mn-table-draggable", { "-grabbed": ((be = E.value) == null ? void 0 : be.key) === B.key, "-target": ((Ce = M.value) == null ? void 0 : Ce.key) === B.key }]),
                  hidden: !k.value.includes(B.key),
                  key: B.key,
                  "data-key": B.key,
                  style: normalizeStyle({ "--column-width": B.width || "auto" }),
                  draggable: "true",
                  onDragstart: (Oe) => ae(B.key),
                  onDragover: pe,
                  onDragend: xe
                }, [
                  createBaseVNode("div", pW, [
                    createVNode($H, {
                      class: "mn-table-column-menu",
                      label: unref(i).t("column"),
                      autoclose: ""
                    }, {
                      trigger: withCtx(() => [
                        createBaseVNode("div", mW, [
                          createBaseVNode("span", null, toDisplayString(unref(Ie)(B.label || B.key)), 1),
                          createVNode(me, {
                            label: b.value.key === B.key ? b.value.order === "up" ? unref(i).t("sortDescending") : unref(i).t("sortAscending") : unref(i).t("sortAscendingU"),
                            icon: b.value.key === B.key ? b.value.order === "up" ? "arrow-up-long" : "arrow-down-long" : "arrow-up-arrow-down",
                            disabled: !z.value.length,
                            labelless: "",
                            mirror: "",
                            variant: "text",
                            color: "neutral",
                            "aria-pressed": b.value.key === B.key,
                            onClick: (Oe) => _(B.key)
                          }, null, 8, ["label", "icon", "disabled", "aria-pressed", "onClick"])
                        ])
                      ]),
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList([...t10.columns].sort((Oe, Ue) => k.value.indexOf(Oe.key) - k.value.indexOf(Ue.key)), (Oe) => (openBlock(), createBlock(me, {
                          key: Oe.key,
                          class: normalizeClass({ "-undisplayed": !k.value.includes(Oe.key) }),
                          label: Oe.label || Oe.key,
                          variant: "text",
                          color: "neutral",
                          icon: "check",
                          role: "menuitemcheckbox",
                          "aria-checked": k.value.includes(Oe.key),
                          onClick: (Ue) => Q(Oe.key)
                        }, null, 8, ["class", "label", "aria-checked", "onClick"]))), 128))
                      ]),
                      _: 2
                    }, 1032, ["label"])
                  ])
                ], 46, hW);
              }), 128)),
              d.value || t10.selectable && f.value ? (openBlock(), createElementBlock("th", gW, [
                createBaseVNode("div", bW, [
                  t10.selectable ? renderSlot(L.$slots, "actions-all", {
                    key: 0,
                    items: x.value
                  }, void 0, true) : (openBlock(), createElementBlock("span", yW, toDisplayString(unref(i).t("actions")), 1))
                ])
              ])) : createCommentVNode("", true)
            ])
          ]),
          createBaseVNode("tbody", vW, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(z.value, (B, X) => (openBlock(), createElementBlock(Fragment, {
              key: JSON.stringify(B[t10.selectionKey]) || null
            }, [
              createBaseVNode("tr", {
                class: "mn-table-row",
                "data-row": X
              }, [
                t10.selectable ? (openBlock(), createElementBlock("td", kW, [
                  createBaseVNode("div", SW, [
                    createVNode(Jc, {
                      label: unref(i).t("selectRow"),
                      labelless: "",
                      modelValue: x.value.some((be) => be[t10.selectionKey] === B[t10.selectionKey]),
                      onChange: (be) => T(B)
                    }, null, 8, ["label", "modelValue", "onChange"])
                  ])
                ])) : createCommentVNode("", true),
                u.value ? (openBlock(), createElementBlock("td", wW, [
                  createBaseVNode("div", CW, [
                    createVNode(me, {
                      label: unref(i).t("showDetails"),
                      "aria-pressed": w.value === X,
                      variant: "text",
                      color: "neutral",
                      labelless: "",
                      icon: w.value === X ? "angle-down" : "angle-right",
                      onClick: (be) => H(X)
                    }, null, 8, ["label", "aria-pressed", "icon", "onClick"])
                  ])
                ])) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList([...t10.columns].sort((be, Ce) => k.value.indexOf(be.key) - k.value.indexOf(Ce.key)), (be) => {
                  var Ce, Oe;
                  return openBlock(), createElementBlock("td", {
                    class: normalizeClass(["mn-table-row-cell", { "-grabbed": ((Ce = E.value) == null ? void 0 : Ce.key) === be.key, "-target": ((Oe = M.value) == null ? void 0 : Oe.key) === be.key }]),
                    hidden: !k.value.includes(be.key),
                    key: be.key
                  }, [
                    createBaseVNode("div", EW, [
                      renderSlot(L.$slots, be.key, {
                        item: { ...B, mnCell: be.format ? be.format(W(B, be.key), B) : void 0 }
                      }, () => [
                        createBaseVNode("span", null, toDisplayString(be.format ? be.format(W(B, be.key), B) : W(B, be.key)), 1)
                      ], true)
                    ])
                  ], 10, OW);
                }), 128)),
                d.value || t10.selectable && f.value ? (openBlock(), createElementBlock("td", MW, [
                  createBaseVNode("div", TW, [
                    renderSlot(L.$slots, "actions", { item: B }, void 0, true)
                  ])
                ])) : createCommentVNode("", true)
              ], 8, xW),
              w.value === X ? (openBlock(), createElementBlock("tr", {
                key: 0,
                "data-row": `${X}-details`
              }, [
                createBaseVNode("td", {
                  colspan: k.value.length + (u.value ? 1 : 0) + (d.value ? 1 : 0) + (t10.selectable ? 1 : 0),
                  class: "mn-table-row-details"
                }, [
                  createBaseVNode("div", NW, [
                    renderSlot(L.$slots, "details", { item: B }, void 0, true)
                  ])
                ], 8, _W)
              ], 8, AW)) : createCommentVNode("", true)
            ], 64))), 128))
          ])
        ]),
        withDirectives(createBaseVNode("div", LW, [
          renderSlot(L.$slots, "empty", {}, void 0, true)
        ], 512), [
          [vShow, !z.value.length]
        ])
      ], 8, iW),
      (c.pages ? Number(c.pages) > 1 : re.value > 1) ? (openBlock(), createBlock($P, {
        key: 1,
        label: `${t10.label}, ${unref(i).t("pagination")}`,
        total: c.pages ? Number(c.pages) : re.value,
        current: v.value,
        onNavigate: K[9] || (K[9] = (B) => O("page", B))
      }, null, 8, ["label", "total", "current"])) : createCommentVNode("", true)
    ]));
  }
});
var IZ = Me(IW, [["__scopeId", "data-v-671e1377"]]);
var PW = ["id"];
var DW = { key: 0 };
var $W = { class: "mn-tabs-controls" };
var RW = ["aria-labelledby"];
var FW = ["id", "aria-labelledby"];
var VW = Object.assign({ name: "mn-tabs" }, {
  __name: "tabs",
  props: {
    label: {
      type: String,
      required: true
    },
    tabs: {
      type: Array,
      required: true
    },
    size: {
      type: String,
      default: "wide",
      validator: (t10) => ["small", "medium", "large", "wide"].includes(String(t10))
    },
    navigation: Boolean
  },
  setup(t10) {
    const e = useId(), n = t10, i = ref(0), s = zm(), r = useRoute(), o = useRouter();
    function a(h10) {
      i.value = h10, n.navigation ? o.push(n.tabs[h10].path) : typeof n.tabs[h10] == "string" ? o.replace({ query: { tab: n.tabs[h10] } }) : o.replace({ query: { tab: n.tabs[h10].code } });
    }
    function l(h10) {
      const p = h10.target.previousElementSibling;
      (p == null ? void 0 : p.type) === "button" ? (p.focus(), i.value = Array.from(p.parentElement.children).indexOf(p)) : (i.value = Array.from(h10.target.parentElement.children).length - 1, h10.target.parentElement.lastElementChild.focus());
    }
    function c(h10) {
      const p = h10.target.nextElementSibling;
      (p == null ? void 0 : p.type) === "button" ? (p.focus(), i.value = Array.from(p.parentElement.children).indexOf(p)) : (i.value = 0, h10.target.parentElement.firstElementChild.focus());
    }
    function u(h10) {
      s.value === "ltr" ? l(h10) : c(h10);
    }
    function d(h10) {
      s.value === "ltr" ? c(h10) : l(h10);
    }
    function f(h10) {
      h10.preventDefault();
      const p = document.getElementById(`${e}-panel-${i.value}`);
      p && p.focus();
    }
    return watch(
      r,
      () => {
        const h10 = n.tabs.findIndex((p) => n.navigation && p.path ? p.path.includes(r == null ? void 0 : r.path) : typeof p == "string" ? (r == null ? void 0 : r.query.tab) === p : (r == null ? void 0 : r.query.tab) === p.code);
        h10 !== -1 && (i.value = h10);
      },
      { immediate: true }
    ), (h10, p) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["mn-tabs", t10.size])
    }, [
      createBaseVNode("span", {
        id: `${unref(e)}-label`,
        hidden: ""
      }, toDisplayString(t10.label), 9, PW),
      t10.navigation ? (openBlock(), createElementBlock("nav", DW, [
        createBaseVNode("ul", $W, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(t10.tabs, (g, m) => (openBlock(), createElementBlock("li", {
            key: JSON.stringify(g)
          }, [
            createVNode(ds, {
              label: g.label || g,
              icon: g.icon || null,
              variant: m === i.value ? "full" : "text",
              tabindex: m === i.value ? 0 : -1,
              "aria-current": m === i.value ? "page" : null,
              color: "neutral",
              wide: "",
              path: g.path,
              onClick: (b) => a(m),
              onKeydown: [
                withKeys(u, ["left"]),
                withKeys(d, ["right"])
              ]
            }, null, 8, ["label", "icon", "variant", "tabindex", "aria-current", "path", "onClick"])
          ]))), 128))
        ])
      ])) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: "mn-tabs-controls",
        role: "tablist",
        "aria-labelledby": `${unref(e)}-label`
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(t10.tabs, (g, m) => (openBlock(), createBlock(me, {
          key: JSON.stringify(g),
          label: g.label || g,
          icon: g.icon || null,
          variant: m === i.value ? "full" : "text",
          "aria-selected": m === i.value,
          id: `${unref(e)}-control-${m}`,
          "aria-controls": `${unref(e)}-panel-${m}`,
          tabindex: m === i.value ? 0 : -1,
          color: "neutral",
          role: "tab",
          wide: "",
          onClick: (b) => a(m),
          onKeydown: [
            withKeys(u, ["left"]),
            withKeys(d, ["right"]),
            withKeys(withModifiers(f, ["exact"]), ["tab"])
          ]
        }, null, 8, ["label", "icon", "variant", "aria-selected", "id", "aria-controls", "tabindex", "onClick", "onKeydown"]))), 128))
      ], 8, RW)),
      t10.navigation ? renderSlot(h10.$slots, "default", { key: 2 }, void 0, true) : (openBlock(true), createElementBlock(Fragment, { key: 3 }, renderList(t10.tabs, (g, m) => withDirectives((openBlock(), createElementBlock("div", {
        key: JSON.stringify(g),
        id: `${unref(e)}-panel-${m}`,
        "aria-labelledby": `${unref(e)}-control-${m}`,
        class: "mn-tabs-panel",
        role: "tabpanel",
        tabindex: "0"
      }, [
        renderSlot(h10.$slots, g.code || g, { item: g }, void 0, true)
      ], 8, FW)), [
        [vShow, m === i.value]
      ])), 128))
    ], 2));
  }
});
var PZ = Me(VW, [["__scopeId", "data-v-1006096a"]]);
var BW = ["data-placement"];
var zW = {
  class: "mn-notification-body",
  role: "status",
  "aria-live": "polite",
  "aria-atomic": "true"
};
var jW = Object.assign({ name: "mn-notification" }, {
  __name: "notification",
  props: {
    modelValue: Array,
    index: Number,
    notification: Object,
    depth: Number,
    placement: String,
    duration: Number,
    expanded: Boolean,
    interacting: Boolean,
    visible: Boolean
  },
  emits: ["removeNotification", "update:modelValue"],
  setup(t10, { emit: e }) {
    useCssVars((W) => {
      var C;
      return {
        "46647b46": `${(C = t10.modelValue[0]) == null ? void 0 : C.height}px`,
        "334d0e9b": `${u.value}px`,
        "53aec926": t10.index,
        "53646b17": t10.depth,
        "47cb47b1": `${o.value ? c.value : p.value}px`
      };
    });
    const n = inject("minuit"), i = e, s = t10, r = ref(false), o = ref(false), a = ref(false), l = ref(false), c = ref(0), u = ref(0), d = ref(null), f = ref(null), h10 = ref(0), p = ref(0), g = ref(0), m = ref(null), b = computed(() => s.index === 0), x = computed(() => s.notification.type), k = computed(() => s.modelValue.findIndex((W) => W.notificationId === s.notification.id) || 0), v = computed(() => s.placement.split("-")), S = computed(() => x.value === "loading"), w = computed(() => s.modelValue.reduce((W, C, O) => O >= k.value ? W : W + C.height, 0)), E = ref(s.duration);
    function M(W) {
      switch (W.type) {
        case "success":
          return "far circle-check";
        case "warning":
          return "far triangle-exclamation";
        case "error":
          return "far circle-exclamation";
        case "loading":
          return "far circle-notch";
        default:
          return W.icon || "sparkles";
      }
    }
    function N(W) {
      var C, O;
      (O = (C = s.notification.action) == null ? void 0 : C.onClick) == null || O.call(C, W), !W.defaultPrevented && V();
    }
    onMounted(() => {
      if (!r.value) return;
      const W = f.value, C = W == null ? void 0 : W.style.height;
      W.style.height = "auto";
      const O = W.getBoundingClientRect().height;
      W.style.height = C, u.value = O;
      let _;
      s.modelValue.find((H) => H.notificationId === s.notification.id) ? _ = s.modelValue.map((H) => H.notificationId === s.notification.id ? { ...H, height: O } : H) : _ = [
        {
          notificationId: s.notification.id,
          height: O,
          placement: s.notification.placement
        },
        ...s.modelValue
      ], i("update:modelValue", _);
    });
    const V = () => {
      o.value = true, c.value = p.value;
      const W = s.modelValue.filter((C) => C.notificationId !== s.notification.id);
      i("update:modelValue", W), setTimeout(() => i("removeNotification", s.notification), 200);
    }, Y = () => {
      var W, C;
      S.value || (V(), (C = (W = s.notification).onDismiss) == null || C.call(W, s.notification));
    }, F = (W) => {
      S.value || (d.value = /* @__PURE__ */ new Date(), c.value = p.value, W.target.setPointerCapture(W.pointerId), W.target.tagName !== "BUTTON" && (a.value = true, m.value = { x: W.clientX, y: W.clientY }));
    }, re = (W) => {
      var ae;
      if (!m.value) return;
      const C = W.clientY - m.value.y, O = W.clientX - m.value.x, T = (v.value[0] === "start" ? Math.min : Math.max)(0, C), H = W.pointerType === "touch" ? 10 : 2;
      Math.abs(T) > H ? (ae = f.value) == null || ae.style.setProperty("--swipe-amount", `${C}px`) : Math.abs(O) > H && (m.value = null);
    }, z = (W) => {
      var T, H, Q, ae, pe, xe;
      if (l.value) return;
      m.value = null;
      const C = Number(((T = f.value) == null ? void 0 : T.style.getPropertyValue("--swipe-amount").replace("px", "")) || 0), O = ((H = /* @__PURE__ */ new Date()) == null ? void 0 : H.getTime()) - ((Q = d.value) == null ? void 0 : Q.getTime()), _ = Math.abs(C) / O;
      if (Math.abs(C) >= 20 || _ > 0.11) {
        c.value = p.value, (pe = (ae = s.notification).onDismiss) == null || pe.call(ae, s.notification), V(), l.value = true;
        return;
      }
      (xe = f.value) == null || xe.style.setProperty("--swipe-amount", "0px"), a.value = false;
    };
    return watchEffect(() => p.value = k.value * 14 + w.value), watchEffect((W) => {
      if (s.notification.promise && x.value === "loading" || s.notification.type === "loading" || s.notification.duration === 1 / 0) return;
      let C;
      const O = () => {
        var T, H;
        if (g.value < h10.value) {
          const Q = ((T = /* @__PURE__ */ new Date()) == null ? void 0 : T.getTime()) - h10.value;
          E.value = E.value - Q;
        }
        g.value = (H = /* @__PURE__ */ new Date()) == null ? void 0 : H.getTime();
      }, _ = () => {
        var T;
        h10.value = (T = /* @__PURE__ */ new Date()) == null ? void 0 : T.getTime(), C = setTimeout(() => {
          var H, Q;
          (Q = (H = s.notification).onAutoClose) == null || Q.call(H, s.notification), V();
        }, E.value);
      };
      s.expanded || s.interacting ? O() : _(), W(() => clearTimeout(C));
    }), watchEffect(() => s.notification.delete && V()), onMounted(() => {
      if (f.value) {
        const W = f.value.getBoundingClientRect().height;
        u.value = W;
        const C = [{ notificationId: s.notification.id, height: W, placement: s.notification.placement }, ...s.modelValue];
        i("update:modelValue", C);
      }
      r.value = true;
    }), onUnmounted(() => {
      if (f.value) {
        const W = s.modelValue.filter((C) => C.notificationId !== s.notification.id);
        i("update:modelValue", W);
      }
    }), (W, C) => (openBlock(), createElementBlock("li", {
      ref_key: "notificationRef",
      ref: f,
      class: normalizeClass(["mn-notification", [x.value, { "-visible": t10.visible, "-expanded": t10.expanded, "-on": r.value, "-first": b.value, "-swiping": a.value, "-swiped": l.value, "-off": o.value }]]),
      tabindex: "0",
      "data-placement": s.placement,
      onPointerdown: F,
      onPointermove: re,
      onPointerup: z
    }, [
      createBaseVNode("div", zW, [
        createVNode(ft, {
          class: "mn-notification-icon",
          label: x.value !== "default" ? x.value : null,
          icon: M(t10.notification),
          spin: x.value === "loading"
        }, null, 8, ["label", "icon", "spin"]),
        createVNode(ui, {
          class: "mn-notification-title",
          lines: 1
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(Ie)(t10.notification.title)), 1)
          ]),
          _: 1
        }),
        createVNode(me, {
          class: "mn-notification-close",
          variant: "text",
          color: "neutral",
          label: unref(n).t("close"),
          icon: "xmark",
          labelless: "",
          disabled: S.value,
          onClick: Y
        }, null, 8, ["label", "disabled"]),
        t10.notification.description ? (openBlock(), createBlock(ui, {
          key: 0,
          class: "mn-notification-description",
          muted: ""
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(Ie)(t10.notification.description)), 1)
          ]),
          _: 1
        })) : createCommentVNode("", true),
        t10.notification.action ? (openBlock(), createBlock(me, {
          key: 1,
          class: "mn-notification-action",
          label: t10.notification.action.label,
          variant: "border",
          color: "neutral",
          onClick: N
        }, null, 8, ["label"])) : createCommentVNode("", true)
      ])
    ], 42, BW));
  }
});
var HW = Me(jW, [["__scopeId", "data-v-2c3b450e"]]);
function Fl(t10) {
  return t10 + 0.5 | 0;
}
var Bs = (t10, e, n) => Math.max(Math.min(t10, n), e);
function Sa(t10) {
  return Bs(Fl(t10 * 2.55), 0, 255);
}
function Ys(t10) {
  return Bs(Fl(t10 * 255), 0, 255);
}
function us(t10) {
  return Bs(Fl(t10 / 2.55) / 100, 0, 1);
}
function Gb(t10) {
  return Bs(Fl(t10 * 100), 0, 100);
}
var ti = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var sp = [..."0123456789ABCDEF"];
var WW = (t10) => sp[t10 & 15];
var UW = (t10) => sp[(t10 & 240) >> 4] + sp[t10 & 15];
var ic = (t10) => (t10 & 240) >> 4 === (t10 & 15);
var qW = (t10) => ic(t10.r) && ic(t10.g) && ic(t10.b) && ic(t10.a);
function KW(t10) {
  var e = t10.length, n;
  return t10[0] === "#" && (e === 4 || e === 5 ? n = {
    r: 255 & ti[t10[1]] * 17,
    g: 255 & ti[t10[2]] * 17,
    b: 255 & ti[t10[3]] * 17,
    a: e === 5 ? ti[t10[4]] * 17 : 255
  } : (e === 7 || e === 9) && (n = {
    r: ti[t10[1]] << 4 | ti[t10[2]],
    g: ti[t10[3]] << 4 | ti[t10[4]],
    b: ti[t10[5]] << 4 | ti[t10[6]],
    a: e === 9 ? ti[t10[7]] << 4 | ti[t10[8]] : 255
  })), n;
}
var YW = (t10, e) => t10 < 255 ? e(t10) : "";
function GW(t10) {
  var e = qW(t10) ? WW : UW;
  return t10 ? "#" + e(t10.r) + e(t10.g) + e(t10.b) + YW(t10.a, e) : void 0;
}
var JW = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function Jk(t10, e, n) {
  const i = e * Math.min(n, 1 - n), s = (r, o = (r + t10 / 30) % 12) => n - i * Math.max(Math.min(o - 3, 9 - o, 1), -1);
  return [s(0), s(8), s(4)];
}
function XW(t10, e, n) {
  const i = (s, r = (s + t10 / 60) % 6) => n - n * e * Math.max(Math.min(r, 4 - r, 1), 0);
  return [i(5), i(3), i(1)];
}
function QW(t10, e, n) {
  const i = Jk(t10, 1, 0.5);
  let s;
  for (e + n > 1 && (s = 1 / (e + n), e *= s, n *= s), s = 0; s < 3; s++)
    i[s] *= 1 - e - n, i[s] += e;
  return i;
}
function ZW(t10, e, n, i, s) {
  return t10 === s ? (e - n) / i + (e < n ? 6 : 0) : e === s ? (n - t10) / i + 2 : (t10 - e) / i + 4;
}
function jm(t10) {
  const n = t10.r / 255, i = t10.g / 255, s = t10.b / 255, r = Math.max(n, i, s), o = Math.min(n, i, s), a = (r + o) / 2;
  let l, c, u;
  return r !== o && (u = r - o, c = a > 0.5 ? u / (2 - r - o) : u / (r + o), l = ZW(n, i, s, u, r), l = l * 60 + 0.5), [l | 0, c || 0, a];
}
function Hm(t10, e, n, i) {
  return (Array.isArray(e) ? t10(e[0], e[1], e[2]) : t10(e, n, i)).map(Ys);
}
function Wm(t10, e, n) {
  return Hm(Jk, t10, e, n);
}
function eU(t10, e, n) {
  return Hm(QW, t10, e, n);
}
function tU(t10, e, n) {
  return Hm(XW, t10, e, n);
}
function Xk(t10) {
  return (t10 % 360 + 360) % 360;
}
function nU(t10) {
  const e = JW.exec(t10);
  let n = 255, i;
  if (!e)
    return;
  e[5] !== i && (n = e[6] ? Sa(+e[5]) : Ys(+e[5]));
  const s = Xk(+e[2]), r = +e[3] / 100, o = +e[4] / 100;
  return e[1] === "hwb" ? i = eU(s, r, o) : e[1] === "hsv" ? i = tU(s, r, o) : i = Wm(s, r, o), {
    r: i[0],
    g: i[1],
    b: i[2],
    a: n
  };
}
function iU(t10, e) {
  var n = jm(t10);
  n[0] = Xk(n[0] + e), n = Wm(n), t10.r = n[0], t10.g = n[1], t10.b = n[2];
}
function sU(t10) {
  if (!t10)
    return;
  const e = jm(t10), n = e[0], i = Gb(e[1]), s = Gb(e[2]);
  return t10.a < 255 ? `hsla(${n}, ${i}%, ${s}%, ${us(t10.a)})` : `hsl(${n}, ${i}%, ${s}%)`;
}
var Jb = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var Xb = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function rU() {
  const t10 = {}, e = Object.keys(Xb), n = Object.keys(Jb);
  let i, s, r, o, a;
  for (i = 0; i < e.length; i++) {
    for (o = a = e[i], s = 0; s < n.length; s++)
      r = n[s], a = a.replace(r, Jb[r]);
    r = parseInt(Xb[o], 16), t10[a] = [r >> 16 & 255, r >> 8 & 255, r & 255];
  }
  return t10;
}
var sc;
function oU(t10) {
  sc || (sc = rU(), sc.transparent = [0, 0, 0, 0]);
  const e = sc[t10.toLowerCase()];
  return e && {
    r: e[0],
    g: e[1],
    b: e[2],
    a: e.length === 4 ? e[3] : 255
  };
}
var aU = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function lU(t10) {
  const e = aU.exec(t10);
  let n = 255, i, s, r;
  if (e) {
    if (e[7] !== i) {
      const o = +e[7];
      n = e[8] ? Sa(o) : Bs(o * 255, 0, 255);
    }
    return i = +e[1], s = +e[3], r = +e[5], i = 255 & (e[2] ? Sa(i) : Bs(i, 0, 255)), s = 255 & (e[4] ? Sa(s) : Bs(s, 0, 255)), r = 255 & (e[6] ? Sa(r) : Bs(r, 0, 255)), {
      r: i,
      g: s,
      b: r,
      a: n
    };
  }
}
function cU(t10) {
  return t10 && (t10.a < 255 ? `rgba(${t10.r}, ${t10.g}, ${t10.b}, ${us(t10.a)})` : `rgb(${t10.r}, ${t10.g}, ${t10.b})`);
}
var Pf = (t10) => t10 <= 31308e-7 ? t10 * 12.92 : Math.pow(t10, 1 / 2.4) * 1.055 - 0.055;
var co = (t10) => t10 <= 0.04045 ? t10 / 12.92 : Math.pow((t10 + 0.055) / 1.055, 2.4);
function uU(t10, e, n) {
  const i = co(us(t10.r)), s = co(us(t10.g)), r = co(us(t10.b));
  return {
    r: Ys(Pf(i + n * (co(us(e.r)) - i))),
    g: Ys(Pf(s + n * (co(us(e.g)) - s))),
    b: Ys(Pf(r + n * (co(us(e.b)) - r))),
    a: t10.a + n * (e.a - t10.a)
  };
}
function rc(t10, e, n) {
  if (t10) {
    let i = jm(t10);
    i[e] = Math.max(0, Math.min(i[e] + i[e] * n, e === 0 ? 360 : 1)), i = Wm(i), t10.r = i[0], t10.g = i[1], t10.b = i[2];
  }
}
function Qk(t10, e) {
  return t10 && Object.assign(e || {}, t10);
}
function Qb(t10) {
  var e = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(t10) ? t10.length >= 3 && (e = { r: t10[0], g: t10[1], b: t10[2], a: 255 }, t10.length > 3 && (e.a = Ys(t10[3]))) : (e = Qk(t10, { r: 0, g: 0, b: 0, a: 1 }), e.a = Ys(e.a)), e;
}
function dU(t10) {
  return t10.charAt(0) === "r" ? lU(t10) : nU(t10);
}
var bl = class _bl {
  constructor(e) {
    if (e instanceof _bl)
      return e;
    const n = typeof e;
    let i;
    n === "object" ? i = Qb(e) : n === "string" && (i = KW(e) || oU(e) || dU(e)), this._rgb = i, this._valid = !!i;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var e = Qk(this._rgb);
    return e && (e.a = us(e.a)), e;
  }
  set rgb(e) {
    this._rgb = Qb(e);
  }
  rgbString() {
    return this._valid ? cU(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? GW(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? sU(this._rgb) : void 0;
  }
  mix(e, n) {
    if (e) {
      const i = this.rgb, s = e.rgb;
      let r;
      const o = n === r ? 0.5 : n, a = 2 * o - 1, l = i.a - s.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
      r = 1 - c, i.r = 255 & c * i.r + r * s.r + 0.5, i.g = 255 & c * i.g + r * s.g + 0.5, i.b = 255 & c * i.b + r * s.b + 0.5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i;
    }
    return this;
  }
  interpolate(e, n) {
    return e && (this._rgb = uU(this._rgb, e._rgb, n)), this;
  }
  clone() {
    return new _bl(this.rgb);
  }
  alpha(e) {
    return this._rgb.a = Ys(e), this;
  }
  clearer(e) {
    const n = this._rgb;
    return n.a *= 1 - e, this;
  }
  greyscale() {
    const e = this._rgb, n = Fl(e.r * 0.3 + e.g * 0.59 + e.b * 0.11);
    return e.r = e.g = e.b = n, this;
  }
  opaquer(e) {
    const n = this._rgb;
    return n.a *= 1 + e, this;
  }
  negate() {
    const e = this._rgb;
    return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this;
  }
  lighten(e) {
    return rc(this._rgb, 2, e), this;
  }
  darken(e) {
    return rc(this._rgb, 2, -e), this;
  }
  saturate(e) {
    return rc(this._rgb, 1, e), this;
  }
  desaturate(e) {
    return rc(this._rgb, 1, -e), this;
  }
  rotate(e) {
    return iU(this._rgb, e), this;
  }
};
function es() {
}
var fU = /* @__PURE__ */ (() => {
  let t10 = 0;
  return () => t10++;
})();
function et(t10) {
  return t10 == null;
}
function wt(t10) {
  if (Array.isArray && Array.isArray(t10))
    return true;
  const e = Object.prototype.toString.call(t10);
  return e.slice(0, 7) === "[object" && e.slice(-6) === "Array]";
}
function Je(t10) {
  return t10 !== null && Object.prototype.toString.call(t10) === "[object Object]";
}
function Yt(t10) {
  return (typeof t10 == "number" || t10 instanceof Number) && isFinite(+t10);
}
function Ci(t10, e) {
  return Yt(t10) ? t10 : e;
}
function Ke(t10, e) {
  return typeof t10 > "u" ? e : t10;
}
var hU = (t10, e) => typeof t10 == "string" && t10.endsWith("%") ? parseFloat(t10) / 100 : +t10 / e;
var Zk = (t10, e) => typeof t10 == "string" && t10.endsWith("%") ? parseFloat(t10) / 100 * e : +t10;
function pt(t10, e, n) {
  if (t10 && typeof t10.call == "function")
    return t10.apply(n, e);
}
function ot(t10, e, n, i) {
  let s, r, o;
  if (wt(t10))
    for (r = t10.length, s = 0; s < r; s++)
      e.call(n, t10[s], s);
  else if (Je(t10))
    for (o = Object.keys(t10), r = o.length, s = 0; s < r; s++)
      e.call(n, t10[o[s]], o[s]);
}
function Vu(t10, e) {
  let n, i, s, r;
  if (!t10 || !e || t10.length !== e.length)
    return false;
  for (n = 0, i = t10.length; n < i; ++n)
    if (s = t10[n], r = e[n], s.datasetIndex !== r.datasetIndex || s.index !== r.index)
      return false;
  return true;
}
function Bu(t10) {
  if (wt(t10))
    return t10.map(Bu);
  if (Je(t10)) {
    const e = /* @__PURE__ */ Object.create(null), n = Object.keys(t10), i = n.length;
    let s = 0;
    for (; s < i; ++s)
      e[n[s]] = Bu(t10[n[s]]);
    return e;
  }
  return t10;
}
function e4(t10) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(t10) === -1;
}
function pU(t10, e, n, i) {
  if (!e4(t10))
    return;
  const s = e[t10], r = n[t10];
  Je(s) && Je(r) ? yl(s, r, i) : e[t10] = Bu(r);
}
function yl(t10, e, n) {
  const i = wt(e) ? e : [
    e
  ], s = i.length;
  if (!Je(t10))
    return t10;
  n = n || {};
  const r = n.merger || pU;
  let o;
  for (let a = 0; a < s; ++a) {
    if (o = i[a], !Je(o))
      continue;
    const l = Object.keys(o);
    for (let c = 0, u = l.length; c < u; ++c)
      r(l[c], t10, o, n);
  }
  return t10;
}
function Ka(t10, e) {
  return yl(t10, e, {
    merger: mU
  });
}
function mU(t10, e, n) {
  if (!e4(t10))
    return;
  const i = e[t10], s = n[t10];
  Je(i) && Je(s) ? Ka(i, s) : Object.prototype.hasOwnProperty.call(e, t10) || (e[t10] = Bu(s));
}
var Zb = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (t10) => t10,
  // default resolvers
  x: (t10) => t10.x,
  y: (t10) => t10.y
};
function gU(t10) {
  const e = t10.split("."), n = [];
  let i = "";
  for (const s of e)
    i += s, i.endsWith("\\") ? i = i.slice(0, -1) + "." : (n.push(i), i = "");
  return n;
}
function bU(t10) {
  const e = gU(t10);
  return (n) => {
    for (const i of e) {
      if (i === "")
        break;
      n = n && n[i];
    }
    return n;
  };
}
function sr(t10, e) {
  return (Zb[e] || (Zb[e] = bU(e)))(t10);
}
function Um(t10) {
  return t10.charAt(0).toUpperCase() + t10.slice(1);
}
var vl = (t10) => typeof t10 < "u";
var rr = (t10) => typeof t10 == "function";
var ey = (t10, e) => {
  if (t10.size !== e.size)
    return false;
  for (const n of t10)
    if (!e.has(n))
      return false;
  return true;
};
function yU(t10) {
  return t10.type === "mouseup" || t10.type === "click" || t10.type === "contextmenu";
}
var _t = Math.PI;
var bt = 2 * _t;
var vU = bt + _t;
var zu = Number.POSITIVE_INFINITY;
var xU = _t / 180;
var Lt = _t / 2;
var gr = _t / 4;
var ty = _t * 2 / 3;
var t4 = Math.log10;
var ji = Math.sign;
function Ya(t10, e, n) {
  return Math.abs(t10 - e) < n;
}
function ny(t10) {
  const e = Math.round(t10);
  t10 = Ya(t10, e, t10 / 1e3) ? e : t10;
  const n = Math.pow(10, Math.floor(t4(t10))), i = t10 / n;
  return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * n;
}
function kU(t10) {
  const e = [], n = Math.sqrt(t10);
  let i;
  for (i = 1; i < n; i++)
    t10 % i === 0 && (e.push(i), e.push(t10 / i));
  return n === (n | 0) && e.push(n), e.sort((s, r) => s - r).pop(), e;
}
function SU(t10) {
  return typeof t10 == "symbol" || typeof t10 == "object" && t10 !== null && !(Symbol.toPrimitive in t10 || "toString" in t10 || "valueOf" in t10);
}
function xl(t10) {
  return !SU(t10) && !isNaN(parseFloat(t10)) && isFinite(t10);
}
function wU(t10, e) {
  const n = Math.round(t10);
  return n - e <= t10 && n + e >= t10;
}
function CU(t10, e, n) {
  let i, s, r;
  for (i = 0, s = t10.length; i < s; i++)
    r = t10[i][n], isNaN(r) || (e.min = Math.min(e.min, r), e.max = Math.max(e.max, r));
}
function $i(t10) {
  return t10 * (_t / 180);
}
function qm(t10) {
  return t10 * (180 / _t);
}
function iy(t10) {
  if (!Yt(t10))
    return;
  let e = 1, n = 0;
  for (; Math.round(t10 * e) / e !== t10; )
    e *= 10, n++;
  return n;
}
function n4(t10, e) {
  const n = e.x - t10.x, i = e.y - t10.y, s = Math.sqrt(n * n + i * i);
  let r = Math.atan2(i, n);
  return r < -0.5 * _t && (r += bt), {
    angle: r,
    distance: s
  };
}
function rp(t10, e) {
  return Math.sqrt(Math.pow(e.x - t10.x, 2) + Math.pow(e.y - t10.y, 2));
}
function OU(t10, e) {
  return (t10 - e + vU) % bt - _t;
}
function zn(t10) {
  return (t10 % bt + bt) % bt;
}
function kl(t10, e, n, i) {
  const s = zn(t10), r = zn(e), o = zn(n), a = zn(r - s), l = zn(o - s), c = zn(s - r), u = zn(s - o);
  return s === r || s === o || i && r === o || a > l && c < u;
}
function sn(t10, e, n) {
  return Math.max(e, Math.min(n, t10));
}
function EU(t10) {
  return sn(t10, -32768, 32767);
}
function ps(t10, e, n, i = 1e-6) {
  return t10 >= Math.min(e, n) - i && t10 <= Math.max(e, n) + i;
}
function Km(t10, e, n) {
  n = n || ((o) => t10[o] < e);
  let i = t10.length - 1, s = 0, r;
  for (; i - s > 1; )
    r = s + i >> 1, n(r) ? s = r : i = r;
  return {
    lo: s,
    hi: i
  };
}
var Lr = (t10, e, n, i) => Km(t10, n, i ? (s) => {
  const r = t10[s][e];
  return r < n || r === n && t10[s + 1][e] === n;
} : (s) => t10[s][e] < n);
var MU = (t10, e, n) => Km(t10, n, (i) => t10[i][e] >= n);
function TU(t10, e, n) {
  let i = 0, s = t10.length;
  for (; i < s && t10[i] < e; )
    i++;
  for (; s > i && t10[s - 1] > n; )
    s--;
  return i > 0 || s < t10.length ? t10.slice(i, s) : t10;
}
var i4 = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function AU(t10, e) {
  if (t10._chartjs) {
    t10._chartjs.listeners.push(e);
    return;
  }
  Object.defineProperty(t10, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        e
      ]
    }
  }), i4.forEach((n) => {
    const i = "_onData" + Um(n), s = t10[n];
    Object.defineProperty(t10, n, {
      configurable: true,
      enumerable: false,
      value(...r) {
        const o = s.apply(this, r);
        return t10._chartjs.listeners.forEach((a) => {
          typeof a[i] == "function" && a[i](...r);
        }), o;
      }
    });
  });
}
function sy(t10, e) {
  const n = t10._chartjs;
  if (!n)
    return;
  const i = n.listeners, s = i.indexOf(e);
  s !== -1 && i.splice(s, 1), !(i.length > 0) && (i4.forEach((r) => {
    delete t10[r];
  }), delete t10._chartjs);
}
function s4(t10) {
  const e = new Set(t10);
  return e.size === t10.length ? t10 : Array.from(e);
}
var r4 = function() {
  return typeof window > "u" ? function(t10) {
    return t10();
  } : window.requestAnimationFrame;
}();
function o4(t10, e) {
  let n = [], i = false;
  return function(...s) {
    n = s, i || (i = true, r4.call(window, () => {
      i = false, t10.apply(e, n);
    }));
  };
}
function _U(t10, e) {
  let n;
  return function(...i) {
    return e ? (clearTimeout(n), n = setTimeout(t10, e, i)) : t10.apply(this, i), e;
  };
}
var a4 = (t10) => t10 === "start" ? "left" : t10 === "end" ? "right" : "center";
var Fn = (t10, e, n) => t10 === "start" ? e : t10 === "end" ? n : (e + n) / 2;
var NU = (t10, e, n, i) => t10 === (i ? "left" : "right") ? n : t10 === "center" ? (e + n) / 2 : e;
function LU(t10, e, n) {
  const i = e.length;
  let s = 0, r = i;
  if (t10._sorted) {
    const { iScale: o, vScale: a, _parsed: l } = t10, c = t10.dataset && t10.dataset.options ? t10.dataset.options.spanGaps : null, u = o.axis, { min: d, max: f, minDefined: h10, maxDefined: p } = o.getUserBounds();
    if (h10) {
      if (s = Math.min(
        // @ts-expect-error Need to type _parsed
        Lr(l, u, d).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        n ? i : Lr(e, u, o.getPixelForValue(d)).lo
      ), c) {
        const g = l.slice(0, s + 1).reverse().findIndex((m) => !et(m[a.axis]));
        s -= Math.max(0, g);
      }
      s = sn(s, 0, i - 1);
    }
    if (p) {
      let g = Math.max(
        // @ts-expect-error Need to type _parsed
        Lr(l, o.axis, f, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        n ? 0 : Lr(e, u, o.getPixelForValue(f), true).hi + 1
      );
      if (c) {
        const m = l.slice(g - 1).findIndex((b) => !et(b[a.axis]));
        g += Math.max(0, m);
      }
      r = sn(g, s, i) - s;
    } else
      r = i - s;
  }
  return {
    start: s,
    count: r
  };
}
function IU(t10) {
  const { xScale: e, yScale: n, _scaleRanges: i } = t10, s = {
    xmin: e.min,
    xmax: e.max,
    ymin: n.min,
    ymax: n.max
  };
  if (!i)
    return t10._scaleRanges = s, true;
  const r = i.xmin !== e.min || i.xmax !== e.max || i.ymin !== n.min || i.ymax !== n.max;
  return Object.assign(i, s), r;
}
var oc = (t10) => t10 === 0 || t10 === 1;
var ry = (t10, e, n) => -(Math.pow(2, 10 * (t10 -= 1)) * Math.sin((t10 - e) * bt / n));
var oy = (t10, e, n) => Math.pow(2, -10 * t10) * Math.sin((t10 - e) * bt / n) + 1;
var Ga = {
  linear: (t10) => t10,
  easeInQuad: (t10) => t10 * t10,
  easeOutQuad: (t10) => -t10 * (t10 - 2),
  easeInOutQuad: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 : -0.5 * (--t10 * (t10 - 2) - 1),
  easeInCubic: (t10) => t10 * t10 * t10,
  easeOutCubic: (t10) => (t10 -= 1) * t10 * t10 + 1,
  easeInOutCubic: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 * t10 : 0.5 * ((t10 -= 2) * t10 * t10 + 2),
  easeInQuart: (t10) => t10 * t10 * t10 * t10,
  easeOutQuart: (t10) => -((t10 -= 1) * t10 * t10 * t10 - 1),
  easeInOutQuart: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 * t10 * t10 : -0.5 * ((t10 -= 2) * t10 * t10 * t10 - 2),
  easeInQuint: (t10) => t10 * t10 * t10 * t10 * t10,
  easeOutQuint: (t10) => (t10 -= 1) * t10 * t10 * t10 * t10 + 1,
  easeInOutQuint: (t10) => (t10 /= 0.5) < 1 ? 0.5 * t10 * t10 * t10 * t10 * t10 : 0.5 * ((t10 -= 2) * t10 * t10 * t10 * t10 + 2),
  easeInSine: (t10) => -Math.cos(t10 * Lt) + 1,
  easeOutSine: (t10) => Math.sin(t10 * Lt),
  easeInOutSine: (t10) => -0.5 * (Math.cos(_t * t10) - 1),
  easeInExpo: (t10) => t10 === 0 ? 0 : Math.pow(2, 10 * (t10 - 1)),
  easeOutExpo: (t10) => t10 === 1 ? 1 : -Math.pow(2, -10 * t10) + 1,
  easeInOutExpo: (t10) => oc(t10) ? t10 : t10 < 0.5 ? 0.5 * Math.pow(2, 10 * (t10 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t10 * 2 - 1)) + 2),
  easeInCirc: (t10) => t10 >= 1 ? t10 : -(Math.sqrt(1 - t10 * t10) - 1),
  easeOutCirc: (t10) => Math.sqrt(1 - (t10 -= 1) * t10),
  easeInOutCirc: (t10) => (t10 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t10 * t10) - 1) : 0.5 * (Math.sqrt(1 - (t10 -= 2) * t10) + 1),
  easeInElastic: (t10) => oc(t10) ? t10 : ry(t10, 0.075, 0.3),
  easeOutElastic: (t10) => oc(t10) ? t10 : oy(t10, 0.075, 0.3),
  easeInOutElastic(t10) {
    return oc(t10) ? t10 : t10 < 0.5 ? 0.5 * ry(t10 * 2, 0.1125, 0.45) : 0.5 + 0.5 * oy(t10 * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(t10) {
    return t10 * t10 * ((1.70158 + 1) * t10 - 1.70158);
  },
  easeOutBack(t10) {
    return (t10 -= 1) * t10 * ((1.70158 + 1) * t10 + 1.70158) + 1;
  },
  easeInOutBack(t10) {
    let e = 1.70158;
    return (t10 /= 0.5) < 1 ? 0.5 * (t10 * t10 * (((e *= 1.525) + 1) * t10 - e)) : 0.5 * ((t10 -= 2) * t10 * (((e *= 1.525) + 1) * t10 + e) + 2);
  },
  easeInBounce: (t10) => 1 - Ga.easeOutBounce(1 - t10),
  easeOutBounce(t10) {
    return t10 < 1 / 2.75 ? 7.5625 * t10 * t10 : t10 < 2 / 2.75 ? 7.5625 * (t10 -= 1.5 / 2.75) * t10 + 0.75 : t10 < 2.5 / 2.75 ? 7.5625 * (t10 -= 2.25 / 2.75) * t10 + 0.9375 : 7.5625 * (t10 -= 2.625 / 2.75) * t10 + 0.984375;
  },
  easeInOutBounce: (t10) => t10 < 0.5 ? Ga.easeInBounce(t10 * 2) * 0.5 : Ga.easeOutBounce(t10 * 2 - 1) * 0.5 + 0.5
};
function Ym(t10) {
  if (t10 && typeof t10 == "object") {
    const e = t10.toString();
    return e === "[object CanvasPattern]" || e === "[object CanvasGradient]";
  }
  return false;
}
function ay(t10) {
  return Ym(t10) ? t10 : new bl(t10);
}
function Df(t10) {
  return Ym(t10) ? t10 : new bl(t10).saturate(0.5).darken(0.1).hexString();
}
var PU = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var DU = [
  "color",
  "borderColor",
  "backgroundColor"
];
function $U(t10) {
  t10.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), t10.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (e) => e !== "onProgress" && e !== "onComplete" && e !== "fn"
  }), t10.set("animations", {
    colors: {
      type: "color",
      properties: DU
    },
    numbers: {
      type: "number",
      properties: PU
    }
  }), t10.describe("animations", {
    _fallback: "animation"
  }), t10.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (e) => e | 0
        }
      }
    }
  });
}
function RU(t10) {
  t10.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var ly = /* @__PURE__ */ new Map();
function FU(t10, e) {
  e = e || {};
  const n = t10 + JSON.stringify(e);
  let i = ly.get(n);
  return i || (i = new Intl.NumberFormat(t10, e), ly.set(n, i)), i;
}
function Gm(t10, e, n) {
  return FU(e, n).format(t10);
}
var VU = {
  values(t10) {
    return wt(t10) ? t10 : "" + t10;
  },
  numeric(t10, e, n) {
    if (t10 === 0)
      return "0";
    const i = this.chart.options.locale;
    let s, r = t10;
    if (n.length > 1) {
      const c = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
      (c < 1e-4 || c > 1e15) && (s = "scientific"), r = BU(t10, n);
    }
    const o = t4(Math.abs(r)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = {
      notation: s,
      minimumFractionDigits: a,
      maximumFractionDigits: a
    };
    return Object.assign(l, this.options.ticks.format), Gm(t10, i, l);
  }
};
function BU(t10, e) {
  let n = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;
  return Math.abs(n) >= 1 && t10 !== Math.floor(t10) && (n = t10 - Math.floor(t10)), n;
}
var Jm = {
  formatters: VU
};
function zU(t10) {
  t10.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (e, n) => n.lineWidth,
      tickColor: (e, n) => n.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Jm.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), t10.route("scale.ticks", "color", "", "color"), t10.route("scale.grid", "color", "", "borderColor"), t10.route("scale.border", "color", "", "borderColor"), t10.route("scale.title", "color", "", "color"), t10.describe("scale", {
    _fallback: false,
    _scriptable: (e) => !e.startsWith("before") && !e.startsWith("after") && e !== "callback" && e !== "parser",
    _indexable: (e) => e !== "borderDash" && e !== "tickBorderDash" && e !== "dash"
  }), t10.describe("scales", {
    _fallback: "scale"
  }), t10.describe("scale.ticks", {
    _scriptable: (e) => e !== "backdropPadding" && e !== "callback",
    _indexable: (e) => e !== "backdropPadding"
  });
}
var Qr = /* @__PURE__ */ Object.create(null);
var op = /* @__PURE__ */ Object.create(null);
function Ja(t10, e) {
  if (!e)
    return t10;
  const n = e.split(".");
  for (let i = 0, s = n.length; i < s; ++i) {
    const r = n[i];
    t10 = t10[r] || (t10[r] = /* @__PURE__ */ Object.create(null));
  }
  return t10;
}
function $f(t10, e, n) {
  return typeof e == "string" ? yl(Ja(t10, e), n) : yl(Ja(t10, ""), e);
}
var jU = class {
  constructor(e, n) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (i) => i.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (i, s) => Df(s.backgroundColor), this.hoverBorderColor = (i, s) => Df(s.borderColor), this.hoverColor = (i, s) => Df(s.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    }, this.maintainAspectRatio = true, this.onHover = null, this.onClick = null, this.parsing = true, this.plugins = {}, this.responsive = true, this.scale = void 0, this.scales = {}, this.showLine = true, this.drawActiveElementsOnTop = true, this.describe(e), this.apply(n);
  }
  set(e, n) {
    return $f(this, e, n);
  }
  get(e) {
    return Ja(this, e);
  }
  describe(e, n) {
    return $f(op, e, n);
  }
  override(e, n) {
    return $f(Qr, e, n);
  }
  route(e, n, i, s) {
    const r = Ja(this, e), o = Ja(this, i), a = "_" + n;
    Object.defineProperties(r, {
      [a]: {
        value: r[n],
        writable: true
      },
      [n]: {
        enumerable: true,
        get() {
          const l = this[a], c = o[s];
          return Je(l) ? Object.assign({}, c, l) : Ke(l, c);
        },
        set(l) {
          this[a] = l;
        }
      }
    });
  }
  apply(e) {
    e.forEach((n) => n(this));
  }
};
var At = new jU({
  _scriptable: (t10) => !t10.startsWith("on"),
  _indexable: (t10) => t10 !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  $U,
  RU,
  zU
]);
function HU(t10) {
  return !t10 || et(t10.size) || et(t10.family) ? null : (t10.style ? t10.style + " " : "") + (t10.weight ? t10.weight + " " : "") + t10.size + "px " + t10.family;
}
function ju(t10, e, n, i, s) {
  let r = e[s];
  return r || (r = e[s] = t10.measureText(s).width, n.push(s)), r > i && (i = r), i;
}
function WU(t10, e, n, i) {
  i = i || {};
  let s = i.data = i.data || {}, r = i.garbageCollect = i.garbageCollect || [];
  i.font !== e && (s = i.data = {}, r = i.garbageCollect = [], i.font = e), t10.save(), t10.font = e;
  let o = 0;
  const a = n.length;
  let l, c, u, d, f;
  for (l = 0; l < a; l++)
    if (d = n[l], d != null && !wt(d))
      o = ju(t10, s, r, o, d);
    else if (wt(d))
      for (c = 0, u = d.length; c < u; c++)
        f = d[c], f != null && !wt(f) && (o = ju(t10, s, r, o, f));
  t10.restore();
  const h10 = r.length / 2;
  if (h10 > n.length) {
    for (l = 0; l < h10; l++)
      delete s[r[l]];
    r.splice(0, h10);
  }
  return o;
}
function br(t10, e, n) {
  const i = t10.currentDevicePixelRatio, s = n !== 0 ? Math.max(n / 2, 0.5) : 0;
  return Math.round((e - s) * i) / i + s;
}
function cy(t10, e) {
  !e && !t10 || (e = e || t10.getContext("2d"), e.save(), e.resetTransform(), e.clearRect(0, 0, t10.width, t10.height), e.restore());
}
function ap(t10, e, n, i) {
  l4(t10, e, n, i, null);
}
function l4(t10, e, n, i, s) {
  let r, o, a, l, c, u, d, f;
  const h10 = e.pointStyle, p = e.rotation, g = e.radius;
  let m = (p || 0) * xU;
  if (h10 && typeof h10 == "object" && (r = h10.toString(), r === "[object HTMLImageElement]" || r === "[object HTMLCanvasElement]")) {
    t10.save(), t10.translate(n, i), t10.rotate(m), t10.drawImage(h10, -h10.width / 2, -h10.height / 2, h10.width, h10.height), t10.restore();
    return;
  }
  if (!(isNaN(g) || g <= 0)) {
    switch (t10.beginPath(), h10) {
      default:
        s ? t10.ellipse(n, i, s / 2, g, 0, 0, bt) : t10.arc(n, i, g, 0, bt), t10.closePath();
        break;
      case "triangle":
        u = s ? s / 2 : g, t10.moveTo(n + Math.sin(m) * u, i - Math.cos(m) * g), m += ty, t10.lineTo(n + Math.sin(m) * u, i - Math.cos(m) * g), m += ty, t10.lineTo(n + Math.sin(m) * u, i - Math.cos(m) * g), t10.closePath();
        break;
      case "rectRounded":
        c = g * 0.516, l = g - c, o = Math.cos(m + gr) * l, d = Math.cos(m + gr) * (s ? s / 2 - c : l), a = Math.sin(m + gr) * l, f = Math.sin(m + gr) * (s ? s / 2 - c : l), t10.arc(n - d, i - a, c, m - _t, m - Lt), t10.arc(n + f, i - o, c, m - Lt, m), t10.arc(n + d, i + a, c, m, m + Lt), t10.arc(n - f, i + o, c, m + Lt, m + _t), t10.closePath();
        break;
      case "rect":
        if (!p) {
          l = Math.SQRT1_2 * g, u = s ? s / 2 : l, t10.rect(n - u, i - l, 2 * u, 2 * l);
          break;
        }
        m += gr;
      case "rectRot":
        d = Math.cos(m) * (s ? s / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, f = Math.sin(m) * (s ? s / 2 : g), t10.moveTo(n - d, i - a), t10.lineTo(n + f, i - o), t10.lineTo(n + d, i + a), t10.lineTo(n - f, i + o), t10.closePath();
        break;
      case "crossRot":
        m += gr;
      case "cross":
        d = Math.cos(m) * (s ? s / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, f = Math.sin(m) * (s ? s / 2 : g), t10.moveTo(n - d, i - a), t10.lineTo(n + d, i + a), t10.moveTo(n + f, i - o), t10.lineTo(n - f, i + o);
        break;
      case "star":
        d = Math.cos(m) * (s ? s / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, f = Math.sin(m) * (s ? s / 2 : g), t10.moveTo(n - d, i - a), t10.lineTo(n + d, i + a), t10.moveTo(n + f, i - o), t10.lineTo(n - f, i + o), m += gr, d = Math.cos(m) * (s ? s / 2 : g), o = Math.cos(m) * g, a = Math.sin(m) * g, f = Math.sin(m) * (s ? s / 2 : g), t10.moveTo(n - d, i - a), t10.lineTo(n + d, i + a), t10.moveTo(n + f, i - o), t10.lineTo(n - f, i + o);
        break;
      case "line":
        o = s ? s / 2 : Math.cos(m) * g, a = Math.sin(m) * g, t10.moveTo(n - o, i - a), t10.lineTo(n + o, i + a);
        break;
      case "dash":
        t10.moveTo(n, i), t10.lineTo(n + Math.cos(m) * (s ? s / 2 : g), i + Math.sin(m) * g);
        break;
      case false:
        t10.closePath();
        break;
    }
    t10.fill(), e.borderWidth > 0 && t10.stroke();
  }
}
function ms(t10, e, n) {
  return n = n || 0.5, !e || t10 && t10.x > e.left - n && t10.x < e.right + n && t10.y > e.top - n && t10.y < e.bottom + n;
}
function Rd(t10, e) {
  t10.save(), t10.beginPath(), t10.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t10.clip();
}
function Fd(t10) {
  t10.restore();
}
function UU(t10, e, n, i, s) {
  if (!e)
    return t10.lineTo(n.x, n.y);
  if (s === "middle") {
    const r = (e.x + n.x) / 2;
    t10.lineTo(r, e.y), t10.lineTo(r, n.y);
  } else s === "after" != !!i ? t10.lineTo(e.x, n.y) : t10.lineTo(n.x, e.y);
  t10.lineTo(n.x, n.y);
}
function qU(t10, e, n, i) {
  if (!e)
    return t10.lineTo(n.x, n.y);
  t10.bezierCurveTo(i ? e.cp1x : e.cp2x, i ? e.cp1y : e.cp2y, i ? n.cp2x : n.cp1x, i ? n.cp2y : n.cp1y, n.x, n.y);
}
function KU(t10, e) {
  e.translation && t10.translate(e.translation[0], e.translation[1]), et(e.rotation) || t10.rotate(e.rotation), e.color && (t10.fillStyle = e.color), e.textAlign && (t10.textAlign = e.textAlign), e.textBaseline && (t10.textBaseline = e.textBaseline);
}
function YU(t10, e, n, i, s) {
  if (s.strikethrough || s.underline) {
    const r = t10.measureText(i), o = e - r.actualBoundingBoxLeft, a = e + r.actualBoundingBoxRight, l = n - r.actualBoundingBoxAscent, c = n + r.actualBoundingBoxDescent, u = s.strikethrough ? (l + c) / 2 : c;
    t10.strokeStyle = t10.fillStyle, t10.beginPath(), t10.lineWidth = s.decorationWidth || 2, t10.moveTo(o, u), t10.lineTo(a, u), t10.stroke();
  }
}
function GU(t10, e) {
  const n = t10.fillStyle;
  t10.fillStyle = e.color, t10.fillRect(e.left, e.top, e.width, e.height), t10.fillStyle = n;
}
function Wo(t10, e, n, i, s, r = {}) {
  const o = wt(e) ? e : [
    e
  ], a = r.strokeWidth > 0 && r.strokeColor !== "";
  let l, c;
  for (t10.save(), t10.font = s.string, KU(t10, r), l = 0; l < o.length; ++l)
    c = o[l], r.backdrop && GU(t10, r.backdrop), a && (r.strokeColor && (t10.strokeStyle = r.strokeColor), et(r.strokeWidth) || (t10.lineWidth = r.strokeWidth), t10.strokeText(c, n, i, r.maxWidth)), t10.fillText(c, n, i, r.maxWidth), YU(t10, n, i, c, r), i += Number(s.lineHeight);
  t10.restore();
}
function Sl(t10, e) {
  const { x: n, y: i, w: s, h: r, radius: o } = e;
  t10.arc(n + o.topLeft, i + o.topLeft, o.topLeft, 1.5 * _t, _t, true), t10.lineTo(n, i + r - o.bottomLeft), t10.arc(n + o.bottomLeft, i + r - o.bottomLeft, o.bottomLeft, _t, Lt, true), t10.lineTo(n + s - o.bottomRight, i + r), t10.arc(n + s - o.bottomRight, i + r - o.bottomRight, o.bottomRight, Lt, 0, true), t10.lineTo(n + s, i + o.topRight), t10.arc(n + s - o.topRight, i + o.topRight, o.topRight, 0, -Lt, true), t10.lineTo(n + o.topLeft, i);
}
var JU = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var XU = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function QU(t10, e) {
  const n = ("" + t10).match(JU);
  if (!n || n[1] === "normal")
    return e * 1.2;
  switch (t10 = +n[2], n[3]) {
    case "px":
      return t10;
    case "%":
      t10 /= 100;
      break;
  }
  return e * t10;
}
var ZU = (t10) => +t10 || 0;
function Xm(t10, e) {
  const n = {}, i = Je(e), s = i ? Object.keys(e) : e, r = Je(t10) ? i ? (o) => Ke(t10[o], t10[e[o]]) : (o) => t10[o] : () => t10;
  for (const o of s)
    n[o] = ZU(r(o));
  return n;
}
function c4(t10) {
  return Xm(t10, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function zr(t10) {
  return Xm(t10, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function xn(t10) {
  const e = c4(t10);
  return e.width = e.left + e.right, e.height = e.top + e.bottom, e;
}
function Qt(t10, e) {
  t10 = t10 || {}, e = e || At.font;
  let n = Ke(t10.size, e.size);
  typeof n == "string" && (n = parseInt(n, 10));
  let i = Ke(t10.style, e.style);
  i && !("" + i).match(XU) && (console.warn('Invalid font style specified: "' + i + '"'), i = void 0);
  const s = {
    family: Ke(t10.family, e.family),
    lineHeight: QU(Ke(t10.lineHeight, e.lineHeight), n),
    size: n,
    style: i,
    weight: Ke(t10.weight, e.weight),
    string: ""
  };
  return s.string = HU(s), s;
}
function ac(t10, e, n, i) {
  let s, r, o;
  for (s = 0, r = t10.length; s < r; ++s)
    if (o = t10[s], o !== void 0 && o !== void 0)
      return o;
}
function eq(t10, e, n) {
  const { min: i, max: s } = t10, r = Zk(e, (s - i) / 2), o = (a, l) => n && a === 0 ? 0 : a + l;
  return {
    min: o(i, -Math.abs(r)),
    max: o(s, r)
  };
}
function ur(t10, e) {
  return Object.assign(Object.create(t10), e);
}
function Qm(t10, e = [
  ""
], n, i, s = () => t10[0]) {
  const r = n || t10;
  typeof i > "u" && (i = h4("_fallback", t10));
  const o = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: t10,
    _rootScopes: r,
    _fallback: i,
    _getTarget: s,
    override: (a) => Qm([
      a,
      ...t10
    ], e, r, i)
  };
  return new Proxy(o, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, l) {
      return delete a[l], delete a._keys, delete t10[0][l], true;
    },
    /**
    * A trap for getting property values.
    */
    get(a, l) {
      return d4(a, l, () => lq(l, e, t10, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, l) {
      return Reflect.getOwnPropertyDescriptor(a._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t10[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(a, l) {
      return dy(a).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(a) {
      return dy(a);
    },
    /**
    * A trap for setting property values.
    */
    set(a, l, c) {
      const u = a._storage || (a._storage = s());
      return a[l] = u[l] = c, delete a._keys, true;
    }
  });
}
function Uo(t10, e, n, i) {
  const s = {
    _cacheable: false,
    _proxy: t10,
    _context: e,
    _subProxy: n,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: u4(t10, i),
    setContext: (r) => Uo(t10, r, n, i),
    override: (r) => Uo(t10.override(r), e, n, i)
  };
  return new Proxy(s, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(r, o) {
      return delete r[o], delete t10[o], true;
    },
    /**
    * A trap for getting property values.
    */
    get(r, o, a) {
      return d4(r, o, () => nq(r, o, a));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(r, o) {
      return r._descriptors.allKeys ? Reflect.has(t10, o) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(t10, o);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(t10);
    },
    /**
    * A trap for the in operator.
    */
    has(r, o) {
      return Reflect.has(t10, o);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(t10);
    },
    /**
    * A trap for setting property values.
    */
    set(r, o, a) {
      return t10[o] = a, delete r[o], true;
    }
  });
}
function u4(t10, e = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable: n = e.scriptable, _indexable: i = e.indexable, _allKeys: s = e.allKeys } = t10;
  return {
    allKeys: s,
    scriptable: n,
    indexable: i,
    isScriptable: rr(n) ? n : () => n,
    isIndexable: rr(i) ? i : () => i
  };
}
var tq = (t10, e) => t10 ? t10 + Um(e) : e;
var Zm = (t10, e) => Je(e) && t10 !== "adapters" && (Object.getPrototypeOf(e) === null || e.constructor === Object);
function d4(t10, e, n) {
  if (Object.prototype.hasOwnProperty.call(t10, e) || e === "constructor")
    return t10[e];
  const i = n();
  return t10[e] = i, i;
}
function nq(t10, e, n) {
  const { _proxy: i, _context: s, _subProxy: r, _descriptors: o } = t10;
  let a = i[e];
  return rr(a) && o.isScriptable(e) && (a = iq(e, a, t10, n)), wt(a) && a.length && (a = sq(e, a, t10, o.isIndexable)), Zm(e, a) && (a = Uo(a, s, r && r[e], o)), a;
}
function iq(t10, e, n, i) {
  const { _proxy: s, _context: r, _subProxy: o, _stack: a } = n;
  if (a.has(t10))
    throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + t10);
  a.add(t10);
  let l = e(r, o || i);
  return a.delete(t10), Zm(t10, l) && (l = eg(s._scopes, s, t10, l)), l;
}
function sq(t10, e, n, i) {
  const { _proxy: s, _context: r, _subProxy: o, _descriptors: a } = n;
  if (typeof r.index < "u" && i(t10))
    return e[r.index % e.length];
  if (Je(e[0])) {
    const l = e, c = s._scopes.filter((u) => u !== l);
    e = [];
    for (const u of l) {
      const d = eg(c, s, t10, u);
      e.push(Uo(d, r, o && o[t10], a));
    }
  }
  return e;
}
function f4(t10, e, n) {
  return rr(t10) ? t10(e, n) : t10;
}
var rq = (t10, e) => t10 === true ? e : typeof t10 == "string" ? sr(e, t10) : void 0;
function oq(t10, e, n, i, s) {
  for (const r of e) {
    const o = rq(n, r);
    if (o) {
      t10.add(o);
      const a = f4(o._fallback, n, s);
      if (typeof a < "u" && a !== n && a !== i)
        return a;
    } else if (o === false && typeof i < "u" && n !== i)
      return null;
  }
  return false;
}
function eg(t10, e, n, i) {
  const s = e._rootScopes, r = f4(e._fallback, n, i), o = [
    ...t10,
    ...s
  ], a = /* @__PURE__ */ new Set();
  a.add(i);
  let l = uy(a, o, n, r || n, i);
  return l === null || typeof r < "u" && r !== n && (l = uy(a, o, r, l, i), l === null) ? false : Qm(Array.from(a), [
    ""
  ], s, r, () => aq(e, n, i));
}
function uy(t10, e, n, i, s) {
  for (; n; )
    n = oq(t10, e, n, i, s);
  return n;
}
function aq(t10, e, n) {
  const i = t10._getTarget();
  e in i || (i[e] = {});
  const s = i[e];
  return wt(s) && Je(n) ? n : s || {};
}
function lq(t10, e, n, i) {
  let s;
  for (const r of e)
    if (s = h4(tq(r, t10), n), typeof s < "u")
      return Zm(t10, s) ? eg(n, i, t10, s) : s;
}
function h4(t10, e) {
  for (const n of e) {
    if (!n)
      continue;
    const i = n[t10];
    if (typeof i < "u")
      return i;
  }
}
function dy(t10) {
  let e = t10._keys;
  return e || (e = t10._keys = cq(t10._scopes)), e;
}
function cq(t10) {
  const e = /* @__PURE__ */ new Set();
  for (const n of t10)
    for (const i of Object.keys(n).filter((s) => !s.startsWith("_")))
      e.add(i);
  return Array.from(e);
}
function uq(t10, e, n, i) {
  const { iScale: s } = t10, { key: r = "r" } = this._parsing, o = new Array(i);
  let a, l, c, u;
  for (a = 0, l = i; a < l; ++a)
    c = a + n, u = e[c], o[a] = {
      r: s.parse(sr(u, r), c)
    };
  return o;
}
var dq = Number.EPSILON || 1e-14;
var qo = (t10, e) => e < t10.length && !t10[e].skip && t10[e];
var p4 = (t10) => t10 === "x" ? "y" : "x";
function fq(t10, e, n, i) {
  const s = t10.skip ? e : t10, r = e, o = n.skip ? e : n, a = rp(r, s), l = rp(o, r);
  let c = a / (a + l), u = l / (a + l);
  c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u;
  const d = i * c, f = i * u;
  return {
    previous: {
      x: r.x - d * (o.x - s.x),
      y: r.y - d * (o.y - s.y)
    },
    next: {
      x: r.x + f * (o.x - s.x),
      y: r.y + f * (o.y - s.y)
    }
  };
}
function hq(t10, e, n) {
  const i = t10.length;
  let s, r, o, a, l, c = qo(t10, 0);
  for (let u = 0; u < i - 1; ++u)
    if (l = c, c = qo(t10, u + 1), !(!l || !c)) {
      if (Ya(e[u], 0, dq)) {
        n[u] = n[u + 1] = 0;
        continue;
      }
      s = n[u] / e[u], r = n[u + 1] / e[u], a = Math.pow(s, 2) + Math.pow(r, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), n[u] = s * o * e[u], n[u + 1] = r * o * e[u]);
    }
}
function pq(t10, e, n = "x") {
  const i = p4(n), s = t10.length;
  let r, o, a, l = qo(t10, 0);
  for (let c = 0; c < s; ++c) {
    if (o = a, a = l, l = qo(t10, c + 1), !a)
      continue;
    const u = a[n], d = a[i];
    o && (r = (u - o[n]) / 3, a[`cp1${n}`] = u - r, a[`cp1${i}`] = d - r * e[c]), l && (r = (l[n] - u) / 3, a[`cp2${n}`] = u + r, a[`cp2${i}`] = d + r * e[c]);
  }
}
function mq(t10, e = "x") {
  const n = p4(e), i = t10.length, s = Array(i).fill(0), r = Array(i);
  let o, a, l, c = qo(t10, 0);
  for (o = 0; o < i; ++o)
    if (a = l, l = c, c = qo(t10, o + 1), !!l) {
      if (c) {
        const u = c[e] - l[e];
        s[o] = u !== 0 ? (c[n] - l[n]) / u : 0;
      }
      r[o] = a ? c ? ji(s[o - 1]) !== ji(s[o]) ? 0 : (s[o - 1] + s[o]) / 2 : s[o - 1] : s[o];
    }
  hq(t10, s, r), pq(t10, r, e);
}
function lc(t10, e, n) {
  return Math.max(Math.min(t10, n), e);
}
function gq(t10, e) {
  let n, i, s, r, o, a = ms(t10[0], e);
  for (n = 0, i = t10.length; n < i; ++n)
    o = r, r = a, a = n < i - 1 && ms(t10[n + 1], e), r && (s = t10[n], o && (s.cp1x = lc(s.cp1x, e.left, e.right), s.cp1y = lc(s.cp1y, e.top, e.bottom)), a && (s.cp2x = lc(s.cp2x, e.left, e.right), s.cp2y = lc(s.cp2y, e.top, e.bottom)));
}
function bq(t10, e, n, i, s) {
  let r, o, a, l;
  if (e.spanGaps && (t10 = t10.filter((c) => !c.skip)), e.cubicInterpolationMode === "monotone")
    mq(t10, s);
  else {
    let c = i ? t10[t10.length - 1] : t10[0];
    for (r = 0, o = t10.length; r < o; ++r)
      a = t10[r], l = fq(c, a, t10[Math.min(r + 1, o - (i ? 0 : 1)) % o], e.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;
  }
  e.capBezierPoints && gq(t10, n);
}
function tg() {
  return typeof window < "u" && typeof document < "u";
}
function ng(t10) {
  let e = t10.parentNode;
  return e && e.toString() === "[object ShadowRoot]" && (e = e.host), e;
}
function Hu(t10, e, n) {
  let i;
  return typeof t10 == "string" ? (i = parseInt(t10, 10), t10.indexOf("%") !== -1 && (i = i / 100 * e.parentNode[n])) : i = t10, i;
}
var Vd = (t10) => t10.ownerDocument.defaultView.getComputedStyle(t10, null);
function yq(t10, e) {
  return Vd(t10).getPropertyValue(e);
}
var vq = [
  "top",
  "right",
  "bottom",
  "left"
];
function jr(t10, e, n) {
  const i = {};
  n = n ? "-" + n : "";
  for (let s = 0; s < 4; s++) {
    const r = vq[s];
    i[r] = parseFloat(t10[e + "-" + r + n]) || 0;
  }
  return i.width = i.left + i.right, i.height = i.top + i.bottom, i;
}
var xq = (t10, e, n) => (t10 > 0 || e > 0) && (!n || !n.shadowRoot);
function kq(t10, e) {
  const n = t10.touches, i = n && n.length ? n[0] : t10, { offsetX: s, offsetY: r } = i;
  let o = false, a, l;
  if (xq(s, r, t10.target))
    a = s, l = r;
  else {
    const c = e.getBoundingClientRect();
    a = i.clientX - c.left, l = i.clientY - c.top, o = true;
  }
  return {
    x: a,
    y: l,
    box: o
  };
}
function Sr(t10, e) {
  if ("native" in t10)
    return t10;
  const { canvas: n, currentDevicePixelRatio: i } = e, s = Vd(n), r = s.boxSizing === "border-box", o = jr(s, "padding"), a = jr(s, "border", "width"), { x: l, y: c, box: u } = kq(t10, n), d = o.left + (u && a.left), f = o.top + (u && a.top);
  let { width: h10, height: p } = e;
  return r && (h10 -= o.width + a.width, p -= o.height + a.height), {
    x: Math.round((l - d) / h10 * n.width / i),
    y: Math.round((c - f) / p * n.height / i)
  };
}
function Sq(t10, e, n) {
  let i, s;
  if (e === void 0 || n === void 0) {
    const r = t10 && ng(t10);
    if (!r)
      e = t10.clientWidth, n = t10.clientHeight;
    else {
      const o = r.getBoundingClientRect(), a = Vd(r), l = jr(a, "border", "width"), c = jr(a, "padding");
      e = o.width - c.width - l.width, n = o.height - c.height - l.height, i = Hu(a.maxWidth, r, "clientWidth"), s = Hu(a.maxHeight, r, "clientHeight");
    }
  }
  return {
    width: e,
    height: n,
    maxWidth: i || zu,
    maxHeight: s || zu
  };
}
var cc = (t10) => Math.round(t10 * 10) / 10;
function wq(t10, e, n, i) {
  const s = Vd(t10), r = jr(s, "margin"), o = Hu(s.maxWidth, t10, "clientWidth") || zu, a = Hu(s.maxHeight, t10, "clientHeight") || zu, l = Sq(t10, e, n);
  let { width: c, height: u } = l;
  if (s.boxSizing === "content-box") {
    const f = jr(s, "border", "width"), h10 = jr(s, "padding");
    c -= h10.width + f.width, u -= h10.height + f.height;
  }
  return c = Math.max(0, c - r.width), u = Math.max(0, i ? c / i : u - r.height), c = cc(Math.min(c, o, l.maxWidth)), u = cc(Math.min(u, a, l.maxHeight)), c && !u && (u = cc(c / 2)), (e !== void 0 || n !== void 0) && i && l.height && u > l.height && (u = l.height, c = cc(Math.floor(u * i))), {
    width: c,
    height: u
  };
}
function fy(t10, e, n) {
  const i = e || 1, s = Math.floor(t10.height * i), r = Math.floor(t10.width * i);
  t10.height = Math.floor(t10.height), t10.width = Math.floor(t10.width);
  const o = t10.canvas;
  return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${t10.height}px`, o.style.width = `${t10.width}px`), t10.currentDevicePixelRatio !== i || o.height !== s || o.width !== r ? (t10.currentDevicePixelRatio = i, o.height = s, o.width = r, t10.ctx.setTransform(i, 0, 0, i, 0, 0), true) : false;
}
var Cq = function() {
  let t10 = false;
  try {
    const e = {
      get passive() {
        return t10 = true, false;
      }
    };
    tg() && (window.addEventListener("test", null, e), window.removeEventListener("test", null, e));
  } catch {
  }
  return t10;
}();
function hy(t10, e) {
  const n = yq(t10, e), i = n && n.match(/^(\d+)(\.\d+)?px$/);
  return i ? +i[1] : void 0;
}
function wr(t10, e, n, i) {
  return {
    x: t10.x + n * (e.x - t10.x),
    y: t10.y + n * (e.y - t10.y)
  };
}
function Oq(t10, e, n, i) {
  return {
    x: t10.x + n * (e.x - t10.x),
    y: i === "middle" ? n < 0.5 ? t10.y : e.y : i === "after" ? n < 1 ? t10.y : e.y : n > 0 ? e.y : t10.y
  };
}
function Eq(t10, e, n, i) {
  const s = {
    x: t10.cp2x,
    y: t10.cp2y
  }, r = {
    x: e.cp1x,
    y: e.cp1y
  }, o = wr(t10, s, n), a = wr(s, r, n), l = wr(r, e, n), c = wr(o, a, n), u = wr(a, l, n);
  return wr(c, u, n);
}
var Mq = function(t10, e) {
  return {
    x(n) {
      return t10 + t10 + e - n;
    },
    setWidth(n) {
      e = n;
    },
    textAlign(n) {
      return n === "center" ? n : n === "right" ? "left" : "right";
    },
    xPlus(n, i) {
      return n - i;
    },
    leftForLtr(n, i) {
      return n - i;
    }
  };
};
var Tq = function() {
  return {
    x(t10) {
      return t10;
    },
    setWidth(t10) {
    },
    textAlign(t10) {
      return t10;
    },
    xPlus(t10, e) {
      return t10 + e;
    },
    leftForLtr(t10, e) {
      return t10;
    }
  };
};
function Mo(t10, e, n) {
  return t10 ? Mq(e, n) : Tq();
}
function m4(t10, e) {
  let n, i;
  (e === "ltr" || e === "rtl") && (n = t10.canvas.style, i = [
    n.getPropertyValue("direction"),
    n.getPropertyPriority("direction")
  ], n.setProperty("direction", e, "important"), t10.prevTextDirection = i);
}
function g4(t10, e) {
  e !== void 0 && (delete t10.prevTextDirection, t10.canvas.style.setProperty("direction", e[0], e[1]));
}
function b4(t10) {
  return t10 === "angle" ? {
    between: kl,
    compare: OU,
    normalize: zn
  } : {
    between: ps,
    compare: (e, n) => e - n,
    normalize: (e) => e
  };
}
function py({ start: t10, end: e, count: n, loop: i, style: s }) {
  return {
    start: t10 % n,
    end: e % n,
    loop: i && (e - t10 + 1) % n === 0,
    style: s
  };
}
function Aq(t10, e, n) {
  const { property: i, start: s, end: r } = n, { between: o, normalize: a } = b4(i), l = e.length;
  let { start: c, end: u, loop: d } = t10, f, h10;
  if (d) {
    for (c += l, u += l, f = 0, h10 = l; f < h10 && o(a(e[c % l][i]), s, r); ++f)
      c--, u--;
    c %= l, u %= l;
  }
  return u < c && (u += l), {
    start: c,
    end: u,
    loop: d,
    style: t10.style
  };
}
function y4(t10, e, n) {
  if (!n)
    return [
      t10
    ];
  const { property: i, start: s, end: r } = n, o = e.length, { compare: a, between: l, normalize: c } = b4(i), { start: u, end: d, loop: f, style: h10 } = Aq(t10, e, n), p = [];
  let g = false, m = null, b, x, k;
  const v = () => l(s, k, b) && a(s, k) !== 0, S = () => a(r, b) === 0 || l(r, k, b), w = () => g || v(), E = () => !g || S();
  for (let M = u, N = u; M <= d; ++M)
    x = e[M % o], !x.skip && (b = c(x[i]), b !== k && (g = l(b, s, r), m === null && w() && (m = a(b, s) === 0 ? M : N), m !== null && E() && (p.push(py({
      start: m,
      end: M,
      loop: f,
      count: o,
      style: h10
    })), m = null), N = M, k = b));
  return m !== null && p.push(py({
    start: m,
    end: d,
    loop: f,
    count: o,
    style: h10
  })), p;
}
function v4(t10, e) {
  const n = [], i = t10.segments;
  for (let s = 0; s < i.length; s++) {
    const r = y4(i[s], t10.points, e);
    r.length && n.push(...r);
  }
  return n;
}
function _q(t10, e, n, i) {
  let s = 0, r = e - 1;
  if (n && !i)
    for (; s < e && !t10[s].skip; )
      s++;
  for (; s < e && t10[s].skip; )
    s++;
  for (s %= e, n && (r += s); r > s && t10[r % e].skip; )
    r--;
  return r %= e, {
    start: s,
    end: r
  };
}
function Nq(t10, e, n, i) {
  const s = t10.length, r = [];
  let o = e, a = t10[e], l;
  for (l = e + 1; l <= n; ++l) {
    const c = t10[l % s];
    c.skip || c.stop ? a.skip || (i = false, r.push({
      start: e % s,
      end: (l - 1) % s,
      loop: i
    }), e = o = c.stop ? l : null) : (o = l, a.skip && (e = l)), a = c;
  }
  return o !== null && r.push({
    start: e % s,
    end: o % s,
    loop: i
  }), r;
}
function Lq(t10, e) {
  const n = t10.points, i = t10.options.spanGaps, s = n.length;
  if (!s)
    return [];
  const r = !!t10._loop, { start: o, end: a } = _q(n, s, r, i);
  if (i === true)
    return my(t10, [
      {
        start: o,
        end: a,
        loop: r
      }
    ], n, e);
  const l = a < o ? a + s : a, c = !!t10._fullLoop && o === 0 && a === s - 1;
  return my(t10, Nq(n, o, l, c), n, e);
}
function my(t10, e, n, i) {
  return !i || !i.setContext || !n ? e : Iq(t10, e, n, i);
}
function Iq(t10, e, n, i) {
  const s = t10._chart.getContext(), r = gy(t10.options), { _datasetIndex: o, options: { spanGaps: a } } = t10, l = n.length, c = [];
  let u = r, d = e[0].start, f = d;
  function h10(p, g, m, b) {
    const x = a ? -1 : 1;
    if (p !== g) {
      for (p += l; n[p % l].skip; )
        p -= x;
      for (; n[g % l].skip; )
        g += x;
      p % l !== g % l && (c.push({
        start: p % l,
        end: g % l,
        loop: m,
        style: b
      }), u = b, d = g % l);
    }
  }
  for (const p of e) {
    d = a ? d : p.start;
    let g = n[d % l], m;
    for (f = d + 1; f <= p.end; f++) {
      const b = n[f % l];
      m = gy(i.setContext(ur(s, {
        type: "segment",
        p0: g,
        p1: b,
        p0DataIndex: (f - 1) % l,
        p1DataIndex: f % l,
        datasetIndex: o
      }))), Pq(m, u) && h10(d, f - 1, p.loop, u), g = b, u = m;
    }
    d < f - 1 && h10(d, f - 1, p.loop, u);
  }
  return c;
}
function gy(t10) {
  return {
    backgroundColor: t10.backgroundColor,
    borderCapStyle: t10.borderCapStyle,
    borderDash: t10.borderDash,
    borderDashOffset: t10.borderDashOffset,
    borderJoinStyle: t10.borderJoinStyle,
    borderWidth: t10.borderWidth,
    borderColor: t10.borderColor
  };
}
function Pq(t10, e) {
  if (!e)
    return false;
  const n = [], i = function(s, r) {
    return Ym(r) ? (n.includes(r) || n.push(r), n.indexOf(r)) : r;
  };
  return JSON.stringify(t10, i) !== JSON.stringify(e, i);
}
var Dq = class {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = false, this._lastDate = void 0;
  }
  _notify(e, n, i, s) {
    const r = n.listeners[s], o = n.duration;
    r.forEach((a) => a({
      chart: e,
      initial: n.initial,
      numSteps: o,
      currentStep: Math.min(i - n.start, o)
    }));
  }
  _refresh() {
    this._request || (this._running = true, this._request = r4.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(e = Date.now()) {
    let n = 0;
    this._charts.forEach((i, s) => {
      if (!i.running || !i.items.length)
        return;
      const r = i.items;
      let o = r.length - 1, a = false, l;
      for (; o >= 0; --o)
        l = r[o], l._active ? (l._total > i.duration && (i.duration = l._total), l.tick(e), a = true) : (r[o] = r[r.length - 1], r.pop());
      a && (s.draw(), this._notify(s, i, e, "progress")), r.length || (i.running = false, this._notify(s, i, e, "complete"), i.initial = false), n += r.length;
    }), this._lastDate = e, n === 0 && (this._running = false);
  }
  _getAnims(e) {
    const n = this._charts;
    let i = n.get(e);
    return i || (i = {
      running: false,
      initial: true,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, n.set(e, i)), i;
  }
  listen(e, n, i) {
    this._getAnims(e).listeners[n].push(i);
  }
  add(e, n) {
    !n || !n.length || this._getAnims(e).items.push(...n);
  }
  has(e) {
    return this._getAnims(e).items.length > 0;
  }
  start(e) {
    const n = this._charts.get(e);
    n && (n.running = true, n.start = Date.now(), n.duration = n.items.reduce((i, s) => Math.max(i, s._duration), 0), this._refresh());
  }
  running(e) {
    if (!this._running)
      return false;
    const n = this._charts.get(e);
    return !(!n || !n.running || !n.items.length);
  }
  stop(e) {
    const n = this._charts.get(e);
    if (!n || !n.items.length)
      return;
    const i = n.items;
    let s = i.length - 1;
    for (; s >= 0; --s)
      i[s].cancel();
    n.items = [], this._notify(e, n, Date.now(), "complete");
  }
  remove(e) {
    return this._charts.delete(e);
  }
};
var ss = new Dq();
var by = "transparent";
var $q = {
  boolean(t10, e, n) {
    return n > 0.5 ? e : t10;
  },
  color(t10, e, n) {
    const i = ay(t10 || by), s = i.valid && ay(e || by);
    return s && s.valid ? s.mix(i, n).hexString() : e;
  },
  number(t10, e, n) {
    return t10 + (e - t10) * n;
  }
};
var Rq = class {
  constructor(e, n, i, s) {
    const r = n[i];
    s = ac([
      e.to,
      s,
      r,
      e.from
    ]);
    const o = ac([
      e.from,
      r,
      s
    ]);
    this._active = true, this._fn = e.fn || $q[e.type || typeof o], this._easing = Ga[e.easing] || Ga.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = n, this._prop = i, this._from = o, this._to = s, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(e, n, i) {
    if (this._active) {
      this._notify(false);
      const s = this._target[this._prop], r = i - this._start, o = this._duration - r;
      this._start = i, this._duration = Math.floor(Math.max(o, e.duration)), this._total += r, this._loop = !!e.loop, this._to = ac([
        e.to,
        n,
        s,
        e.from
      ]), this._from = ac([
        e.from,
        s,
        n
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = false, this._notify(false));
  }
  tick(e) {
    const n = e - this._start, i = this._duration, s = this._prop, r = this._from, o = this._loop, a = this._to;
    let l;
    if (this._active = r !== a && (o || n < i), !this._active) {
      this._target[s] = a, this._notify(true);
      return;
    }
    if (n < 0) {
      this._target[s] = r;
      return;
    }
    l = n / i % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[s] = this._fn(r, a, l);
  }
  wait() {
    const e = this._promises || (this._promises = []);
    return new Promise((n, i) => {
      e.push({
        res: n,
        rej: i
      });
    });
  }
  _notify(e) {
    const n = e ? "res" : "rej", i = this._promises || [];
    for (let s = 0; s < i.length; s++)
      i[s][n]();
  }
};
var x4 = class {
  constructor(e, n) {
    this._chart = e, this._properties = /* @__PURE__ */ new Map(), this.configure(n);
  }
  configure(e) {
    if (!Je(e))
      return;
    const n = Object.keys(At.animation), i = this._properties;
    Object.getOwnPropertyNames(e).forEach((s) => {
      const r = e[s];
      if (!Je(r))
        return;
      const o = {};
      for (const a of n)
        o[a] = r[a];
      (wt(r.properties) && r.properties || [
        s
      ]).forEach((a) => {
        (a === s || !i.has(a)) && i.set(a, o);
      });
    });
  }
  _animateOptions(e, n) {
    const i = n.options, s = Vq(e, i);
    if (!s)
      return [];
    const r = this._createAnimations(s, i);
    return i.$shared && Fq(e.options.$animations, i).then(() => {
      e.options = i;
    }, () => {
    }), r;
  }
  _createAnimations(e, n) {
    const i = this._properties, s = [], r = e.$animations || (e.$animations = {}), o = Object.keys(n), a = Date.now();
    let l;
    for (l = o.length - 1; l >= 0; --l) {
      const c = o[l];
      if (c.charAt(0) === "$")
        continue;
      if (c === "options") {
        s.push(...this._animateOptions(e, n));
        continue;
      }
      const u = n[c];
      let d = r[c];
      const f = i.get(c);
      if (d)
        if (f && d.active()) {
          d.update(f, u, a);
          continue;
        } else
          d.cancel();
      if (!f || !f.duration) {
        e[c] = u;
        continue;
      }
      r[c] = d = new Rq(f, e, c, u), s.push(d);
    }
    return s;
  }
  update(e, n) {
    if (this._properties.size === 0) {
      Object.assign(e, n);
      return;
    }
    const i = this._createAnimations(e, n);
    if (i.length)
      return ss.add(this._chart, i), true;
  }
};
function Fq(t10, e) {
  const n = [], i = Object.keys(e);
  for (let s = 0; s < i.length; s++) {
    const r = t10[i[s]];
    r && r.active() && n.push(r.wait());
  }
  return Promise.all(n);
}
function Vq(t10, e) {
  if (!e)
    return;
  let n = t10.options;
  if (!n) {
    t10.options = e;
    return;
  }
  return n.$shared && (t10.options = n = Object.assign({}, n, {
    $shared: false,
    $animations: {}
  })), n;
}
function yy(t10, e) {
  const n = t10 && t10.options || {}, i = n.reverse, s = n.min === void 0 ? e : 0, r = n.max === void 0 ? e : 0;
  return {
    start: i ? r : s,
    end: i ? s : r
  };
}
function Bq(t10, e, n) {
  if (n === false)
    return false;
  const i = yy(t10, n), s = yy(e, n);
  return {
    top: s.end,
    right: i.end,
    bottom: s.start,
    left: i.start
  };
}
function zq(t10) {
  let e, n, i, s;
  return Je(t10) ? (e = t10.top, n = t10.right, i = t10.bottom, s = t10.left) : e = n = i = s = t10, {
    top: e,
    right: n,
    bottom: i,
    left: s,
    disabled: t10 === false
  };
}
function k4(t10, e) {
  const n = [], i = t10._getSortedDatasetMetas(e);
  let s, r;
  for (s = 0, r = i.length; s < r; ++s)
    n.push(i[s].index);
  return n;
}
function vy(t10, e, n, i = {}) {
  const s = t10.keys, r = i.mode === "single";
  let o, a, l, c;
  if (e === null)
    return;
  let u = false;
  for (o = 0, a = s.length; o < a; ++o) {
    if (l = +s[o], l === n) {
      if (u = true, i.all)
        continue;
      break;
    }
    c = t10.values[l], Yt(c) && (r || e === 0 || ji(e) === ji(c)) && (e += c);
  }
  return !u && !i.all ? 0 : e;
}
function jq(t10, e) {
  const { iScale: n, vScale: i } = e, s = n.axis === "x" ? "x" : "y", r = i.axis === "x" ? "x" : "y", o = Object.keys(t10), a = new Array(o.length);
  let l, c, u;
  for (l = 0, c = o.length; l < c; ++l)
    u = o[l], a[l] = {
      [s]: u,
      [r]: t10[u]
    };
  return a;
}
function Rf(t10, e) {
  const n = t10 && t10.options.stacked;
  return n || n === void 0 && e.stack !== void 0;
}
function Hq(t10, e, n) {
  return `${t10.id}.${e.id}.${n.stack || n.type}`;
}
function Wq(t10) {
  const { min: e, max: n, minDefined: i, maxDefined: s } = t10.getUserBounds();
  return {
    min: i ? e : Number.NEGATIVE_INFINITY,
    max: s ? n : Number.POSITIVE_INFINITY
  };
}
function Uq(t10, e, n) {
  const i = t10[e] || (t10[e] = {});
  return i[n] || (i[n] = {});
}
function xy(t10, e, n, i) {
  for (const s of e.getMatchingVisibleMetas(i).reverse()) {
    const r = t10[s.index];
    if (n && r > 0 || !n && r < 0)
      return s.index;
  }
  return null;
}
function ky(t10, e) {
  const { chart: n, _cachedMeta: i } = t10, s = n._stacks || (n._stacks = {}), { iScale: r, vScale: o, index: a } = i, l = r.axis, c = o.axis, u = Hq(r, o, i), d = e.length;
  let f;
  for (let h10 = 0; h10 < d; ++h10) {
    const p = e[h10], { [l]: g, [c]: m } = p, b = p._stacks || (p._stacks = {});
    f = b[c] = Uq(s, u, g), f[a] = m, f._top = xy(f, o, true, i.type), f._bottom = xy(f, o, false, i.type);
    const x = f._visualValues || (f._visualValues = {});
    x[a] = m;
  }
}
function Ff(t10, e) {
  const n = t10.scales;
  return Object.keys(n).filter((i) => n[i].axis === e).shift();
}
function qq(t10, e) {
  return ur(t10, {
    active: false,
    dataset: void 0,
    datasetIndex: e,
    index: e,
    mode: "default",
    type: "dataset"
  });
}
function Kq(t10, e, n) {
  return ur(t10, {
    active: false,
    dataIndex: e,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: e,
    mode: "default",
    type: "data"
  });
}
function ca(t10, e) {
  const n = t10.controller.index, i = t10.vScale && t10.vScale.axis;
  if (i) {
    e = e || t10._parsed;
    for (const s of e) {
      const r = s._stacks;
      if (!r || r[i] === void 0 || r[i][n] === void 0)
        return;
      delete r[i][n], r[i]._visualValues !== void 0 && r[i]._visualValues[n] !== void 0 && delete r[i]._visualValues[n];
    }
  }
}
var Vf = (t10) => t10 === "reset" || t10 === "none";
var Sy = (t10, e) => e ? t10 : Object.assign({}, t10);
var Yq = (t10, e, n) => t10 && !e.hidden && e._stacked && {
  keys: k4(n, true),
  values: null
};
var Gs = class {
  constructor(e, n) {
    this.chart = e, this._ctx = e.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = false, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = false, this.supportsDecimation = false, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const e = this._cachedMeta;
    this.configure(), this.linkScales(), e._stacked = Rf(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(e) {
    this.index !== e && ca(this._cachedMeta), this.index = e;
  }
  linkScales() {
    const e = this.chart, n = this._cachedMeta, i = this.getDataset(), s = (d, f, h10, p) => d === "x" ? f : d === "r" ? p : h10, r = n.xAxisID = Ke(i.xAxisID, Ff(e, "x")), o = n.yAxisID = Ke(i.yAxisID, Ff(e, "y")), a = n.rAxisID = Ke(i.rAxisID, Ff(e, "r")), l = n.indexAxis, c = n.iAxisID = s(l, r, o, a), u = n.vAxisID = s(l, o, r, a);
    n.xScale = this.getScaleForId(r), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(a), n.iScale = this.getScaleForId(c), n.vScale = this.getScaleForId(u);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(e) {
    return this.chart.scales[e];
  }
  _getOtherScale(e) {
    const n = this._cachedMeta;
    return e === n.iScale ? n.vScale : n.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const e = this._cachedMeta;
    this._data && sy(this._data, this), e._stacked && ca(e);
  }
  _dataCheck() {
    const e = this.getDataset(), n = e.data || (e.data = []), i = this._data;
    if (Je(n)) {
      const s = this._cachedMeta;
      this._data = jq(n, s);
    } else if (i !== n) {
      if (i) {
        sy(i, this);
        const s = this._cachedMeta;
        ca(s), s._parsed = [];
      }
      n && Object.isExtensible(n) && AU(n, this), this._syncList = [], this._data = n;
    }
  }
  addElements() {
    const e = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(e) {
    const n = this._cachedMeta, i = this.getDataset();
    let s = false;
    this._dataCheck();
    const r = n._stacked;
    n._stacked = Rf(n.vScale, n), n.stack !== i.stack && (s = true, ca(n), n.stack = i.stack), this._resyncElements(e), (s || r !== n._stacked) && (ky(this, n._parsed), n._stacked = Rf(n.vScale, n));
  }
  configure() {
    const e = this.chart.config, n = e.datasetScopeKeys(this._type), i = e.getOptionScopes(this.getDataset(), n, true);
    this.options = e.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(e, n) {
    const { _cachedMeta: i, _data: s } = this, { iScale: r, _stacked: o } = i, a = r.axis;
    let l = e === 0 && n === s.length ? true : i._sorted, c = e > 0 && i._parsed[e - 1], u, d, f;
    if (this._parsing === false)
      i._parsed = s, i._sorted = true, f = s;
    else {
      wt(s[e]) ? f = this.parseArrayData(i, s, e, n) : Je(s[e]) ? f = this.parseObjectData(i, s, e, n) : f = this.parsePrimitiveData(i, s, e, n);
      const h10 = () => d[a] === null || c && d[a] < c[a];
      for (u = 0; u < n; ++u)
        i._parsed[u + e] = d = f[u], l && (h10() && (l = false), c = d);
      i._sorted = l;
    }
    o && ky(this, f);
  }
  parsePrimitiveData(e, n, i, s) {
    const { iScale: r, vScale: o } = e, a = r.axis, l = o.axis, c = r.getLabels(), u = r === o, d = new Array(s);
    let f, h10, p;
    for (f = 0, h10 = s; f < h10; ++f)
      p = f + i, d[f] = {
        [a]: u || r.parse(c[p], p),
        [l]: o.parse(n[p], p)
      };
    return d;
  }
  parseArrayData(e, n, i, s) {
    const { xScale: r, yScale: o } = e, a = new Array(s);
    let l, c, u, d;
    for (l = 0, c = s; l < c; ++l)
      u = l + i, d = n[u], a[l] = {
        x: r.parse(d[0], u),
        y: o.parse(d[1], u)
      };
    return a;
  }
  parseObjectData(e, n, i, s) {
    const { xScale: r, yScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(s);
    let u, d, f, h10;
    for (u = 0, d = s; u < d; ++u)
      f = u + i, h10 = n[f], c[u] = {
        x: r.parse(sr(h10, a), f),
        y: o.parse(sr(h10, l), f)
      };
    return c;
  }
  getParsed(e) {
    return this._cachedMeta._parsed[e];
  }
  getDataElement(e) {
    return this._cachedMeta.data[e];
  }
  applyStack(e, n, i) {
    const s = this.chart, r = this._cachedMeta, o = n[e.axis], a = {
      keys: k4(s, true),
      values: n._stacks[e.axis]._visualValues
    };
    return vy(a, o, r.index, {
      mode: i
    });
  }
  updateRangeFromParsed(e, n, i, s) {
    const r = i[n.axis];
    let o = r === null ? NaN : r;
    const a = s && i._stacks[n.axis];
    s && a && (s.values = a, o = vy(s, r, this._cachedMeta.index)), e.min = Math.min(e.min, o), e.max = Math.max(e.max, o);
  }
  getMinMax(e, n) {
    const i = this._cachedMeta, s = i._parsed, r = i._sorted && e === i.iScale, o = s.length, a = this._getOtherScale(e), l = Yq(n, i, this.chart), c = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: u, max: d } = Wq(a);
    let f, h10;
    function p() {
      h10 = s[f];
      const g = h10[a.axis];
      return !Yt(h10[e.axis]) || u > g || d < g;
    }
    for (f = 0; f < o && !(!p() && (this.updateRangeFromParsed(c, e, h10, l), r)); ++f)
      ;
    if (r) {
      for (f = o - 1; f >= 0; --f)
        if (!p()) {
          this.updateRangeFromParsed(c, e, h10, l);
          break;
        }
    }
    return c;
  }
  getAllParsedValues(e) {
    const n = this._cachedMeta._parsed, i = [];
    let s, r, o;
    for (s = 0, r = n.length; s < r; ++s)
      o = n[s][e.axis], Yt(o) && i.push(o);
    return i;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, i = n.iScale, s = n.vScale, r = this.getParsed(e);
    return {
      label: i ? "" + i.getLabelForValue(r[i.axis]) : "",
      value: s ? "" + s.getLabelForValue(r[s.axis]) : ""
    };
  }
  _update(e) {
    const n = this._cachedMeta;
    this.update(e || "default"), n._clip = zq(Ke(this.options.clip, Bq(n.xScale, n.yScale, this.getMaxOverflow())));
  }
  update(e) {
  }
  draw() {
    const e = this._ctx, n = this.chart, i = this._cachedMeta, s = i.data || [], r = n.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || s.length - a, c = this.options.drawActiveElementsOnTop;
    let u;
    for (i.dataset && i.dataset.draw(e, r, a, l), u = a; u < a + l; ++u) {
      const d = s[u];
      d.hidden || (d.active && c ? o.push(d) : d.draw(e, r));
    }
    for (u = 0; u < o.length; ++u)
      o[u].draw(e, r);
  }
  getStyle(e, n) {
    const i = n ? "active" : "default";
    return e === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(e || 0, i);
  }
  getContext(e, n, i) {
    const s = this.getDataset();
    let r;
    if (e >= 0 && e < this._cachedMeta.data.length) {
      const o = this._cachedMeta.data[e];
      r = o.$context || (o.$context = Kq(this.getContext(), e, o)), r.parsed = this.getParsed(e), r.raw = s.data[e], r.index = r.dataIndex = e;
    } else
      r = this.$context || (this.$context = qq(this.chart.getContext(), this.index)), r.dataset = s, r.index = r.datasetIndex = this.index;
    return r.active = !!n, r.mode = i, r;
  }
  resolveDatasetElementOptions(e) {
    return this._resolveElementOptions(this.datasetElementType.id, e);
  }
  resolveDataElementOptions(e, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, e);
  }
  _resolveElementOptions(e, n = "default", i) {
    const s = n === "active", r = this._cachedDataOpts, o = e + "-" + n, a = r[o], l = this.enableOptionSharing && vl(i);
    if (a)
      return Sy(a, l);
    const c = this.chart.config, u = c.datasetElementScopeKeys(this._type, e), d = s ? [
      `${e}Hover`,
      "hover",
      e,
      ""
    ] : [
      e,
      ""
    ], f = c.getOptionScopes(this.getDataset(), u), h10 = Object.keys(At.elements[e]), p = () => this.getContext(i, s, n), g = c.resolveNamedOptions(f, h10, p, d);
    return g.$shared && (g.$shared = l, r[o] = Object.freeze(Sy(g, l))), g;
  }
  _resolveAnimations(e, n, i) {
    const s = this.chart, r = this._cachedDataOpts, o = `animation-${n}`, a = r[o];
    if (a)
      return a;
    let l;
    if (s.options.animation !== false) {
      const u = this.chart.config, d = u.datasetAnimationScopeKeys(this._type, n), f = u.getOptionScopes(this.getDataset(), d);
      l = u.createResolver(f, this.getContext(e, i, n));
    }
    const c = new x4(s, l && l.animations);
    return l && l._cacheable && (r[o] = Object.freeze(c)), c;
  }
  getSharedOptions(e) {
    if (e.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, e));
  }
  includeOptions(e, n) {
    return !n || Vf(e) || this.chart._animationsDisabled;
  }
  _getSharedOptions(e, n) {
    const i = this.resolveDataElementOptions(e, n), s = this._sharedOptions, r = this.getSharedOptions(i), o = this.includeOptions(n, r) || r !== s;
    return this.updateSharedOptions(r, n, i), {
      sharedOptions: r,
      includeOptions: o
    };
  }
  updateElement(e, n, i, s) {
    Vf(s) ? Object.assign(e, i) : this._resolveAnimations(n, s).update(e, i);
  }
  updateSharedOptions(e, n, i) {
    e && !Vf(n) && this._resolveAnimations(void 0, n).update(e, i);
  }
  _setStyle(e, n, i, s) {
    e.active = s;
    const r = this.getStyle(n, s);
    this._resolveAnimations(n, i, s).update(e, {
      options: !s && this.getSharedOptions(r) || r
    });
  }
  removeHoverStyle(e, n, i) {
    this._setStyle(e, i, "active", false);
  }
  setHoverStyle(e, n, i) {
    this._setStyle(e, i, "active", true);
  }
  _removeDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", false);
  }
  _setDatasetHoverStyle() {
    const e = this._cachedMeta.dataset;
    e && this._setStyle(e, void 0, "active", true);
  }
  _resyncElements(e) {
    const n = this._data, i = this._cachedMeta.data;
    for (const [a, l, c] of this._syncList)
      this[a](l, c);
    this._syncList = [];
    const s = i.length, r = n.length, o = Math.min(r, s);
    o && this.parse(0, o), r > s ? this._insertElements(s, r - s, e) : r < s && this._removeElements(r, s - r);
  }
  _insertElements(e, n, i = true) {
    const s = this._cachedMeta, r = s.data, o = e + n;
    let a;
    const l = (c) => {
      for (c.length += n, a = c.length - 1; a >= o; a--)
        c[a] = c[a - n];
    };
    for (l(r), a = e; a < o; ++a)
      r[a] = new this.dataElementType();
    this._parsing && l(s._parsed), this.parse(e, n), i && this.updateElements(r, e, n, "reset");
  }
  updateElements(e, n, i, s) {
  }
  _removeElements(e, n) {
    const i = this._cachedMeta;
    if (this._parsing) {
      const s = i._parsed.splice(e, n);
      i._stacked && ca(i, s);
    }
    i.data.splice(e, n);
  }
  _sync(e) {
    if (this._parsing)
      this._syncList.push(e);
    else {
      const [n, i, s] = e;
      this[n](i, s);
    }
    this.chart._dataChanges.push([
      this.index,
      ...e
    ]);
  }
  _onDataPush() {
    const e = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - e,
      e
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(e, n) {
    n && this._sync([
      "_removeElements",
      e,
      n
    ]);
    const i = arguments.length - 2;
    i && this._sync([
      "_insertElements",
      e,
      i
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
ve(Gs, "defaults", {}), ve(Gs, "datasetElementType", null), ve(Gs, "dataElementType", null);
function Gq(t10, e) {
  if (!t10._cache.$bar) {
    const n = t10.getMatchingVisibleMetas(e);
    let i = [];
    for (let s = 0, r = n.length; s < r; s++)
      i = i.concat(n[s].controller.getAllParsedValues(t10));
    t10._cache.$bar = s4(i.sort((s, r) => s - r));
  }
  return t10._cache.$bar;
}
function Jq(t10) {
  const e = t10.iScale, n = Gq(e, t10.type);
  let i = e._length, s, r, o, a;
  const l = () => {
    o === 32767 || o === -32768 || (vl(a) && (i = Math.min(i, Math.abs(o - a) || i)), a = o);
  };
  for (s = 0, r = n.length; s < r; ++s)
    o = e.getPixelForValue(n[s]), l();
  for (a = void 0, s = 0, r = e.ticks.length; s < r; ++s)
    o = e.getPixelForTick(s), l();
  return i;
}
function Xq(t10, e, n, i) {
  const s = n.barThickness;
  let r, o;
  return et(s) ? (r = e.min * n.categoryPercentage, o = n.barPercentage) : (r = s * i, o = 1), {
    chunk: r / i,
    ratio: o,
    start: e.pixels[t10] - r / 2
  };
}
function Qq(t10, e, n, i) {
  const s = e.pixels, r = s[t10];
  let o = t10 > 0 ? s[t10 - 1] : null, a = t10 < s.length - 1 ? s[t10 + 1] : null;
  const l = n.categoryPercentage;
  o === null && (o = r - (a === null ? e.end - e.start : a - r)), a === null && (a = r + r - o);
  const c = r - (r - Math.min(o, a)) / 2 * l;
  return {
    chunk: Math.abs(a - o) / 2 * l / i,
    ratio: n.barPercentage,
    start: c
  };
}
function Zq(t10, e, n, i) {
  const s = n.parse(t10[0], i), r = n.parse(t10[1], i), o = Math.min(s, r), a = Math.max(s, r);
  let l = o, c = a;
  Math.abs(o) > Math.abs(a) && (l = a, c = o), e[n.axis] = c, e._custom = {
    barStart: l,
    barEnd: c,
    start: s,
    end: r,
    min: o,
    max: a
  };
}
function S4(t10, e, n, i) {
  return wt(t10) ? Zq(t10, e, n, i) : e[n.axis] = n.parse(t10, i), e;
}
function wy(t10, e, n, i) {
  const s = t10.iScale, r = t10.vScale, o = s.getLabels(), a = s === r, l = [];
  let c, u, d, f;
  for (c = n, u = n + i; c < u; ++c)
    f = e[c], d = {}, d[s.axis] = a || s.parse(o[c], c), l.push(S4(f, d, r, c));
  return l;
}
function Bf(t10) {
  return t10 && t10.barStart !== void 0 && t10.barEnd !== void 0;
}
function eK(t10, e, n) {
  return t10 !== 0 ? ji(t10) : (e.isHorizontal() ? 1 : -1) * (e.min >= n ? 1 : -1);
}
function tK(t10) {
  let e, n, i, s, r;
  return t10.horizontal ? (e = t10.base > t10.x, n = "left", i = "right") : (e = t10.base < t10.y, n = "bottom", i = "top"), e ? (s = "end", r = "start") : (s = "start", r = "end"), {
    start: n,
    end: i,
    reverse: e,
    top: s,
    bottom: r
  };
}
function nK(t10, e, n, i) {
  let s = e.borderSkipped;
  const r = {};
  if (!s) {
    t10.borderSkipped = r;
    return;
  }
  if (s === true) {
    t10.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start: o, end: a, reverse: l, top: c, bottom: u } = tK(t10);
  s === "middle" && n && (t10.enableBorderRadius = true, (n._top || 0) === i ? s = c : (n._bottom || 0) === i ? s = u : (r[Cy(u, o, a, l)] = true, s = c)), r[Cy(s, o, a, l)] = true, t10.borderSkipped = r;
}
function Cy(t10, e, n, i) {
  return i ? (t10 = iK(t10, e, n), t10 = Oy(t10, n, e)) : t10 = Oy(t10, e, n), t10;
}
function iK(t10, e, n) {
  return t10 === e ? n : t10 === n ? e : t10;
}
function Oy(t10, e, n) {
  return t10 === "start" ? e : t10 === "end" ? n : t10;
}
function sK(t10, { inflateAmount: e }, n) {
  t10.inflateAmount = e === "auto" ? n === 1 ? 0.33 : 0 : e;
}
var Ac = class extends Gs {
  parsePrimitiveData(e, n, i, s) {
    return wy(e, n, i, s);
  }
  parseArrayData(e, n, i, s) {
    return wy(e, n, i, s);
  }
  parseObjectData(e, n, i, s) {
    const { iScale: r, vScale: o } = e, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = r.axis === "x" ? a : l, u = o.axis === "x" ? a : l, d = [];
    let f, h10, p, g;
    for (f = i, h10 = i + s; f < h10; ++f)
      g = n[f], p = {}, p[r.axis] = r.parse(sr(g, c), f), d.push(S4(sr(g, u), p, o, f));
    return d;
  }
  updateRangeFromParsed(e, n, i, s) {
    super.updateRangeFromParsed(e, n, i, s);
    const r = i._custom;
    r && n === this._cachedMeta.vScale && (e.min = Math.min(e.min, r.min), e.max = Math.max(e.max, r.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, { iScale: i, vScale: s } = n, r = this.getParsed(e), o = r._custom, a = Bf(o) ? "[" + o.start + ", " + o.end + "]" : "" + s.getLabelForValue(r[s.axis]);
    return {
      label: "" + i.getLabelForValue(r[i.axis]),
      value: a
    };
  }
  initialize() {
    this.enableOptionSharing = true, super.initialize();
    const e = this._cachedMeta;
    e.stack = this.getDataset().stack;
  }
  update(e) {
    const n = this._cachedMeta;
    this.updateElements(n.data, 0, n.data.length, e);
  }
  updateElements(e, n, i, s) {
    const r = s === "reset", { index: o, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), u = this._getRuler(), { sharedOptions: d, includeOptions: f } = this._getSharedOptions(n, s);
    for (let h10 = n; h10 < n + i; h10++) {
      const p = this.getParsed(h10), g = r || et(p[a.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(h10), m = this._calculateBarIndexPixels(h10, u), b = (p._stacks || {})[a.axis], x = {
        horizontal: c,
        base: g.base,
        enableBorderRadius: !b || Bf(p._custom) || o === b._top || o === b._bottom,
        x: c ? g.head : m.center,
        y: c ? m.center : g.head,
        height: c ? m.size : Math.abs(g.size),
        width: c ? Math.abs(g.size) : m.size
      };
      f && (x.options = d || this.resolveDataElementOptions(h10, e[h10].active ? "active" : s));
      const k = x.options || e[h10].options;
      nK(x, k, b, o), sK(x, k, u.ratio), this.updateElement(e[h10], h10, x, s);
    }
  }
  _getStacks(e, n) {
    const { iScale: i } = this._cachedMeta, s = i.getMatchingVisibleMetas(this._type).filter((u) => u.controller.options.grouped), r = i.options.stacked, o = [], a = this._cachedMeta.controller.getParsed(n), l = a && a[i.axis], c = (u) => {
      const d = u._parsed.find((h10) => h10[i.axis] === l), f = d && d[u.vScale.axis];
      if (et(f) || isNaN(f))
        return true;
    };
    for (const u of s)
      if (!(n !== void 0 && c(u)) && ((r === false || o.indexOf(u.stack) === -1 || r === void 0 && u.stack === void 0) && o.push(u.stack), u.index === e))
        break;
    return o.length || o.push(void 0), o;
  }
  _getStackCount(e) {
    return this._getStacks(void 0, e).length;
  }
  _getStackIndex(e, n, i) {
    const s = this._getStacks(e, i), r = n !== void 0 ? s.indexOf(n) : -1;
    return r === -1 ? s.length - 1 : r;
  }
  _getRuler() {
    const e = this.options, n = this._cachedMeta, i = n.iScale, s = [];
    let r, o;
    for (r = 0, o = n.data.length; r < o; ++r)
      s.push(i.getPixelForValue(this.getParsed(r)[i.axis], r));
    const a = e.barThickness;
    return {
      min: a || Jq(n),
      pixels: s,
      start: i._startPixel,
      end: i._endPixel,
      stackCount: this._getStackCount(),
      scale: i,
      grouped: e.grouped,
      ratio: a ? 1 : e.categoryPercentage * e.barPercentage
    };
  }
  _calculateBarValuePixels(e) {
    const { _cachedMeta: { vScale: n, _stacked: i, index: s }, options: { base: r, minBarLength: o } } = this, a = r || 0, l = this.getParsed(e), c = l._custom, u = Bf(c);
    let d = l[n.axis], f = 0, h10 = i ? this.applyStack(n, l, i) : d, p, g;
    h10 !== d && (f = h10 - d, h10 = d), u && (d = c.barStart, h10 = c.barEnd - c.barStart, d !== 0 && ji(d) !== ji(c.barEnd) && (f = 0), f += d);
    const m = !et(r) && !u ? r : f;
    let b = n.getPixelForValue(m);
    if (this.chart.getDataVisibility(e) ? p = n.getPixelForValue(f + h10) : p = b, g = p - b, Math.abs(g) < o) {
      g = eK(g, n, a) * o, d === a && (b -= g / 2);
      const x = n.getPixelForDecimal(0), k = n.getPixelForDecimal(1), v = Math.min(x, k), S = Math.max(x, k);
      b = Math.max(Math.min(b, S), v), p = b + g, i && !u && (l._stacks[n.axis]._visualValues[s] = n.getValueForPixel(p) - n.getValueForPixel(b));
    }
    if (b === n.getPixelForValue(a)) {
      const x = ji(g) * n.getLineWidthForValue(a) / 2;
      b += x, g -= x;
    }
    return {
      size: g,
      base: b,
      head: p,
      center: p + g / 2
    };
  }
  _calculateBarIndexPixels(e, n) {
    const i = n.scale, s = this.options, r = s.skipNull, o = Ke(s.maxBarThickness, 1 / 0);
    let a, l;
    if (n.grouped) {
      const c = r ? this._getStackCount(e) : n.stackCount, u = s.barThickness === "flex" ? Qq(e, n, s, c) : Xq(e, n, s, c), d = this._getStackIndex(this.index, this._cachedMeta.stack, r ? e : void 0);
      a = u.start + u.chunk * d + u.chunk / 2, l = Math.min(o, u.chunk * u.ratio);
    } else
      a = i.getPixelForValue(this.getParsed(e)[i.axis], e), l = Math.min(o, n.min * n.ratio);
    return {
      base: a - l / 2,
      head: a + l / 2,
      center: a,
      size: l
    };
  }
  draw() {
    const e = this._cachedMeta, n = e.vScale, i = e.data, s = i.length;
    let r = 0;
    for (; r < s; ++r)
      this.getParsed(r)[n.axis] !== null && !i[r].hidden && i[r].draw(this._ctx);
  }
};
ve(Ac, "id", "bar"), ve(Ac, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
}), ve(Ac, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
function rK(t10, e, n) {
  let i = 1, s = 1, r = 0, o = 0;
  if (e < bt) {
    const a = t10, l = a + e, c = Math.cos(a), u = Math.sin(a), d = Math.cos(l), f = Math.sin(l), h10 = (k, v, S) => kl(k, a, l, true) ? 1 : Math.max(v, v * n, S, S * n), p = (k, v, S) => kl(k, a, l, true) ? -1 : Math.min(v, v * n, S, S * n), g = h10(0, c, d), m = h10(Lt, u, f), b = p(_t, c, d), x = p(_t + Lt, u, f);
    i = (g - b) / 2, s = (m - x) / 2, r = -(g + b) / 2, o = -(m + x) / 2;
  }
  return {
    ratioX: i,
    ratioY: s,
    offsetX: r,
    offsetY: o
  };
}
var wa = class extends Gs {
  constructor(e, n) {
    super(e, n), this.enableOptionSharing = true, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(e, n) {
    const i = this.getDataset().data, s = this._cachedMeta;
    if (this._parsing === false)
      s._parsed = i;
    else {
      let r = (l) => +i[l];
      if (Je(i[e])) {
        const { key: l = "value" } = this._parsing;
        r = (c) => +sr(i[c], l);
      }
      let o, a;
      for (o = e, a = e + n; o < a; ++o)
        s._parsed[o] = r(o);
    }
  }
  _getRotation() {
    return $i(this.options.rotation - 90);
  }
  _getCircumference() {
    return $i(this.options.circumference);
  }
  _getRotationExtents() {
    let e = bt, n = -bt;
    for (let i = 0; i < this.chart.data.datasets.length; ++i)
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const s = this.chart.getDatasetMeta(i).controller, r = s._getRotation(), o = s._getCircumference();
        e = Math.min(e, r), n = Math.max(n, r + o);
      }
    return {
      rotation: e,
      circumference: n - e
    };
  }
  update(e) {
    const n = this.chart, { chartArea: i } = n, s = this._cachedMeta, r = s.data, o = this.getMaxBorderWidth() + this.getMaxOffset(r) + this.options.spacing, a = Math.max((Math.min(i.width, i.height) - o) / 2, 0), l = Math.min(hU(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: u, rotation: d } = this._getRotationExtents(), { ratioX: f, ratioY: h10, offsetX: p, offsetY: g } = rK(d, u, l), m = (i.width - o) / f, b = (i.height - o) / h10, x = Math.max(Math.min(m, b) / 2, 0), k = Zk(this.options.radius, x), v = Math.max(k * l, 0), S = (k - v) / this._getVisibleDatasetWeightTotal();
    this.offsetX = p * k, this.offsetY = g * k, s.total = this.calculateTotal(), this.outerRadius = k - S * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - S * c, 0), this.updateElements(r, 0, r.length, e);
  }
  _circumference(e, n) {
    const i = this.options, s = this._cachedMeta, r = this._getCircumference();
    return n && i.animation.animateRotate || !this.chart.getDataVisibility(e) || s._parsed[e] === null || s.data[e].hidden ? 0 : this.calculateCircumference(s._parsed[e] * r / bt);
  }
  updateElements(e, n, i, s) {
    const r = s === "reset", o = this.chart, a = o.chartArea, c = o.options.animation, u = (a.left + a.right) / 2, d = (a.top + a.bottom) / 2, f = r && c.animateScale, h10 = f ? 0 : this.innerRadius, p = f ? 0 : this.outerRadius, { sharedOptions: g, includeOptions: m } = this._getSharedOptions(n, s);
    let b = this._getRotation(), x;
    for (x = 0; x < n; ++x)
      b += this._circumference(x, r);
    for (x = n; x < n + i; ++x) {
      const k = this._circumference(x, r), v = e[x], S = {
        x: u + this.offsetX,
        y: d + this.offsetY,
        startAngle: b,
        endAngle: b + k,
        circumference: k,
        outerRadius: p,
        innerRadius: h10
      };
      m && (S.options = g || this.resolveDataElementOptions(x, v.active ? "active" : s)), b += k, this.updateElement(v, x, S, s);
    }
  }
  calculateTotal() {
    const e = this._cachedMeta, n = e.data;
    let i = 0, s;
    for (s = 0; s < n.length; s++) {
      const r = e._parsed[s];
      r !== null && !isNaN(r) && this.chart.getDataVisibility(s) && !n[s].hidden && (i += Math.abs(r));
    }
    return i;
  }
  calculateCircumference(e) {
    const n = this._cachedMeta.total;
    return n > 0 && !isNaN(e) ? bt * (Math.abs(e) / n) : 0;
  }
  getLabelAndValue(e) {
    const n = this._cachedMeta, i = this.chart, s = i.data.labels || [], r = Gm(n._parsed[e], i.options.locale);
    return {
      label: s[e] || "",
      value: r
    };
  }
  getMaxBorderWidth(e) {
    let n = 0;
    const i = this.chart;
    let s, r, o, a, l;
    if (!e) {
      for (s = 0, r = i.data.datasets.length; s < r; ++s)
        if (i.isDatasetVisible(s)) {
          o = i.getDatasetMeta(s), e = o.data, a = o.controller;
          break;
        }
    }
    if (!e)
      return 0;
    for (s = 0, r = e.length; s < r; ++s)
      l = a.resolveDataElementOptions(s), l.borderAlign !== "inner" && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return n;
  }
  getMaxOffset(e) {
    let n = 0;
    for (let i = 0, s = e.length; i < s; ++i) {
      const r = this.resolveDataElementOptions(i);
      n = Math.max(n, r.offset || 0, r.hoverOffset || 0);
    }
    return n;
  }
  _getRingWeightOffset(e) {
    let n = 0;
    for (let i = 0; i < e; ++i)
      this.chart.isDatasetVisible(i) && (n += this._getRingWeight(i));
    return n;
  }
  _getRingWeight(e) {
    return Math.max(Ke(this.chart.data.datasets[e].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
ve(wa, "id", "doughnut"), ve(wa, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), ve(wa, "descriptors", {
  _scriptable: (e) => e !== "spacing",
  _indexable: (e) => e !== "spacing" && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash")
}), ve(wa, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(e) {
          const n = e.data;
          if (n.labels.length && n.datasets.length) {
            const { labels: { pointStyle: i, color: s } } = e.legend.options;
            return n.labels.map((r, o) => {
              const l = e.getDatasetMeta(0).controller.getStyle(o);
              return {
                text: r,
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                fontColor: s,
                lineWidth: l.borderWidth,
                pointStyle: i,
                hidden: !e.getDataVisibility(o),
                index: o
              };
            });
          }
          return [];
        }
      },
      onClick(e, n, i) {
        i.chart.toggleDataVisibility(n.index), i.chart.update();
      }
    }
  }
});
var _c = class extends Gs {
  initialize() {
    this.enableOptionSharing = true, this.supportsDecimation = true, super.initialize();
  }
  update(e) {
    const n = this._cachedMeta, { dataset: i, data: s = [], _dataset: r } = n, o = this.chart._animationsDisabled;
    let { start: a, count: l } = LU(n, s, o);
    this._drawStart = a, this._drawCount = l, IU(n) && (a = 0, l = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!r._decimated, i.points = s;
    const c = this.resolveDatasetElementOptions(e);
    this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(i, void 0, {
      animated: !o,
      options: c
    }, e), this.updateElements(s, a, l, e);
  }
  updateElements(e, n, i, s) {
    const r = s === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: u, includeOptions: d } = this._getSharedOptions(n, s), f = o.axis, h10 = a.axis, { spanGaps: p, segment: g } = this.options, m = xl(p) ? p : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || r || s === "none", x = n + i, k = e.length;
    let v = n > 0 && this.getParsed(n - 1);
    for (let S = 0; S < k; ++S) {
      const w = e[S], E = b ? w : {};
      if (S < n || S >= x) {
        E.skip = true;
        continue;
      }
      const M = this.getParsed(S), N = et(M[h10]), V = E[f] = o.getPixelForValue(M[f], S), Y = E[h10] = r || N ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, M, l) : M[h10], S);
      E.skip = isNaN(V) || isNaN(Y) || N, E.stop = S > 0 && Math.abs(M[f] - v[f]) > m, g && (E.parsed = M, E.raw = c.data[S]), d && (E.options = u || this.resolveDataElementOptions(S, w.active ? "active" : s)), b || this.updateElement(w, S, E, s), v = M;
    }
  }
  getMaxOverflow() {
    const e = this._cachedMeta, n = e.dataset, i = n.options && n.options.borderWidth || 0, s = e.data || [];
    if (!s.length)
      return i;
    const r = s[0].size(this.resolveDataElementOptions(0)), o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));
    return Math.max(i, r, o) / 2;
  }
  draw() {
    const e = this._cachedMeta;
    e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw();
  }
};
ve(_c, "id", "line"), ve(_c, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
}), ve(_c, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
var Nc = class extends Gs {
  getLabelAndValue(e) {
    const n = this._cachedMeta.vScale, i = this.getParsed(e);
    return {
      label: n.getLabels()[e],
      value: "" + n.getLabelForValue(i[n.axis])
    };
  }
  parseObjectData(e, n, i, s) {
    return uq.bind(this)(e, n, i, s);
  }
  update(e) {
    const n = this._cachedMeta, i = n.dataset, s = n.data || [], r = n.iScale.getLabels();
    if (i.points = s, e !== "resize") {
      const o = this.resolveDatasetElementOptions(e);
      this.options.showLine || (o.borderWidth = 0);
      const a = {
        _loop: true,
        _fullLoop: r.length === s.length,
        options: o
      };
      this.updateElement(i, void 0, a, e);
    }
    this.updateElements(s, 0, s.length, e);
  }
  updateElements(e, n, i, s) {
    const r = this._cachedMeta.rScale, o = s === "reset";
    for (let a = n; a < n + i; a++) {
      const l = e[a], c = this.resolveDataElementOptions(a, l.active ? "active" : s), u = r.getPointPositionForValue(a, this.getParsed(a).r), d = o ? r.xCenter : u.x, f = o ? r.yCenter : u.y, h10 = {
        x: d,
        y: f,
        angle: u.angle,
        skip: isNaN(d) || isNaN(f),
        options: c
      };
      this.updateElement(l, a, h10, s);
    }
  }
};
ve(Nc, "id", "radar"), ve(Nc, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
}), ve(Nc, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
function yr() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var ig = class _ig {
  constructor(e) {
    ve(this, "options");
    this.options = e || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(e) {
    Object.assign(_ig.prototype, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return yr();
  }
  parse() {
    return yr();
  }
  format() {
    return yr();
  }
  add() {
    return yr();
  }
  diff() {
    return yr();
  }
  startOf() {
    return yr();
  }
  endOf() {
    return yr();
  }
};
var oK = {
  _date: ig
};
function aK(t10, e, n, i) {
  const { controller: s, data: r, _sorted: o } = t10, a = s._cachedMeta.iScale, l = t10.dataset && t10.dataset.options ? t10.dataset.options.spanGaps : null;
  if (a && e === a.axis && e !== "r" && o && r.length) {
    const c = a._reversePixels ? MU : Lr;
    if (i) {
      if (s._sharedOptions) {
        const u = r[0], d = typeof u.getRange == "function" && u.getRange(e);
        if (d) {
          const f = c(r, e, n - d), h10 = c(r, e, n + d);
          return {
            lo: f.lo,
            hi: h10.hi
          };
        }
      }
    } else {
      const u = c(r, e, n);
      if (l) {
        const { vScale: d } = s._cachedMeta, { _parsed: f } = t10, h10 = f.slice(0, u.lo + 1).reverse().findIndex((g) => !et(g[d.axis]));
        u.lo -= Math.max(0, h10);
        const p = f.slice(u.hi).findIndex((g) => !et(g[d.axis]));
        u.hi += Math.max(0, p);
      }
      return u;
    }
  }
  return {
    lo: 0,
    hi: r.length - 1
  };
}
function Bd(t10, e, n, i, s) {
  const r = t10.getSortedVisibleDatasetMetas(), o = n[e];
  for (let a = 0, l = r.length; a < l; ++a) {
    const { index: c, data: u } = r[a], { lo: d, hi: f } = aK(r[a], e, o, s);
    for (let h10 = d; h10 <= f; ++h10) {
      const p = u[h10];
      p.skip || i(p, c, h10);
    }
  }
}
function lK(t10) {
  const e = t10.indexOf("x") !== -1, n = t10.indexOf("y") !== -1;
  return function(i, s) {
    const r = e ? Math.abs(i.x - s.x) : 0, o = n ? Math.abs(i.y - s.y) : 0;
    return Math.sqrt(Math.pow(r, 2) + Math.pow(o, 2));
  };
}
function zf(t10, e, n, i, s) {
  const r = [];
  return !s && !t10.isPointInArea(e) || Bd(t10, n, e, function(a, l, c) {
    !s && !ms(a, t10.chartArea, 0) || a.inRange(e.x, e.y, i) && r.push({
      element: a,
      datasetIndex: l,
      index: c
    });
  }, true), r;
}
function cK(t10, e, n, i) {
  let s = [];
  function r(o, a, l) {
    const { startAngle: c, endAngle: u } = o.getProps([
      "startAngle",
      "endAngle"
    ], i), { angle: d } = n4(o, {
      x: e.x,
      y: e.y
    });
    kl(d, c, u) && s.push({
      element: o,
      datasetIndex: a,
      index: l
    });
  }
  return Bd(t10, n, e, r), s;
}
function uK(t10, e, n, i, s, r) {
  let o = [];
  const a = lK(n);
  let l = Number.POSITIVE_INFINITY;
  function c(u, d, f) {
    const h10 = u.inRange(e.x, e.y, s);
    if (i && !h10)
      return;
    const p = u.getCenterPoint(s);
    if (!(!!r || t10.isPointInArea(p)) && !h10)
      return;
    const m = a(e, p);
    m < l ? (o = [
      {
        element: u,
        datasetIndex: d,
        index: f
      }
    ], l = m) : m === l && o.push({
      element: u,
      datasetIndex: d,
      index: f
    });
  }
  return Bd(t10, n, e, c), o;
}
function jf(t10, e, n, i, s, r) {
  return !r && !t10.isPointInArea(e) ? [] : n === "r" && !i ? cK(t10, e, n, s) : uK(t10, e, n, i, s, r);
}
function Ey(t10, e, n, i, s) {
  const r = [], o = n === "x" ? "inXRange" : "inYRange";
  let a = false;
  return Bd(t10, n, e, (l, c, u) => {
    l[o] && l[o](e[n], s) && (r.push({
      element: l,
      datasetIndex: c,
      index: u
    }), a = a || l.inRange(e.x, e.y, s));
  }), i && !a ? [] : r;
}
var dK = {
  modes: {
    index(t10, e, n, i) {
      const s = Sr(e, t10), r = n.axis || "x", o = n.includeInvisible || false, a = n.intersect ? zf(t10, s, r, i, o) : jf(t10, s, r, false, i, o), l = [];
      return a.length ? (t10.getSortedVisibleDatasetMetas().forEach((c) => {
        const u = a[0].index, d = c.data[u];
        d && !d.skip && l.push({
          element: d,
          datasetIndex: c.index,
          index: u
        });
      }), l) : [];
    },
    dataset(t10, e, n, i) {
      const s = Sr(e, t10), r = n.axis || "xy", o = n.includeInvisible || false;
      let a = n.intersect ? zf(t10, s, r, i, o) : jf(t10, s, r, false, i, o);
      if (a.length > 0) {
        const l = a[0].datasetIndex, c = t10.getDatasetMeta(l).data;
        a = [];
        for (let u = 0; u < c.length; ++u)
          a.push({
            element: c[u],
            datasetIndex: l,
            index: u
          });
      }
      return a;
    },
    point(t10, e, n, i) {
      const s = Sr(e, t10), r = n.axis || "xy", o = n.includeInvisible || false;
      return zf(t10, s, r, i, o);
    },
    nearest(t10, e, n, i) {
      const s = Sr(e, t10), r = n.axis || "xy", o = n.includeInvisible || false;
      return jf(t10, s, r, n.intersect, i, o);
    },
    x(t10, e, n, i) {
      const s = Sr(e, t10);
      return Ey(t10, s, "x", n.intersect, i);
    },
    y(t10, e, n, i) {
      const s = Sr(e, t10);
      return Ey(t10, s, "y", n.intersect, i);
    }
  }
};
var w4 = [
  "left",
  "top",
  "right",
  "bottom"
];
function ua(t10, e) {
  return t10.filter((n) => n.pos === e);
}
function My(t10, e) {
  return t10.filter((n) => w4.indexOf(n.pos) === -1 && n.box.axis === e);
}
function da(t10, e) {
  return t10.sort((n, i) => {
    const s = e ? i : n, r = e ? n : i;
    return s.weight === r.weight ? s.index - r.index : s.weight - r.weight;
  });
}
function fK(t10) {
  const e = [];
  let n, i, s, r, o, a;
  for (n = 0, i = (t10 || []).length; n < i; ++n)
    s = t10[n], { position: r, options: { stack: o, stackWeight: a = 1 } } = s, e.push({
      index: n,
      box: s,
      pos: r,
      horizontal: s.isHorizontal(),
      weight: s.weight,
      stack: o && r + o,
      stackWeight: a
    });
  return e;
}
function hK(t10) {
  const e = {};
  for (const n of t10) {
    const { stack: i, pos: s, stackWeight: r } = n;
    if (!i || !w4.includes(s))
      continue;
    const o = e[i] || (e[i] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    o.count++, o.weight += r;
  }
  return e;
}
function pK(t10, e) {
  const n = hK(t10), { vBoxMaxWidth: i, hBoxMaxHeight: s } = e;
  let r, o, a;
  for (r = 0, o = t10.length; r < o; ++r) {
    a = t10[r];
    const { fullSize: l } = a.box, c = n[a.stack], u = c && a.stackWeight / c.weight;
    a.horizontal ? (a.width = u ? u * i : l && e.availableWidth, a.height = s) : (a.width = i, a.height = u ? u * s : l && e.availableHeight);
  }
  return n;
}
function mK(t10) {
  const e = fK(t10), n = da(e.filter((c) => c.box.fullSize), true), i = da(ua(e, "left"), true), s = da(ua(e, "right")), r = da(ua(e, "top"), true), o = da(ua(e, "bottom")), a = My(e, "x"), l = My(e, "y");
  return {
    fullSize: n,
    leftAndTop: i.concat(r),
    rightAndBottom: s.concat(l).concat(o).concat(a),
    chartArea: ua(e, "chartArea"),
    vertical: i.concat(s).concat(l),
    horizontal: r.concat(o).concat(a)
  };
}
function Ty(t10, e, n, i) {
  return Math.max(t10[n], e[n]) + Math.max(t10[i], e[i]);
}
function C4(t10, e) {
  t10.top = Math.max(t10.top, e.top), t10.left = Math.max(t10.left, e.left), t10.bottom = Math.max(t10.bottom, e.bottom), t10.right = Math.max(t10.right, e.right);
}
function gK(t10, e, n, i) {
  const { pos: s, box: r } = n, o = t10.maxPadding;
  if (!Je(s)) {
    n.size && (t10[s] -= n.size);
    const d = i[n.stack] || {
      size: 0,
      count: 1
    };
    d.size = Math.max(d.size, n.horizontal ? r.height : r.width), n.size = d.size / d.count, t10[s] += n.size;
  }
  r.getPadding && C4(o, r.getPadding());
  const a = Math.max(0, e.outerWidth - Ty(o, t10, "left", "right")), l = Math.max(0, e.outerHeight - Ty(o, t10, "top", "bottom")), c = a !== t10.w, u = l !== t10.h;
  return t10.w = a, t10.h = l, n.horizontal ? {
    same: c,
    other: u
  } : {
    same: u,
    other: c
  };
}
function bK(t10) {
  const e = t10.maxPadding;
  function n(i) {
    const s = Math.max(e[i] - t10[i], 0);
    return t10[i] += s, s;
  }
  t10.y += n("top"), t10.x += n("left"), n("right"), n("bottom");
}
function yK(t10, e) {
  const n = e.maxPadding;
  function i(s) {
    const r = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return s.forEach((o) => {
      r[o] = Math.max(e[o], n[o]);
    }), r;
  }
  return i(t10 ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Ca(t10, e, n, i) {
  const s = [];
  let r, o, a, l, c, u;
  for (r = 0, o = t10.length, c = 0; r < o; ++r) {
    a = t10[r], l = a.box, l.update(a.width || e.w, a.height || e.h, yK(a.horizontal, e));
    const { same: d, other: f } = gK(e, n, a, i);
    c |= d && s.length, u = u || f, l.fullSize || s.push(a);
  }
  return c && Ca(s, e, n, i) || u;
}
function uc(t10, e, n, i, s) {
  t10.top = n, t10.left = e, t10.right = e + i, t10.bottom = n + s, t10.width = i, t10.height = s;
}
function Ay(t10, e, n, i) {
  const s = n.padding;
  let { x: r, y: o } = e;
  for (const a of t10) {
    const l = a.box, c = i[a.stack] || {
      placed: 0,
      weight: 1
    }, u = a.stackWeight / c.weight || 1;
    if (a.horizontal) {
      const d = e.w * u, f = c.size || l.height;
      vl(c.start) && (o = c.start), l.fullSize ? uc(l, s.left, o, n.outerWidth - s.right - s.left, f) : uc(l, e.left + c.placed, o, d, f), c.start = o, c.placed += d, o = l.bottom;
    } else {
      const d = e.h * u, f = c.size || l.width;
      vl(c.start) && (r = c.start), l.fullSize ? uc(l, r, s.top, f, n.outerHeight - s.bottom - s.top) : uc(l, r, e.top + c.placed, f, d), c.start = r, c.placed += d, r = l.right;
    }
  }
  e.x = r, e.y = o;
}
var zs = {
  addBox(t10, e) {
    t10.boxes || (t10.boxes = []), e.fullSize = e.fullSize || false, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function() {
      return [
        {
          z: 0,
          draw(n) {
            e.draw(n);
          }
        }
      ];
    }, t10.boxes.push(e);
  },
  removeBox(t10, e) {
    const n = t10.boxes ? t10.boxes.indexOf(e) : -1;
    n !== -1 && t10.boxes.splice(n, 1);
  },
  configure(t10, e, n) {
    e.fullSize = n.fullSize, e.position = n.position, e.weight = n.weight;
  },
  update(t10, e, n, i) {
    if (!t10)
      return;
    const s = xn(t10.options.layout.padding), r = Math.max(e - s.width, 0), o = Math.max(n - s.height, 0), a = mK(t10.boxes), l = a.vertical, c = a.horizontal;
    ot(t10.boxes, (g) => {
      typeof g.beforeLayout == "function" && g.beforeLayout();
    });
    const u = l.reduce((g, m) => m.box.options && m.box.options.display === false ? g : g + 1, 0) || 1, d = Object.freeze({
      outerWidth: e,
      outerHeight: n,
      padding: s,
      availableWidth: r,
      availableHeight: o,
      vBoxMaxWidth: r / 2 / u,
      hBoxMaxHeight: o / 2
    }), f = Object.assign({}, s);
    C4(f, xn(i));
    const h10 = Object.assign({
      maxPadding: f,
      w: r,
      h: o,
      x: s.left,
      y: s.top
    }, s), p = pK(l.concat(c), d);
    Ca(a.fullSize, h10, d, p), Ca(l, h10, d, p), Ca(c, h10, d, p) && Ca(l, h10, d, p), bK(h10), Ay(a.leftAndTop, h10, d, p), h10.x += h10.w, h10.y += h10.h, Ay(a.rightAndBottom, h10, d, p), t10.chartArea = {
      left: h10.left,
      top: h10.top,
      right: h10.left + h10.w,
      bottom: h10.top + h10.h,
      height: h10.h,
      width: h10.w
    }, ot(a.chartArea, (g) => {
      const m = g.box;
      Object.assign(m, t10.chartArea), m.update(h10.w, h10.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var O4 = class {
  acquireContext(e, n) {
  }
  releaseContext(e) {
    return false;
  }
  addEventListener(e, n, i) {
  }
  removeEventListener(e, n, i) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(e, n, i, s) {
    return n = Math.max(0, n || e.width), i = i || e.height, {
      width: n,
      height: Math.max(0, s ? Math.floor(n / s) : i)
    };
  }
  isAttached(e) {
    return true;
  }
  updateConfig(e) {
  }
};
var vK = class extends O4 {
  acquireContext(e) {
    return e && e.getContext && e.getContext("2d") || null;
  }
  updateConfig(e) {
    e.options.animation = false;
  }
};
var Lc = "$chartjs";
var xK = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var _y = (t10) => t10 === null || t10 === "";
function kK(t10, e) {
  const n = t10.style, i = t10.getAttribute("height"), s = t10.getAttribute("width");
  if (t10[Lc] = {
    initial: {
      height: i,
      width: s,
      style: {
        display: n.display,
        height: n.height,
        width: n.width
      }
    }
  }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", _y(s)) {
    const r = hy(t10, "width");
    r !== void 0 && (t10.width = r);
  }
  if (_y(i))
    if (t10.style.height === "")
      t10.height = t10.width / (e || 2);
    else {
      const r = hy(t10, "height");
      r !== void 0 && (t10.height = r);
    }
  return t10;
}
var E4 = Cq ? {
  passive: true
} : false;
function SK(t10, e, n) {
  t10 && t10.addEventListener(e, n, E4);
}
function wK(t10, e, n) {
  t10 && t10.canvas && t10.canvas.removeEventListener(e, n, E4);
}
function CK(t10, e) {
  const n = xK[t10.type] || t10.type, { x: i, y: s } = Sr(t10, e);
  return {
    type: n,
    chart: e,
    native: t10,
    x: i !== void 0 ? i : null,
    y: s !== void 0 ? s : null
  };
}
function Wu(t10, e) {
  for (const n of t10)
    if (n === e || n.contains(e))
      return true;
}
function OK(t10, e, n) {
  const i = t10.canvas, s = new MutationObserver((r) => {
    let o = false;
    for (const a of r)
      o = o || Wu(a.addedNodes, i), o = o && !Wu(a.removedNodes, i);
    o && n();
  });
  return s.observe(document, {
    childList: true,
    subtree: true
  }), s;
}
function EK(t10, e, n) {
  const i = t10.canvas, s = new MutationObserver((r) => {
    let o = false;
    for (const a of r)
      o = o || Wu(a.removedNodes, i), o = o && !Wu(a.addedNodes, i);
    o && n();
  });
  return s.observe(document, {
    childList: true,
    subtree: true
  }), s;
}
var wl = /* @__PURE__ */ new Map();
var Ny = 0;
function M4() {
  const t10 = window.devicePixelRatio;
  t10 !== Ny && (Ny = t10, wl.forEach((e, n) => {
    n.currentDevicePixelRatio !== t10 && e();
  }));
}
function MK(t10, e) {
  wl.size || window.addEventListener("resize", M4), wl.set(t10, e);
}
function TK(t10) {
  wl.delete(t10), wl.size || window.removeEventListener("resize", M4);
}
function AK(t10, e, n) {
  const i = t10.canvas, s = i && ng(i);
  if (!s)
    return;
  const r = o4((a, l) => {
    const c = s.clientWidth;
    n(a, l), c < s.clientWidth && n();
  }, window), o = new ResizeObserver((a) => {
    const l = a[0], c = l.contentRect.width, u = l.contentRect.height;
    c === 0 && u === 0 || r(c, u);
  });
  return o.observe(s), MK(t10, r), o;
}
function Hf(t10, e, n) {
  n && n.disconnect(), e === "resize" && TK(t10);
}
function _K(t10, e, n) {
  const i = t10.canvas, s = o4((r) => {
    t10.ctx !== null && n(CK(r, t10));
  }, t10);
  return SK(i, e, s), s;
}
var NK = class extends O4 {
  acquireContext(e, n) {
    const i = e && e.getContext && e.getContext("2d");
    return i && i.canvas === e ? (kK(e, n), i) : null;
  }
  releaseContext(e) {
    const n = e.canvas;
    if (!n[Lc])
      return false;
    const i = n[Lc].initial;
    [
      "height",
      "width"
    ].forEach((r) => {
      const o = i[r];
      et(o) ? n.removeAttribute(r) : n.setAttribute(r, o);
    });
    const s = i.style || {};
    return Object.keys(s).forEach((r) => {
      n.style[r] = s[r];
    }), n.width = n.width, delete n[Lc], true;
  }
  addEventListener(e, n, i) {
    this.removeEventListener(e, n);
    const s = e.$proxies || (e.$proxies = {}), o = {
      attach: OK,
      detach: EK,
      resize: AK
    }[n] || _K;
    s[n] = o(e, n, i);
  }
  removeEventListener(e, n) {
    const i = e.$proxies || (e.$proxies = {}), s = i[n];
    if (!s)
      return;
    ({
      attach: Hf,
      detach: Hf,
      resize: Hf
    }[n] || wK)(e, n, s), i[n] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(e, n, i, s) {
    return wq(e, n, i, s);
  }
  isAttached(e) {
    const n = e && ng(e);
    return !!(n && n.isConnected);
  }
};
function LK(t10) {
  return !tg() || typeof OffscreenCanvas < "u" && t10 instanceof OffscreenCanvas ? vK : NK;
}
var vc;
var dr = (vc = class {
  constructor() {
    ve(this, "x");
    ve(this, "y");
    ve(this, "active", false);
    ve(this, "options");
    ve(this, "$animations");
  }
  tooltipPosition(e) {
    const { x: n, y: i } = this.getProps([
      "x",
      "y"
    ], e);
    return {
      x: n,
      y: i
    };
  }
  hasValue() {
    return xl(this.x) && xl(this.y);
  }
  getProps(e, n) {
    const i = this.$animations;
    if (!n || !i)
      return this;
    const s = {};
    return e.forEach((r) => {
      s[r] = i[r] && i[r].active() ? i[r]._to : this[r];
    }), s;
  }
}, ve(vc, "defaults", {}), ve(vc, "defaultRoutes"), vc);
function IK(t10, e) {
  const n = t10.options.ticks, i = PK(t10), s = Math.min(n.maxTicksLimit || i, i), r = n.major.enabled ? $K(e) : [], o = r.length, a = r[0], l = r[o - 1], c = [];
  if (o > s)
    return RK(e, c, r, o / s), c;
  const u = DK(r, e, s);
  if (o > 0) {
    let d, f;
    const h10 = o > 1 ? Math.round((l - a) / (o - 1)) : null;
    for (dc(e, c, u, et(h10) ? 0 : a - h10, a), d = 0, f = o - 1; d < f; d++)
      dc(e, c, u, r[d], r[d + 1]);
    return dc(e, c, u, l, et(h10) ? e.length : l + h10), c;
  }
  return dc(e, c, u), c;
}
function PK(t10) {
  const e = t10.options.offset, n = t10._tickSize(), i = t10._length / n + (e ? 0 : 1), s = t10._maxLength / n;
  return Math.floor(Math.min(i, s));
}
function DK(t10, e, n) {
  const i = FK(t10), s = e.length / n;
  if (!i)
    return Math.max(s, 1);
  const r = kU(i);
  for (let o = 0, a = r.length - 1; o < a; o++) {
    const l = r[o];
    if (l > s)
      return l;
  }
  return Math.max(s, 1);
}
function $K(t10) {
  const e = [];
  let n, i;
  for (n = 0, i = t10.length; n < i; n++)
    t10[n].major && e.push(n);
  return e;
}
function RK(t10, e, n, i) {
  let s = 0, r = n[0], o;
  for (i = Math.ceil(i), o = 0; o < t10.length; o++)
    o === r && (e.push(t10[o]), s++, r = n[s * i]);
}
function dc(t10, e, n, i, s) {
  const r = Ke(i, 0), o = Math.min(Ke(s, t10.length), t10.length);
  let a = 0, l, c, u;
  for (n = Math.ceil(n), s && (l = s - i, n = l / Math.floor(l / n)), u = r; u < 0; )
    a++, u = Math.round(r + a * n);
  for (c = Math.max(r, 0); c < o; c++)
    c === u && (e.push(t10[c]), a++, u = Math.round(r + a * n));
}
function FK(t10) {
  const e = t10.length;
  let n, i;
  if (e < 2)
    return false;
  for (i = t10[0], n = 1; n < e; ++n)
    if (t10[n] - t10[n - 1] !== i)
      return false;
  return i;
}
var VK = (t10) => t10 === "left" ? "right" : t10 === "right" ? "left" : t10;
var Ly = (t10, e, n) => e === "top" || e === "left" ? t10[e] + n : t10[e] - n;
var Iy = (t10, e) => Math.min(e || t10, t10);
function Py(t10, e) {
  const n = [], i = t10.length / e, s = t10.length;
  let r = 0;
  for (; r < s; r += i)
    n.push(t10[Math.floor(r)]);
  return n;
}
function BK(t10, e, n) {
  const i = t10.ticks.length, s = Math.min(e, i - 1), r = t10._startPixel, o = t10._endPixel, a = 1e-6;
  let l = t10.getPixelForTick(s), c;
  if (!(n && (i === 1 ? c = Math.max(l - r, o - l) : e === 0 ? c = (t10.getPixelForTick(1) - l) / 2 : c = (l - t10.getPixelForTick(s - 1)) / 2, l += s < e ? c : -c, l < r - a || l > o + a)))
    return l;
}
function zK(t10, e) {
  ot(t10, (n) => {
    const i = n.gc, s = i.length / 2;
    let r;
    if (s > e) {
      for (r = 0; r < s; ++r)
        delete n.data[i[r]];
      i.splice(0, s);
    }
  });
}
function fa(t10) {
  return t10.drawTicks ? t10.tickLength : 0;
}
function Dy(t10, e) {
  if (!t10.display)
    return 0;
  const n = Qt(t10.font, e), i = xn(t10.padding);
  return (wt(t10.text) ? t10.text.length : 1) * n.lineHeight + i.height;
}
function jK(t10, e) {
  return ur(t10, {
    scale: e,
    type: "scale"
  });
}
function HK(t10, e, n) {
  return ur(t10, {
    tick: n,
    index: e,
    type: "tick"
  });
}
function WK(t10, e, n) {
  let i = a4(t10);
  return (n && e !== "right" || !n && e === "right") && (i = VK(i)), i;
}
function UK(t10, e, n, i) {
  const { top: s, left: r, bottom: o, right: a, chart: l } = t10, { chartArea: c, scales: u } = l;
  let d = 0, f, h10, p;
  const g = o - s, m = a - r;
  if (t10.isHorizontal()) {
    if (h10 = Fn(i, r, a), Je(n)) {
      const b = Object.keys(n)[0], x = n[b];
      p = u[b].getPixelForValue(x) + g - e;
    } else n === "center" ? p = (c.bottom + c.top) / 2 + g - e : p = Ly(t10, n, e);
    f = a - r;
  } else {
    if (Je(n)) {
      const b = Object.keys(n)[0], x = n[b];
      h10 = u[b].getPixelForValue(x) - m + e;
    } else n === "center" ? h10 = (c.left + c.right) / 2 - m + e : h10 = Ly(t10, n, e);
    p = Fn(i, o, s), d = n === "left" ? -Lt : Lt;
  }
  return {
    titleX: h10,
    titleY: p,
    maxWidth: f,
    rotation: d
  };
}
var Zo = class _Zo extends dr {
  constructor(e) {
    super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = false, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = false, this.$context = void 0;
  }
  init(e) {
    this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax);
  }
  parse(e, n) {
    return e;
  }
  getUserBounds() {
    let { _userMin: e, _userMax: n, _suggestedMin: i, _suggestedMax: s } = this;
    return e = Ci(e, Number.POSITIVE_INFINITY), n = Ci(n, Number.NEGATIVE_INFINITY), i = Ci(i, Number.POSITIVE_INFINITY), s = Ci(s, Number.NEGATIVE_INFINITY), {
      min: Ci(e, i),
      max: Ci(n, s),
      minDefined: Yt(e),
      maxDefined: Yt(n)
    };
  }
  getMinMax(e) {
    let { min: n, max: i, minDefined: s, maxDefined: r } = this.getUserBounds(), o;
    if (s && r)
      return {
        min: n,
        max: i
      };
    const a = this.getMatchingVisibleMetas();
    for (let l = 0, c = a.length; l < c; ++l)
      o = a[l].controller.getMinMax(this, e), s || (n = Math.min(n, o.min)), r || (i = Math.max(i, o.max));
    return n = r && n > i ? i : n, i = s && n > i ? n : i, {
      min: Ci(n, Ci(i, n)),
      max: Ci(i, Ci(n, i))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const e = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [];
  }
  getLabelItems(e = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(e));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = false;
  }
  beforeUpdate() {
    pt(this.options.beforeUpdate, [
      this
    ]);
  }
  update(e, n, i) {
    const { beginAtZero: s, grace: r, ticks: o } = this.options, a = o.sampleSize;
    this.beforeUpdate(), this.maxWidth = e, this.maxHeight = n, this._margins = i = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = eq(this, r, s), this._dataLimitsCached = true), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = a < this.ticks.length;
    this._convertTicksToLabels(l ? Py(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = IK(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let e = this.options.reverse, n, i;
    this.isHorizontal() ? (n = this.left, i = this.right) : (n = this.top, i = this.bottom, e = !e), this._startPixel = n, this._endPixel = i, this._reversePixels = e, this._length = i - n, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    pt(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    pt(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    pt(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(e) {
    this.chart.notifyPlugins(e, this.getContext()), pt(this.options[e], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    pt(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(e) {
    const n = this.options.ticks;
    let i, s, r;
    for (i = 0, s = e.length; i < s; i++)
      r = e[i], r.label = pt(n.callback, [
        r.value,
        i,
        e
      ], this);
  }
  afterTickToLabelConversion() {
    pt(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    pt(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const e = this.options, n = e.ticks, i = Iy(this.ticks.length, e.ticks.maxTicksLimit), s = n.minRotation || 0, r = n.maxRotation;
    let o = s, a, l, c;
    if (!this._isVisible() || !n.display || s >= r || i <= 1 || !this.isHorizontal()) {
      this.labelRotation = s;
      return;
    }
    const u = this._getLabelSizes(), d = u.widest.width, f = u.highest.height, h10 = sn(this.chart.width - d, 0, this.maxWidth);
    a = e.offset ? this.maxWidth / i : h10 / (i - 1), d + 6 > a && (a = h10 / (i - (e.offset ? 0.5 : 1)), l = this.maxHeight - fa(e.grid) - n.padding - Dy(e.title, this.chart.options.font), c = Math.sqrt(d * d + f * f), o = qm(Math.min(Math.asin(sn((u.highest.height + 6) / a, -1, 1)), Math.asin(sn(l / c, -1, 1)) - Math.asin(sn(f / c, -1, 1)))), o = Math.max(s, Math.min(r, o))), this.labelRotation = o;
  }
  afterCalculateLabelRotation() {
    pt(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    pt(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const e = {
      width: 0,
      height: 0
    }, { chart: n, options: { ticks: i, title: s, grid: r } } = this, o = this._isVisible(), a = this.isHorizontal();
    if (o) {
      const l = Dy(s, n.options.font);
      if (a ? (e.width = this.maxWidth, e.height = fa(r) + l) : (e.height = this.maxHeight, e.width = fa(r) + l), i.display && this.ticks.length) {
        const { first: c, last: u, widest: d, highest: f } = this._getLabelSizes(), h10 = i.padding * 2, p = $i(this.labelRotation), g = Math.cos(p), m = Math.sin(p);
        if (a) {
          const b = i.mirror ? 0 : m * d.width + g * f.height;
          e.height = Math.min(this.maxHeight, e.height + b + h10);
        } else {
          const b = i.mirror ? 0 : g * d.width + m * f.height;
          e.width = Math.min(this.maxWidth, e.width + b + h10);
        }
        this._calculatePadding(c, u, m, g);
      }
    }
    this._handleMargins(), a ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(e, n, i, s) {
    const { ticks: { align: r, padding: o }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const u = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);
      let f = 0, h10 = 0;
      l ? c ? (f = s * e.width, h10 = i * n.height) : (f = i * e.height, h10 = s * n.width) : r === "start" ? h10 = n.width : r === "end" ? f = e.width : r !== "inner" && (f = e.width / 2, h10 = n.width / 2), this.paddingLeft = Math.max((f - u + o) * this.width / (this.width - u), 0), this.paddingRight = Math.max((h10 - d + o) * this.width / (this.width - d), 0);
    } else {
      let u = n.height / 2, d = e.height / 2;
      r === "start" ? (u = 0, d = e.height) : r === "end" && (u = n.height, d = 0), this.paddingTop = u + o, this.paddingBottom = d + o;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    pt(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: e, position: n } = this.options;
    return n === "top" || n === "bottom" || e === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(e) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(e);
    let n, i;
    for (n = 0, i = e.length; n < i; n++)
      et(e[n].label) && (e.splice(n, 1), i--, n--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let e = this._labelSizes;
    if (!e) {
      const n = this.options.ticks.sampleSize;
      let i = this.ticks;
      n < i.length && (i = Py(i, n)), this._labelSizes = e = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit);
    }
    return e;
  }
  _computeLabelSizes(e, n, i) {
    const { ctx: s, _longestTextCache: r } = this, o = [], a = [], l = Math.floor(n / Iy(n, i));
    let c = 0, u = 0, d, f, h10, p, g, m, b, x, k, v, S;
    for (d = 0; d < n; d += l) {
      if (p = e[d].label, g = this._resolveTickFontOptions(d), s.font = m = g.string, b = r[m] = r[m] || {
        data: {},
        gc: []
      }, x = g.lineHeight, k = v = 0, !et(p) && !wt(p))
        k = ju(s, b.data, b.gc, k, p), v = x;
      else if (wt(p))
        for (f = 0, h10 = p.length; f < h10; ++f)
          S = p[f], !et(S) && !wt(S) && (k = ju(s, b.data, b.gc, k, S), v += x);
      o.push(k), a.push(v), c = Math.max(k, c), u = Math.max(v, u);
    }
    zK(r, n);
    const w = o.indexOf(c), E = a.indexOf(u), M = (N) => ({
      width: o[N] || 0,
      height: a[N] || 0
    });
    return {
      first: M(0),
      last: M(n - 1),
      widest: M(w),
      highest: M(E),
      widths: o,
      heights: a
    };
  }
  getLabelForValue(e) {
    return e;
  }
  getPixelForValue(e, n) {
    return NaN;
  }
  getValueForPixel(e) {
  }
  getPixelForTick(e) {
    const n = this.ticks;
    return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value);
  }
  getPixelForDecimal(e) {
    this._reversePixels && (e = 1 - e);
    const n = this._startPixel + e * this._length;
    return EU(this._alignToPixels ? br(this.chart, n, 0) : n);
  }
  getDecimalForPixel(e) {
    const n = (e - this._startPixel) / this._length;
    return this._reversePixels ? 1 - n : n;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: e, max: n } = this;
    return e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0;
  }
  getContext(e) {
    const n = this.ticks || [];
    if (e >= 0 && e < n.length) {
      const i = n[e];
      return i.$context || (i.$context = HK(this.getContext(), e, i));
    }
    return this.$context || (this.$context = jK(this.chart.getContext(), this));
  }
  _tickSize() {
    const e = this.options.ticks, n = $i(this.labelRotation), i = Math.abs(Math.cos(n)), s = Math.abs(Math.sin(n)), r = this._getLabelSizes(), o = e.autoSkipPadding || 0, a = r ? r.widest.width + o : 0, l = r ? r.highest.height + o : 0;
    return this.isHorizontal() ? l * i > a * s ? a / i : l / s : l * s < a * i ? l / i : a / s;
  }
  _isVisible() {
    const e = this.options.display;
    return e !== "auto" ? !!e : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(e) {
    const n = this.axis, i = this.chart, s = this.options, { grid: r, position: o, border: a } = s, l = r.offset, c = this.isHorizontal(), d = this.ticks.length + (l ? 1 : 0), f = fa(r), h10 = [], p = a.setContext(this.getContext()), g = p.display ? p.width : 0, m = g / 2, b = function(C) {
      return br(i, C, g);
    };
    let x, k, v, S, w, E, M, N, V, Y, F, re;
    if (o === "top")
      x = b(this.bottom), E = this.bottom - f, N = x - m, Y = b(e.top) + m, re = e.bottom;
    else if (o === "bottom")
      x = b(this.top), Y = e.top, re = b(e.bottom) - m, E = x + m, N = this.top + f;
    else if (o === "left")
      x = b(this.right), w = this.right - f, M = x - m, V = b(e.left) + m, F = e.right;
    else if (o === "right")
      x = b(this.left), V = e.left, F = b(e.right) - m, w = x + m, M = this.left + f;
    else if (n === "x") {
      if (o === "center")
        x = b((e.top + e.bottom) / 2 + 0.5);
      else if (Je(o)) {
        const C = Object.keys(o)[0], O = o[C];
        x = b(this.chart.scales[C].getPixelForValue(O));
      }
      Y = e.top, re = e.bottom, E = x + m, N = E + f;
    } else if (n === "y") {
      if (o === "center")
        x = b((e.left + e.right) / 2);
      else if (Je(o)) {
        const C = Object.keys(o)[0], O = o[C];
        x = b(this.chart.scales[C].getPixelForValue(O));
      }
      w = x - m, M = w - f, V = e.left, F = e.right;
    }
    const z = Ke(s.ticks.maxTicksLimit, d), W = Math.max(1, Math.ceil(d / z));
    for (k = 0; k < d; k += W) {
      const C = this.getContext(k), O = r.setContext(C), _ = a.setContext(C), T = O.lineWidth, H = O.color, Q = _.dash || [], ae = _.dashOffset, pe = O.tickWidth, xe = O.tickColor, Te = O.tickBorderDash || [], L = O.tickBorderDashOffset;
      v = BK(this, k, l), v !== void 0 && (S = br(i, v, T), c ? w = M = V = F = S : E = N = Y = re = S, h10.push({
        tx1: w,
        ty1: E,
        tx2: M,
        ty2: N,
        x1: V,
        y1: Y,
        x2: F,
        y2: re,
        width: T,
        color: H,
        borderDash: Q,
        borderDashOffset: ae,
        tickWidth: pe,
        tickColor: xe,
        tickBorderDash: Te,
        tickBorderDashOffset: L
      }));
    }
    return this._ticksLength = d, this._borderValue = x, h10;
  }
  _computeLabelItems(e) {
    const n = this.axis, i = this.options, { position: s, ticks: r } = i, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: u, mirror: d } = r, f = fa(i.grid), h10 = f + u, p = d ? -u : h10, g = -$i(this.labelRotation), m = [];
    let b, x, k, v, S, w, E, M, N, V, Y, F, re = "middle";
    if (s === "top")
      w = this.bottom - p, E = this._getXAxisLabelAlignment();
    else if (s === "bottom")
      w = this.top + p, E = this._getXAxisLabelAlignment();
    else if (s === "left") {
      const W = this._getYAxisLabelAlignment(f);
      E = W.textAlign, S = W.x;
    } else if (s === "right") {
      const W = this._getYAxisLabelAlignment(f);
      E = W.textAlign, S = W.x;
    } else if (n === "x") {
      if (s === "center")
        w = (e.top + e.bottom) / 2 + h10;
      else if (Je(s)) {
        const W = Object.keys(s)[0], C = s[W];
        w = this.chart.scales[W].getPixelForValue(C) + h10;
      }
      E = this._getXAxisLabelAlignment();
    } else if (n === "y") {
      if (s === "center")
        S = (e.left + e.right) / 2 - h10;
      else if (Je(s)) {
        const W = Object.keys(s)[0], C = s[W];
        S = this.chart.scales[W].getPixelForValue(C);
      }
      E = this._getYAxisLabelAlignment(f).textAlign;
    }
    n === "y" && (l === "start" ? re = "top" : l === "end" && (re = "bottom"));
    const z = this._getLabelSizes();
    for (b = 0, x = a.length; b < x; ++b) {
      k = a[b], v = k.label;
      const W = r.setContext(this.getContext(b));
      M = this.getPixelForTick(b) + r.labelOffset, N = this._resolveTickFontOptions(b), V = N.lineHeight, Y = wt(v) ? v.length : 1;
      const C = Y / 2, O = W.color, _ = W.textStrokeColor, T = W.textStrokeWidth;
      let H = E;
      o ? (S = M, E === "inner" && (b === x - 1 ? H = this.options.reverse ? "left" : "right" : b === 0 ? H = this.options.reverse ? "right" : "left" : H = "center"), s === "top" ? c === "near" || g !== 0 ? F = -Y * V + V / 2 : c === "center" ? F = -z.highest.height / 2 - C * V + V : F = -z.highest.height + V / 2 : c === "near" || g !== 0 ? F = V / 2 : c === "center" ? F = z.highest.height / 2 - C * V : F = z.highest.height - Y * V, d && (F *= -1), g !== 0 && !W.showLabelBackdrop && (S += V / 2 * Math.sin(g))) : (w = M, F = (1 - Y) * V / 2);
      let Q;
      if (W.showLabelBackdrop) {
        const ae = xn(W.backdropPadding), pe = z.heights[b], xe = z.widths[b];
        let Te = F - ae.top, L = 0 - ae.left;
        switch (re) {
          case "middle":
            Te -= pe / 2;
            break;
          case "bottom":
            Te -= pe;
            break;
        }
        switch (E) {
          case "center":
            L -= xe / 2;
            break;
          case "right":
            L -= xe;
            break;
          case "inner":
            b === x - 1 ? L -= xe : b > 0 && (L -= xe / 2);
            break;
        }
        Q = {
          left: L,
          top: Te,
          width: xe + ae.width,
          height: pe + ae.height,
          color: W.backdropColor
        };
      }
      m.push({
        label: v,
        font: N,
        textOffset: F,
        options: {
          rotation: g,
          color: O,
          strokeColor: _,
          strokeWidth: T,
          textAlign: H,
          textBaseline: re,
          translation: [
            S,
            w
          ],
          backdrop: Q
        }
      });
    }
    return m;
  }
  _getXAxisLabelAlignment() {
    const { position: e, ticks: n } = this.options;
    if (-$i(this.labelRotation))
      return e === "top" ? "left" : "right";
    let s = "center";
    return n.align === "start" ? s = "left" : n.align === "end" ? s = "right" : n.align === "inner" && (s = "inner"), s;
  }
  _getYAxisLabelAlignment(e) {
    const { position: n, ticks: { crossAlign: i, mirror: s, padding: r } } = this.options, o = this._getLabelSizes(), a = e + r, l = o.widest.width;
    let c, u;
    return n === "left" ? s ? (u = this.right + r, i === "near" ? c = "left" : i === "center" ? (c = "center", u += l / 2) : (c = "right", u += l)) : (u = this.right - a, i === "near" ? c = "right" : i === "center" ? (c = "center", u -= l / 2) : (c = "left", u = this.left)) : n === "right" ? s ? (u = this.left + r, i === "near" ? c = "right" : i === "center" ? (c = "center", u -= l / 2) : (c = "left", u -= l)) : (u = this.left + a, i === "near" ? c = "left" : i === "center" ? (c = "center", u += l / 2) : (c = "right", u = this.right)) : c = "right", {
      textAlign: c,
      x: u
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const e = this.chart, n = this.options.position;
    if (n === "left" || n === "right")
      return {
        top: 0,
        left: this.left,
        bottom: e.height,
        right: this.right
      };
    if (n === "top" || n === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: e.width
      };
  }
  drawBackground() {
    const { ctx: e, options: { backgroundColor: n }, left: i, top: s, width: r, height: o } = this;
    n && (e.save(), e.fillStyle = n, e.fillRect(i, s, r, o), e.restore());
  }
  getLineWidthForValue(e) {
    const n = this.options.grid;
    if (!this._isVisible() || !n.display)
      return 0;
    const s = this.ticks.findIndex((r) => r.value === e);
    return s >= 0 ? n.setContext(this.getContext(s)).lineWidth : 0;
  }
  drawGrid(e) {
    const n = this.options.grid, i = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e));
    let r, o;
    const a = (l, c, u) => {
      !u.width || !u.color || (i.save(), i.lineWidth = u.width, i.strokeStyle = u.color, i.setLineDash(u.borderDash || []), i.lineDashOffset = u.borderDashOffset, i.beginPath(), i.moveTo(l.x, l.y), i.lineTo(c.x, c.y), i.stroke(), i.restore());
    };
    if (n.display)
      for (r = 0, o = s.length; r < o; ++r) {
        const l = s[r];
        n.drawOnChartArea && a({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), n.drawTicks && a({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: e, ctx: n, options: { border: i, grid: s } } = this, r = i.setContext(this.getContext()), o = i.display ? r.width : 0;
    if (!o)
      return;
    const a = s.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let c, u, d, f;
    this.isHorizontal() ? (c = br(e, this.left, o) - o / 2, u = br(e, this.right, a) + a / 2, d = f = l) : (d = br(e, this.top, o) - o / 2, f = br(e, this.bottom, a) + a / 2, c = u = l), n.save(), n.lineWidth = r.width, n.strokeStyle = r.color, n.beginPath(), n.moveTo(c, d), n.lineTo(u, f), n.stroke(), n.restore();
  }
  drawLabels(e) {
    if (!this.options.ticks.display)
      return;
    const i = this.ctx, s = this._computeLabelArea();
    s && Rd(i, s);
    const r = this.getLabelItems(e);
    for (const o of r) {
      const a = o.options, l = o.font, c = o.label, u = o.textOffset;
      Wo(i, c, 0, u, l, a);
    }
    s && Fd(i);
  }
  drawTitle() {
    const { ctx: e, options: { position: n, title: i, reverse: s } } = this;
    if (!i.display)
      return;
    const r = Qt(i.font), o = xn(i.padding), a = i.align;
    let l = r.lineHeight / 2;
    n === "bottom" || n === "center" || Je(n) ? (l += o.bottom, wt(i.text) && (l += r.lineHeight * (i.text.length - 1))) : l += o.top;
    const { titleX: c, titleY: u, maxWidth: d, rotation: f } = UK(this, l, n, a);
    Wo(e, i.text, 0, 0, r, {
      color: i.color,
      maxWidth: d,
      rotation: f,
      textAlign: WK(a, n, s),
      textBaseline: "middle",
      translation: [
        c,
        u
      ]
    });
  }
  draw(e) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e));
  }
  _layers() {
    const e = this.options, n = e.ticks && e.ticks.z || 0, i = Ke(e.grid && e.grid.z, -1), s = Ke(e.border && e.border.z, 0);
    return !this._isVisible() || this.draw !== _Zo.prototype.draw ? [
      {
        z: n,
        draw: (r) => {
          this.draw(r);
        }
      }
    ] : [
      {
        z: i,
        draw: (r) => {
          this.drawBackground(), this.drawGrid(r), this.drawTitle();
        }
      },
      {
        z: s,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: n,
        draw: (r) => {
          this.drawLabels(r);
        }
      }
    ];
  }
  getMatchingVisibleMetas(e) {
    const n = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", s = [];
    let r, o;
    for (r = 0, o = n.length; r < o; ++r) {
      const a = n[r];
      a[i] === this.id && (!e || a.type === e) && s.push(a);
    }
    return s;
  }
  _resolveTickFontOptions(e) {
    const n = this.options.ticks.setContext(this.getContext(e));
    return Qt(n.font);
  }
  _maxDigits() {
    const e = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / e;
  }
};
var fc = class {
  constructor(e, n, i) {
    this.type = e, this.scope = n, this.override = i, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(e) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype);
  }
  register(e) {
    const n = Object.getPrototypeOf(e);
    let i;
    YK(n) && (i = this.register(n));
    const s = this.items, r = e.id, o = this.scope + "." + r;
    if (!r)
      throw new Error("class does not have id: " + e);
    return r in s || (s[r] = e, qK(e, o, i), this.override && At.override(e.id, e.overrides)), o;
  }
  get(e) {
    return this.items[e];
  }
  unregister(e) {
    const n = this.items, i = e.id, s = this.scope;
    i in n && delete n[i], s && i in At[s] && (delete At[s][i], this.override && delete Qr[i]);
  }
};
function qK(t10, e, n) {
  const i = yl(/* @__PURE__ */ Object.create(null), [
    n ? At.get(n) : {},
    At.get(e),
    t10.defaults
  ]);
  At.set(e, i), t10.defaultRoutes && KK(e, t10.defaultRoutes), t10.descriptors && At.describe(e, t10.descriptors);
}
function KK(t10, e) {
  Object.keys(e).forEach((n) => {
    const i = n.split("."), s = i.pop(), r = [
      t10
    ].concat(i).join("."), o = e[n].split("."), a = o.pop(), l = o.join(".");
    At.route(r, s, l, a);
  });
}
function YK(t10) {
  return "id" in t10 && "defaults" in t10;
}
var GK = class {
  constructor() {
    this.controllers = new fc(Gs, "datasets", true), this.elements = new fc(dr, "elements"), this.plugins = new fc(Object, "plugins"), this.scales = new fc(Zo, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...e) {
    this._each("register", e);
  }
  remove(...e) {
    this._each("unregister", e);
  }
  addControllers(...e) {
    this._each("register", e, this.controllers);
  }
  addElements(...e) {
    this._each("register", e, this.elements);
  }
  addPlugins(...e) {
    this._each("register", e, this.plugins);
  }
  addScales(...e) {
    this._each("register", e, this.scales);
  }
  getController(e) {
    return this._get(e, this.controllers, "controller");
  }
  getElement(e) {
    return this._get(e, this.elements, "element");
  }
  getPlugin(e) {
    return this._get(e, this.plugins, "plugin");
  }
  getScale(e) {
    return this._get(e, this.scales, "scale");
  }
  removeControllers(...e) {
    this._each("unregister", e, this.controllers);
  }
  removeElements(...e) {
    this._each("unregister", e, this.elements);
  }
  removePlugins(...e) {
    this._each("unregister", e, this.plugins);
  }
  removeScales(...e) {
    this._each("unregister", e, this.scales);
  }
  _each(e, n, i) {
    [
      ...n
    ].forEach((s) => {
      const r = i || this._getRegistryForType(s);
      i || r.isForType(s) || r === this.plugins && s.id ? this._exec(e, r, s) : ot(s, (o) => {
        const a = i || this._getRegistryForType(o);
        this._exec(e, a, o);
      });
    });
  }
  _exec(e, n, i) {
    const s = Um(e);
    pt(i["before" + s], [], i), n[e](i), pt(i["after" + s], [], i);
  }
  _getRegistryForType(e) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const i = this._typedRegistries[n];
      if (i.isForType(e))
        return i;
    }
    return this.plugins;
  }
  _get(e, n, i) {
    const s = n.get(e);
    if (s === void 0)
      throw new Error('"' + e + '" is not a registered ' + i + ".");
    return s;
  }
};
var _i = new GK();
var JK = class {
  constructor() {
    this._init = [];
  }
  notify(e, n, i, s) {
    n === "beforeInit" && (this._init = this._createDescriptors(e, true), this._notify(this._init, e, "install"));
    const r = s ? this._descriptors(e).filter(s) : this._descriptors(e), o = this._notify(r, e, n, i);
    return n === "afterDestroy" && (this._notify(r, e, "stop"), this._notify(this._init, e, "uninstall")), o;
  }
  _notify(e, n, i, s) {
    s = s || {};
    for (const r of e) {
      const o = r.plugin, a = o[i], l = [
        n,
        s,
        r.options
      ];
      if (pt(a, l, o) === false && s.cancelable)
        return false;
    }
    return true;
  }
  invalidate() {
    et(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(e) {
    if (this._cache)
      return this._cache;
    const n = this._cache = this._createDescriptors(e);
    return this._notifyStateChanges(e), n;
  }
  _createDescriptors(e, n) {
    const i = e && e.config, s = Ke(i.options && i.options.plugins, {}), r = XK(i);
    return s === false && !n ? [] : ZK(e, r, s, n);
  }
  _notifyStateChanges(e) {
    const n = this._oldCache || [], i = this._cache, s = (r, o) => r.filter((a) => !o.some((l) => a.plugin.id === l.plugin.id));
    this._notify(s(n, i), e, "stop"), this._notify(s(i, n), e, "start");
  }
};
function XK(t10) {
  const e = {}, n = [], i = Object.keys(_i.plugins.items);
  for (let r = 0; r < i.length; r++)
    n.push(_i.getPlugin(i[r]));
  const s = t10.plugins || [];
  for (let r = 0; r < s.length; r++) {
    const o = s[r];
    n.indexOf(o) === -1 && (n.push(o), e[o.id] = true);
  }
  return {
    plugins: n,
    localIds: e
  };
}
function QK(t10, e) {
  return !e && t10 === false ? null : t10 === true ? {} : t10;
}
function ZK(t10, { plugins: e, localIds: n }, i, s) {
  const r = [], o = t10.getContext();
  for (const a of e) {
    const l = a.id, c = QK(i[l], s);
    c !== null && r.push({
      plugin: a,
      options: eY(t10.config, {
        plugin: a,
        local: n[l]
      }, c, o)
    });
  }
  return r;
}
function eY(t10, { plugin: e, local: n }, i, s) {
  const r = t10.pluginScopeKeys(e), o = t10.getOptionScopes(i, r);
  return n && e.defaults && o.push(e.defaults), t10.createResolver(o, s, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function lp(t10, e) {
  const n = At.datasets[t10] || {};
  return ((e.datasets || {})[t10] || {}).indexAxis || e.indexAxis || n.indexAxis || "x";
}
function tY(t10, e) {
  let n = t10;
  return t10 === "_index_" ? n = e : t10 === "_value_" && (n = e === "x" ? "y" : "x"), n;
}
function nY(t10, e) {
  return t10 === e ? "_index_" : "_value_";
}
function $y(t10) {
  if (t10 === "x" || t10 === "y" || t10 === "r")
    return t10;
}
function iY(t10) {
  if (t10 === "top" || t10 === "bottom")
    return "x";
  if (t10 === "left" || t10 === "right")
    return "y";
}
function cp(t10, ...e) {
  if ($y(t10))
    return t10;
  for (const n of e) {
    const i = n.axis || iY(n.position) || t10.length > 1 && $y(t10[0].toLowerCase());
    if (i)
      return i;
  }
  throw new Error(`Cannot determine type of '${t10}' axis. Please provide 'axis' or 'position' option.`);
}
function Ry(t10, e, n) {
  if (n[e + "AxisID"] === t10)
    return {
      axis: e
    };
}
function sY(t10, e) {
  if (e.data && e.data.datasets) {
    const n = e.data.datasets.filter((i) => i.xAxisID === t10 || i.yAxisID === t10);
    if (n.length)
      return Ry(t10, "x", n[0]) || Ry(t10, "y", n[0]);
  }
  return {};
}
function rY(t10, e) {
  const n = Qr[t10.type] || {
    scales: {}
  }, i = e.scales || {}, s = lp(t10.type, e), r = /* @__PURE__ */ Object.create(null);
  return Object.keys(i).forEach((o) => {
    const a = i[o];
    if (!Je(a))
      return console.error(`Invalid scale configuration for scale: ${o}`);
    if (a._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${o}`);
    const l = cp(o, a, sY(o, t10), At.scales[a.type]), c = nY(l, s), u = n.scales || {};
    r[o] = Ka(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      a,
      u[l],
      u[c]
    ]);
  }), t10.data.datasets.forEach((o) => {
    const a = o.type || t10.type, l = o.indexAxis || lp(a, e), u = (Qr[a] || {}).scales || {};
    Object.keys(u).forEach((d) => {
      const f = tY(d, l), h10 = o[f + "AxisID"] || f;
      r[h10] = r[h10] || /* @__PURE__ */ Object.create(null), Ka(r[h10], [
        {
          axis: f
        },
        i[h10],
        u[d]
      ]);
    });
  }), Object.keys(r).forEach((o) => {
    const a = r[o];
    Ka(a, [
      At.scales[a.type],
      At.scale
    ]);
  }), r;
}
function T4(t10) {
  const e = t10.options || (t10.options = {});
  e.plugins = Ke(e.plugins, {}), e.scales = rY(t10, e);
}
function A4(t10) {
  return t10 = t10 || {}, t10.datasets = t10.datasets || [], t10.labels = t10.labels || [], t10;
}
function oY(t10) {
  return t10 = t10 || {}, t10.data = A4(t10.data), T4(t10), t10;
}
var Fy = /* @__PURE__ */ new Map();
var _4 = /* @__PURE__ */ new Set();
function hc(t10, e) {
  let n = Fy.get(t10);
  return n || (n = e(), Fy.set(t10, n), _4.add(n)), n;
}
var ha = (t10, e, n) => {
  const i = sr(e, n);
  i !== void 0 && t10.add(i);
};
var aY = class {
  constructor(e) {
    this._config = oY(e), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(e) {
    this._config.type = e;
  }
  get data() {
    return this._config.data;
  }
  set data(e) {
    this._config.data = A4(e);
  }
  get options() {
    return this._config.options;
  }
  set options(e) {
    this._config.options = e;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const e = this._config;
    this.clearCache(), T4(e);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(e) {
    return hc(e, () => [
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(e, n) {
    return hc(`${e}.transition.${n}`, () => [
      [
        `datasets.${e}.transitions.${n}`,
        `transitions.${n}`
      ],
      [
        `datasets.${e}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(e, n) {
    return hc(`${e}-${n}`, () => [
      [
        `datasets.${e}.elements.${n}`,
        `datasets.${e}`,
        `elements.${n}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(e) {
    const n = e.id, i = this.type;
    return hc(`${i}-plugin-${n}`, () => [
      [
        `plugins.${n}`,
        ...e.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(e, n) {
    const i = this._scopeCache;
    let s = i.get(e);
    return (!s || n) && (s = /* @__PURE__ */ new Map(), i.set(e, s)), s;
  }
  getOptionScopes(e, n, i) {
    const { options: s, type: r } = this, o = this._cachedScopes(e, i), a = o.get(n);
    if (a)
      return a;
    const l = /* @__PURE__ */ new Set();
    n.forEach((u) => {
      e && (l.add(e), u.forEach((d) => ha(l, e, d))), u.forEach((d) => ha(l, s, d)), u.forEach((d) => ha(l, Qr[r] || {}, d)), u.forEach((d) => ha(l, At, d)), u.forEach((d) => ha(l, op, d));
    });
    const c = Array.from(l);
    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), _4.has(n) && o.set(n, c), c;
  }
  chartOptionScopes() {
    const { options: e, type: n } = this;
    return [
      e,
      Qr[n] || {},
      At.datasets[n] || {},
      {
        type: n
      },
      At,
      op
    ];
  }
  resolveNamedOptions(e, n, i, s = [
    ""
  ]) {
    const r = {
      $shared: true
    }, { resolver: o, subPrefixes: a } = Vy(this._resolverCache, e, s);
    let l = o;
    if (cY(o, n)) {
      r.$shared = false, i = rr(i) ? i() : i;
      const c = this.createResolver(e, i, a);
      l = Uo(o, i, c);
    }
    for (const c of n)
      r[c] = l[c];
    return r;
  }
  createResolver(e, n, i = [
    ""
  ], s) {
    const { resolver: r } = Vy(this._resolverCache, e, i);
    return Je(n) ? Uo(r, n, void 0, s) : r;
  }
};
function Vy(t10, e, n) {
  let i = t10.get(e);
  i || (i = /* @__PURE__ */ new Map(), t10.set(e, i));
  const s = n.join();
  let r = i.get(s);
  return r || (r = {
    resolver: Qm(e, n),
    subPrefixes: n.filter((a) => !a.toLowerCase().includes("hover"))
  }, i.set(s, r)), r;
}
var lY = (t10) => Je(t10) && Object.getOwnPropertyNames(t10).some((e) => rr(t10[e]));
function cY(t10, e) {
  const { isScriptable: n, isIndexable: i } = u4(t10);
  for (const s of e) {
    const r = n(s), o = i(s), a = (o || r) && t10[s];
    if (r && (rr(a) || lY(a)) || o && wt(a))
      return true;
  }
  return false;
}
var uY = "4.4.8";
var dY = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function By(t10, e) {
  return t10 === "top" || t10 === "bottom" || dY.indexOf(t10) === -1 && e === "x";
}
function zy(t10, e) {
  return function(n, i) {
    return n[t10] === i[t10] ? n[e] - i[e] : n[t10] - i[t10];
  };
}
function jy(t10) {
  const e = t10.chart, n = e.options.animation;
  e.notifyPlugins("afterRender"), pt(n && n.onComplete, [
    t10
  ], e);
}
function fY(t10) {
  const e = t10.chart, n = e.options.animation;
  pt(n && n.onProgress, [
    t10
  ], e);
}
function N4(t10) {
  return tg() && typeof t10 == "string" ? t10 = document.getElementById(t10) : t10 && t10.length && (t10 = t10[0]), t10 && t10.canvas && (t10 = t10.canvas), t10;
}
var Ic = {};
var Hy = (t10) => {
  const e = N4(t10);
  return Object.values(Ic).filter((n) => n.canvas === e).pop();
};
function hY(t10, e, n) {
  const i = Object.keys(t10);
  for (const s of i) {
    const r = +s;
    if (r >= e) {
      const o = t10[s];
      delete t10[s], (n > 0 || r > e) && (t10[r + n] = o);
    }
  }
}
function pY(t10, e, n, i) {
  return !n || t10.type === "mouseout" ? null : i ? e : t10;
}
function pc(t10, e, n) {
  return t10.options.clip ? t10[n] : e[n];
}
function mY(t10, e) {
  const { xScale: n, yScale: i } = t10;
  return n && i ? {
    left: pc(n, e, "left"),
    right: pc(n, e, "right"),
    top: pc(i, e, "top"),
    bottom: pc(i, e, "bottom")
  } : e;
}
var St = class {
  static register(...e) {
    _i.add(...e), Wy();
  }
  static unregister(...e) {
    _i.remove(...e), Wy();
  }
  constructor(e, n) {
    const i = this.config = new aY(n), s = N4(e), r = Hy(s);
    if (r)
      throw new Error("Canvas is already in use. Chart with ID '" + r.id + "' must be destroyed before the canvas with ID '" + r.canvas.id + "' can be reused.");
    const o = i.createResolver(i.chartOptionScopes(), this.getContext());
    this.platform = new (i.platform || LK(s))(), this.platform.updateConfig(i);
    const a = this.platform.acquireContext(s, o.aspectRatio), l = a && a.canvas, c = l && l.height, u = l && l.width;
    if (this.id = fU(), this.ctx = a, this.canvas = l, this.width = u, this.height = c, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new JK(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = false, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = _U((d) => this.update(d), o.resizeDelay || 0), this._dataChanges = [], Ic[this.id] = this, !a || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    ss.listen(this, "complete", jy), ss.listen(this, "progress", fY), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: e, maintainAspectRatio: n }, width: i, height: s, _aspectRatio: r } = this;
    return et(e) ? n && r ? r : s ? i / s : null : e;
  }
  get data() {
    return this.config.data;
  }
  set data(e) {
    this.config.data = e;
  }
  get options() {
    return this._options;
  }
  set options(e) {
    this.config.options = e;
  }
  get registry() {
    return _i;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : fy(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return cy(this.canvas, this.ctx), this;
  }
  stop() {
    return ss.stop(this), this;
  }
  resize(e, n) {
    ss.running(this) ? this._resizeBeforeDraw = {
      width: e,
      height: n
    } : this._resize(e, n);
  }
  _resize(e, n) {
    const i = this.options, s = this.canvas, r = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(s, e, n, r), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, fy(this, a, true) && (this.notifyPlugins("resize", {
      size: o
    }), pt(i.onResize, [
      this,
      o
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const n = this.options.scales || {};
    ot(n, (i, s) => {
      i.id = s;
    });
  }
  buildOrUpdateScales() {
    const e = this.options, n = e.scales, i = this.scales, s = Object.keys(i).reduce((o, a) => (o[a] = false, o), {});
    let r = [];
    n && (r = r.concat(Object.keys(n).map((o) => {
      const a = n[o], l = cp(o, a), c = l === "r", u = l === "x";
      return {
        options: a,
        dposition: c ? "chartArea" : u ? "bottom" : "left",
        dtype: c ? "radialLinear" : u ? "category" : "linear"
      };
    }))), ot(r, (o) => {
      const a = o.options, l = a.id, c = cp(l, a), u = Ke(a.type, o.dtype);
      (a.position === void 0 || By(a.position, c) !== By(o.dposition)) && (a.position = o.dposition), s[l] = true;
      let d = null;
      if (l in i && i[l].type === u)
        d = i[l];
      else {
        const f = _i.getScale(u);
        d = new f({
          id: l,
          type: u,
          ctx: this.ctx,
          chart: this
        }), i[d.id] = d;
      }
      d.init(a, e);
    }), ot(s, (o, a) => {
      o || delete i[a];
    }), ot(i, (o) => {
      zs.configure(this, o, o.options), zs.addBox(this, o);
    });
  }
  _updateMetasets() {
    const e = this._metasets, n = this.data.datasets.length, i = e.length;
    if (e.sort((s, r) => s.index - r.index), i > n) {
      for (let s = n; s < i; ++s)
        this._destroyDatasetMeta(s);
      e.splice(n, i - n);
    }
    this._sortedMetasets = e.slice(0).sort(zy("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: e, data: { datasets: n } } = this;
    e.length > n.length && delete this._stacks, e.forEach((i, s) => {
      n.filter((r) => r === i._dataset).length === 0 && this._destroyDatasetMeta(s);
    });
  }
  buildOrUpdateControllers() {
    const e = [], n = this.data.datasets;
    let i, s;
    for (this._removeUnreferencedMetasets(), i = 0, s = n.length; i < s; i++) {
      const r = n[i];
      let o = this.getDatasetMeta(i);
      const a = r.type || this.config.type;
      if (o.type && o.type !== a && (this._destroyDatasetMeta(i), o = this.getDatasetMeta(i)), o.type = a, o.indexAxis = r.indexAxis || lp(a, this.options), o.order = r.order || 0, o.index = i, o.label = "" + r.label, o.visible = this.isDatasetVisible(i), o.controller)
        o.controller.updateIndex(i), o.controller.linkScales();
      else {
        const l = _i.getController(a), { datasetElementType: c, dataElementType: u } = At.datasets[a];
        Object.assign(l, {
          dataElementType: _i.getElement(u),
          datasetElementType: c && _i.getElement(c)
        }), o.controller = new l(this, i), e.push(o.controller);
      }
    }
    return this._updateMetasets(), e;
  }
  _resetElements() {
    ot(this.data.datasets, (e, n) => {
      this.getDatasetMeta(n).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(e) {
    const n = this.config;
    n.update();
    const i = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !i.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: e,
      cancelable: true
    }) === false)
      return;
    const r = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let o = 0;
    for (let c = 0, u = this.data.datasets.length; c < u; c++) {
      const { controller: d } = this.getDatasetMeta(c), f = !s && r.indexOf(d) === -1;
      d.buildOrUpdateElements(f), o = Math.max(+d.getMaxOverflow(), o);
    }
    o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || ot(r, (c) => {
      c.reset();
    }), this._updateDatasets(e), this.notifyPlugins("afterUpdate", {
      mode: e
    }), this._layers.sort(zy("z", "_idx"));
    const { _active: a, _lastEvent: l } = this;
    l ? this._eventHandler(l, true) : a.length && this._updateHoverStyles(a, a, true), this.render();
  }
  _updateScales() {
    ot(this.scales, (e) => {
      zs.removeBox(this, e);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const e = this.options, n = new Set(Object.keys(this._listeners)), i = new Set(e.events);
    (!ey(n, i) || !!this._responsiveListeners !== e.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: e } = this, n = this._getUniformDataChanges() || [];
    for (const { method: i, start: s, count: r } of n) {
      const o = i === "_removeElements" ? -r : r;
      hY(e, s, o);
    }
  }
  _getUniformDataChanges() {
    const e = this._dataChanges;
    if (!e || !e.length)
      return;
    this._dataChanges = [];
    const n = this.data.datasets.length, i = (r) => new Set(e.filter((o) => o[0] === r).map((o, a) => a + "," + o.splice(1).join(","))), s = i(0);
    for (let r = 1; r < n; r++)
      if (!ey(s, i(r)))
        return;
    return Array.from(s).map((r) => r.split(",")).map((r) => ({
      method: r[1],
      start: +r[2],
      count: +r[3]
    }));
  }
  _updateLayout(e) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false)
      return;
    zs.update(this, this.width, this.height, e);
    const n = this.chartArea, i = n.width <= 0 || n.height <= 0;
    this._layers = [], ot(this.boxes, (s) => {
      i && s.position === "chartArea" || (s.configure && s.configure(), this._layers.push(...s._layers()));
    }, this), this._layers.forEach((s, r) => {
      s._idx = r;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(e) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: e,
      cancelable: true
    }) !== false) {
      for (let n = 0, i = this.data.datasets.length; n < i; ++n)
        this.getDatasetMeta(n).controller.configure();
      for (let n = 0, i = this.data.datasets.length; n < i; ++n)
        this._updateDataset(n, rr(e) ? e({
          datasetIndex: n
        }) : e);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: e
      });
    }
  }
  _updateDataset(e, n) {
    const i = this.getDatasetMeta(e), s = {
      meta: i,
      index: e,
      mode: n,
      cancelable: true
    };
    this.notifyPlugins("beforeDatasetUpdate", s) !== false && (i.controller._update(n), s.cancelable = false, this.notifyPlugins("afterDatasetUpdate", s));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: true
    }) !== false && (ss.has(this) ? this.attached && !ss.running(this) && ss.start(this) : (this.draw(), jy({
      chart: this
    })));
  }
  draw() {
    let e;
    if (this._resizeBeforeDraw) {
      const { width: i, height: s } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(i, s);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false)
      return;
    const n = this._layers;
    for (e = 0; e < n.length && n[e].z <= 0; ++e)
      n[e].draw(this.chartArea);
    for (this._drawDatasets(); e < n.length; ++e)
      n[e].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(e) {
    const n = this._sortedMetasets, i = [];
    let s, r;
    for (s = 0, r = n.length; s < r; ++s) {
      const o = n[s];
      (!e || o.visible) && i.push(o);
    }
    return i;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false)
      return;
    const e = this.getSortedVisibleDatasetMetas();
    for (let n = e.length - 1; n >= 0; --n)
      this._drawDataset(e[n]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(e) {
    const n = this.ctx, i = e._clip, s = !i.disabled, r = mY(e, this.chartArea), o = {
      meta: e,
      index: e.index,
      cancelable: true
    };
    this.notifyPlugins("beforeDatasetDraw", o) !== false && (s && Rd(n, {
      left: i.left === false ? 0 : r.left - i.left,
      right: i.right === false ? this.width : r.right + i.right,
      top: i.top === false ? 0 : r.top - i.top,
      bottom: i.bottom === false ? this.height : r.bottom + i.bottom
    }), e.controller.draw(), s && Fd(n), o.cancelable = false, this.notifyPlugins("afterDatasetDraw", o));
  }
  isPointInArea(e) {
    return ms(e, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, n, i, s) {
    const r = dK.modes[n];
    return typeof r == "function" ? r(this, e, i, s) : [];
  }
  getDatasetMeta(e) {
    const n = this.data.datasets[e], i = this._metasets;
    let s = i.filter((r) => r && r._dataset === n).pop();
    return s || (s = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: n && n.order || 0,
      index: e,
      _dataset: n,
      _parsed: [],
      _sorted: false
    }, i.push(s)), s;
  }
  getContext() {
    return this.$context || (this.$context = ur(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(e) {
    const n = this.data.datasets[e];
    if (!n)
      return false;
    const i = this.getDatasetMeta(e);
    return typeof i.hidden == "boolean" ? !i.hidden : !n.hidden;
  }
  setDatasetVisibility(e, n) {
    const i = this.getDatasetMeta(e);
    i.hidden = !n;
  }
  toggleDataVisibility(e) {
    this._hiddenIndices[e] = !this._hiddenIndices[e];
  }
  getDataVisibility(e) {
    return !this._hiddenIndices[e];
  }
  _updateVisibility(e, n, i) {
    const s = i ? "show" : "hide", r = this.getDatasetMeta(e), o = r.controller._resolveAnimations(void 0, s);
    vl(n) ? (r.data[n].hidden = !i, this.update()) : (this.setDatasetVisibility(e, i), o.update(r, {
      visible: i
    }), this.update((a) => a.datasetIndex === e ? s : void 0));
  }
  hide(e, n) {
    this._updateVisibility(e, n, false);
  }
  show(e, n) {
    this._updateVisibility(e, n, true);
  }
  _destroyDatasetMeta(e) {
    const n = this._metasets[e];
    n && n.controller && n.controller._destroy(), delete this._metasets[e];
  }
  _stop() {
    let e, n;
    for (this.stop(), ss.remove(this), e = 0, n = this.data.datasets.length; e < n; ++e)
      this._destroyDatasetMeta(e);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: e, ctx: n } = this;
    this._stop(), this.config.clearCache(), e && (this.unbindEvents(), cy(e, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete Ic[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...e) {
    return this.canvas.toDataURL(...e);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = true;
  }
  bindUserEvents() {
    const e = this._listeners, n = this.platform, i = (r, o) => {
      n.addEventListener(this, r, o), e[r] = o;
    }, s = (r, o, a) => {
      r.offsetX = o, r.offsetY = a, this._eventHandler(r);
    };
    ot(this.options.events, (r) => i(r, s));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const e = this._responsiveListeners, n = this.platform, i = (l, c) => {
      n.addEventListener(this, l, c), e[l] = c;
    }, s = (l, c) => {
      e[l] && (n.removeEventListener(this, l, c), delete e[l]);
    }, r = (l, c) => {
      this.canvas && this.resize(l, c);
    };
    let o;
    const a = () => {
      s("attach", a), this.attached = true, this.resize(), i("resize", r), i("detach", o);
    };
    o = () => {
      this.attached = false, s("resize", r), this._stop(), this._resize(0, 0), i("attach", a);
    }, n.isAttached(this.canvas) ? a() : o();
  }
  unbindEvents() {
    ot(this._listeners, (e, n) => {
      this.platform.removeEventListener(this, n, e);
    }), this._listeners = {}, ot(this._responsiveListeners, (e, n) => {
      this.platform.removeEventListener(this, n, e);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(e, n, i) {
    const s = i ? "set" : "remove";
    let r, o, a, l;
    for (n === "dataset" && (r = this.getDatasetMeta(e[0].datasetIndex), r.controller["_" + s + "DatasetHoverStyle"]()), a = 0, l = e.length; a < l; ++a) {
      o = e[a];
      const c = o && this.getDatasetMeta(o.datasetIndex).controller;
      c && c[s + "HoverStyle"](o.element, o.datasetIndex, o.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e) {
    const n = this._active || [], i = e.map(({ datasetIndex: r, index: o }) => {
      const a = this.getDatasetMeta(r);
      if (!a)
        throw new Error("No dataset found at index " + r);
      return {
        datasetIndex: r,
        element: a.data[o],
        index: o
      };
    });
    !Vu(i, n) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, n));
  }
  notifyPlugins(e, n, i) {
    return this._plugins.notify(this, e, n, i);
  }
  isPluginEnabled(e) {
    return this._plugins._cache.filter((n) => n.plugin.id === e).length === 1;
  }
  _updateHoverStyles(e, n, i) {
    const s = this.options.hover, r = (l, c) => l.filter((u) => !c.some((d) => u.datasetIndex === d.datasetIndex && u.index === d.index)), o = r(n, e), a = i ? e : r(e, n);
    o.length && this.updateHoverStyle(o, s.mode, false), a.length && s.mode && this.updateHoverStyle(a, s.mode, true);
  }
  _eventHandler(e, n) {
    const i = {
      event: e,
      replay: n,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    }, s = (o) => (o.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", i, s) === false)
      return;
    const r = this._handleEvent(e, n, i.inChartArea);
    return i.cancelable = false, this.notifyPlugins("afterEvent", i, s), (r || i.changed) && this.render(), this;
  }
  _handleEvent(e, n, i) {
    const { _active: s = [], options: r } = this, o = n, a = this._getActiveElements(e, s, i, o), l = yU(e), c = pY(e, this._lastEvent, i, l);
    i && (this._lastEvent = null, pt(r.onHover, [
      e,
      a,
      this
    ], this), l && pt(r.onClick, [
      e,
      a,
      this
    ], this));
    const u = !Vu(a, s);
    return (u || n) && (this._active = a, this._updateHoverStyles(a, s, n)), this._lastEvent = c, u;
  }
  _getActiveElements(e, n, i, s) {
    if (e.type === "mouseout")
      return [];
    if (!i)
      return n;
    const r = this.options.hover;
    return this.getElementsAtEventForMode(e, r.mode, r, s);
  }
};
ve(St, "defaults", At), ve(St, "instances", Ic), ve(St, "overrides", Qr), ve(St, "registry", _i), ve(St, "version", uY), ve(St, "getChart", Hy);
function Wy() {
  return ot(St.instances, (t10) => t10._plugins.invalidate());
}
function gY(t10, e, n) {
  const { startAngle: i, pixelMargin: s, x: r, y: o, outerRadius: a, innerRadius: l } = e;
  let c = s / a;
  t10.beginPath(), t10.arc(r, o, a, i - c, n + c), l > s ? (c = s / l, t10.arc(r, o, l, n + c, i - c, true)) : t10.arc(r, o, s, n + Lt, i - Lt), t10.closePath(), t10.clip();
}
function bY(t10) {
  return Xm(t10, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function yY(t10, e, n, i) {
  const s = bY(t10.options.borderRadius), r = (n - e) / 2, o = Math.min(r, i * e / 2), a = (l) => {
    const c = (n - Math.min(r, l)) * i / 2;
    return sn(l, 0, Math.min(r, c));
  };
  return {
    outerStart: a(s.outerStart),
    outerEnd: a(s.outerEnd),
    innerStart: sn(s.innerStart, 0, o),
    innerEnd: sn(s.innerEnd, 0, o)
  };
}
function uo(t10, e, n, i) {
  return {
    x: n + t10 * Math.cos(e),
    y: i + t10 * Math.sin(e)
  };
}
function Uu(t10, e, n, i, s, r) {
  const { x: o, y: a, startAngle: l, pixelMargin: c, innerRadius: u } = e, d = Math.max(e.outerRadius + i + n - c, 0), f = u > 0 ? u + i + n + c : 0;
  let h10 = 0;
  const p = s - l;
  if (i) {
    const W = u > 0 ? u - i : 0, C = d > 0 ? d - i : 0, O = (W + C) / 2, _ = O !== 0 ? p * O / (O + i) : p;
    h10 = (p - _) / 2;
  }
  const g = Math.max(1e-3, p * d - n / _t) / d, m = (p - g) / 2, b = l + m + h10, x = s - m - h10, { outerStart: k, outerEnd: v, innerStart: S, innerEnd: w } = yY(e, f, d, x - b), E = d - k, M = d - v, N = b + k / E, V = x - v / M, Y = f + S, F = f + w, re = b + S / Y, z = x - w / F;
  if (t10.beginPath(), r) {
    const W = (N + V) / 2;
    if (t10.arc(o, a, d, N, W), t10.arc(o, a, d, W, V), v > 0) {
      const T = uo(M, V, o, a);
      t10.arc(T.x, T.y, v, V, x + Lt);
    }
    const C = uo(F, x, o, a);
    if (t10.lineTo(C.x, C.y), w > 0) {
      const T = uo(F, z, o, a);
      t10.arc(T.x, T.y, w, x + Lt, z + Math.PI);
    }
    const O = (x - w / f + (b + S / f)) / 2;
    if (t10.arc(o, a, f, x - w / f, O, true), t10.arc(o, a, f, O, b + S / f, true), S > 0) {
      const T = uo(Y, re, o, a);
      t10.arc(T.x, T.y, S, re + Math.PI, b - Lt);
    }
    const _ = uo(E, b, o, a);
    if (t10.lineTo(_.x, _.y), k > 0) {
      const T = uo(E, N, o, a);
      t10.arc(T.x, T.y, k, b - Lt, N);
    }
  } else {
    t10.moveTo(o, a);
    const W = Math.cos(N) * d + o, C = Math.sin(N) * d + a;
    t10.lineTo(W, C);
    const O = Math.cos(V) * d + o, _ = Math.sin(V) * d + a;
    t10.lineTo(O, _);
  }
  t10.closePath();
}
function vY(t10, e, n, i, s) {
  const { fullCircles: r, startAngle: o, circumference: a } = e;
  let l = e.endAngle;
  if (r) {
    Uu(t10, e, n, i, l, s);
    for (let c = 0; c < r; ++c)
      t10.fill();
    isNaN(a) || (l = o + (a % bt || bt));
  }
  return Uu(t10, e, n, i, l, s), t10.fill(), l;
}
function xY(t10, e, n, i, s) {
  const { fullCircles: r, startAngle: o, circumference: a, options: l } = e, { borderWidth: c, borderJoinStyle: u, borderDash: d, borderDashOffset: f } = l, h10 = l.borderAlign === "inner";
  if (!c)
    return;
  t10.setLineDash(d || []), t10.lineDashOffset = f, h10 ? (t10.lineWidth = c * 2, t10.lineJoin = u || "round") : (t10.lineWidth = c, t10.lineJoin = u || "bevel");
  let p = e.endAngle;
  if (r) {
    Uu(t10, e, n, i, p, s);
    for (let g = 0; g < r; ++g)
      t10.stroke();
    isNaN(a) || (p = o + (a % bt || bt));
  }
  h10 && gY(t10, e, p), r || (Uu(t10, e, n, i, p, s), t10.stroke());
}
var Oa = class extends dr {
  constructor(n) {
    super();
    ve(this, "circumference");
    ve(this, "endAngle");
    ve(this, "fullCircles");
    ve(this, "innerRadius");
    ve(this, "outerRadius");
    ve(this, "pixelMargin");
    ve(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, n && Object.assign(this, n);
  }
  inRange(n, i, s) {
    const r = this.getProps([
      "x",
      "y"
    ], s), { angle: o, distance: a } = n4(r, {
      x: n,
      y: i
    }), { startAngle: l, endAngle: c, innerRadius: u, outerRadius: d, circumference: f } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], s), h10 = (this.options.spacing + this.options.borderWidth) / 2, p = Ke(f, c - l), g = kl(o, l, c) && l !== c, m = p >= bt || g, b = ps(a, u + h10, d + h10);
    return m && b;
  }
  getCenterPoint(n) {
    const { x: i, y: s, startAngle: r, endAngle: o, innerRadius: a, outerRadius: l } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], n), { offset: c, spacing: u } = this.options, d = (r + o) / 2, f = (a + l + u + c) / 2;
    return {
      x: i + Math.cos(d) * f,
      y: s + Math.sin(d) * f
    };
  }
  tooltipPosition(n) {
    return this.getCenterPoint(n);
  }
  draw(n) {
    const { options: i, circumference: s } = this, r = (i.offset || 0) / 4, o = (i.spacing || 0) / 2, a = i.circular;
    if (this.pixelMargin = i.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = s > bt ? Math.floor(s / bt) : 0, s === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    n.save();
    const l = (this.startAngle + this.endAngle) / 2;
    n.translate(Math.cos(l) * r, Math.sin(l) * r);
    const c = 1 - Math.sin(Math.min(_t, s || 0)), u = r * c;
    n.fillStyle = i.backgroundColor, n.strokeStyle = i.borderColor, vY(n, this, u, o, a), xY(n, this, u, o, a), n.restore();
  }
};
ve(Oa, "id", "arc"), ve(Oa, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
}), ve(Oa, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), ve(Oa, "descriptors", {
  _scriptable: true,
  _indexable: (n) => n !== "borderDash"
});
function L4(t10, e, n = e) {
  t10.lineCap = Ke(n.borderCapStyle, e.borderCapStyle), t10.setLineDash(Ke(n.borderDash, e.borderDash)), t10.lineDashOffset = Ke(n.borderDashOffset, e.borderDashOffset), t10.lineJoin = Ke(n.borderJoinStyle, e.borderJoinStyle), t10.lineWidth = Ke(n.borderWidth, e.borderWidth), t10.strokeStyle = Ke(n.borderColor, e.borderColor);
}
function kY(t10, e, n) {
  t10.lineTo(n.x, n.y);
}
function SY(t10) {
  return t10.stepped ? UU : t10.tension || t10.cubicInterpolationMode === "monotone" ? qU : kY;
}
function I4(t10, e, n = {}) {
  const i = t10.length, { start: s = 0, end: r = i - 1 } = n, { start: o, end: a } = e, l = Math.max(s, o), c = Math.min(r, a), u = s < o && r < o || s > a && r > a;
  return {
    count: i,
    start: l,
    loop: e.loop,
    ilen: c < l && !u ? i + c - l : c - l
  };
}
function wY(t10, e, n, i) {
  const { points: s, options: r } = e, { count: o, start: a, loop: l, ilen: c } = I4(s, n, i), u = SY(r);
  let { move: d = true, reverse: f } = i || {}, h10, p, g;
  for (h10 = 0; h10 <= c; ++h10)
    p = s[(a + (f ? c - h10 : h10)) % o], !p.skip && (d ? (t10.moveTo(p.x, p.y), d = false) : u(t10, g, p, f, r.stepped), g = p);
  return l && (p = s[(a + (f ? c : 0)) % o], u(t10, g, p, f, r.stepped)), !!l;
}
function CY(t10, e, n, i) {
  const s = e.points, { count: r, start: o, ilen: a } = I4(s, n, i), { move: l = true, reverse: c } = i || {};
  let u = 0, d = 0, f, h10, p, g, m, b;
  const x = (v) => (o + (c ? a - v : v)) % r, k = () => {
    g !== m && (t10.lineTo(u, m), t10.lineTo(u, g), t10.lineTo(u, b));
  };
  for (l && (h10 = s[x(0)], t10.moveTo(h10.x, h10.y)), f = 0; f <= a; ++f) {
    if (h10 = s[x(f)], h10.skip)
      continue;
    const v = h10.x, S = h10.y, w = v | 0;
    w === p ? (S < g ? g = S : S > m && (m = S), u = (d * u + v) / ++d) : (k(), t10.lineTo(v, S), p = w, d = 0, g = m = S), b = S;
  }
  k();
}
function up(t10) {
  const e = t10.options, n = e.borderDash && e.borderDash.length;
  return !t10._decimated && !t10._loop && !e.tension && e.cubicInterpolationMode !== "monotone" && !e.stepped && !n ? CY : wY;
}
function OY(t10) {
  return t10.stepped ? Oq : t10.tension || t10.cubicInterpolationMode === "monotone" ? Eq : wr;
}
function EY(t10, e, n, i) {
  let s = e._path;
  s || (s = e._path = new Path2D(), e.path(s, n, i) && s.closePath()), L4(t10, e.options), t10.stroke(s);
}
function MY(t10, e, n, i) {
  const { segments: s, options: r } = e, o = up(e);
  for (const a of s)
    L4(t10, r, a.style), t10.beginPath(), o(t10, e, a, {
      start: n,
      end: n + i - 1
    }) && t10.closePath(), t10.stroke();
}
var TY = typeof Path2D == "function";
function AY(t10, e, n, i) {
  TY && !e.options.segment ? EY(t10, e, n, i) : MY(t10, e, n, i);
}
var gs = class extends dr {
  constructor(e) {
    super(), this.animated = true, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = false, this._pointsUpdated = false, this._datasetIndex = void 0, e && Object.assign(this, e);
  }
  updateControlPoints(e, n) {
    const i = this.options;
    if ((i.tension || i.cubicInterpolationMode === "monotone") && !i.stepped && !this._pointsUpdated) {
      const s = i.spanGaps ? this._loop : this._fullLoop;
      bq(this._points, i, e, s, n), this._pointsUpdated = true;
    }
  }
  set points(e) {
    this._points = e, delete this._segments, delete this._path, this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = Lq(this, this.options.segment));
  }
  first() {
    const e = this.segments, n = this.points;
    return e.length && n[e[0].start];
  }
  last() {
    const e = this.segments, n = this.points, i = e.length;
    return i && n[e[i - 1].end];
  }
  interpolate(e, n) {
    const i = this.options, s = e[n], r = this.points, o = v4(this, {
      property: n,
      start: s,
      end: s
    });
    if (!o.length)
      return;
    const a = [], l = OY(i);
    let c, u;
    for (c = 0, u = o.length; c < u; ++c) {
      const { start: d, end: f } = o[c], h10 = r[d], p = r[f];
      if (h10 === p) {
        a.push(h10);
        continue;
      }
      const g = Math.abs((s - h10[n]) / (p[n] - h10[n])), m = l(h10, p, g, i.stepped);
      m[n] = e[n], a.push(m);
    }
    return a.length === 1 ? a[0] : a;
  }
  pathSegment(e, n, i) {
    return up(this)(e, this, n, i);
  }
  path(e, n, i) {
    const s = this.segments, r = up(this);
    let o = this._loop;
    n = n || 0, i = i || this.points.length - n;
    for (const a of s)
      o &= r(e, this, a, {
        start: n,
        end: n + i - 1
      });
    return !!o;
  }
  draw(e, n, i, s) {
    const r = this.options || {};
    (this.points || []).length && r.borderWidth && (e.save(), AY(e, this, i, s), e.restore()), this.animated && (this._pointsUpdated = false, this._path = void 0);
  }
};
ve(gs, "id", "line"), ve(gs, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
}), ve(gs, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), ve(gs, "descriptors", {
  _scriptable: true,
  _indexable: (e) => e !== "borderDash" && e !== "fill"
});
function Uy(t10, e, n, i) {
  const s = t10.options, { [n]: r } = t10.getProps([
    n
  ], i);
  return Math.abs(e - r) < s.radius + s.hitRadius;
}
var Xa = class extends dr {
  constructor(n) {
    super();
    ve(this, "parsed");
    ve(this, "skip");
    ve(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, n && Object.assign(this, n);
  }
  inRange(n, i, s) {
    const r = this.options, { x: o, y: a } = this.getProps([
      "x",
      "y"
    ], s);
    return Math.pow(n - o, 2) + Math.pow(i - a, 2) < Math.pow(r.hitRadius + r.radius, 2);
  }
  inXRange(n, i) {
    return Uy(this, n, "x", i);
  }
  inYRange(n, i) {
    return Uy(this, n, "y", i);
  }
  getCenterPoint(n) {
    const { x: i, y: s } = this.getProps([
      "x",
      "y"
    ], n);
    return {
      x: i,
      y: s
    };
  }
  size(n) {
    n = n || this.options || {};
    let i = n.radius || 0;
    i = Math.max(i, i && n.hoverRadius || 0);
    const s = i && n.borderWidth || 0;
    return (i + s) * 2;
  }
  draw(n, i) {
    const s = this.options;
    this.skip || s.radius < 0.1 || !ms(this, i, this.size(s) / 2) || (n.strokeStyle = s.borderColor, n.lineWidth = s.borderWidth, n.fillStyle = s.backgroundColor, ap(n, s, this.x, this.y));
  }
  getRange() {
    const n = this.options || {};
    return n.radius + n.hitRadius;
  }
};
ve(Xa, "id", "point"), /**
* @type {any}
*/
ve(Xa, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
ve(Xa, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function P4(t10, e) {
  const { x: n, y: i, base: s, width: r, height: o } = t10.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], e);
  let a, l, c, u, d;
  return t10.horizontal ? (d = o / 2, a = Math.min(n, s), l = Math.max(n, s), c = i - d, u = i + d) : (d = r / 2, a = n - d, l = n + d, c = Math.min(i, s), u = Math.max(i, s)), {
    left: a,
    top: c,
    right: l,
    bottom: u
  };
}
function js(t10, e, n, i) {
  return t10 ? 0 : sn(e, n, i);
}
function _Y(t10, e, n) {
  const i = t10.options.borderWidth, s = t10.borderSkipped, r = c4(i);
  return {
    t: js(s.top, r.top, 0, n),
    r: js(s.right, r.right, 0, e),
    b: js(s.bottom, r.bottom, 0, n),
    l: js(s.left, r.left, 0, e)
  };
}
function NY(t10, e, n) {
  const { enableBorderRadius: i } = t10.getProps([
    "enableBorderRadius"
  ]), s = t10.options.borderRadius, r = zr(s), o = Math.min(e, n), a = t10.borderSkipped, l = i || Je(s);
  return {
    topLeft: js(!l || a.top || a.left, r.topLeft, 0, o),
    topRight: js(!l || a.top || a.right, r.topRight, 0, o),
    bottomLeft: js(!l || a.bottom || a.left, r.bottomLeft, 0, o),
    bottomRight: js(!l || a.bottom || a.right, r.bottomRight, 0, o)
  };
}
function LY(t10) {
  const e = P4(t10), n = e.right - e.left, i = e.bottom - e.top, s = _Y(t10, n / 2, i / 2), r = NY(t10, n / 2, i / 2);
  return {
    outer: {
      x: e.left,
      y: e.top,
      w: n,
      h: i,
      radius: r
    },
    inner: {
      x: e.left + s.l,
      y: e.top + s.t,
      w: n - s.l - s.r,
      h: i - s.t - s.b,
      radius: {
        topLeft: Math.max(0, r.topLeft - Math.max(s.t, s.l)),
        topRight: Math.max(0, r.topRight - Math.max(s.t, s.r)),
        bottomLeft: Math.max(0, r.bottomLeft - Math.max(s.b, s.l)),
        bottomRight: Math.max(0, r.bottomRight - Math.max(s.b, s.r))
      }
    }
  };
}
function Wf(t10, e, n, i) {
  const s = e === null, r = n === null, a = t10 && !(s && r) && P4(t10, i);
  return a && (s || ps(e, a.left, a.right)) && (r || ps(n, a.top, a.bottom));
}
function IY(t10) {
  return t10.topLeft || t10.topRight || t10.bottomLeft || t10.bottomRight;
}
function PY(t10, e) {
  t10.rect(e.x, e.y, e.w, e.h);
}
function Uf(t10, e, n = {}) {
  const i = t10.x !== n.x ? -e : 0, s = t10.y !== n.y ? -e : 0, r = (t10.x + t10.w !== n.x + n.w ? e : 0) - i, o = (t10.y + t10.h !== n.y + n.h ? e : 0) - s;
  return {
    x: t10.x + i,
    y: t10.y + s,
    w: t10.w + r,
    h: t10.h + o,
    radius: t10.radius
  };
}
var Pc = class extends dr {
  constructor(e) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e);
  }
  draw(e) {
    const { inflateAmount: n, options: { borderColor: i, backgroundColor: s } } = this, { inner: r, outer: o } = LY(this), a = IY(o.radius) ? Sl : PY;
    e.save(), (o.w !== r.w || o.h !== r.h) && (e.beginPath(), a(e, Uf(o, n, r)), e.clip(), a(e, Uf(r, -n, o)), e.fillStyle = i, e.fill("evenodd")), e.beginPath(), a(e, Uf(r, n)), e.fillStyle = s, e.fill(), e.restore();
  }
  inRange(e, n, i) {
    return Wf(this, e, n, i);
  }
  inXRange(e, n) {
    return Wf(this, e, null, n);
  }
  inYRange(e, n) {
    return Wf(this, null, e, n);
  }
  getCenterPoint(e) {
    const { x: n, y: i, base: s, horizontal: r } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], e);
    return {
      x: r ? (n + s) / 2 : n,
      y: r ? i : (i + s) / 2
    };
  }
  getRange(e) {
    return e === "x" ? this.width / 2 : this.height / 2;
  }
};
ve(Pc, "id", "bar"), ve(Pc, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
}), ve(Pc, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function DY(t10, e, n) {
  const i = t10.segments, s = t10.points, r = e.points, o = [];
  for (const a of i) {
    let { start: l, end: c } = a;
    c = sg(l, c, s);
    const u = dp(n, s[l], s[c], a.loop);
    if (!e.segments) {
      o.push({
        source: a,
        target: u,
        start: s[l],
        end: s[c]
      });
      continue;
    }
    const d = v4(e, u);
    for (const f of d) {
      const h10 = dp(n, r[f.start], r[f.end], f.loop), p = y4(a, s, h10);
      for (const g of p)
        o.push({
          source: g,
          target: f,
          start: {
            [n]: qy(u, h10, "start", Math.max)
          },
          end: {
            [n]: qy(u, h10, "end", Math.min)
          }
        });
    }
  }
  return o;
}
function dp(t10, e, n, i) {
  if (i)
    return;
  let s = e[t10], r = n[t10];
  return t10 === "angle" && (s = zn(s), r = zn(r)), {
    property: t10,
    start: s,
    end: r
  };
}
function $Y(t10, e) {
  const { x: n = null, y: i = null } = t10 || {}, s = e.points, r = [];
  return e.segments.forEach(({ start: o, end: a }) => {
    a = sg(o, a, s);
    const l = s[o], c = s[a];
    i !== null ? (r.push({
      x: l.x,
      y: i
    }), r.push({
      x: c.x,
      y: i
    })) : n !== null && (r.push({
      x: n,
      y: l.y
    }), r.push({
      x: n,
      y: c.y
    }));
  }), r;
}
function sg(t10, e, n) {
  for (; e > t10; e--) {
    const i = n[e];
    if (!isNaN(i.x) && !isNaN(i.y))
      break;
  }
  return e;
}
function qy(t10, e, n, i) {
  return t10 && e ? i(t10[n], e[n]) : t10 ? t10[n] : e ? e[n] : 0;
}
function D4(t10, e) {
  let n = [], i = false;
  return wt(t10) ? (i = true, n = t10) : n = $Y(t10, e), n.length ? new gs({
    points: n,
    options: {
      tension: 0
    },
    _loop: i,
    _fullLoop: i
  }) : null;
}
function Ky(t10) {
  return t10 && t10.fill !== false;
}
function RY(t10, e, n) {
  let s = t10[e].fill;
  const r = [
    e
  ];
  let o;
  if (!n)
    return s;
  for (; s !== false && r.indexOf(s) === -1; ) {
    if (!Yt(s))
      return s;
    if (o = t10[s], !o)
      return false;
    if (o.visible)
      return s;
    r.push(s), s = o.fill;
  }
  return false;
}
function FY(t10, e, n) {
  const i = jY(t10);
  if (Je(i))
    return isNaN(i.value) ? false : i;
  let s = parseFloat(i);
  return Yt(s) && Math.floor(s) === s ? VY(i[0], e, s, n) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(i) >= 0 && i;
}
function VY(t10, e, n, i) {
  return (t10 === "-" || t10 === "+") && (n = e + n), n === e || n < 0 || n >= i ? false : n;
}
function BY(t10, e) {
  let n = null;
  return t10 === "start" ? n = e.bottom : t10 === "end" ? n = e.top : Je(t10) ? n = e.getPixelForValue(t10.value) : e.getBasePixel && (n = e.getBasePixel()), n;
}
function zY(t10, e, n) {
  let i;
  return t10 === "start" ? i = n : t10 === "end" ? i = e.options.reverse ? e.min : e.max : Je(t10) ? i = t10.value : i = e.getBaseValue(), i;
}
function jY(t10) {
  const e = t10.options, n = e.fill;
  let i = Ke(n && n.target, n);
  return i === void 0 && (i = !!e.backgroundColor), i === false || i === null ? false : i === true ? "origin" : i;
}
function HY(t10) {
  const { scale: e, index: n, line: i } = t10, s = [], r = i.segments, o = i.points, a = WY(e, n);
  a.push(D4({
    x: null,
    y: e.bottom
  }, i));
  for (let l = 0; l < r.length; l++) {
    const c = r[l];
    for (let u = c.start; u <= c.end; u++)
      UY(s, o[u], a);
  }
  return new gs({
    points: s,
    options: {}
  });
}
function WY(t10, e) {
  const n = [], i = t10.getMatchingVisibleMetas("line");
  for (let s = 0; s < i.length; s++) {
    const r = i[s];
    if (r.index === e)
      break;
    r.hidden || n.unshift(r.dataset);
  }
  return n;
}
function UY(t10, e, n) {
  const i = [];
  for (let s = 0; s < n.length; s++) {
    const r = n[s], { first: o, last: a, point: l } = qY(r, e, "x");
    if (!(!l || o && a)) {
      if (o)
        i.unshift(l);
      else if (t10.push(l), !a)
        break;
    }
  }
  t10.push(...i);
}
function qY(t10, e, n) {
  const i = t10.interpolate(e, n);
  if (!i)
    return {};
  const s = i[n], r = t10.segments, o = t10.points;
  let a = false, l = false;
  for (let c = 0; c < r.length; c++) {
    const u = r[c], d = o[u.start][n], f = o[u.end][n];
    if (ps(s, d, f)) {
      a = s === d, l = s === f;
      break;
    }
  }
  return {
    first: a,
    last: l,
    point: i
  };
}
var $4 = class {
  constructor(e) {
    this.x = e.x, this.y = e.y, this.radius = e.radius;
  }
  pathSegment(e, n, i) {
    const { x: s, y: r, radius: o } = this;
    return n = n || {
      start: 0,
      end: bt
    }, e.arc(s, r, o, n.end, n.start, true), !i.bounds;
  }
  interpolate(e) {
    const { x: n, y: i, radius: s } = this, r = e.angle;
    return {
      x: n + Math.cos(r) * s,
      y: i + Math.sin(r) * s,
      angle: r
    };
  }
};
function KY(t10) {
  const { chart: e, fill: n, line: i } = t10;
  if (Yt(n))
    return YY(e, n);
  if (n === "stack")
    return HY(t10);
  if (n === "shape")
    return true;
  const s = GY(t10);
  return s instanceof $4 ? s : D4(s, i);
}
function YY(t10, e) {
  const n = t10.getDatasetMeta(e);
  return n && t10.isDatasetVisible(e) ? n.dataset : null;
}
function GY(t10) {
  return (t10.scale || {}).getPointPositionForValue ? XY(t10) : JY(t10);
}
function JY(t10) {
  const { scale: e = {}, fill: n } = t10, i = BY(n, e);
  if (Yt(i)) {
    const s = e.isHorizontal();
    return {
      x: s ? i : null,
      y: s ? null : i
    };
  }
  return null;
}
function XY(t10) {
  const { scale: e, fill: n } = t10, i = e.options, s = e.getLabels().length, r = i.reverse ? e.max : e.min, o = zY(n, e, r), a = [];
  if (i.grid.circular) {
    const l = e.getPointPositionForValue(0, r);
    return new $4({
      x: l.x,
      y: l.y,
      radius: e.getDistanceFromCenterForValue(o)
    });
  }
  for (let l = 0; l < s; ++l)
    a.push(e.getPointPositionForValue(l, o));
  return a;
}
function qf(t10, e, n) {
  const i = KY(e), { line: s, scale: r, axis: o } = e, a = s.options, l = a.fill, c = a.backgroundColor, { above: u = c, below: d = c } = l || {};
  i && s.points.length && (Rd(t10, n), QY(t10, {
    line: s,
    target: i,
    above: u,
    below: d,
    area: n,
    scale: r,
    axis: o
  }), Fd(t10));
}
function QY(t10, e) {
  const { line: n, target: i, above: s, below: r, area: o, scale: a } = e, l = n._loop ? "angle" : e.axis;
  t10.save(), l === "x" && r !== s && (Yy(t10, i, o.top), Gy(t10, {
    line: n,
    target: i,
    color: s,
    scale: a,
    property: l
  }), t10.restore(), t10.save(), Yy(t10, i, o.bottom)), Gy(t10, {
    line: n,
    target: i,
    color: r,
    scale: a,
    property: l
  }), t10.restore();
}
function Yy(t10, e, n) {
  const { segments: i, points: s } = e;
  let r = true, o = false;
  t10.beginPath();
  for (const a of i) {
    const { start: l, end: c } = a, u = s[l], d = s[sg(l, c, s)];
    r ? (t10.moveTo(u.x, u.y), r = false) : (t10.lineTo(u.x, n), t10.lineTo(u.x, u.y)), o = !!e.pathSegment(t10, a, {
      move: o
    }), o ? t10.closePath() : t10.lineTo(d.x, n);
  }
  t10.lineTo(e.first().x, n), t10.closePath(), t10.clip();
}
function Gy(t10, e) {
  const { line: n, target: i, property: s, color: r, scale: o } = e, a = DY(n, i, s);
  for (const { source: l, target: c, start: u, end: d } of a) {
    const { style: { backgroundColor: f = r } = {} } = l, h10 = i !== true;
    t10.save(), t10.fillStyle = f, ZY(t10, o, h10 && dp(s, u, d)), t10.beginPath();
    const p = !!n.pathSegment(t10, l);
    let g;
    if (h10) {
      p ? t10.closePath() : Jy(t10, i, d, s);
      const m = !!i.pathSegment(t10, c, {
        move: p,
        reverse: true
      });
      g = p && m, g || Jy(t10, i, u, s);
    }
    t10.closePath(), t10.fill(g ? "evenodd" : "nonzero"), t10.restore();
  }
}
function ZY(t10, e, n) {
  const { top: i, bottom: s } = e.chart.chartArea, { property: r, start: o, end: a } = n || {};
  r === "x" && (t10.beginPath(), t10.rect(o, i, a - o, s - i), t10.clip());
}
function Jy(t10, e, n, i) {
  const s = e.interpolate(n, i);
  s && t10.lineTo(s.x, s.y);
}
var eG = {
  id: "filler",
  afterDatasetsUpdate(t10, e, n) {
    const i = (t10.data.datasets || []).length, s = [];
    let r, o, a, l;
    for (o = 0; o < i; ++o)
      r = t10.getDatasetMeta(o), a = r.dataset, l = null, a && a.options && a instanceof gs && (l = {
        visible: t10.isDatasetVisible(o),
        index: o,
        fill: FY(a, o, i),
        chart: t10,
        axis: r.controller.options.indexAxis,
        scale: r.vScale,
        line: a
      }), r.$filler = l, s.push(l);
    for (o = 0; o < i; ++o)
      l = s[o], !(!l || l.fill === false) && (l.fill = RY(s, o, n.propagate));
  },
  beforeDraw(t10, e, n) {
    const i = n.drawTime === "beforeDraw", s = t10.getSortedVisibleDatasetMetas(), r = t10.chartArea;
    for (let o = s.length - 1; o >= 0; --o) {
      const a = s[o].$filler;
      a && (a.line.updateControlPoints(r, a.axis), i && a.fill && qf(t10.ctx, a, r));
    }
  },
  beforeDatasetsDraw(t10, e, n) {
    if (n.drawTime !== "beforeDatasetsDraw")
      return;
    const i = t10.getSortedVisibleDatasetMetas();
    for (let s = i.length - 1; s >= 0; --s) {
      const r = i[s].$filler;
      Ky(r) && qf(t10.ctx, r, t10.chartArea);
    }
  },
  beforeDatasetDraw(t10, e, n) {
    const i = e.meta.$filler;
    !Ky(i) || n.drawTime !== "beforeDatasetDraw" || qf(t10.ctx, i, t10.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var Xy = (t10, e) => {
  let { boxHeight: n = e, boxWidth: i = e } = t10;
  return t10.usePointStyle && (n = Math.min(n, e), i = t10.pointStyleWidth || Math.min(i, e)), {
    boxWidth: i,
    boxHeight: n,
    itemHeight: Math.max(e, n)
  };
};
var tG = (t10, e) => t10 !== null && e !== null && t10.datasetIndex === e.datasetIndex && t10.index === e.index;
var Qy = class extends dr {
  constructor(e) {
    super(), this._added = false, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = false, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(e, n, i) {
    this.maxWidth = e, this.maxHeight = n, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const e = this.options.labels || {};
    let n = pt(e.generateLabels, [
      this.chart
    ], this) || [];
    e.filter && (n = n.filter((i) => e.filter(i, this.chart.data))), e.sort && (n = n.sort((i, s) => e.sort(i, s, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n;
  }
  fit() {
    const { options: e, ctx: n } = this;
    if (!e.display) {
      this.width = this.height = 0;
      return;
    }
    const i = e.labels, s = Qt(i.font), r = s.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = Xy(i, r);
    let c, u;
    n.font = s.string, this.isHorizontal() ? (c = this.maxWidth, u = this._fitRows(o, r, a, l) + 10) : (u = this.maxHeight, c = this._fitCols(o, s, a, l) + 10), this.width = Math.min(c, e.maxWidth || this.maxWidth), this.height = Math.min(u, e.maxHeight || this.maxHeight);
  }
  _fitRows(e, n, i, s) {
    const { ctx: r, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [
      0
    ], u = s + a;
    let d = e;
    r.textAlign = "left", r.textBaseline = "middle";
    let f = -1, h10 = -u;
    return this.legendItems.forEach((p, g) => {
      const m = i + n / 2 + r.measureText(p.text).width;
      (g === 0 || c[c.length - 1] + m + 2 * a > o) && (d += u, c[c.length - (g > 0 ? 0 : 1)] = 0, h10 += u, f++), l[g] = {
        left: 0,
        top: h10,
        row: f,
        width: m,
        height: s
      }, c[c.length - 1] += m + a;
    }), d;
  }
  _fitCols(e, n, i, s) {
    const { ctx: r, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], u = o - e;
    let d = a, f = 0, h10 = 0, p = 0, g = 0;
    return this.legendItems.forEach((m, b) => {
      const { itemWidth: x, itemHeight: k } = nG(i, n, r, m, s);
      b > 0 && h10 + k + 2 * a > u && (d += f + a, c.push({
        width: f,
        height: h10
      }), p += f + a, g++, f = h10 = 0), l[b] = {
        left: p,
        top: h10,
        col: g,
        width: x,
        height: k
      }, f = Math.max(f, x), h10 += k + a;
    }), d += f, c.push({
      width: f,
      height: h10
    }), d;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const e = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: i, labels: { padding: s }, rtl: r } } = this, o = Mo(r, this.left, this.width);
    if (this.isHorizontal()) {
      let a = 0, l = Fn(i, this.left + s, this.right - this.lineWidths[a]);
      for (const c of n)
        a !== c.row && (a = c.row, l = Fn(i, this.left + s, this.right - this.lineWidths[a])), c.top += this.top + e + s, c.left = o.leftForLtr(o.x(l), c.width), l += c.width + s;
    } else {
      let a = 0, l = Fn(i, this.top + e + s, this.bottom - this.columnSizes[a].height);
      for (const c of n)
        c.col !== a && (a = c.col, l = Fn(i, this.top + e + s, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + s, c.left = o.leftForLtr(o.x(c.left), c.width), l += c.height + s;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const e = this.ctx;
      Rd(e, this), this._draw(), Fd(e);
    }
  }
  _draw() {
    const { options: e, columnSizes: n, lineWidths: i, ctx: s } = this, { align: r, labels: o } = e, a = At.color, l = Mo(e.rtl, this.left, this.width), c = Qt(o.font), { padding: u } = o, d = c.size, f = d / 2;
    let h10;
    this.drawTitle(), s.textAlign = l.textAlign("left"), s.textBaseline = "middle", s.lineWidth = 0.5, s.font = c.string;
    const { boxWidth: p, boxHeight: g, itemHeight: m } = Xy(o, d), b = function(w, E, M) {
      if (isNaN(p) || p <= 0 || isNaN(g) || g < 0)
        return;
      s.save();
      const N = Ke(M.lineWidth, 1);
      if (s.fillStyle = Ke(M.fillStyle, a), s.lineCap = Ke(M.lineCap, "butt"), s.lineDashOffset = Ke(M.lineDashOffset, 0), s.lineJoin = Ke(M.lineJoin, "miter"), s.lineWidth = N, s.strokeStyle = Ke(M.strokeStyle, a), s.setLineDash(Ke(M.lineDash, [])), o.usePointStyle) {
        const V = {
          radius: g * Math.SQRT2 / 2,
          pointStyle: M.pointStyle,
          rotation: M.rotation,
          borderWidth: N
        }, Y = l.xPlus(w, p / 2), F = E + f;
        l4(s, V, Y, F, o.pointStyleWidth && p);
      } else {
        const V = E + Math.max((d - g) / 2, 0), Y = l.leftForLtr(w, p), F = zr(M.borderRadius);
        s.beginPath(), Object.values(F).some((re) => re !== 0) ? Sl(s, {
          x: Y,
          y: V,
          w: p,
          h: g,
          radius: F
        }) : s.rect(Y, V, p, g), s.fill(), N !== 0 && s.stroke();
      }
      s.restore();
    }, x = function(w, E, M) {
      Wo(s, M.text, w, E + m / 2, c, {
        strikethrough: M.hidden,
        textAlign: l.textAlign(M.textAlign)
      });
    }, k = this.isHorizontal(), v = this._computeTitleHeight();
    k ? h10 = {
      x: Fn(r, this.left + u, this.right - i[0]),
      y: this.top + u + v,
      line: 0
    } : h10 = {
      x: this.left + u,
      y: Fn(r, this.top + v + u, this.bottom - n[0].height),
      line: 0
    }, m4(this.ctx, e.textDirection);
    const S = m + u;
    this.legendItems.forEach((w, E) => {
      s.strokeStyle = w.fontColor, s.fillStyle = w.fontColor;
      const M = s.measureText(w.text).width, N = l.textAlign(w.textAlign || (w.textAlign = o.textAlign)), V = p + f + M;
      let Y = h10.x, F = h10.y;
      l.setWidth(this.width), k ? E > 0 && Y + V + u > this.right && (F = h10.y += S, h10.line++, Y = h10.x = Fn(r, this.left + u, this.right - i[h10.line])) : E > 0 && F + S > this.bottom && (Y = h10.x = Y + n[h10.line].width + u, h10.line++, F = h10.y = Fn(r, this.top + v + u, this.bottom - n[h10.line].height));
      const re = l.x(Y);
      if (b(re, F, w), Y = NU(N, Y + p + f, k ? Y + V : this.right, e.rtl), x(l.x(Y), F, w), k)
        h10.x += V + u;
      else if (typeof w.text != "string") {
        const z = c.lineHeight;
        h10.y += R4(w, z) + u;
      } else
        h10.y += S;
    }), g4(this.ctx, e.textDirection);
  }
  drawTitle() {
    const e = this.options, n = e.title, i = Qt(n.font), s = xn(n.padding);
    if (!n.display)
      return;
    const r = Mo(e.rtl, this.left, this.width), o = this.ctx, a = n.position, l = i.size / 2, c = s.top + l;
    let u, d = this.left, f = this.width;
    if (this.isHorizontal())
      f = Math.max(...this.lineWidths), u = this.top + c, d = Fn(e.align, d, this.right - f);
    else {
      const p = this.columnSizes.reduce((g, m) => Math.max(g, m.height), 0);
      u = c + Fn(e.align, this.top, this.bottom - p - e.labels.padding - this._computeTitleHeight());
    }
    const h10 = Fn(a, d, d + f);
    o.textAlign = r.textAlign(a4(a)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = i.string, Wo(o, n.text, h10, u, i);
  }
  _computeTitleHeight() {
    const e = this.options.title, n = Qt(e.font), i = xn(e.padding);
    return e.display ? n.lineHeight + i.height : 0;
  }
  _getLegendItemAt(e, n) {
    let i, s, r;
    if (ps(e, this.left, this.right) && ps(n, this.top, this.bottom)) {
      for (r = this.legendHitBoxes, i = 0; i < r.length; ++i)
        if (s = r[i], ps(e, s.left, s.left + s.width) && ps(n, s.top, s.top + s.height))
          return this.legendItems[i];
    }
    return null;
  }
  handleEvent(e) {
    const n = this.options;
    if (!rG(e.type, n))
      return;
    const i = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const s = this._hoveredItem, r = tG(s, i);
      s && !r && pt(n.onLeave, [
        e,
        s,
        this
      ], this), this._hoveredItem = i, i && !r && pt(n.onHover, [
        e,
        i,
        this
      ], this);
    } else i && pt(n.onClick, [
      e,
      i,
      this
    ], this);
  }
};
function nG(t10, e, n, i, s) {
  const r = iG(i, t10, e, n), o = sG(s, i, e.lineHeight);
  return {
    itemWidth: r,
    itemHeight: o
  };
}
function iG(t10, e, n, i) {
  let s = t10.text;
  return s && typeof s != "string" && (s = s.reduce((r, o) => r.length > o.length ? r : o)), e + n.size / 2 + i.measureText(s).width;
}
function sG(t10, e, n) {
  let i = t10;
  return typeof e.text != "string" && (i = R4(e, n)), i;
}
function R4(t10, e) {
  const n = t10.text ? t10.text.length : 0;
  return e * n;
}
function rG(t10, e) {
  return !!((t10 === "mousemove" || t10 === "mouseout") && (e.onHover || e.onLeave) || e.onClick && (t10 === "click" || t10 === "mouseup"));
}
var zd = {
  id: "legend",
  _element: Qy,
  start(t10, e, n) {
    const i = t10.legend = new Qy({
      ctx: t10.ctx,
      options: n,
      chart: t10
    });
    zs.configure(t10, i, n), zs.addBox(t10, i);
  },
  stop(t10) {
    zs.removeBox(t10, t10.legend), delete t10.legend;
  },
  beforeUpdate(t10, e, n) {
    const i = t10.legend;
    zs.configure(t10, i, n), i.options = n;
  },
  afterUpdate(t10) {
    const e = t10.legend;
    e.buildLabels(), e.adjustHitBoxes();
  },
  afterEvent(t10, e) {
    e.replay || t10.legend.handleEvent(e.event);
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(t10, e, n) {
      const i = e.datasetIndex, s = n.chart;
      s.isDatasetVisible(i) ? (s.hide(i), e.hidden = true) : (s.show(i), e.hidden = false);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (t10) => t10.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(t10) {
        const e = t10.data.datasets, { labels: { usePointStyle: n, pointStyle: i, textAlign: s, color: r, useBorderRadius: o, borderRadius: a } } = t10.legend.options;
        return t10._getSortedDatasetMetas().map((l) => {
          const c = l.controller.getStyle(n ? 0 : void 0), u = xn(c.borderWidth);
          return {
            text: e[l.index].label,
            fillStyle: c.backgroundColor,
            fontColor: r,
            hidden: !l.visible,
            lineCap: c.borderCapStyle,
            lineDash: c.borderDash,
            lineDashOffset: c.borderDashOffset,
            lineJoin: c.borderJoinStyle,
            lineWidth: (u.width + u.height) / 4,
            strokeStyle: c.borderColor,
            pointStyle: i || c.pointStyle,
            rotation: c.rotation,
            textAlign: s || c.textAlign,
            borderRadius: o && (a || c.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (t10) => t10.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (t10) => !t10.startsWith("on"),
    labels: {
      _scriptable: (t10) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(t10)
    }
  }
};
var Ea = {
  average(t10) {
    if (!t10.length)
      return false;
    let e, n, i = /* @__PURE__ */ new Set(), s = 0, r = 0;
    for (e = 0, n = t10.length; e < n; ++e) {
      const a = t10[e].element;
      if (a && a.hasValue()) {
        const l = a.tooltipPosition();
        i.add(l.x), s += l.y, ++r;
      }
    }
    return r === 0 || i.size === 0 ? false : {
      x: [
        ...i
      ].reduce((a, l) => a + l) / i.size,
      y: s / r
    };
  },
  nearest(t10, e) {
    if (!t10.length)
      return false;
    let n = e.x, i = e.y, s = Number.POSITIVE_INFINITY, r, o, a;
    for (r = 0, o = t10.length; r < o; ++r) {
      const l = t10[r].element;
      if (l && l.hasValue()) {
        const c = l.getCenterPoint(), u = rp(e, c);
        u < s && (s = u, a = l);
      }
    }
    if (a) {
      const l = a.tooltipPosition();
      n = l.x, i = l.y;
    }
    return {
      x: n,
      y: i
    };
  }
};
function Oi(t10, e) {
  return e && (wt(e) ? Array.prototype.push.apply(t10, e) : t10.push(e)), t10;
}
function rs(t10) {
  return (typeof t10 == "string" || t10 instanceof String) && t10.indexOf(`
`) > -1 ? t10.split(`
`) : t10;
}
function oG(t10, e) {
  const { element: n, datasetIndex: i, index: s } = e, r = t10.getDatasetMeta(i).controller, { label: o, value: a } = r.getLabelAndValue(s);
  return {
    chart: t10,
    label: o,
    parsed: r.getParsed(s),
    raw: t10.data.datasets[i].data[s],
    formattedValue: a,
    dataset: r.getDataset(),
    dataIndex: s,
    datasetIndex: i,
    element: n
  };
}
function Zy(t10, e) {
  const n = t10.chart.ctx, { body: i, footer: s, title: r } = t10, { boxWidth: o, boxHeight: a } = e, l = Qt(e.bodyFont), c = Qt(e.titleFont), u = Qt(e.footerFont), d = r.length, f = s.length, h10 = i.length, p = xn(e.padding);
  let g = p.height, m = 0, b = i.reduce((v, S) => v + S.before.length + S.lines.length + S.after.length, 0);
  if (b += t10.beforeBody.length + t10.afterBody.length, d && (g += d * c.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), b) {
    const v = e.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
    g += h10 * v + (b - h10) * l.lineHeight + (b - 1) * e.bodySpacing;
  }
  f && (g += e.footerMarginTop + f * u.lineHeight + (f - 1) * e.footerSpacing);
  let x = 0;
  const k = function(v) {
    m = Math.max(m, n.measureText(v).width + x);
  };
  return n.save(), n.font = c.string, ot(t10.title, k), n.font = l.string, ot(t10.beforeBody.concat(t10.afterBody), k), x = e.displayColors ? o + 2 + e.boxPadding : 0, ot(i, (v) => {
    ot(v.before, k), ot(v.lines, k), ot(v.after, k);
  }), x = 0, n.font = u.string, ot(t10.footer, k), n.restore(), m += p.width, {
    width: m,
    height: g
  };
}
function aG(t10, e) {
  const { y: n, height: i } = e;
  return n < i / 2 ? "top" : n > t10.height - i / 2 ? "bottom" : "center";
}
function lG(t10, e, n, i) {
  const { x: s, width: r } = i, o = n.caretSize + n.caretPadding;
  if (t10 === "left" && s + r + o > e.width || t10 === "right" && s - r - o < 0)
    return true;
}
function cG(t10, e, n, i) {
  const { x: s, width: r } = n, { width: o, chartArea: { left: a, right: l } } = t10;
  let c = "center";
  return i === "center" ? c = s <= (a + l) / 2 ? "left" : "right" : s <= r / 2 ? c = "left" : s >= o - r / 2 && (c = "right"), lG(c, t10, e, n) && (c = "center"), c;
}
function e1(t10, e, n) {
  const i = n.yAlign || e.yAlign || aG(t10, n);
  return {
    xAlign: n.xAlign || e.xAlign || cG(t10, e, n, i),
    yAlign: i
  };
}
function uG(t10, e) {
  let { x: n, width: i } = t10;
  return e === "right" ? n -= i : e === "center" && (n -= i / 2), n;
}
function dG(t10, e, n) {
  let { y: i, height: s } = t10;
  return e === "top" ? i += n : e === "bottom" ? i -= s + n : i -= s / 2, i;
}
function t1(t10, e, n, i) {
  const { caretSize: s, caretPadding: r, cornerRadius: o } = t10, { xAlign: a, yAlign: l } = n, c = s + r, { topLeft: u, topRight: d, bottomLeft: f, bottomRight: h10 } = zr(o);
  let p = uG(e, a);
  const g = dG(e, l, c);
  return l === "center" ? a === "left" ? p += c : a === "right" && (p -= c) : a === "left" ? p -= Math.max(u, f) + s : a === "right" && (p += Math.max(d, h10) + s), {
    x: sn(p, 0, i.width - e.width),
    y: sn(g, 0, i.height - e.height)
  };
}
function mc(t10, e, n) {
  const i = xn(n.padding);
  return e === "center" ? t10.x + t10.width / 2 : e === "right" ? t10.x + t10.width - i.right : t10.x + i.left;
}
function n1(t10) {
  return Oi([], rs(t10));
}
function fG(t10, e, n) {
  return ur(t10, {
    tooltip: e,
    tooltipItems: n,
    type: "tooltip"
  });
}
function i1(t10, e) {
  const n = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
  return n ? t10.override(n) : t10;
}
var F4 = {
  beforeTitle: es,
  title(t10) {
    if (t10.length > 0) {
      const e = t10[0], n = e.chart.data.labels, i = n ? n.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return e.dataset.label || "";
      if (e.label)
        return e.label;
      if (i > 0 && e.dataIndex < i)
        return n[e.dataIndex];
    }
    return "";
  },
  afterTitle: es,
  beforeBody: es,
  beforeLabel: es,
  label(t10) {
    if (this && this.options && this.options.mode === "dataset")
      return t10.label + ": " + t10.formattedValue || t10.formattedValue;
    let e = t10.dataset.label || "";
    e && (e += ": ");
    const n = t10.formattedValue;
    return et(n) || (e += n), e;
  },
  labelColor(t10) {
    const n = t10.chart.getDatasetMeta(t10.datasetIndex).controller.getStyle(t10.dataIndex);
    return {
      borderColor: n.borderColor,
      backgroundColor: n.backgroundColor,
      borderWidth: n.borderWidth,
      borderDash: n.borderDash,
      borderDashOffset: n.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(t10) {
    const n = t10.chart.getDatasetMeta(t10.datasetIndex).controller.getStyle(t10.dataIndex);
    return {
      pointStyle: n.pointStyle,
      rotation: n.rotation
    };
  },
  afterLabel: es,
  afterBody: es,
  beforeFooter: es,
  footer: es,
  afterFooter: es
};
function wn(t10, e, n, i) {
  const s = t10[e].call(n, i);
  return typeof s > "u" ? F4[e].call(n, i) : s;
}
var fp = class extends dr {
  constructor(e) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(e) {
    this.options = e, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const e = this._cachedAnimations;
    if (e)
      return e;
    const n = this.chart, i = this.options.setContext(this.getContext()), s = i.enabled && n.options.animation && i.animations, r = new x4(this.chart, s);
    return s._cacheable && (this._cachedAnimations = Object.freeze(r)), r;
  }
  getContext() {
    return this.$context || (this.$context = fG(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(e, n) {
    const { callbacks: i } = n, s = wn(i, "beforeTitle", this, e), r = wn(i, "title", this, e), o = wn(i, "afterTitle", this, e);
    let a = [];
    return a = Oi(a, rs(s)), a = Oi(a, rs(r)), a = Oi(a, rs(o)), a;
  }
  getBeforeBody(e, n) {
    return n1(wn(n.callbacks, "beforeBody", this, e));
  }
  getBody(e, n) {
    const { callbacks: i } = n, s = [];
    return ot(e, (r) => {
      const o = {
        before: [],
        lines: [],
        after: []
      }, a = i1(i, r);
      Oi(o.before, rs(wn(a, "beforeLabel", this, r))), Oi(o.lines, wn(a, "label", this, r)), Oi(o.after, rs(wn(a, "afterLabel", this, r))), s.push(o);
    }), s;
  }
  getAfterBody(e, n) {
    return n1(wn(n.callbacks, "afterBody", this, e));
  }
  getFooter(e, n) {
    const { callbacks: i } = n, s = wn(i, "beforeFooter", this, e), r = wn(i, "footer", this, e), o = wn(i, "afterFooter", this, e);
    let a = [];
    return a = Oi(a, rs(s)), a = Oi(a, rs(r)), a = Oi(a, rs(o)), a;
  }
  _createItems(e) {
    const n = this._active, i = this.chart.data, s = [], r = [], o = [];
    let a = [], l, c;
    for (l = 0, c = n.length; l < c; ++l)
      a.push(oG(this.chart, n[l]));
    return e.filter && (a = a.filter((u, d, f) => e.filter(u, d, f, i))), e.itemSort && (a = a.sort((u, d) => e.itemSort(u, d, i))), ot(a, (u) => {
      const d = i1(e.callbacks, u);
      s.push(wn(d, "labelColor", this, u)), r.push(wn(d, "labelPointStyle", this, u)), o.push(wn(d, "labelTextColor", this, u));
    }), this.labelColors = s, this.labelPointStyles = r, this.labelTextColors = o, this.dataPoints = a, a;
  }
  update(e, n) {
    const i = this.options.setContext(this.getContext()), s = this._active;
    let r, o = [];
    if (!s.length)
      this.opacity !== 0 && (r = {
        opacity: 0
      });
    else {
      const a = Ea[i.position].call(this, s, this._eventPosition);
      o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);
      const l = this._size = Zy(this, i), c = Object.assign({}, a, l), u = e1(this.chart, i, c), d = t1(i, c, u, this.chart);
      this.xAlign = u.xAlign, this.yAlign = u.yAlign, r = {
        opacity: 1,
        x: d.x,
        y: d.y,
        width: l.width,
        height: l.height,
        caretX: a.x,
        caretY: a.y
      };
    }
    this._tooltipItems = o, this.$context = void 0, r && this._resolveAnimations().update(this, r), e && i.external && i.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: n
    });
  }
  drawCaret(e, n, i, s) {
    const r = this.getCaretPosition(e, i, s);
    n.lineTo(r.x1, r.y1), n.lineTo(r.x2, r.y2), n.lineTo(r.x3, r.y3);
  }
  getCaretPosition(e, n, i) {
    const { xAlign: s, yAlign: r } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: l, topRight: c, bottomLeft: u, bottomRight: d } = zr(a), { x: f, y: h10 } = e, { width: p, height: g } = n;
    let m, b, x, k, v, S;
    return r === "center" ? (v = h10 + g / 2, s === "left" ? (m = f, b = m - o, k = v + o, S = v - o) : (m = f + p, b = m + o, k = v - o, S = v + o), x = m) : (s === "left" ? b = f + Math.max(l, u) + o : s === "right" ? b = f + p - Math.max(c, d) - o : b = this.caretX, r === "top" ? (k = h10, v = k - o, m = b - o, x = b + o) : (k = h10 + g, v = k + o, m = b + o, x = b - o), S = k), {
      x1: m,
      x2: b,
      x3: x,
      y1: k,
      y2: v,
      y3: S
    };
  }
  drawTitle(e, n, i) {
    const s = this.title, r = s.length;
    let o, a, l;
    if (r) {
      const c = Mo(i.rtl, this.x, this.width);
      for (e.x = mc(this, i.titleAlign, i), n.textAlign = c.textAlign(i.titleAlign), n.textBaseline = "middle", o = Qt(i.titleFont), a = i.titleSpacing, n.fillStyle = i.titleColor, n.font = o.string, l = 0; l < r; ++l)
        n.fillText(s[l], c.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + a, l + 1 === r && (e.y += i.titleMarginBottom - a);
    }
  }
  _drawColorBox(e, n, i, s, r) {
    const o = this.labelColors[i], a = this.labelPointStyles[i], { boxHeight: l, boxWidth: c } = r, u = Qt(r.bodyFont), d = mc(this, "left", r), f = s.x(d), h10 = l < u.lineHeight ? (u.lineHeight - l) / 2 : 0, p = n.y + h10;
    if (r.usePointStyle) {
      const g = {
        radius: Math.min(c, l) / 2,
        pointStyle: a.pointStyle,
        rotation: a.rotation,
        borderWidth: 1
      }, m = s.leftForLtr(f, c) + c / 2, b = p + l / 2;
      e.strokeStyle = r.multiKeyBackground, e.fillStyle = r.multiKeyBackground, ap(e, g, m, b), e.strokeStyle = o.borderColor, e.fillStyle = o.backgroundColor, ap(e, g, m, b);
    } else {
      e.lineWidth = Je(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, e.strokeStyle = o.borderColor, e.setLineDash(o.borderDash || []), e.lineDashOffset = o.borderDashOffset || 0;
      const g = s.leftForLtr(f, c), m = s.leftForLtr(s.xPlus(f, 1), c - 2), b = zr(o.borderRadius);
      Object.values(b).some((x) => x !== 0) ? (e.beginPath(), e.fillStyle = r.multiKeyBackground, Sl(e, {
        x: g,
        y: p,
        w: c,
        h: l,
        radius: b
      }), e.fill(), e.stroke(), e.fillStyle = o.backgroundColor, e.beginPath(), Sl(e, {
        x: m,
        y: p + 1,
        w: c - 2,
        h: l - 2,
        radius: b
      }), e.fill()) : (e.fillStyle = r.multiKeyBackground, e.fillRect(g, p, c, l), e.strokeRect(g, p, c, l), e.fillStyle = o.backgroundColor, e.fillRect(m, p + 1, c - 2, l - 2));
    }
    e.fillStyle = this.labelTextColors[i];
  }
  drawBody(e, n, i) {
    const { body: s } = this, { bodySpacing: r, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: u } = i, d = Qt(i.bodyFont);
    let f = d.lineHeight, h10 = 0;
    const p = Mo(i.rtl, this.x, this.width), g = function(M) {
      n.fillText(M, p.x(e.x + h10), e.y + f / 2), e.y += f + r;
    }, m = p.textAlign(o);
    let b, x, k, v, S, w, E;
    for (n.textAlign = o, n.textBaseline = "middle", n.font = d.string, e.x = mc(this, m, i), n.fillStyle = i.bodyColor, ot(this.beforeBody, g), h10 = a && m !== "right" ? o === "center" ? c / 2 + u : c + 2 + u : 0, v = 0, w = s.length; v < w; ++v) {
      for (b = s[v], x = this.labelTextColors[v], n.fillStyle = x, ot(b.before, g), k = b.lines, a && k.length && (this._drawColorBox(n, e, v, p, i), f = Math.max(d.lineHeight, l)), S = 0, E = k.length; S < E; ++S)
        g(k[S]), f = d.lineHeight;
      ot(b.after, g);
    }
    h10 = 0, f = d.lineHeight, ot(this.afterBody, g), e.y -= r;
  }
  drawFooter(e, n, i) {
    const s = this.footer, r = s.length;
    let o, a;
    if (r) {
      const l = Mo(i.rtl, this.x, this.width);
      for (e.x = mc(this, i.footerAlign, i), e.y += i.footerMarginTop, n.textAlign = l.textAlign(i.footerAlign), n.textBaseline = "middle", o = Qt(i.footerFont), n.fillStyle = i.footerColor, n.font = o.string, a = 0; a < r; ++a)
        n.fillText(s[a], l.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + i.footerSpacing;
    }
  }
  drawBackground(e, n, i, s) {
    const { xAlign: r, yAlign: o } = this, { x: a, y: l } = e, { width: c, height: u } = i, { topLeft: d, topRight: f, bottomLeft: h10, bottomRight: p } = zr(s.cornerRadius);
    n.fillStyle = s.backgroundColor, n.strokeStyle = s.borderColor, n.lineWidth = s.borderWidth, n.beginPath(), n.moveTo(a + d, l), o === "top" && this.drawCaret(e, n, i, s), n.lineTo(a + c - f, l), n.quadraticCurveTo(a + c, l, a + c, l + f), o === "center" && r === "right" && this.drawCaret(e, n, i, s), n.lineTo(a + c, l + u - p), n.quadraticCurveTo(a + c, l + u, a + c - p, l + u), o === "bottom" && this.drawCaret(e, n, i, s), n.lineTo(a + h10, l + u), n.quadraticCurveTo(a, l + u, a, l + u - h10), o === "center" && r === "left" && this.drawCaret(e, n, i, s), n.lineTo(a, l + d), n.quadraticCurveTo(a, l, a + d, l), n.closePath(), n.fill(), s.borderWidth > 0 && n.stroke();
  }
  _updateAnimationTarget(e) {
    const n = this.chart, i = this.$animations, s = i && i.x, r = i && i.y;
    if (s || r) {
      const o = Ea[e.position].call(this, this._active, this._eventPosition);
      if (!o)
        return;
      const a = this._size = Zy(this, e), l = Object.assign({}, o, this._size), c = e1(n, e, l), u = t1(e, l, c, n);
      (s._to !== u.x || r._to !== u.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, u));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(e) {
    const n = this.options.setContext(this.getContext());
    let i = this.opacity;
    if (!i)
      return;
    this._updateAnimationTarget(n);
    const s = {
      width: this.width,
      height: this.height
    }, r = {
      x: this.x,
      y: this.y
    };
    i = Math.abs(i) < 1e-3 ? 0 : i;
    const o = xn(n.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    n.enabled && a && (e.save(), e.globalAlpha = i, this.drawBackground(r, e, s, n), m4(e, n.textDirection), r.y += o.top, this.drawTitle(r, e, n), this.drawBody(r, e, n), this.drawFooter(r, e, n), g4(e, n.textDirection), e.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(e, n) {
    const i = this._active, s = e.map(({ datasetIndex: a, index: l }) => {
      const c = this.chart.getDatasetMeta(a);
      if (!c)
        throw new Error("Cannot find a dataset at index " + a);
      return {
        datasetIndex: a,
        element: c.data[l],
        index: l
      };
    }), r = !Vu(i, s), o = this._positionChanged(s, n);
    (r || o) && (this._active = s, this._eventPosition = n, this._ignoreReplayEvents = true, this.update(true));
  }
  handleEvent(e, n, i = true) {
    if (n && this._ignoreReplayEvents)
      return false;
    this._ignoreReplayEvents = false;
    const s = this.options, r = this._active || [], o = this._getActiveElements(e, r, n, i), a = this._positionChanged(o, e), l = n || !Vu(o, r) || a;
    return l && (this._active = o, (s.enabled || s.external) && (this._eventPosition = {
      x: e.x,
      y: e.y
    }, this.update(true, n))), l;
  }
  _getActiveElements(e, n, i, s) {
    const r = this.options;
    if (e.type === "mouseout")
      return [];
    if (!s)
      return n.filter((a) => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0);
    const o = this.chart.getElementsAtEventForMode(e, r.mode, r, i);
    return r.reverse && o.reverse(), o;
  }
  _positionChanged(e, n) {
    const { caretX: i, caretY: s, options: r } = this, o = Ea[r.position].call(this, e, n);
    return o !== false && (i !== o.x || s !== o.y);
  }
};
ve(fp, "positioners", Ea);
var jd = {
  id: "tooltip",
  _element: fp,
  positioners: Ea,
  afterInit(t10, e, n) {
    n && (t10.tooltip = new fp({
      chart: t10,
      options: n
    }));
  },
  beforeUpdate(t10, e, n) {
    t10.tooltip && t10.tooltip.initialize(n);
  },
  reset(t10, e, n) {
    t10.tooltip && t10.tooltip.initialize(n);
  },
  afterDraw(t10) {
    const e = t10.tooltip;
    if (e && e._willRender()) {
      const n = {
        tooltip: e
      };
      if (t10.notifyPlugins("beforeTooltipDraw", {
        ...n,
        cancelable: true
      }) === false)
        return;
      e.draw(t10.ctx), t10.notifyPlugins("afterTooltipDraw", n);
    }
  },
  afterEvent(t10, e) {
    if (t10.tooltip) {
      const n = e.replay;
      t10.tooltip.handleEvent(e.event, n, e.inChartArea) && (e.changed = true);
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (t10, e) => e.bodyFont.size,
    boxWidth: (t10, e) => e.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: F4
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (t10) => t10 !== "filter" && t10 !== "itemSort" && t10 !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var hG = (t10, e, n, i) => (typeof e == "string" ? (n = t10.push(e) - 1, i.unshift({
  index: n,
  label: e
})) : isNaN(e) && (n = null), n);
function pG(t10, e, n, i) {
  const s = t10.indexOf(e);
  if (s === -1)
    return hG(t10, e, n, i);
  const r = t10.lastIndexOf(e);
  return s !== r ? n : s;
}
var mG = (t10, e) => t10 === null ? null : sn(Math.round(t10), 0, e);
function s1(t10) {
  const e = this.getLabels();
  return t10 >= 0 && t10 < e.length ? e[t10] : t10;
}
var qu = class extends Zo {
  constructor(e) {
    super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(e) {
    const n = this._addedLabels;
    if (n.length) {
      const i = this.getLabels();
      for (const { index: s, label: r } of n)
        i[s] === r && i.splice(s, 1);
      this._addedLabels = [];
    }
    super.init(e);
  }
  parse(e, n) {
    if (et(e))
      return null;
    const i = this.getLabels();
    return n = isFinite(n) && i[n] === e ? n : pG(i, e, Ke(n, e), this._addedLabels), mG(n, i.length - 1);
  }
  determineDataLimits() {
    const { minDefined: e, maxDefined: n } = this.getUserBounds();
    let { min: i, max: s } = this.getMinMax(true);
    this.options.bounds === "ticks" && (e || (i = 0), n || (s = this.getLabels().length - 1)), this.min = i, this.max = s;
  }
  buildTicks() {
    const e = this.min, n = this.max, i = this.options.offset, s = [];
    let r = this.getLabels();
    r = e === 0 && n === r.length - 1 ? r : r.slice(e, n + 1), this._valueRange = Math.max(r.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? 0.5 : 0);
    for (let o = e; o <= n; o++)
      s.push({
        value: o
      });
    return s;
  }
  getLabelForValue(e) {
    return s1.call(this, e);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(e) {
    return typeof e != "number" && (e = this.parse(e)), e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getPixelForTick(e) {
    const n = this.ticks;
    return e < 0 || e > n.length - 1 ? null : this.getPixelForValue(n[e].value);
  }
  getValueForPixel(e) {
    return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
ve(qu, "id", "category"), ve(qu, "defaults", {
  ticks: {
    callback: s1
  }
});
function gG(t10, e) {
  const n = [], { bounds: s, step: r, min: o, max: a, precision: l, count: c, maxTicks: u, maxDigits: d, includeBounds: f } = t10, h10 = r || 1, p = u - 1, { min: g, max: m } = e, b = !et(o), x = !et(a), k = !et(c), v = (m - g) / (d + 1);
  let S = ny((m - g) / p / h10) * h10, w, E, M, N;
  if (S < 1e-14 && !b && !x)
    return [
      {
        value: g
      },
      {
        value: m
      }
    ];
  N = Math.ceil(m / S) - Math.floor(g / S), N > p && (S = ny(N * S / p / h10) * h10), et(l) || (w = Math.pow(10, l), S = Math.ceil(S * w) / w), s === "ticks" ? (E = Math.floor(g / S) * S, M = Math.ceil(m / S) * S) : (E = g, M = m), b && x && r && wU((a - o) / r, S / 1e3) ? (N = Math.round(Math.min((a - o) / S, u)), S = (a - o) / N, E = o, M = a) : k ? (E = b ? o : E, M = x ? a : M, N = c - 1, S = (M - E) / N) : (N = (M - E) / S, Ya(N, Math.round(N), S / 1e3) ? N = Math.round(N) : N = Math.ceil(N));
  const V = Math.max(iy(S), iy(E));
  w = Math.pow(10, et(l) ? V : l), E = Math.round(E * w) / w, M = Math.round(M * w) / w;
  let Y = 0;
  for (b && (f && E !== o ? (n.push({
    value: o
  }), E < o && Y++, Ya(Math.round((E + Y * S) * w) / w, o, r1(o, v, t10)) && Y++) : E < o && Y++); Y < N; ++Y) {
    const F = Math.round((E + Y * S) * w) / w;
    if (x && F > a)
      break;
    n.push({
      value: F
    });
  }
  return x && f && M !== a ? n.length && Ya(n[n.length - 1].value, a, r1(a, v, t10)) ? n[n.length - 1].value = a : n.push({
    value: a
  }) : (!x || M === a) && n.push({
    value: M
  }), n;
}
function r1(t10, e, { horizontal: n, minRotation: i }) {
  const s = $i(i), r = (n ? Math.sin(s) : Math.cos(s)) || 1e-3, o = 0.75 * e * ("" + t10).length;
  return Math.min(e / r, o);
}
var hp = class extends Zo {
  constructor(e) {
    super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(e, n) {
    return et(e) || (typeof e == "number" || e instanceof Number) && !isFinite(+e) ? null : +e;
  }
  handleTickRangeOptions() {
    const { beginAtZero: e } = this.options, { minDefined: n, maxDefined: i } = this.getUserBounds();
    let { min: s, max: r } = this;
    const o = (l) => s = n ? s : l, a = (l) => r = i ? r : l;
    if (e) {
      const l = ji(s), c = ji(r);
      l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && o(0);
    }
    if (s === r) {
      let l = r === 0 ? 1 : Math.abs(r * 0.05);
      a(r + l), e || o(s - l);
    }
    this.min = s, this.max = r;
  }
  getTickLimit() {
    const e = this.options.ticks;
    let { maxTicksLimit: n, stepSize: i } = e, s;
    return i ? (s = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, s > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${s} ticks. Limiting to 1000.`), s = 1e3)) : (s = this.computeTickLimit(), n = n || 11), n && (s = Math.min(n, s)), s;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const e = this.options, n = e.ticks;
    let i = this.getTickLimit();
    i = Math.max(2, i);
    const s = {
      maxTicks: i,
      bounds: e.bounds,
      min: e.min,
      max: e.max,
      precision: n.precision,
      step: n.stepSize,
      count: n.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: n.minRotation || 0,
      includeBounds: n.includeBounds !== false
    }, r = this._range || this, o = gG(s, r);
    return e.bounds === "ticks" && CU(o, this, "value"), e.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o;
  }
  configure() {
    const e = this.ticks;
    let n = this.min, i = this.max;
    if (super.configure(), this.options.offset && e.length) {
      const s = (i - n) / Math.max(e.length - 1, 1) / 2;
      n -= s, i += s;
    }
    this._startValue = n, this._endValue = i, this._valueRange = i - n;
  }
  getLabelForValue(e) {
    return Gm(e, this.chart.options.locale, this.options.ticks.format);
  }
};
var Ku = class extends hp {
  determineDataLimits() {
    const { min: e, max: n } = this.getMinMax(true);
    this.min = Yt(e) ? e : 0, this.max = Yt(n) ? n : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const e = this.isHorizontal(), n = e ? this.width : this.height, i = $i(this.options.ticks.minRotation), s = (e ? Math.sin(i) : Math.cos(i)) || 1e-3, r = this._resolveTickFontOptions(0);
    return Math.ceil(n / Math.min(40, r.lineHeight / s));
  }
  getPixelForValue(e) {
    return e === null ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange);
  }
  getValueForPixel(e) {
    return this._startValue + this.getDecimalForPixel(e) * this._valueRange;
  }
};
ve(Ku, "id", "linear"), ve(Ku, "defaults", {
  ticks: {
    callback: Jm.formatters.numeric
  }
});
function pp(t10) {
  const e = t10.ticks;
  if (e.display && t10.display) {
    const n = xn(e.backdropPadding);
    return Ke(e.font && e.font.size, At.font.size) + n.height;
  }
  return 0;
}
function bG(t10, e, n) {
  return n = wt(n) ? n : [
    n
  ], {
    w: WU(t10, e.string, n),
    h: n.length * e.lineHeight
  };
}
function o1(t10, e, n, i, s) {
  return t10 === i || t10 === s ? {
    start: e - n / 2,
    end: e + n / 2
  } : t10 < i || t10 > s ? {
    start: e - n,
    end: e
  } : {
    start: e,
    end: e + n
  };
}
function yG(t10) {
  const e = {
    l: t10.left + t10._padding.left,
    r: t10.right - t10._padding.right,
    t: t10.top + t10._padding.top,
    b: t10.bottom - t10._padding.bottom
  }, n = Object.assign({}, e), i = [], s = [], r = t10._pointLabels.length, o = t10.options.pointLabels, a = o.centerPointLabels ? _t / r : 0;
  for (let l = 0; l < r; l++) {
    const c = o.setContext(t10.getPointLabelContext(l));
    s[l] = c.padding;
    const u = t10.getPointPosition(l, t10.drawingArea + s[l], a), d = Qt(c.font), f = bG(t10.ctx, d, t10._pointLabels[l]);
    i[l] = f;
    const h10 = zn(t10.getIndexAngle(l) + a), p = Math.round(qm(h10)), g = o1(p, u.x, f.w, 0, 180), m = o1(p, u.y, f.h, 90, 270);
    vG(n, e, h10, g, m);
  }
  t10.setCenterPoint(e.l - n.l, n.r - e.r, e.t - n.t, n.b - e.b), t10._pointLabelItems = SG(t10, i, s);
}
function vG(t10, e, n, i, s) {
  const r = Math.abs(Math.sin(n)), o = Math.abs(Math.cos(n));
  let a = 0, l = 0;
  i.start < e.l ? (a = (e.l - i.start) / r, t10.l = Math.min(t10.l, e.l - a)) : i.end > e.r && (a = (i.end - e.r) / r, t10.r = Math.max(t10.r, e.r + a)), s.start < e.t ? (l = (e.t - s.start) / o, t10.t = Math.min(t10.t, e.t - l)) : s.end > e.b && (l = (s.end - e.b) / o, t10.b = Math.max(t10.b, e.b + l));
}
function xG(t10, e, n) {
  const i = t10.drawingArea, { extra: s, additionalAngle: r, padding: o, size: a } = n, l = t10.getPointPosition(e, i + s + o, r), c = Math.round(qm(zn(l.angle + Lt))), u = OG(l.y, a.h, c), d = wG(c), f = CG(l.x, a.w, d);
  return {
    visible: true,
    x: l.x,
    y: u,
    textAlign: d,
    left: f,
    top: u,
    right: f + a.w,
    bottom: u + a.h
  };
}
function kG(t10, e) {
  if (!e)
    return true;
  const { left: n, top: i, right: s, bottom: r } = t10;
  return !(ms({
    x: n,
    y: i
  }, e) || ms({
    x: n,
    y: r
  }, e) || ms({
    x: s,
    y: i
  }, e) || ms({
    x: s,
    y: r
  }, e));
}
function SG(t10, e, n) {
  const i = [], s = t10._pointLabels.length, r = t10.options, { centerPointLabels: o, display: a } = r.pointLabels, l = {
    extra: pp(r) / 2,
    additionalAngle: o ? _t / s : 0
  };
  let c;
  for (let u = 0; u < s; u++) {
    l.padding = n[u], l.size = e[u];
    const d = xG(t10, u, l);
    i.push(d), a === "auto" && (d.visible = kG(d, c), d.visible && (c = d));
  }
  return i;
}
function wG(t10) {
  return t10 === 0 || t10 === 180 ? "center" : t10 < 180 ? "left" : "right";
}
function CG(t10, e, n) {
  return n === "right" ? t10 -= e : n === "center" && (t10 -= e / 2), t10;
}
function OG(t10, e, n) {
  return n === 90 || n === 270 ? t10 -= e / 2 : (n > 270 || n < 90) && (t10 -= e), t10;
}
function EG(t10, e, n) {
  const { left: i, top: s, right: r, bottom: o } = n, { backdropColor: a } = e;
  if (!et(a)) {
    const l = zr(e.borderRadius), c = xn(e.backdropPadding);
    t10.fillStyle = a;
    const u = i - c.left, d = s - c.top, f = r - i + c.width, h10 = o - s + c.height;
    Object.values(l).some((p) => p !== 0) ? (t10.beginPath(), Sl(t10, {
      x: u,
      y: d,
      w: f,
      h: h10,
      radius: l
    }), t10.fill()) : t10.fillRect(u, d, f, h10);
  }
}
function MG(t10, e) {
  const { ctx: n, options: { pointLabels: i } } = t10;
  for (let s = e - 1; s >= 0; s--) {
    const r = t10._pointLabelItems[s];
    if (!r.visible)
      continue;
    const o = i.setContext(t10.getPointLabelContext(s));
    EG(n, o, r);
    const a = Qt(o.font), { x: l, y: c, textAlign: u } = r;
    Wo(n, t10._pointLabels[s], l, c + a.lineHeight / 2, a, {
      color: o.color,
      textAlign: u,
      textBaseline: "middle"
    });
  }
}
function V4(t10, e, n, i) {
  const { ctx: s } = t10;
  if (n)
    s.arc(t10.xCenter, t10.yCenter, e, 0, bt);
  else {
    let r = t10.getPointPosition(0, e);
    s.moveTo(r.x, r.y);
    for (let o = 1; o < i; o++)
      r = t10.getPointPosition(o, e), s.lineTo(r.x, r.y);
  }
}
function TG(t10, e, n, i, s) {
  const r = t10.ctx, o = e.circular, { color: a, lineWidth: l } = e;
  !o && !i || !a || !l || n < 0 || (r.save(), r.strokeStyle = a, r.lineWidth = l, r.setLineDash(s.dash || []), r.lineDashOffset = s.dashOffset, r.beginPath(), V4(t10, n, o, i), r.closePath(), r.stroke(), r.restore());
}
function AG(t10, e, n) {
  return ur(t10, {
    label: n,
    index: e,
    type: "pointLabel"
  });
}
var Ma = class extends hp {
  constructor(e) {
    super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const e = this._padding = xn(pp(this.options) / 2), n = this.width = this.maxWidth - e.width, i = this.height = this.maxHeight - e.height;
    this.xCenter = Math.floor(this.left + n / 2 + e.left), this.yCenter = Math.floor(this.top + i / 2 + e.top), this.drawingArea = Math.floor(Math.min(n, i) / 2);
  }
  determineDataLimits() {
    const { min: e, max: n } = this.getMinMax(false);
    this.min = Yt(e) && !isNaN(e) ? e : 0, this.max = Yt(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / pp(this.options));
  }
  generateTickLabels(e) {
    hp.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map((n, i) => {
      const s = pt(this.options.pointLabels.callback, [
        n,
        i
      ], this);
      return s || s === 0 ? s : "";
    }).filter((n, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const e = this.options;
    e.display && e.pointLabels.display ? yG(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(e, n, i, s) {
    this.xCenter += Math.floor((e - n) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, n, i, s));
  }
  getIndexAngle(e) {
    const n = bt / (this._pointLabels.length || 1), i = this.options.startAngle || 0;
    return zn(e * n + $i(i));
  }
  getDistanceFromCenterForValue(e) {
    if (et(e))
      return NaN;
    const n = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - e) * n : (e - this.min) * n;
  }
  getValueForDistanceFromCenter(e) {
    if (et(e))
      return NaN;
    const n = e / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - n : this.min + n;
  }
  getPointLabelContext(e) {
    const n = this._pointLabels || [];
    if (e >= 0 && e < n.length) {
      const i = n[e];
      return AG(this.getContext(), e, i);
    }
  }
  getPointPosition(e, n, i = 0) {
    const s = this.getIndexAngle(e) - Lt + i;
    return {
      x: Math.cos(s) * n + this.xCenter,
      y: Math.sin(s) * n + this.yCenter,
      angle: s
    };
  }
  getPointPositionForValue(e, n) {
    return this.getPointPosition(e, this.getDistanceFromCenterForValue(n));
  }
  getBasePosition(e) {
    return this.getPointPositionForValue(e || 0, this.getBaseValue());
  }
  getPointLabelPosition(e) {
    const { left: n, top: i, right: s, bottom: r } = this._pointLabelItems[e];
    return {
      left: n,
      top: i,
      right: s,
      bottom: r
    };
  }
  drawBackground() {
    const { backgroundColor: e, grid: { circular: n } } = this.options;
    if (e) {
      const i = this.ctx;
      i.save(), i.beginPath(), V4(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), i.closePath(), i.fillStyle = e, i.fill(), i.restore();
    }
  }
  drawGrid() {
    const e = this.ctx, n = this.options, { angleLines: i, grid: s, border: r } = n, o = this._pointLabels.length;
    let a, l, c;
    if (n.pointLabels.display && MG(this, o), s.display && this.ticks.forEach((u, d) => {
      if (d !== 0 || d === 0 && this.min < 0) {
        l = this.getDistanceFromCenterForValue(u.value);
        const f = this.getContext(d), h10 = s.setContext(f), p = r.setContext(f);
        TG(this, h10, l, o, p);
      }
    }), i.display) {
      for (e.save(), a = o - 1; a >= 0; a--) {
        const u = i.setContext(this.getPointLabelContext(a)), { color: d, lineWidth: f } = u;
        !f || !d || (e.lineWidth = f, e.strokeStyle = d, e.setLineDash(u.borderDash), e.lineDashOffset = u.borderDashOffset, l = this.getDistanceFromCenterForValue(n.reverse ? this.min : this.max), c = this.getPointPosition(a, l), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(c.x, c.y), e.stroke());
      }
      e.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const e = this.ctx, n = this.options, i = n.ticks;
    if (!i.display)
      return;
    const s = this.getIndexAngle(0);
    let r, o;
    e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(s), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach((a, l) => {
      if (l === 0 && this.min >= 0 && !n.reverse)
        return;
      const c = i.setContext(this.getContext(l)), u = Qt(c.font);
      if (r = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {
        e.font = u.string, o = e.measureText(a.label).width, e.fillStyle = c.backdropColor;
        const d = xn(c.backdropPadding);
        e.fillRect(-o / 2 - d.left, -r - u.size / 2 - d.top, o + d.width, u.size + d.height);
      }
      Wo(e, a.label, 0, -r, u, {
        color: c.color,
        strokeColor: c.textStrokeColor,
        strokeWidth: c.textStrokeWidth
      });
    }), e.restore();
  }
  drawTitle() {
  }
};
ve(Ma, "id", "radialLinear"), ve(Ma, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Jm.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(e) {
      return e;
    },
    padding: 5,
    centerPointLabels: false
  }
}), ve(Ma, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), ve(Ma, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var Hd = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var Nn = Object.keys(Hd);
function a1(t10, e) {
  return t10 - e;
}
function l1(t10, e) {
  if (et(e))
    return null;
  const n = t10._adapter, { parser: i, round: s, isoWeekday: r } = t10._parseOpts;
  let o = e;
  return typeof i == "function" && (o = i(o)), Yt(o) || (o = typeof i == "string" ? n.parse(o, i) : n.parse(o)), o === null ? null : (s && (o = s === "week" && (xl(r) || r === true) ? n.startOf(o, "isoWeek", r) : n.startOf(o, s)), +o);
}
function c1(t10, e, n, i) {
  const s = Nn.length;
  for (let r = Nn.indexOf(t10); r < s - 1; ++r) {
    const o = Hd[Nn[r]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER;
    if (o.common && Math.ceil((n - e) / (a * o.size)) <= i)
      return Nn[r];
  }
  return Nn[s - 1];
}
function _G(t10, e, n, i, s) {
  for (let r = Nn.length - 1; r >= Nn.indexOf(n); r--) {
    const o = Nn[r];
    if (Hd[o].common && t10._adapter.diff(s, i, o) >= e - 1)
      return o;
  }
  return Nn[n ? Nn.indexOf(n) : 0];
}
function NG(t10) {
  for (let e = Nn.indexOf(t10) + 1, n = Nn.length; e < n; ++e)
    if (Hd[Nn[e]].common)
      return Nn[e];
}
function u1(t10, e, n) {
  if (!n)
    t10[e] = true;
  else if (n.length) {
    const { lo: i, hi: s } = Km(n, e), r = n[i] >= e ? n[i] : n[s];
    t10[r] = true;
  }
}
function LG(t10, e, n, i) {
  const s = t10._adapter, r = +s.startOf(e[0].value, i), o = e[e.length - 1].value;
  let a, l;
  for (a = r; a <= o; a = +s.add(a, 1, i))
    l = n[a], l >= 0 && (e[l].major = true);
  return e;
}
function d1(t10, e, n) {
  const i = [], s = {}, r = e.length;
  let o, a;
  for (o = 0; o < r; ++o)
    a = e[o], s[a] = o, i.push({
      value: a,
      major: false
    });
  return r === 0 || !n ? i : LG(t10, i, s, n);
}
var Yu = class extends Zo {
  constructor(e) {
    super(e), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = false, this._parseOpts = void 0;
  }
  init(e, n = {}) {
    const i = e.time || (e.time = {}), s = this._adapter = new oK._date(e.adapters.date);
    s.init(n), Ka(i.displayFormats, s.formats()), this._parseOpts = {
      parser: i.parser,
      round: i.round,
      isoWeekday: i.isoWeekday
    }, super.init(e), this._normalized = n.normalized;
  }
  parse(e, n) {
    return e === void 0 ? null : l1(this, e);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const e = this.options, n = this._adapter, i = e.time.unit || "day";
    let { min: s, max: r, minDefined: o, maxDefined: a } = this.getUserBounds();
    function l(c) {
      !o && !isNaN(c.min) && (s = Math.min(s, c.min)), !a && !isNaN(c.max) && (r = Math.max(r, c.max));
    }
    (!o || !a) && (l(this._getLabelBounds()), (e.bounds !== "ticks" || e.ticks.source !== "labels") && l(this.getMinMax(false))), s = Yt(s) && !isNaN(s) ? s : +n.startOf(Date.now(), i), r = Yt(r) && !isNaN(r) ? r : +n.endOf(Date.now(), i) + 1, this.min = Math.min(s, r - 1), this.max = Math.max(s + 1, r);
  }
  _getLabelBounds() {
    const e = this.getLabelTimestamps();
    let n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
    return e.length && (n = e[0], i = e[e.length - 1]), {
      min: n,
      max: i
    };
  }
  buildTicks() {
    const e = this.options, n = e.time, i = e.ticks, s = i.source === "labels" ? this.getLabelTimestamps() : this._generate();
    e.bounds === "ticks" && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);
    const r = this.min, o = this.max, a = TU(s, r, o);
    return this._unit = n.unit || (i.autoSkip ? c1(n.minUnit, this.min, this.max, this._getLabelCapacity(r)) : _G(this, a.length, n.minUnit, this.min, this.max)), this._majorUnit = !i.major.enabled || this._unit === "year" ? void 0 : NG(this._unit), this.initOffsets(s), e.reverse && a.reverse(), d1(this, a, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e) => +e.value));
  }
  initOffsets(e = []) {
    let n = 0, i = 0, s, r;
    this.options.offset && e.length && (s = this.getDecimalForValue(e[0]), e.length === 1 ? n = 1 - s : n = (this.getDecimalForValue(e[1]) - s) / 2, r = this.getDecimalForValue(e[e.length - 1]), e.length === 1 ? i = r : i = (r - this.getDecimalForValue(e[e.length - 2])) / 2);
    const o = e.length < 3 ? 0.5 : 0.25;
    n = sn(n, 0, o), i = sn(i, 0, o), this._offsets = {
      start: n,
      end: i,
      factor: 1 / (n + 1 + i)
    };
  }
  _generate() {
    const e = this._adapter, n = this.min, i = this.max, s = this.options, r = s.time, o = r.unit || c1(r.minUnit, n, i, this._getLabelCapacity(n)), a = Ke(s.ticks.stepSize, 1), l = o === "week" ? r.isoWeekday : false, c = xl(l) || l === true, u = {};
    let d = n, f, h10;
    if (c && (d = +e.startOf(d, "isoWeek", l)), d = +e.startOf(d, c ? "day" : o), e.diff(i, n, o) > 1e5 * a)
      throw new Error(n + " and " + i + " are too far apart with stepSize of " + a + " " + o);
    const p = s.ticks.source === "data" && this.getDataTimestamps();
    for (f = d, h10 = 0; f < i; f = +e.add(f, a, o), h10++)
      u1(u, f, p);
    return (f === i || s.bounds === "ticks" || h10 === 1) && u1(u, f, p), Object.keys(u).sort(a1).map((g) => +g);
  }
  getLabelForValue(e) {
    const n = this._adapter, i = this.options.time;
    return i.tooltipFormat ? n.format(e, i.tooltipFormat) : n.format(e, i.displayFormats.datetime);
  }
  format(e, n) {
    const s = this.options.time.displayFormats, r = this._unit, o = n || s[r];
    return this._adapter.format(e, o);
  }
  _tickFormatFunction(e, n, i, s) {
    const r = this.options, o = r.ticks.callback;
    if (o)
      return pt(o, [
        e,
        n,
        i
      ], this);
    const a = r.time.displayFormats, l = this._unit, c = this._majorUnit, u = l && a[l], d = c && a[c], f = i[n], h10 = c && d && f && f.major;
    return this._adapter.format(e, s || (h10 ? d : u));
  }
  generateTickLabels(e) {
    let n, i, s;
    for (n = 0, i = e.length; n < i; ++n)
      s = e[n], s.label = this._tickFormatFunction(s.value, n, e);
  }
  getDecimalForValue(e) {
    return e === null ? NaN : (e - this.min) / (this.max - this.min);
  }
  getPixelForValue(e) {
    const n = this._offsets, i = this.getDecimalForValue(e);
    return this.getPixelForDecimal((n.start + i) * n.factor);
  }
  getValueForPixel(e) {
    const n = this._offsets, i = this.getDecimalForPixel(e) / n.factor - n.end;
    return this.min + i * (this.max - this.min);
  }
  _getLabelSize(e) {
    const n = this.options.ticks, i = this.ctx.measureText(e).width, s = $i(this.isHorizontal() ? n.maxRotation : n.minRotation), r = Math.cos(s), o = Math.sin(s), a = this._resolveTickFontOptions(0).size;
    return {
      w: i * r + a * o,
      h: i * o + a * r
    };
  }
  _getLabelCapacity(e) {
    const n = this.options.time, i = n.displayFormats, s = i[n.unit] || i.millisecond, r = this._tickFormatFunction(e, 0, d1(this, [
      e
    ], this._majorUnit), s), o = this._getLabelSize(r), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
    return a > 0 ? a : 1;
  }
  getDataTimestamps() {
    let e = this._cache.data || [], n, i;
    if (e.length)
      return e;
    const s = this.getMatchingVisibleMetas();
    if (this._normalized && s.length)
      return this._cache.data = s[0].controller.getAllParsedValues(this);
    for (n = 0, i = s.length; n < i; ++n)
      e = e.concat(s[n].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(e);
  }
  getLabelTimestamps() {
    const e = this._cache.labels || [];
    let n, i;
    if (e.length)
      return e;
    const s = this.getLabels();
    for (n = 0, i = s.length; n < i; ++n)
      e.push(l1(this, s[n]));
    return this._cache.labels = this._normalized ? e : this.normalize(e);
  }
  normalize(e) {
    return s4(e.sort(a1));
  }
};
ve(Yu, "id", "time"), ve(Yu, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function gc(t10, e, n) {
  let i = 0, s = t10.length - 1, r, o, a, l;
  n ? (e >= t10[i].pos && e <= t10[s].pos && ({ lo: i, hi: s } = Lr(t10, "pos", e)), { pos: r, time: a } = t10[i], { pos: o, time: l } = t10[s]) : (e >= t10[i].time && e <= t10[s].time && ({ lo: i, hi: s } = Lr(t10, "time", e)), { time: r, pos: a } = t10[i], { time: o, pos: l } = t10[s]);
  const c = o - r;
  return c ? a + (l - a) * (e - r) / c : a;
}
var f1 = class extends Yu {
  constructor(e) {
    super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const e = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(e);
    this._minPos = gc(n, this.min), this._tableRange = gc(n, this.max) - this._minPos, super.initOffsets(e);
  }
  buildLookupTable(e) {
    const { min: n, max: i } = this, s = [], r = [];
    let o, a, l, c, u;
    for (o = 0, a = e.length; o < a; ++o)
      c = e[o], c >= n && c <= i && s.push(c);
    if (s.length < 2)
      return [
        {
          time: n,
          pos: 0
        },
        {
          time: i,
          pos: 1
        }
      ];
    for (o = 0, a = s.length; o < a; ++o)
      u = s[o + 1], l = s[o - 1], c = s[o], Math.round((u + l) / 2) !== c && r.push({
        time: c,
        pos: o / (a - 1)
      });
    return r;
  }
  _generate() {
    const e = this.min, n = this.max;
    let i = super.getDataTimestamps();
    return (!i.includes(e) || !i.length) && i.splice(0, 0, e), (!i.includes(n) || i.length === 1) && i.push(n), i.sort((s, r) => s - r);
  }
  _getTimestampsForTable() {
    let e = this._cache.all || [];
    if (e.length)
      return e;
    const n = this.getDataTimestamps(), i = this.getLabelTimestamps();
    return n.length && i.length ? e = this.normalize(n.concat(i)) : e = n.length ? n : i, e = this._cache.all = e, e;
  }
  getDecimalForValue(e) {
    return (gc(this._table, e) - this._minPos) / this._tableRange;
  }
  getValueForPixel(e) {
    const n = this._offsets, i = this.getDecimalForPixel(e) / n.factor - n.end;
    return gc(this._table, i * this._tableRange + this._minPos, true);
  }
};
ve(f1, "id", "timeseries"), ve(f1, "defaults", Yu.defaults);
var IG = { class: "mn-bar" };
var PG = ["id"];
var DG = ["aria-labelledby", "aria-describedby"];
var $G = Object.assign({ name: "mn-bar" }, {
  __name: "bar",
  props: {
    label: {
      type: String,
      required: true
    },
    data: {
      type: Object,
      default: null
    },
    horizontal: Boolean,
    stacked: Boolean,
    labelless: Boolean,
    legendless: Boolean,
    tooltipless: Boolean
  },
  setup(t10) {
    const e = useId(), n = t10;
    St.register(Ac, Pc, qu, zd, Ku, jd), St.defaults.color = ai("--text-neutral-muted"), St.defaults.borderColor = ai("--border-neutral-muted");
    const i = ref(null);
    return onMounted(async () => {
      new St(i.value, {
        type: "bar",
        data: n.data,
        options: {
          animation: false,
          scales: {
            x: {
              grid: {
                drawOnChartArea: false
              },
              stacked: n.stacked
            },
            y: {
              stacked: n.stacked
            }
          },
          elements: {
            bar: {
              borderWidth: 2
            }
          },
          indexAxis: n.horizontal ? "y" : "x",
          plugins: {
            legend: {
              display: !n.legendless && n.data.datasets.length > 1
            },
            tooltip: {
              enabled: !n.tooltipless
            }
          }
        }
      });
    }), (s, r) => (openBlock(), createElementBlock("div", IG, [
      createVNode(ui, {
        id: `${unref(e)}-label`,
        class: normalizeClass({ invisible: t10.labelless }),
        align: "center",
        bold: "",
        "aria-hidden": "true"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(unref(Ie)(t10.label)), 1)
        ]),
        _: 1
      }, 8, ["id", "class"]),
      createBaseVNode("p", {
        id: `${unref(e)}-description`,
        class: "invisible",
        "aria-hidden": "true"
      }, [
        renderSlot(s.$slots, "description", {}, void 0, true)
      ], 8, PG),
      createBaseVNode("canvas", {
        ref_key: "chartRef",
        ref: i,
        "aria-labelledby": `${unref(e)}-label`,
        "aria-describedby": `${unref(e)}-description`
      }, null, 8, DG)
    ]));
  }
});
var $Z = Me($G, [["__scopeId", "data-v-03f5895b"]]);
var RG = { class: "mn-doughnut" };
var FG = ["id"];
var VG = ["aria-labelledby", "aria-describedby"];
var BG = Object.assign({ name: "mn-doughnut" }, {
  __name: "doughnut",
  props: {
    label: {
      type: String,
      required: true
    },
    data: {
      type: Object,
      default: null
    },
    labelless: Boolean,
    legendless: Boolean,
    tooltipless: Boolean
  },
  setup(t10) {
    const e = useId(), n = t10;
    St.register(Oa, wa, zd, jd), St.defaults.color = ai("--text-neutral-muted"), St.defaults.borderColor = ai("--border-neutral-muted");
    const i = ref(null);
    return onMounted(async () => {
      new St(i.value, {
        type: "doughnut",
        data: n.data,
        options: {
          animation: false,
          elements: {
            arc: {
              borderWidth: 2
            }
          },
          plugins: {
            legend: {
              display: !n.legendless
            },
            tooltip: {
              enabled: !n.tooltipless
            }
          }
        }
      });
    }), (s, r) => (openBlock(), createElementBlock("div", RG, [
      createVNode(ui, {
        id: `${unref(e)}-label`,
        class: normalizeClass({ invisible: t10.labelless }),
        align: "center",
        bold: "",
        "aria-hidden": "true"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(unref(Ie)(t10.label)), 1)
        ]),
        _: 1
      }, 8, ["id", "class"]),
      createBaseVNode("p", {
        id: `${unref(e)}-description`,
        class: "invisible",
        "aria-hidden": "true"
      }, [
        renderSlot(s.$slots, "description", {}, void 0, true)
      ], 8, FG),
      createBaseVNode("canvas", {
        ref_key: "chartRef",
        ref: i,
        "aria-labelledby": `${unref(e)}-label`,
        "aria-describedby": `${unref(e)}-description`
      }, null, 8, VG)
    ]));
  }
});
var RZ = Me(BG, [["__scopeId", "data-v-b22f2209"]]);
var zG = { class: "mn-line" };
var jG = ["id"];
var HG = ["aria-labelledby", "aria-describedby"];
var WG = Object.assign({ name: "mn-line" }, {
  __name: "line",
  props: {
    label: {
      type: String,
      required: true
    },
    data: {
      type: Object,
      default: null
    },
    horizontal: Boolean,
    labelless: Boolean,
    legendless: Boolean,
    tooltipless: Boolean
  },
  setup(t10) {
    const e = useId(), n = t10;
    St.register(qu, zd, Ku, _c, gs, Xa, jd), St.defaults.color = ai("--text-neutral-muted"), St.defaults.borderColor = ai("--border-neutral-muted");
    const i = ref(null);
    return onMounted(async () => {
      var s;
      (s = n.data) == null || s.datasets.forEach((r) => {
        r.cubicInterpolationMode = "monotone";
      }), new St(i.value, {
        type: "line",
        data: n.data,
        options: {
          animation: false,
          elements: {
            line: {
              borderWidth: 2
            },
            point: {
              pointBackgroundColor: ai("--bg-neutral")
            }
          },
          scales: {
            x: {
              grid: {
                drawOnChartArea: false
              }
            }
          },
          plugins: {
            legend: {
              display: !n.legendless && n.data.datasets.length > 1
            },
            tooltip: {
              enabled: !n.tooltipless
            }
          }
        }
      });
    }), (s, r) => (openBlock(), createElementBlock("div", zG, [
      createVNode(ui, {
        id: `${unref(e)}-label`,
        class: normalizeClass({ invisible: t10.labelless }),
        align: "center",
        bold: "",
        "aria-hidden": "true"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(unref(Ie)(t10.label)), 1)
        ]),
        _: 1
      }, 8, ["id", "class"]),
      createBaseVNode("p", {
        id: `${unref(e)}-description`,
        class: "invisible",
        "aria-hidden": "true"
      }, [
        renderSlot(s.$slots, "description", {}, void 0, true)
      ], 8, jG),
      createBaseVNode("canvas", {
        ref_key: "chartRef",
        ref: i,
        "aria-labelledby": `${unref(e)}-label`,
        "aria-describedby": `${unref(e)}-description`
      }, null, 8, HG)
    ]));
  }
});
var FZ = Me(WG, [["__scopeId", "data-v-7b3484c1"]]);
var UG = { class: "mn-radar" };
var qG = ["id"];
var KG = ["aria-labelledby", "aria-describedby"];
var YG = Object.assign({ name: "mn-radar" }, {
  __name: "radar",
  props: {
    label: {
      type: String,
      required: true
    },
    data: {
      type: Object,
      default: null
    },
    horizontal: Boolean,
    labelless: Boolean,
    legendless: Boolean,
    tooltipless: Boolean
  },
  setup(t10) {
    const e = useId(), n = t10;
    St.register(eG, zd, gs, Xa, Nc, Ma, jd), St.defaults.color = ai("--text-neutral-muted"), St.defaults.borderColor = ai("--border-neutral-muted");
    const i = ref(null);
    return onMounted(async () => {
      new St(i.value, {
        type: "radar",
        data: n.data,
        options: {
          animation: false,
          elements: {
            line: {
              tension: 0.4,
              borderWidth: 2
            },
            point: {
              pointBackgroundColor: ai("--bg-neutral")
            }
          },
          scales: {
            r: {
              angleLines: {
                display: false
              },
              beginAtZero: true,
              grid: {
                circular: true
              },
              ticks: {
                backdropColor: ai("--bg-neutral")
              }
            }
          },
          plugins: {
            filler: {
              propagate: true
            },
            legend: {
              display: !n.legendless && n.data.datasets.length > 1
            },
            tooltip: {
              enabled: !n.tooltipless
            }
          }
        }
      });
    }), (s, r) => (openBlock(), createElementBlock("div", UG, [
      createVNode(ui, {
        id: `${unref(e)}-label`,
        class: normalizeClass({ invisible: t10.labelless }),
        align: "center",
        bold: "",
        "aria-hidden": "true"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(unref(Ie)(t10.label)), 1)
        ]),
        _: 1
      }, 8, ["id", "class"]),
      createBaseVNode("p", {
        id: `${unref(e)}-description`,
        class: "invisible",
        "aria-hidden": "true"
      }, [
        renderSlot(s.$slots, "description", {}, void 0, true)
      ], 8, qG),
      createBaseVNode("canvas", {
        ref_key: "chartRef",
        ref: i,
        "aria-labelledby": `${unref(e)}-label`,
        "aria-describedby": `${unref(e)}-description`
      }, null, 8, KG)
    ]));
  }
});
var VZ = Me(YG, [["__scopeId", "data-v-621ca414"]]);
var GG = { class: "mn-app-style-content" };
var JG = ["aria-labelledby"];
var XG = ["aria-labelledby"];
var QG = ["aria-labelledby"];
var ZG = Object.assign({ name: "mn-app-style" }, {
  __name: "app-style",
  setup(t10) {
    const e = inject("minuit"), n = useId(), i = ["slate", "gray", "zinc", "neutral", "stone"], s = [
      "red",
      "orange",
      "amber",
      "yellow",
      "lime",
      "green",
      "emerald",
      "teal",
      "cyan",
      "sky",
      "blue",
      "indigo",
      "violet",
      "purple",
      "fuchsia",
      "pink",
      "rose",
      "neutral"
    ];
    function r(l) {
      e.value.neutral = l;
    }
    function o(l) {
      e.value.accent = l;
    }
    function a(l) {
      e.value.radius = l;
    }
    return (l, c) => (openBlock(), createBlock(Yp, {
      class: "mn-app-style",
      label: unref(e).t("style"),
      variant: "text",
      color: "neutral",
      icon: "paintbrush",
      labelless: ""
    }, {
      default: withCtx(() => [
        createBaseVNode("div", GG, [
          createVNode(Ft, {
            id: `${unref(n)}-neutrals`,
            label: unref(Ie)(unref(e).t("neutral"))
          }, null, 8, ["id", "label"]),
          createBaseVNode("div", {
            class: "mn-app-style-colors",
            role: "group",
            "aria-labelledby": `${unref(n)}-neutrals`,
            onKeydown: c[0] || (c[0] = (...u) => l.handleList && l.handleList(...u))
          }, [
            (openBlock(), createElementBlock(Fragment, null, renderList(i, (u) => createVNode(me, {
              key: u,
              class: "mn-app-style-color",
              style: normalizeStyle({ "--color": `var(--${u}-500)` }),
              label: u,
              variant: "text",
              color: "neutral",
              icon: "circle",
              role: "menuitemradio",
              "aria-checked": u === unref(e).neutral,
              labelless: "",
              onClick: (d) => r(u)
            }, null, 8, ["style", "label", "aria-checked", "onClick"])), 64))
          ], 40, JG),
          createVNode(Ft, {
            id: `${unref(n)}-accents`,
            label: unref(Ie)(unref(e).t("accent"))
          }, null, 8, ["id", "label"]),
          createBaseVNode("div", {
            class: "mn-app-style-colors",
            role: "group",
            "aria-labelledby": `${unref(n)}-accents`,
            onKeydown: c[1] || (c[1] = (...u) => l.handleList && l.handleList(...u))
          }, [
            (openBlock(), createElementBlock(Fragment, null, renderList(s, (u) => createVNode(me, {
              key: u,
              class: "mn-app-style-color",
              style: normalizeStyle({ "--color": `var(--${u}-500)` }),
              label: u,
              variant: "text",
              color: "neutral",
              icon: "circle",
              role: "menuitemradio",
              "aria-checked": u === unref(e).accent,
              labelless: "",
              onClick: (d) => o(u)
            }, null, 8, ["style", "label", "aria-checked", "onClick"])), 64))
          ], 40, XG),
          createVNode(Ft, {
            id: `${unref(n)}-radiuses`,
            label: unref(Ie)(unref(e).t("radius"))
          }, null, 8, ["id", "label"]),
          createBaseVNode("div", {
            class: "mn-app-style-radiuses",
            role: "group",
            "aria-labelledby": `${unref(n)}-radiuses`,
            onKeydown: c[4] || (c[4] = (...u) => l.handleList && l.handleList(...u))
          }, [
            createVNode(me, {
              class: "mn-app-style-radius",
              label: unref(e).t("sharp"),
              variant: unref(e).radius === "sharp" ? "full" : "text",
              color: "neutral",
              wide: "",
              role: "menuitemradio",
              "aria-checked": unref(e).radius === "sharp",
              onClick: c[2] || (c[2] = (u) => a("sharp"))
            }, null, 8, ["label", "variant", "aria-checked"]),
            createVNode(me, {
              class: "mn-app-style-radius",
              label: unref(e).t("soft"),
              variant: unref(e).radius === "soft" ? "full" : "text",
              color: "neutral",
              wide: "",
              role: "menuitemradio",
              "aria-checked": unref(e).radius === "soft",
              onClick: c[3] || (c[3] = (u) => a("soft"))
            }, null, 8, ["label", "variant", "aria-checked"])
          ], 40, QG)
        ])
      ]),
      _: 1
    }, 8, ["label"]));
  }
});
var BZ = Me(ZG, [["__scopeId", "data-v-2bad620a"]]);
var h1 = typeof window < "u";
var eJ = /\{([0-9a-zA-Z]+)\}/g;
function tJ(t10, ...e) {
  return e.length === 1 && rn(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t10.replace(eJ, (n, i) => e.hasOwnProperty(i) ? e[i] : "");
}
var Cs = (t10, e = false) => e ? Symbol.for(t10) : Symbol(t10);
var mp = (t10) => typeof t10 == "number" && isFinite(t10);
var Gu = (t10) => oJ(t10) === "[object RegExp]";
var nJ = (t10) => jn(t10) && Object.keys(t10).length === 0;
var Hi = Object.assign;
var iJ = Object.create;
var Ln = (t10 = null) => iJ(t10);
var p1;
var go = () => p1 || (p1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : Ln());
var sJ = Object.prototype.hasOwnProperty;
function Ju(t10, e) {
  return sJ.call(t10, e);
}
var Ri = Array.isArray;
var ko = (t10) => typeof t10 == "function";
var Mt = (t10) => typeof t10 == "string";
var si = (t10) => typeof t10 == "boolean";
var rn = (t10) => t10 !== null && typeof t10 == "object";
var rJ = Object.prototype.toString;
var oJ = (t10) => rJ.call(t10);
var jn = (t10) => {
  if (!rn(t10))
    return false;
  const e = Object.getPrototypeOf(t10);
  return e === null || e.constructor === Object;
};
function B4(t10) {
  let e = t10;
  return () => ++e;
}
function Wd(t10, e) {
  typeof console < "u" && console.warn("[intlify] " + t10);
}
var m1 = {};
function aJ(t10) {
  m1[t10] || (m1[t10] = true, Wd(t10));
}
function lJ() {
  const t10 = /* @__PURE__ */ new Map();
  return {
    events: t10,
    on(n, i) {
      const s = t10.get(n);
      s && s.push(i) || t10.set(n, [i]);
    },
    off(n, i) {
      const s = t10.get(n);
      s && s.splice(s.indexOf(i) >>> 0, 1);
    },
    emit(n, i) {
      (t10.get(n) || []).slice().map((s) => s(i)), (t10.get("*") || []).slice().map((s) => s(n, i));
    }
  };
}
var bc = (t10) => !rn(t10) || Ri(t10);
function Dc(t10, e) {
  if (bc(t10) || bc(e))
    throw new Error("Invalid value");
  const n = [{ src: t10, des: e }];
  for (; n.length; ) {
    const { src: i, des: s } = n.pop();
    Object.keys(i).forEach((r) => {
      r !== "__proto__" && (rn(i[r]) && !rn(s[r]) && (s[r] = Array.isArray(i[r]) ? [] : Ln()), bc(s[r]) || bc(i[r]) ? s[r] = i[r] : n.push({ src: i[r], des: s[r] }));
    });
  }
}
var Zr = typeof window < "u";
var qn;
var eo;
if (true) {
  const t10 = Zr && window.performance;
  t10 && t10.mark && t10.measure && t10.clearMarks && // @ts-ignore browser compat
  t10.clearMeasures && (qn = (e) => {
    t10.mark(e);
  }, eo = (e, n, i) => {
    t10.measure(e, n, i), t10.clearMarks(n), t10.clearMarks(i);
  });
}
var cJ = /\{([0-9a-zA-Z]+)\}/g;
function z4(t10, ...e) {
  return e.length === 1 && jt(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t10.replace(cJ, (n, i) => e.hasOwnProperty(i) ? e[i] : "");
}
var uJ = (t10, e, n) => dJ({ l: t10, k: e, s: n });
var dJ = (t10) => JSON.stringify(t10).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
var pn = (t10) => typeof t10 == "number" && isFinite(t10);
var fJ = (t10) => H4(t10) === "[object Date]";
var g1 = (t10) => H4(t10) === "[object RegExp]";
var rg = (t10) => yt(t10) && Object.keys(t10).length === 0;
var ea = Object.assign;
var hJ = Object.create;
var kn = (t10 = null) => hJ(t10);
var b1;
var Kf = () => b1 || (b1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : kn());
function y1(t10) {
  return t10.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var pJ = Object.prototype.hasOwnProperty;
function Ir(t10, e) {
  return pJ.call(t10, e);
}
var Wi = Array.isArray;
var zt = (t10) => typeof t10 == "function";
var ze = (t10) => typeof t10 == "string";
var mn = (t10) => typeof t10 == "boolean";
var jt = (t10) => t10 !== null && typeof t10 == "object";
var mJ = (t10) => jt(t10) && zt(t10.then) && zt(t10.catch);
var j4 = Object.prototype.toString;
var H4 = (t10) => j4.call(t10);
var yt = (t10) => {
  if (!jt(t10))
    return false;
  const e = Object.getPrototypeOf(t10);
  return e === null || e.constructor === Object;
};
var gJ = (t10) => t10 == null ? "" : Wi(t10) || yt(t10) && t10.toString === j4 ? JSON.stringify(t10, null, 2) : String(t10);
function bJ(t10, e = "") {
  return t10.reduce((n, i, s) => s === 0 ? n + i : n + e + i, "");
}
var v1 = 2;
function yJ(t10, e = 0, n = t10.length) {
  const i = t10.split(/\r?\n/);
  let s = 0;
  const r = [];
  for (let o = 0; o < i.length; o++)
    if (s += i[o].length + 1, s >= e) {
      for (let a = o - v1; a <= o + v1 || n > s; a++) {
        if (a < 0 || a >= i.length)
          continue;
        const l = a + 1;
        r.push(`${l}${" ".repeat(3 - String(l).length)}|  ${i[a]}`);
        const c = i[a].length;
        if (a === o) {
          const u = e - (s - c) + 1, d = Math.max(1, n > s ? c - u : n - e);
          r.push("   |  " + " ".repeat(u) + "^".repeat(d));
        } else if (a > o) {
          if (n > s) {
            const u = Math.max(Math.min(n - s, c), 1);
            r.push("   |  " + "^".repeat(u));
          }
          s += c + 1;
        }
      }
      break;
    }
  return r.join(`
`);
}
function W4(t10) {
  let e = t10;
  return () => ++e;
}
function ta(t10, e) {
  typeof console < "u" && (console.warn("[intlify] " + t10), e && console.warn(e.stack));
}
var x1 = {};
function vJ(t10) {
  x1[t10] || (x1[t10] = true, ta(t10));
}
function xJ(t10, e, n) {
  return { line: t10, column: e, offset: n };
}
function Xu(t10, e, n) {
  return { start: t10, end: e };
}
var kJ = /\{([0-9a-zA-Z]+)\}/g;
function U4(t10, ...e) {
  return e.length === 1 && SJ(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t10.replace(kJ, (n, i) => e.hasOwnProperty(i) ? e[i] : "");
}
var q4 = Object.assign;
var k1 = (t10) => typeof t10 == "string";
var SJ = (t10) => t10 !== null && typeof t10 == "object";
function K4(t10, e = "") {
  return t10.reduce((n, i, s) => s === 0 ? n + i : n + e + i, "");
}
var Ud = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
var wJ = {
  [Ud.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'."
};
function CJ(t10, e, ...n) {
  const i = U4(wJ[t10], ...n || []), s = { message: String(i), code: t10 };
  return e && (s.location = e), s;
}
var Re = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
var OJ = {
  // tokenizer error messages
  [Re.EXPECTED_TOKEN]: "Expected token: '{0}'",
  [Re.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
  [Re.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
  [Re.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
  [Re.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
  [Re.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
  [Re.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
  [Re.EMPTY_PLACEHOLDER]: "Empty placeholder",
  [Re.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
  [Re.INVALID_LINKED_FORMAT]: "Invalid linked format",
  // parser error messages
  [Re.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
  [Re.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
  [Re.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
  [Re.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
  // generator error messages
  [Re.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
  // minimizer error messages
  [Re.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
};
function na(t10, e, n = {}) {
  const { domain: i, messages: s, args: r } = n, o = U4((s || OJ)[t10] || "", ...r || []), a = new SyntaxError(String(o));
  return a.code = t10, e && (a.location = e), a.domain = i, a;
}
function EJ(t10) {
  throw t10;
}
var MJ = /<\/?[\w\s="/.':;#-\/]+>/;
var TJ = (t10) => MJ.test(t10);
var ts = " ";
var AJ = "\r";
var dn = `
`;
var _J = "\u2028";
var NJ = "\u2029";
function LJ(t10) {
  const e = t10;
  let n = 0, i = 1, s = 1, r = 0;
  const o = (E) => e[E] === AJ && e[E + 1] === dn, a = (E) => e[E] === dn, l = (E) => e[E] === NJ, c = (E) => e[E] === _J, u = (E) => o(E) || a(E) || l(E) || c(E), d = () => n, f = () => i, h10 = () => s, p = () => r, g = (E) => o(E) || l(E) || c(E) ? dn : e[E], m = () => g(n), b = () => g(n + r);
  function x() {
    return r = 0, u(n) && (i++, s = 0), o(n) && n++, n++, s++, e[n];
  }
  function k() {
    return o(n + r) && r++, r++, e[n + r];
  }
  function v() {
    n = 0, i = 1, s = 1, r = 0;
  }
  function S(E = 0) {
    r = E;
  }
  function w() {
    const E = n + r;
    for (; E !== n; )
      x();
    r = 0;
  }
  return {
    index: d,
    line: f,
    column: h10,
    peekOffset: p,
    charAt: g,
    currentChar: m,
    currentPeek: b,
    next: x,
    peek: k,
    reset: v,
    resetPeek: S,
    skipToPeek: w
  };
}
var Ts = void 0;
var S1 = "'";
var PJ = "tokenizer";
function DJ(t10, e = {}) {
  const n = e.location !== false, i = LJ(t10), s = () => i.index(), r = () => xJ(i.line(), i.column(), i.index()), o = r(), a = s(), l = {
    currentType: 14,
    offset: a,
    startLoc: o,
    endLoc: o,
    lastType: 14,
    lastOffset: a,
    lastStartLoc: o,
    lastEndLoc: o,
    braceNest: 0,
    inLinked: false,
    text: ""
  }, c = () => l, { onError: u } = e;
  function d(I, $, ne, ...Se) {
    const Ze = c();
    if ($.column += ne, $.offset += ne, u) {
      const Qe = n ? Xu(Ze.startLoc, $) : null, Ye = na(I, Qe, {
        domain: PJ,
        args: Se
      });
      u(Ye);
    }
  }
  function f(I, $, ne) {
    I.endLoc = r(), I.currentType = $;
    const Se = { type: $ };
    return n && (Se.loc = Xu(I.startLoc, I.endLoc)), ne != null && (Se.value = ne), Se;
  }
  const h10 = (I) => f(
    I,
    14
    /* TokenTypes.EOF */
  );
  function p(I, $) {
    return I.currentChar() === $ ? (I.next(), $) : (d(Re.EXPECTED_TOKEN, r(), 0, $), "");
  }
  function g(I) {
    let $ = "";
    for (; I.currentPeek() === ts || I.currentPeek() === dn; )
      $ += I.currentPeek(), I.peek();
    return $;
  }
  function m(I) {
    const $ = g(I);
    return I.skipToPeek(), $;
  }
  function b(I) {
    if (I === Ts)
      return false;
    const $ = I.charCodeAt(0);
    return $ >= 97 && $ <= 122 || // a-z
    $ >= 65 && $ <= 90 || // A-Z
    $ === 95;
  }
  function x(I) {
    if (I === Ts)
      return false;
    const $ = I.charCodeAt(0);
    return $ >= 48 && $ <= 57;
  }
  function k(I, $) {
    const { currentType: ne } = $;
    if (ne !== 2)
      return false;
    g(I);
    const Se = b(I.currentPeek());
    return I.resetPeek(), Se;
  }
  function v(I, $) {
    const { currentType: ne } = $;
    if (ne !== 2)
      return false;
    g(I);
    const Se = I.currentPeek() === "-" ? I.peek() : I.currentPeek(), Ze = x(Se);
    return I.resetPeek(), Ze;
  }
  function S(I, $) {
    const { currentType: ne } = $;
    if (ne !== 2)
      return false;
    g(I);
    const Se = I.currentPeek() === S1;
    return I.resetPeek(), Se;
  }
  function w(I, $) {
    const { currentType: ne } = $;
    if (ne !== 8)
      return false;
    g(I);
    const Se = I.currentPeek() === ".";
    return I.resetPeek(), Se;
  }
  function E(I, $) {
    const { currentType: ne } = $;
    if (ne !== 9)
      return false;
    g(I);
    const Se = b(I.currentPeek());
    return I.resetPeek(), Se;
  }
  function M(I, $) {
    const { currentType: ne } = $;
    if (!(ne === 8 || ne === 12))
      return false;
    g(I);
    const Se = I.currentPeek() === ":";
    return I.resetPeek(), Se;
  }
  function N(I, $) {
    const { currentType: ne } = $;
    if (ne !== 10)
      return false;
    const Se = () => {
      const Qe = I.currentPeek();
      return Qe === "{" ? b(I.peek()) : Qe === "@" || Qe === "%" || Qe === "|" || Qe === ":" || Qe === "." || Qe === ts || !Qe ? false : Qe === dn ? (I.peek(), Se()) : F(I, false);
    }, Ze = Se();
    return I.resetPeek(), Ze;
  }
  function V(I) {
    g(I);
    const $ = I.currentPeek() === "|";
    return I.resetPeek(), $;
  }
  function Y(I) {
    const $ = g(I), ne = I.currentPeek() === "%" && I.peek() === "{";
    return I.resetPeek(), {
      isModulo: ne,
      hasSpace: $.length > 0
    };
  }
  function F(I, $ = true) {
    const ne = (Ze = false, Qe = "", Ye = false) => {
      const Z = I.currentPeek();
      return Z === "{" ? Qe === "%" ? false : Ze : Z === "@" || !Z ? Qe === "%" ? true : Ze : Z === "%" ? (I.peek(), ne(Ze, "%", true)) : Z === "|" ? Qe === "%" || Ye ? true : !(Qe === ts || Qe === dn) : Z === ts ? (I.peek(), ne(true, ts, Ye)) : Z === dn ? (I.peek(), ne(true, dn, Ye)) : true;
    }, Se = ne();
    return $ && I.resetPeek(), Se;
  }
  function re(I, $) {
    const ne = I.currentChar();
    return ne === Ts ? Ts : $(ne) ? (I.next(), ne) : null;
  }
  function z(I) {
    const $ = I.charCodeAt(0);
    return $ >= 97 && $ <= 122 || // a-z
    $ >= 65 && $ <= 90 || // A-Z
    $ >= 48 && $ <= 57 || // 0-9
    $ === 95 || // _
    $ === 36;
  }
  function W(I) {
    return re(I, z);
  }
  function C(I) {
    const $ = I.charCodeAt(0);
    return $ >= 97 && $ <= 122 || // a-z
    $ >= 65 && $ <= 90 || // A-Z
    $ >= 48 && $ <= 57 || // 0-9
    $ === 95 || // _
    $ === 36 || // $
    $ === 45;
  }
  function O(I) {
    return re(I, C);
  }
  function _(I) {
    const $ = I.charCodeAt(0);
    return $ >= 48 && $ <= 57;
  }
  function T(I) {
    return re(I, _);
  }
  function H(I) {
    const $ = I.charCodeAt(0);
    return $ >= 48 && $ <= 57 || // 0-9
    $ >= 65 && $ <= 70 || // A-F
    $ >= 97 && $ <= 102;
  }
  function Q(I) {
    return re(I, H);
  }
  function ae(I) {
    let $ = "", ne = "";
    for (; $ = T(I); )
      ne += $;
    return ne;
  }
  function pe(I) {
    m(I);
    const $ = I.currentChar();
    return $ !== "%" && d(Re.EXPECTED_TOKEN, r(), 0, $), I.next(), "%";
  }
  function xe(I) {
    let $ = "";
    for (; ; ) {
      const ne = I.currentChar();
      if (ne === "{" || ne === "}" || ne === "@" || ne === "|" || !ne)
        break;
      if (ne === "%")
        if (F(I))
          $ += ne, I.next();
        else
          break;
      else if (ne === ts || ne === dn)
        if (F(I))
          $ += ne, I.next();
        else {
          if (V(I))
            break;
          $ += ne, I.next();
        }
      else
        $ += ne, I.next();
    }
    return $;
  }
  function Te(I) {
    m(I);
    let $ = "", ne = "";
    for (; $ = O(I); )
      ne += $;
    return I.currentChar() === Ts && d(Re.UNTERMINATED_CLOSING_BRACE, r(), 0), ne;
  }
  function L(I) {
    m(I);
    let $ = "";
    return I.currentChar() === "-" ? (I.next(), $ += `-${ae(I)}`) : $ += ae(I), I.currentChar() === Ts && d(Re.UNTERMINATED_CLOSING_BRACE, r(), 0), $;
  }
  function K(I) {
    return I !== S1 && I !== dn;
  }
  function B(I) {
    m(I), p(I, "'");
    let $ = "", ne = "";
    for (; $ = re(I, K); )
      $ === "\\" ? ne += X(I) : ne += $;
    const Se = I.currentChar();
    return Se === dn || Se === Ts ? (d(Re.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, r(), 0), Se === dn && (I.next(), p(I, "'")), ne) : (p(I, "'"), ne);
  }
  function X(I) {
    const $ = I.currentChar();
    switch ($) {
      case "\\":
      case "'":
        return I.next(), `\\${$}`;
      case "u":
        return be(I, $, 4);
      case "U":
        return be(I, $, 6);
      default:
        return d(Re.UNKNOWN_ESCAPE_SEQUENCE, r(), 0, $), "";
    }
  }
  function be(I, $, ne) {
    p(I, $);
    let Se = "";
    for (let Ze = 0; Ze < ne; Ze++) {
      const Qe = Q(I);
      if (!Qe) {
        d(Re.INVALID_UNICODE_ESCAPE_SEQUENCE, r(), 0, `\\${$}${Se}${I.currentChar()}`);
        break;
      }
      Se += Qe;
    }
    return `\\${$}${Se}`;
  }
  function Ce(I) {
    return I !== "{" && I !== "}" && I !== ts && I !== dn;
  }
  function Oe(I) {
    m(I);
    let $ = "", ne = "";
    for (; $ = re(I, Ce); )
      ne += $;
    return ne;
  }
  function Ue(I) {
    let $ = "", ne = "";
    for (; $ = W(I); )
      ne += $;
    return ne;
  }
  function J(I) {
    const $ = (ne) => {
      const Se = I.currentChar();
      return Se === "{" || Se === "%" || Se === "@" || Se === "|" || Se === "(" || Se === ")" || !Se || Se === ts ? ne : (ne += Se, I.next(), $(ne));
    };
    return $("");
  }
  function Fe(I) {
    m(I);
    const $ = p(
      I,
      "|"
      /* TokenChars.Pipe */
    );
    return m(I), $;
  }
  function xt(I, $) {
    let ne = null;
    switch (I.currentChar()) {
      case "{":
        return $.braceNest >= 1 && d(Re.NOT_ALLOW_NEST_PLACEHOLDER, r(), 0), I.next(), ne = f(
          $,
          2,
          "{"
          /* TokenChars.BraceLeft */
        ), m(I), $.braceNest++, ne;
      case "}":
        return $.braceNest > 0 && $.currentType === 2 && d(Re.EMPTY_PLACEHOLDER, r(), 0), I.next(), ne = f(
          $,
          3,
          "}"
          /* TokenChars.BraceRight */
        ), $.braceNest--, $.braceNest > 0 && m(I), $.inLinked && $.braceNest === 0 && ($.inLinked = false), ne;
      case "@":
        return $.braceNest > 0 && d(Re.UNTERMINATED_CLOSING_BRACE, r(), 0), ne = Ct(I, $) || h10($), $.braceNest = 0, ne;
      default: {
        let Ze = true, Qe = true, Ye = true;
        if (V(I))
          return $.braceNest > 0 && d(Re.UNTERMINATED_CLOSING_BRACE, r(), 0), ne = f($, 1, Fe(I)), $.braceNest = 0, $.inLinked = false, ne;
        if ($.braceNest > 0 && ($.currentType === 5 || $.currentType === 6 || $.currentType === 7))
          return d(Re.UNTERMINATED_CLOSING_BRACE, r(), 0), $.braceNest = 0, Pt(I, $);
        if (Ze = k(I, $))
          return ne = f($, 5, Te(I)), m(I), ne;
        if (Qe = v(I, $))
          return ne = f($, 6, L(I)), m(I), ne;
        if (Ye = S(I, $))
          return ne = f($, 7, B(I)), m(I), ne;
        if (!Ze && !Qe && !Ye)
          return ne = f($, 13, Oe(I)), d(Re.INVALID_TOKEN_IN_PLACEHOLDER, r(), 0, ne.value), m(I), ne;
        break;
      }
    }
    return ne;
  }
  function Ct(I, $) {
    const { currentType: ne } = $;
    let Se = null;
    const Ze = I.currentChar();
    switch ((ne === 8 || ne === 9 || ne === 12 || ne === 10) && (Ze === dn || Ze === ts) && d(Re.INVALID_LINKED_FORMAT, r(), 0), Ze) {
      case "@":
        return I.next(), Se = f(
          $,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        ), $.inLinked = true, Se;
      case ".":
        return m(I), I.next(), f(
          $,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        return m(I), I.next(), f(
          $,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        return V(I) ? (Se = f($, 1, Fe(I)), $.braceNest = 0, $.inLinked = false, Se) : w(I, $) || M(I, $) ? (m(I), Ct(I, $)) : E(I, $) ? (m(I), f($, 12, Ue(I))) : N(I, $) ? (m(I), Ze === "{" ? xt(I, $) || Se : f($, 11, J(I))) : (ne === 8 && d(Re.INVALID_LINKED_FORMAT, r(), 0), $.braceNest = 0, $.inLinked = false, Pt(I, $));
    }
  }
  function Pt(I, $) {
    let ne = {
      type: 14
      /* TokenTypes.EOF */
    };
    if ($.braceNest > 0)
      return xt(I, $) || h10($);
    if ($.inLinked)
      return Ct(I, $) || h10($);
    switch (I.currentChar()) {
      case "{":
        return xt(I, $) || h10($);
      case "}":
        return d(Re.UNBALANCED_CLOSING_BRACE, r(), 0), I.next(), f(
          $,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return Ct(I, $) || h10($);
      default: {
        if (V(I))
          return ne = f($, 1, Fe(I)), $.braceNest = 0, $.inLinked = false, ne;
        const { isModulo: Ze, hasSpace: Qe } = Y(I);
        if (Ze)
          return Qe ? f($, 0, xe(I)) : f($, 4, pe(I));
        if (F(I))
          return f($, 0, xe(I));
        break;
      }
    }
    return ne;
  }
  function un() {
    const { currentType: I, offset: $, startLoc: ne, endLoc: Se } = l;
    return l.lastType = I, l.lastOffset = $, l.lastStartLoc = ne, l.lastEndLoc = Se, l.offset = s(), l.startLoc = r(), i.currentChar() === Ts ? f(
      l,
      14
      /* TokenTypes.EOF */
    ) : Pt(i, l);
  }
  return {
    nextToken: un,
    currentOffset: s,
    currentPosition: r,
    context: c
  };
}
var $J = "parser";
var RJ = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function FJ(t10, e, n) {
  switch (t10) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const i = parseInt(e || n, 16);
      return i <= 55295 || i >= 57344 ? String.fromCodePoint(i) : "�";
    }
  }
}
function VJ(t10 = {}) {
  const e = t10.location !== false, { onError: n, onWarn: i } = t10;
  function s(k, v, S, w, ...E) {
    const M = k.currentPosition();
    if (M.offset += w, M.column += w, n) {
      const N = e ? Xu(S, M) : null, V = na(v, N, {
        domain: $J,
        args: E
      });
      n(V);
    }
  }
  function r(k, v, S, w, ...E) {
    const M = k.currentPosition();
    if (M.offset += w, M.column += w, i) {
      const N = e ? Xu(S, M) : null;
      i(CJ(v, N, E));
    }
  }
  function o(k, v, S) {
    const w = { type: k };
    return e && (w.start = v, w.end = v, w.loc = { start: S, end: S }), w;
  }
  function a(k, v, S, w) {
    e && (k.end = v, k.loc && (k.loc.end = S));
  }
  function l(k, v) {
    const S = k.context(), w = o(3, S.offset, S.startLoc);
    return w.value = v, a(w, k.currentOffset(), k.currentPosition()), w;
  }
  function c(k, v) {
    const S = k.context(), { lastOffset: w, lastStartLoc: E } = S, M = o(5, w, E);
    return M.index = parseInt(v, 10), k.nextToken(), a(M, k.currentOffset(), k.currentPosition()), M;
  }
  function u(k, v, S) {
    const w = k.context(), { lastOffset: E, lastStartLoc: M } = w, N = o(4, E, M);
    return N.key = v, S === true && (N.modulo = true), k.nextToken(), a(N, k.currentOffset(), k.currentPosition()), N;
  }
  function d(k, v) {
    const S = k.context(), { lastOffset: w, lastStartLoc: E } = S, M = o(9, w, E);
    return M.value = v.replace(RJ, FJ), k.nextToken(), a(M, k.currentOffset(), k.currentPosition()), M;
  }
  function f(k) {
    const v = k.nextToken(), S = k.context(), { lastOffset: w, lastStartLoc: E } = S, M = o(8, w, E);
    return v.type !== 12 ? (s(k, Re.UNEXPECTED_EMPTY_LINKED_MODIFIER, S.lastStartLoc, 0), M.value = "", a(M, w, E), {
      nextConsumeToken: v,
      node: M
    }) : (v.value == null && s(k, Re.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, hi(v)), M.value = v.value || "", a(M, k.currentOffset(), k.currentPosition()), {
      node: M
    });
  }
  function h10(k, v) {
    const S = k.context(), w = o(7, S.offset, S.startLoc);
    return w.value = v, a(w, k.currentOffset(), k.currentPosition()), w;
  }
  function p(k) {
    const v = k.context(), S = o(6, v.offset, v.startLoc);
    let w = k.nextToken();
    if (w.type === 9) {
      const E = f(k);
      S.modifier = E.node, w = E.nextConsumeToken || k.nextToken();
    }
    switch (w.type !== 10 && s(k, Re.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, hi(w)), w = k.nextToken(), w.type === 2 && (w = k.nextToken()), w.type) {
      case 11:
        w.value == null && s(k, Re.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, hi(w)), S.key = h10(k, w.value || "");
        break;
      case 5:
        w.value == null && s(k, Re.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, hi(w)), S.key = u(k, w.value || "");
        break;
      case 6:
        w.value == null && s(k, Re.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, hi(w)), S.key = c(k, w.value || "");
        break;
      case 7:
        w.value == null && s(k, Re.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, hi(w)), S.key = d(k, w.value || "");
        break;
      default: {
        s(k, Re.UNEXPECTED_EMPTY_LINKED_KEY, v.lastStartLoc, 0);
        const E = k.context(), M = o(7, E.offset, E.startLoc);
        return M.value = "", a(M, E.offset, E.startLoc), S.key = M, a(S, E.offset, E.startLoc), {
          nextConsumeToken: w,
          node: S
        };
      }
    }
    return a(S, k.currentOffset(), k.currentPosition()), {
      node: S
    };
  }
  function g(k) {
    const v = k.context(), S = v.currentType === 1 ? k.currentOffset() : v.offset, w = v.currentType === 1 ? v.endLoc : v.startLoc, E = o(2, S, w);
    E.items = [];
    let M = null, N = null;
    do {
      const F = M || k.nextToken();
      switch (M = null, F.type) {
        case 0:
          F.value == null && s(k, Re.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, hi(F)), E.items.push(l(k, F.value || ""));
          break;
        case 6:
          F.value == null && s(k, Re.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, hi(F)), E.items.push(c(k, F.value || ""));
          break;
        case 4:
          N = true;
          break;
        case 5:
          F.value == null && s(k, Re.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, hi(F)), E.items.push(u(k, F.value || "", !!N)), N && (r(k, Ud.USE_MODULO_SYNTAX, v.lastStartLoc, 0, hi(F)), N = null);
          break;
        case 7:
          F.value == null && s(k, Re.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, hi(F)), E.items.push(d(k, F.value || ""));
          break;
        case 8: {
          const re = p(k);
          E.items.push(re.node), M = re.nextConsumeToken || null;
          break;
        }
      }
    } while (v.currentType !== 14 && v.currentType !== 1);
    const V = v.currentType === 1 ? v.lastOffset : k.currentOffset(), Y = v.currentType === 1 ? v.lastEndLoc : k.currentPosition();
    return a(E, V, Y), E;
  }
  function m(k, v, S, w) {
    const E = k.context();
    let M = w.items.length === 0;
    const N = o(1, v, S);
    N.cases = [], N.cases.push(w);
    do {
      const V = g(k);
      M || (M = V.items.length === 0), N.cases.push(V);
    } while (E.currentType !== 14);
    return M && s(k, Re.MUST_HAVE_MESSAGES_IN_PLURAL, S, 0), a(N, k.currentOffset(), k.currentPosition()), N;
  }
  function b(k) {
    const v = k.context(), { offset: S, startLoc: w } = v, E = g(k);
    return v.currentType === 14 ? E : m(k, S, w, E);
  }
  function x(k) {
    const v = DJ(k, q4({}, t10)), S = v.context(), w = o(0, S.offset, S.startLoc);
    return e && w.loc && (w.loc.source = k), w.body = b(v), t10.onCacheKey && (w.cacheKey = t10.onCacheKey(k)), S.currentType !== 14 && s(v, Re.UNEXPECTED_LEXICAL_ANALYSIS, S.lastStartLoc, 0, k[S.offset] || ""), a(w, v.currentOffset(), v.currentPosition()), w;
  }
  return { parse: x };
}
function hi(t10) {
  if (t10.type === 14)
    return "EOF";
  const e = (t10.value || "").replace(/\r?\n/gu, "\\n");
  return e.length > 10 ? e.slice(0, 9) + "…" : e;
}
function BJ(t10, e = {}) {
  const n = {
    ast: t10,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => n, helper: (r) => (n.helpers.add(r), r) };
}
function w1(t10, e) {
  for (let n = 0; n < t10.length; n++)
    og(t10[n], e);
}
function og(t10, e) {
  switch (t10.type) {
    case 1:
      w1(t10.cases, e), e.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      w1(t10.items, e);
      break;
    case 6: {
      og(t10.key, e), e.helper(
        "linked"
        /* HelperNameMap.LINKED */
      ), e.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      e.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), e.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function zJ(t10, e = {}) {
  const n = BJ(t10);
  n.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ), t10.body && og(t10.body, n);
  const i = n.context();
  t10.helpers = Array.from(i.helpers);
}
function jJ(t10) {
  const e = t10.body;
  return e.type === 2 ? C1(e) : e.cases.forEach((n) => C1(n)), t10;
}
function C1(t10) {
  if (t10.items.length === 1) {
    const e = t10.items[0];
    (e.type === 3 || e.type === 9) && (t10.static = e.value, delete e.value);
  } else {
    const e = [];
    for (let n = 0; n < t10.items.length; n++) {
      const i = t10.items[n];
      if (!(i.type === 3 || i.type === 9) || i.value == null)
        break;
      e.push(i.value);
    }
    if (e.length === t10.items.length) {
      t10.static = K4(e);
      for (let n = 0; n < t10.items.length; n++) {
        const i = t10.items[n];
        (i.type === 3 || i.type === 9) && delete i.value;
      }
    }
  }
}
var HJ = "minifier";
function bo(t10) {
  switch (t10.t = t10.type, t10.type) {
    case 0: {
      const e = t10;
      bo(e.body), e.b = e.body, delete e.body;
      break;
    }
    case 1: {
      const e = t10, n = e.cases;
      for (let i = 0; i < n.length; i++)
        bo(n[i]);
      e.c = n, delete e.cases;
      break;
    }
    case 2: {
      const e = t10, n = e.items;
      for (let i = 0; i < n.length; i++)
        bo(n[i]);
      e.i = n, delete e.items, e.static && (e.s = e.static, delete e.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const e = t10;
      e.value && (e.v = e.value, delete e.value);
      break;
    }
    case 6: {
      const e = t10;
      bo(e.key), e.k = e.key, delete e.key, e.modifier && (bo(e.modifier), e.m = e.modifier, delete e.modifier);
      break;
    }
    case 5: {
      const e = t10;
      e.i = e.index, delete e.index;
      break;
    }
    case 4: {
      const e = t10;
      e.k = e.key, delete e.key;
      break;
    }
    default:
      throw na(Re.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: HJ,
        args: [t10.type]
      });
  }
  delete t10.type;
}
var WJ = "parser";
function UJ(t10, e) {
  const { filename: n, breakLineCode: i, needIndent: s } = e, r = e.location !== false, o = {
    filename: n,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: i,
    needIndent: s,
    indentLevel: 0
  };
  r && t10.loc && (o.source = t10.loc.source);
  const a = () => o;
  function l(g, m) {
    o.code += g;
  }
  function c(g, m = true) {
    const b = m ? i : "";
    l(s ? b + "  ".repeat(g) : b);
  }
  function u(g = true) {
    const m = ++o.indentLevel;
    g && c(m);
  }
  function d(g = true) {
    const m = --o.indentLevel;
    g && c(m);
  }
  function f() {
    c(o.indentLevel);
  }
  return {
    context: a,
    push: l,
    indent: u,
    deindent: d,
    newline: f,
    helper: (g) => `_${g}`,
    needIndent: () => o.needIndent
  };
}
function qJ(t10, e) {
  const { helper: n } = t10;
  t10.push(`${n(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`), Ko(t10, e.key), e.modifier ? (t10.push(", "), Ko(t10, e.modifier), t10.push(", _type")) : t10.push(", undefined, _type"), t10.push(")");
}
function KJ(t10, e) {
  const { helper: n, needIndent: i } = t10;
  t10.push(`${n(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`), t10.indent(i());
  const s = e.items.length;
  for (let r = 0; r < s && (Ko(t10, e.items[r]), r !== s - 1); r++)
    t10.push(", ");
  t10.deindent(i()), t10.push("])");
}
function YJ(t10, e) {
  const { helper: n, needIndent: i } = t10;
  if (e.cases.length > 1) {
    t10.push(`${n(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`), t10.indent(i());
    const s = e.cases.length;
    for (let r = 0; r < s && (Ko(t10, e.cases[r]), r !== s - 1); r++)
      t10.push(", ");
    t10.deindent(i()), t10.push("])");
  }
}
function GJ(t10, e) {
  e.body ? Ko(t10, e.body) : t10.push("null");
}
function Ko(t10, e) {
  const { helper: n } = t10;
  switch (e.type) {
    case 0:
      GJ(t10, e);
      break;
    case 1:
      YJ(t10, e);
      break;
    case 2:
      KJ(t10, e);
      break;
    case 6:
      qJ(t10, e);
      break;
    case 8:
      t10.push(JSON.stringify(e.value), e);
      break;
    case 7:
      t10.push(JSON.stringify(e.value), e);
      break;
    case 5:
      t10.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "list"
        /* HelperNameMap.LIST */
      )}(${e.index}))`, e);
      break;
    case 4:
      t10.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(e.key)}))`, e);
      break;
    case 9:
      t10.push(JSON.stringify(e.value), e);
      break;
    case 3:
      t10.push(JSON.stringify(e.value), e);
      break;
    default:
      throw na(Re.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: WJ,
        args: [e.type]
      });
  }
}
var JJ = (t10, e = {}) => {
  const n = k1(e.mode) ? e.mode : "normal", i = k1(e.filename) ? e.filename : "message.intl";
  e.sourceMap;
  const s = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`, r = e.needIndent ? e.needIndent : n !== "arrow", o = t10.helpers || [], a = UJ(t10, {
    filename: i,
    breakLineCode: s,
    needIndent: r
  });
  a.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), a.indent(r), o.length > 0 && (a.push(`const { ${K4(o.map((u) => `${u}: _${u}`), ", ")} } = ctx`), a.newline()), a.push("return "), Ko(a, t10), a.deindent(r), a.push("}"), delete t10.helpers;
  const { code: l, map: c } = a.context();
  return {
    ast: t10,
    code: l,
    map: c ? c.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function XJ(t10, e = {}) {
  const n = q4({}, e), i = !!n.jit, s = !!n.minify, r = n.optimize == null ? true : n.optimize, a = VJ(n).parse(t10);
  return i ? (r && jJ(a), s && bo(a), { ast: a, code: "" }) : (zJ(a, n), JJ(a, n));
}
function QJ() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Kf().__INTLIFY_PROD_DEVTOOLS__ = false), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Kf().__INTLIFY_JIT_COMPILATION__ = false), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Kf().__INTLIFY_DROP_MESSAGE_COMPILER__ = false);
}
var fr = [];
fr[
  0
  /* States.BEFORE_PATH */
] = {
  w: [
    0
    /* States.BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
fr[
  1
  /* States.IN_PATH */
] = {
  w: [
    1
    /* States.IN_PATH */
  ],
  ".": [
    2
    /* States.BEFORE_IDENT */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
fr[
  2
  /* States.BEFORE_IDENT */
] = {
  w: [
    2
    /* States.BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ]
};
fr[
  3
  /* States.IN_IDENT */
] = {
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ],
  w: [
    1,
    1
    /* Actions.PUSH */
  ],
  ".": [
    2,
    1
    /* Actions.PUSH */
  ],
  "[": [
    4,
    1
    /* Actions.PUSH */
  ],
  o: [
    7,
    1
    /* Actions.PUSH */
  ]
};
fr[
  4
  /* States.IN_SUB_PATH */
] = {
  "'": [
    5,
    0
    /* Actions.APPEND */
  ],
  '"': [
    6,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  "]": [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* Actions.APPEND */
  ]
};
fr[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  "'": [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* Actions.APPEND */
  ]
};
fr[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  '"': [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* Actions.APPEND */
  ]
};
var ZJ = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function eX(t10) {
  return ZJ.test(t10);
}
function tX(t10) {
  const e = t10.charCodeAt(0), n = t10.charCodeAt(t10.length - 1);
  return e === n && (e === 34 || e === 39) ? t10.slice(1, -1) : t10;
}
function nX(t10) {
  if (t10 == null)
    return "o";
  switch (t10.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return t10;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function iX(t10) {
  const e = t10.trim();
  return t10.charAt(0) === "0" && isNaN(parseInt(t10)) ? false : eX(e) ? tX(e) : "*" + e;
}
function sX(t10) {
  const e = [];
  let n = -1, i = 0, s = 0, r, o, a, l, c, u, d;
  const f = [];
  f[
    0
    /* Actions.APPEND */
  ] = () => {
    o === void 0 ? o = a : o += a;
  }, f[
    1
    /* Actions.PUSH */
  ] = () => {
    o !== void 0 && (e.push(o), o = void 0);
  }, f[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    f[
      0
      /* Actions.APPEND */
    ](), s++;
  }, f[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (s > 0)
      s--, i = 4, f[
        0
        /* Actions.APPEND */
      ]();
    else {
      if (s = 0, o === void 0 || (o = iX(o), o === false))
        return false;
      f[
        1
        /* Actions.PUSH */
      ]();
    }
  };
  function h10() {
    const p = t10[n + 1];
    if (i === 5 && p === "'" || i === 6 && p === '"')
      return n++, a = "\\" + p, f[
        0
        /* Actions.APPEND */
      ](), true;
  }
  for (; i !== null; )
    if (n++, r = t10[n], !(r === "\\" && h10())) {
      if (l = nX(r), d = fr[i], c = d[l] || d.l || 8, c === 8 || (i = c[0], c[1] !== void 0 && (u = f[c[1]], u && (a = r, u() === false))))
        return;
      if (i === 7)
        return e;
    }
}
var O1 = /* @__PURE__ */ new Map();
function rX(t10, e) {
  return jt(t10) ? t10[e] : null;
}
function oX(t10, e) {
  if (!jt(t10))
    return null;
  let n = O1.get(e);
  if (n || (n = sX(e), n && O1.set(e, n)), !n)
    return null;
  const i = n.length;
  let s = t10, r = 0;
  for (; r < i; ) {
    const o = s[n[r]];
    if (o === void 0 || zt(s))
      return null;
    s = o, r++;
  }
  return s;
}
var aX = (t10) => t10;
var lX = (t10) => "";
var cX = "text";
var uX = (t10) => t10.length === 0 ? "" : bJ(t10);
var dX = gJ;
function E1(t10, e) {
  return t10 = Math.abs(t10), e === 2 ? t10 ? t10 > 1 ? 1 : 0 : 1 : t10 ? Math.min(t10, 2) : 0;
}
function fX(t10) {
  const e = pn(t10.pluralIndex) ? t10.pluralIndex : -1;
  return t10.named && (pn(t10.named.count) || pn(t10.named.n)) ? pn(t10.named.count) ? t10.named.count : pn(t10.named.n) ? t10.named.n : e : e;
}
function hX(t10, e) {
  e.count || (e.count = t10), e.n || (e.n = t10);
}
function pX(t10 = {}) {
  const e = t10.locale, n = fX(t10), i = jt(t10.pluralRules) && ze(e) && zt(t10.pluralRules[e]) ? t10.pluralRules[e] : E1, s = jt(t10.pluralRules) && ze(e) && zt(t10.pluralRules[e]) ? E1 : void 0, r = (b) => b[i(n, b.length, s)], o = t10.list || [], a = (b) => o[b], l = t10.named || kn();
  pn(t10.pluralIndex) && hX(n, l);
  const c = (b) => l[b];
  function u(b) {
    const x = zt(t10.messages) ? t10.messages(b) : jt(t10.messages) ? t10.messages[b] : false;
    return x || (t10.parent ? t10.parent.message(b) : lX);
  }
  const d = (b) => t10.modifiers ? t10.modifiers[b] : aX, f = yt(t10.processor) && zt(t10.processor.normalize) ? t10.processor.normalize : uX, h10 = yt(t10.processor) && zt(t10.processor.interpolate) ? t10.processor.interpolate : dX, p = yt(t10.processor) && ze(t10.processor.type) ? t10.processor.type : cX, m = {
    list: a,
    named: c,
    plural: r,
    linked: (b, ...x) => {
      const [k, v] = x;
      let S = "text", w = "";
      x.length === 1 ? jt(k) ? (w = k.modifier || w, S = k.type || S) : ze(k) && (w = k || w) : x.length === 2 && (ze(k) && (w = k || w), ze(v) && (S = v || S));
      const E = u(b)(m), M = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        S === "vnode" && Wi(E) && w ? E[0] : E
      );
      return w ? d(w)(M, S) : M;
    },
    message: u,
    type: p,
    interpolate: h10,
    normalize: f,
    values: ea(kn(), o, l)
  };
  return m;
}
var Cl = null;
function mX(t10) {
  Cl = t10;
}
function gX(t10, e, n) {
  Cl && Cl.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: t10,
    version: e,
    meta: n
  });
}
var bX = yX(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function yX(t10) {
  return (e) => Cl && Cl.emit(t10, e);
}
var Y4 = Ud.__EXTEND_POINT__;
var vr = W4(Y4);
var fn = {
  NOT_FOUND_KEY: Y4,
  // 2
  FALLBACK_TO_TRANSLATE: vr(),
  // 3
  CANNOT_FORMAT_NUMBER: vr(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: vr(),
  // 5
  CANNOT_FORMAT_DATE: vr(),
  // 6
  FALLBACK_TO_DATE_FORMAT: vr(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: vr(),
  // 8
  __EXTEND_POINT__: vr()
  // 9
};
var vX = {
  [fn.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
  [fn.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
  [fn.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
  [fn.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
  [fn.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
  [fn.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
  [fn.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future."
};
function to(t10, ...e) {
  return z4(vX[t10], ...e);
}
var G4 = Re.__EXTEND_POINT__;
var xr = W4(G4);
var Ht = {
  INVALID_ARGUMENT: G4,
  // 17
  INVALID_DATE_ARGUMENT: xr(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: xr(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: xr(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: xr(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: xr(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: xr(),
  // 23
  __EXTEND_POINT__: xr()
  // 24
};
function Fi(t10) {
  return na(t10, null, true ? { messages: xX } : void 0);
}
var xX = {
  [Ht.INVALID_ARGUMENT]: "Invalid arguments",
  [Ht.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [Ht.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [Ht.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [Ht.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [Ht.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [Ht.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function ag(t10, e) {
  return e.locale != null ? M1(e.locale) : M1(t10.locale);
}
var Yf;
function M1(t10) {
  if (ze(t10))
    return t10;
  if (zt(t10)) {
    if (t10.resolvedOnce && Yf != null)
      return Yf;
    if (t10.constructor.name === "Function") {
      const e = t10();
      if (mJ(e))
        throw Fi(Ht.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return Yf = e;
    } else
      throw Fi(Ht.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else
    throw Fi(Ht.NOT_SUPPORT_LOCALE_TYPE);
}
function kX(t10, e, n) {
  return [.../* @__PURE__ */ new Set([
    n,
    ...Wi(e) ? e : jt(e) ? Object.keys(e) : ze(e) ? [e] : [n]
  ])];
}
function J4(t10, e, n) {
  const i = ze(n) ? n : Ol, s = t10;
  s.__localeChainCache || (s.__localeChainCache = /* @__PURE__ */ new Map());
  let r = s.__localeChainCache.get(i);
  if (!r) {
    r = [];
    let o = [n];
    for (; Wi(o); )
      o = T1(r, o, e);
    const a = Wi(e) || !yt(e) ? e : e.default ? e.default : null;
    o = ze(a) ? [a] : a, Wi(o) && T1(r, o, false), s.__localeChainCache.set(i, r);
  }
  return r;
}
function T1(t10, e, n) {
  let i = true;
  for (let s = 0; s < e.length && mn(i); s++) {
    const r = e[s];
    ze(r) && (i = SX(t10, e[s], n));
  }
  return i;
}
function SX(t10, e, n) {
  let i;
  const s = e.split("-");
  do {
    const r = s.join("-");
    i = wX(t10, r, n), s.splice(-1, 1);
  } while (s.length && i === true);
  return i;
}
function wX(t10, e, n) {
  let i = false;
  if (!t10.includes(e) && (i = true, e)) {
    i = e[e.length - 1] !== "!";
    const s = e.replace(/!/g, "");
    t10.push(s), (Wi(n) || yt(n)) && n[s] && (i = n[s]);
  }
  return i;
}
var CX = "9.14.3";
var qd = -1;
var Ol = "en-US";
var Qu = "";
var A1 = (t10) => `${t10.charAt(0).toLocaleUpperCase()}${t10.substr(1)}`;
function OX() {
  return {
    upper: (t10, e) => e === "text" && ze(t10) ? t10.toUpperCase() : e === "vnode" && jt(t10) && "__v_isVNode" in t10 ? t10.children.toUpperCase() : t10,
    lower: (t10, e) => e === "text" && ze(t10) ? t10.toLowerCase() : e === "vnode" && jt(t10) && "__v_isVNode" in t10 ? t10.children.toLowerCase() : t10,
    capitalize: (t10, e) => e === "text" && ze(t10) ? A1(t10) : e === "vnode" && jt(t10) && "__v_isVNode" in t10 ? A1(t10.children) : t10
  };
}
var X4;
function _1(t10) {
  X4 = t10;
}
var Q4;
function EX(t10) {
  Q4 = t10;
}
var Z4;
function MX(t10) {
  Z4 = t10;
}
var eS = null;
var AX = () => eS;
var tS = null;
var N1 = (t10) => {
  tS = t10;
};
var _X = () => tS;
var L1 = 0;
function NX(t10 = {}) {
  const e = zt(t10.onWarn) ? t10.onWarn : ta, n = ze(t10.version) ? t10.version : CX, i = ze(t10.locale) || zt(t10.locale) ? t10.locale : Ol, s = zt(i) ? Ol : i, r = Wi(t10.fallbackLocale) || yt(t10.fallbackLocale) || ze(t10.fallbackLocale) || t10.fallbackLocale === false ? t10.fallbackLocale : s, o = yt(t10.messages) ? t10.messages : Gf(s), a = yt(t10.datetimeFormats) ? t10.datetimeFormats : Gf(s), l = yt(t10.numberFormats) ? t10.numberFormats : Gf(s), c = ea(kn(), t10.modifiers, OX()), u = t10.pluralRules || kn(), d = zt(t10.missing) ? t10.missing : null, f = mn(t10.missingWarn) || g1(t10.missingWarn) ? t10.missingWarn : true, h10 = mn(t10.fallbackWarn) || g1(t10.fallbackWarn) ? t10.fallbackWarn : true, p = !!t10.fallbackFormat, g = !!t10.unresolving, m = zt(t10.postTranslation) ? t10.postTranslation : null, b = yt(t10.processor) ? t10.processor : null, x = mn(t10.warnHtmlMessage) ? t10.warnHtmlMessage : true, k = !!t10.escapeParameter, v = zt(t10.messageCompiler) ? t10.messageCompiler : X4;
  zt(t10.messageCompiler) && vJ(to(fn.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  const S = zt(t10.messageResolver) ? t10.messageResolver : Q4 || rX, w = zt(t10.localeFallbacker) ? t10.localeFallbacker : Z4 || kX, E = jt(t10.fallbackContext) ? t10.fallbackContext : void 0, M = t10, N = jt(M.__datetimeFormatters) ? M.__datetimeFormatters : /* @__PURE__ */ new Map(), V = jt(M.__numberFormatters) ? M.__numberFormatters : /* @__PURE__ */ new Map(), Y = jt(M.__meta) ? M.__meta : {};
  L1++;
  const F = {
    version: n,
    cid: L1,
    locale: i,
    fallbackLocale: r,
    messages: o,
    modifiers: c,
    pluralRules: u,
    missing: d,
    missingWarn: f,
    fallbackWarn: h10,
    fallbackFormat: p,
    unresolving: g,
    postTranslation: m,
    processor: b,
    warnHtmlMessage: x,
    escapeParameter: k,
    messageCompiler: v,
    messageResolver: S,
    localeFallbacker: w,
    fallbackContext: E,
    onWarn: e,
    __meta: Y
  };
  return F.datetimeFormats = a, F.numberFormats = l, F.__datetimeFormatters = N, F.__numberFormatters = V, F.__v_emitter = M.__v_emitter != null ? M.__v_emitter : void 0, gX(F, n, Y), F;
}
var Gf = (t10) => ({ [t10]: kn() });
function Kd(t10, e) {
  return t10 instanceof RegExp ? t10.test(e) : t10;
}
function nS(t10, e) {
  return t10 instanceof RegExp ? t10.test(e) : t10;
}
function lg(t10, e, n, i, s) {
  const { missing: r, onWarn: o } = t10;
  if (true) {
    const a = t10.__v_emitter;
    a && a.emit("missing", {
      locale: n,
      key: e,
      type: s,
      groupId: `${s}:${e}`
    });
  }
  if (r !== null) {
    const a = r(t10, n, e, s);
    return ze(a) ? a : e;
  } else
    return nS(i, e) && o(to(fn.NOT_FOUND_KEY, { key: e, locale: n })), e;
}
function pa(t10, e, n) {
  const i = t10;
  i.__localeChainCache = /* @__PURE__ */ new Map(), t10.localeFallbacker(t10, n, e);
}
function iS(t10, e) {
  return t10 === e ? false : t10.split("-")[0] === e.split("-")[0];
}
function LX(t10, e) {
  const n = e.indexOf(t10);
  if (n === -1)
    return false;
  for (let i = n + 1; i < e.length; i++)
    if (iS(t10, e[i]))
      return true;
  return false;
}
function Jf(t10) {
  return (n) => IX(n, t10);
}
function IX(t10, e) {
  const n = DX(e);
  if (n == null)
    throw El(
      0
      /* NodeTypes.Resource */
    );
  if (cg(n) === 1) {
    const r = RX(n);
    return t10.plural(r.reduce((o, a) => [
      ...o,
      I1(t10, a)
    ], []));
  } else
    return I1(t10, n);
}
var PX = ["b", "body"];
function DX(t10) {
  return hr(t10, PX);
}
var $X = ["c", "cases"];
function RX(t10) {
  return hr(t10, $X, []);
}
function I1(t10, e) {
  const n = VX(e);
  if (n != null)
    return t10.type === "text" ? n : t10.normalize([n]);
  {
    const i = zX(e).reduce((s, r) => [...s, gp(t10, r)], []);
    return t10.normalize(i);
  }
}
var FX = ["s", "static"];
function VX(t10) {
  return hr(t10, FX);
}
var BX = ["i", "items"];
function zX(t10) {
  return hr(t10, BX, []);
}
function gp(t10, e) {
  const n = cg(e);
  switch (n) {
    case 3:
      return yc(e, n);
    case 9:
      return yc(e, n);
    case 4: {
      const i = e;
      if (Ir(i, "k") && i.k)
        return t10.interpolate(t10.named(i.k));
      if (Ir(i, "key") && i.key)
        return t10.interpolate(t10.named(i.key));
      throw El(n);
    }
    case 5: {
      const i = e;
      if (Ir(i, "i") && pn(i.i))
        return t10.interpolate(t10.list(i.i));
      if (Ir(i, "index") && pn(i.index))
        return t10.interpolate(t10.list(i.index));
      throw El(n);
    }
    case 6: {
      const i = e, s = UX(i), r = KX(i);
      return t10.linked(gp(t10, r), s ? gp(t10, s) : void 0, t10.type);
    }
    case 7:
      return yc(e, n);
    case 8:
      return yc(e, n);
    default:
      throw new Error(`unhandled node on format message part: ${n}`);
  }
}
var jX = ["t", "type"];
function cg(t10) {
  return hr(t10, jX);
}
var HX = ["v", "value"];
function yc(t10, e) {
  const n = hr(t10, HX);
  if (n)
    return n;
  throw El(e);
}
var WX = ["m", "modifier"];
function UX(t10) {
  return hr(t10, WX);
}
var qX = ["k", "key"];
function KX(t10) {
  const e = hr(t10, qX);
  if (e)
    return e;
  throw El(
    6
    /* NodeTypes.Linked */
  );
}
function hr(t10, e, n) {
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    if (Ir(t10, s) && t10[s] != null)
      return t10[s];
  }
  return n;
}
function El(t10) {
  return new Error(`unhandled node type: ${t10}`);
}
var YX = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";
function sS(t10, e) {
  e && TJ(t10) && ta(z4(YX, { source: t10 }));
}
var rS = (t10) => t10;
var So = kn();
function oS(t10) {
  t10.code === Ud.USE_MODULO_SYNTAX && ta(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${t10.message})`);
}
function no(t10) {
  return jt(t10) && cg(t10) === 0 && (Ir(t10, "b") || Ir(t10, "body"));
}
function aS(t10, e = {}) {
  let n = false;
  const i = e.onError || EJ;
  return e.onError = (s) => {
    n = true, i(s);
  }, { ...XJ(t10, e), detectError: n };
}
var GX = (t10, e) => {
  if (!ze(t10))
    throw Fi(Ht.NOT_SUPPORT_NON_STRING_MESSAGE);
  e.onWarn = oS;
  {
    const n = mn(e.warnHtmlMessage) ? e.warnHtmlMessage : true;
    sS(t10, n);
    const s = (e.onCacheKey || rS)(t10), r = So[s];
    if (r)
      return r;
    const { code: o, detectError: a } = aS(t10, e), l = new Function(`return ${o}`)();
    return a ? l : So[s] = l;
  }
};
function JX(t10, e) {
  if (e.onWarn = oS, __INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && ze(t10)) {
    const n = mn(e.warnHtmlMessage) ? e.warnHtmlMessage : true;
    sS(t10, n);
    const s = (e.onCacheKey || rS)(t10), r = So[s];
    if (r)
      return r;
    const { ast: o, detectError: a } = aS(t10, {
      ...e,
      location: true,
      jit: true
    }), l = Jf(o);
    return a ? l : So[s] = l;
  } else {
    if (!no(t10))
      return ta(`the message that is resolve with key '${e.key}' is not supported for jit compilation`), () => t10;
    const n = t10.cacheKey;
    if (n) {
      const i = So[n];
      return i || (So[n] = Jf(t10));
    } else
      return Jf(t10);
  }
}
var P1 = () => "";
var ri = (t10) => zt(t10);
function D1(t10, ...e) {
  const { fallbackFormat: n, postTranslation: i, unresolving: s, messageCompiler: r, fallbackLocale: o, messages: a } = t10, [l, c] = bp(...e), u = mn(c.missingWarn) ? c.missingWarn : t10.missingWarn, d = mn(c.fallbackWarn) ? c.fallbackWarn : t10.fallbackWarn, f = mn(c.escapeParameter) ? c.escapeParameter : t10.escapeParameter, h10 = !!c.resolvedMessage, p = ze(c.default) || mn(c.default) ? mn(c.default) ? r ? l : () => l : c.default : n ? r ? l : () => l : "", g = n || p !== "", m = ag(t10, c);
  f && XX(c);
  let [b, x, k] = h10 ? [
    l,
    m,
    a[m] || kn()
  ] : lS(t10, l, m, o, d, u), v = b, S = l;
  if (!h10 && !(ze(v) || no(v) || ri(v)) && g && (v = p, S = v), !h10 && (!(ze(v) || no(v) || ri(v)) || !ze(x)))
    return s ? qd : l;
  if (ze(v) && t10.messageCompiler == null)
    return ta(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${l}'.`), l;
  let w = false;
  const E = () => {
    w = true;
  }, M = ri(v) ? v : cS(t10, l, x, v, S, E);
  if (w)
    return v;
  const N = tQ(t10, x, k, c), V = pX(N), Y = QX(t10, M, V), F = i ? i(Y, l) : Y;
  if (true) {
    const re = {
      timestamp: Date.now(),
      key: ze(l) ? l : ri(v) ? v.key : "",
      locale: x || (ri(v) ? v.locale : ""),
      format: ze(v) ? v : ri(v) ? v.source : "",
      message: F
    };
    re.meta = ea({}, t10.__meta, AX() || {}), bX(re);
  }
  return F;
}
function XX(t10) {
  Wi(t10.list) ? t10.list = t10.list.map((e) => ze(e) ? y1(e) : e) : jt(t10.named) && Object.keys(t10.named).forEach((e) => {
    ze(t10.named[e]) && (t10.named[e] = y1(t10.named[e]));
  });
}
function lS(t10, e, n, i, s, r) {
  const { messages: o, onWarn: a, messageResolver: l, localeFallbacker: c } = t10, u = c(t10, i, n);
  let d = kn(), f, h10 = null, p = n, g = null;
  const m = "translate";
  for (let b = 0; b < u.length; b++) {
    if (f = g = u[b], n !== f && !iS(n, f) && Kd(s, e) && a(to(fn.FALLBACK_TO_TRANSLATE, {
      key: e,
      target: f
    })), n !== f) {
      const S = t10.__v_emitter;
      S && S.emit("fallback", {
        type: m,
        key: e,
        from: p,
        to: g,
        groupId: `${m}:${e}`
      });
    }
    d = o[f] || kn();
    let x = null, k, v;
    if (Zr && (x = window.performance.now(), k = "intlify-message-resolve-start", v = "intlify-message-resolve-end", qn && qn(k)), (h10 = l(d, e)) === null && (h10 = d[e]), Zr) {
      const S = window.performance.now(), w = t10.__v_emitter;
      w && x && h10 && w.emit("message-resolve", {
        type: "message-resolve",
        key: e,
        message: h10,
        time: S - x,
        groupId: `${m}:${e}`
      }), k && v && qn && eo && (qn(v), eo("intlify message resolve", k, v));
    }
    if (ze(h10) || no(h10) || ri(h10))
      break;
    if (!LX(f, u)) {
      const S = lg(
        t10,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        e,
        f,
        r,
        m
      );
      S !== e && (h10 = S);
    }
    p = g;
  }
  return [h10, f, d];
}
function cS(t10, e, n, i, s, r) {
  const { messageCompiler: o, warnHtmlMessage: a } = t10;
  if (ri(i)) {
    const f = i;
    return f.locale = f.locale || n, f.key = f.key || e, f;
  }
  if (o == null) {
    const f = () => i;
    return f.locale = n, f.key = e, f;
  }
  let l = null, c, u;
  Zr && (l = window.performance.now(), c = "intlify-message-compilation-start", u = "intlify-message-compilation-end", qn && qn(c));
  const d = o(i, ZX(t10, n, s, i, a, r));
  if (Zr) {
    const f = window.performance.now(), h10 = t10.__v_emitter;
    h10 && l && h10.emit("message-compilation", {
      type: "message-compilation",
      message: i,
      time: f - l,
      groupId: `translate:${e}`
    }), c && u && qn && eo && (qn(u), eo("intlify message compilation", c, u));
  }
  return d.locale = n, d.key = e, d.source = i, d;
}
function QX(t10, e, n) {
  let i = null, s, r;
  Zr && (i = window.performance.now(), s = "intlify-message-evaluation-start", r = "intlify-message-evaluation-end", qn && qn(s));
  const o = e(n);
  if (Zr) {
    const a = window.performance.now(), l = t10.__v_emitter;
    l && i && l.emit("message-evaluation", {
      type: "message-evaluation",
      value: o,
      time: a - i,
      groupId: `translate:${e.key}`
    }), s && r && qn && eo && (qn(r), eo("intlify message evaluation", s, r));
  }
  return o;
}
function bp(...t10) {
  const [e, n, i] = t10, s = kn();
  if (!ze(e) && !pn(e) && !ri(e) && !no(e))
    throw Fi(Ht.INVALID_ARGUMENT);
  const r = pn(e) ? String(e) : (ri(e), e);
  return pn(n) ? s.plural = n : ze(n) ? s.default = n : yt(n) && !rg(n) ? s.named = n : Wi(n) && (s.list = n), pn(i) ? s.plural = i : ze(i) ? s.default = i : yt(i) && ea(s, i), [r, s];
}
function ZX(t10, e, n, i, s, r) {
  return {
    locale: e,
    key: n,
    warnHtmlMessage: s,
    onError: (o) => {
      if (r && r(o), true) {
        const a = eQ(i), l = `Message compilation error: ${o.message}`, c = o.location && a && yJ(a, o.location.start.offset, o.location.end.offset), u = t10.__v_emitter;
        u && a && u.emit("compile-error", {
          message: a,
          error: o.message,
          start: o.location && o.location.start.offset,
          end: o.location && o.location.end.offset,
          groupId: `translate:${n}`
        }), console.error(c ? `${l}
${c}` : l);
      } else
        throw o;
    },
    onCacheKey: (o) => uJ(e, n, o)
  };
}
function eQ(t10) {
  if (ze(t10))
    return t10;
  if (t10.loc && t10.loc.source)
    return t10.loc.source;
}
function tQ(t10, e, n, i) {
  const { modifiers: s, pluralRules: r, messageResolver: o, fallbackLocale: a, fallbackWarn: l, missingWarn: c, fallbackContext: u } = t10, f = {
    locale: e,
    modifiers: s,
    pluralRules: r,
    messages: (h10) => {
      let p = o(n, h10);
      if (p == null && u) {
        const [, , g] = lS(u, h10, e, a, l, c);
        p = o(g, h10);
      }
      if (ze(p) || no(p)) {
        let g = false;
        const b = cS(t10, h10, e, p, h10, () => {
          g = true;
        });
        return g ? P1 : b;
      } else return ri(p) ? p : P1;
    }
  };
  return t10.processor && (f.processor = t10.processor), i.list && (f.list = i.list), i.named && (f.named = i.named), pn(i.plural) && (f.pluralIndex = i.plural), f;
}
var $1 = typeof Intl < "u";
var uS = {
  dateTimeFormat: $1 && typeof Intl.DateTimeFormat < "u",
  numberFormat: $1 && typeof Intl.NumberFormat < "u"
};
function R1(t10, ...e) {
  const { datetimeFormats: n, unresolving: i, fallbackLocale: s, onWarn: r, localeFallbacker: o } = t10, { __datetimeFormatters: a } = t10;
  if (!uS.dateTimeFormat)
    return r(to(fn.CANNOT_FORMAT_DATE)), Qu;
  const [l, c, u, d] = yp(...e), f = mn(u.missingWarn) ? u.missingWarn : t10.missingWarn, h10 = mn(u.fallbackWarn) ? u.fallbackWarn : t10.fallbackWarn, p = !!u.part, g = ag(t10, u), m = o(
    t10,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    s,
    g
  );
  if (!ze(l) || l === "")
    return new Intl.DateTimeFormat(g, d).format(c);
  let b = {}, x, k = null, v = g, S = null;
  const w = "datetime format";
  for (let N = 0; N < m.length; N++) {
    if (x = S = m[N], g !== x && Kd(h10, l) && r(to(fn.FALLBACK_TO_DATE_FORMAT, {
      key: l,
      target: x
    })), g !== x) {
      const V = t10.__v_emitter;
      V && V.emit("fallback", {
        type: w,
        key: l,
        from: v,
        to: S,
        groupId: `${w}:${l}`
      });
    }
    if (b = n[x] || {}, k = b[l], yt(k))
      break;
    lg(t10, l, x, f, w), v = S;
  }
  if (!yt(k) || !ze(x))
    return i ? qd : l;
  let E = `${x}__${l}`;
  rg(d) || (E = `${E}__${JSON.stringify(d)}`);
  let M = a.get(E);
  return M || (M = new Intl.DateTimeFormat(x, ea({}, k, d)), a.set(E, M)), p ? M.formatToParts(c) : M.format(c);
}
var dS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function yp(...t10) {
  const [e, n, i, s] = t10, r = kn();
  let o = kn(), a;
  if (ze(e)) {
    const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!l)
      throw Fi(Ht.INVALID_ISO_DATE_ARGUMENT);
    const c = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
    a = new Date(c);
    try {
      a.toISOString();
    } catch {
      throw Fi(Ht.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (fJ(e)) {
    if (isNaN(e.getTime()))
      throw Fi(Ht.INVALID_DATE_ARGUMENT);
    a = e;
  } else if (pn(e))
    a = e;
  else
    throw Fi(Ht.INVALID_ARGUMENT);
  return ze(n) ? r.key = n : yt(n) && Object.keys(n).forEach((l) => {
    dS.includes(l) ? o[l] = n[l] : r[l] = n[l];
  }), ze(i) ? r.locale = i : yt(i) && (o = i), yt(s) && (o = s), [r.key || "", a, r, o];
}
function F1(t10, e, n) {
  const i = t10;
  for (const s in n) {
    const r = `${e}__${s}`;
    i.__datetimeFormatters.has(r) && i.__datetimeFormatters.delete(r);
  }
}
function V1(t10, ...e) {
  const { numberFormats: n, unresolving: i, fallbackLocale: s, onWarn: r, localeFallbacker: o } = t10, { __numberFormatters: a } = t10;
  if (!uS.numberFormat)
    return r(to(fn.CANNOT_FORMAT_NUMBER)), Qu;
  const [l, c, u, d] = vp(...e), f = mn(u.missingWarn) ? u.missingWarn : t10.missingWarn, h10 = mn(u.fallbackWarn) ? u.fallbackWarn : t10.fallbackWarn, p = !!u.part, g = ag(t10, u), m = o(
    t10,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    s,
    g
  );
  if (!ze(l) || l === "")
    return new Intl.NumberFormat(g, d).format(c);
  let b = {}, x, k = null, v = g, S = null;
  const w = "number format";
  for (let N = 0; N < m.length; N++) {
    if (x = S = m[N], g !== x && Kd(h10, l) && r(to(fn.FALLBACK_TO_NUMBER_FORMAT, {
      key: l,
      target: x
    })), g !== x) {
      const V = t10.__v_emitter;
      V && V.emit("fallback", {
        type: w,
        key: l,
        from: v,
        to: S,
        groupId: `${w}:${l}`
      });
    }
    if (b = n[x] || {}, k = b[l], yt(k))
      break;
    lg(t10, l, x, f, w), v = S;
  }
  if (!yt(k) || !ze(x))
    return i ? qd : l;
  let E = `${x}__${l}`;
  rg(d) || (E = `${E}__${JSON.stringify(d)}`);
  let M = a.get(E);
  return M || (M = new Intl.NumberFormat(x, ea({}, k, d)), a.set(E, M)), p ? M.formatToParts(c) : M.format(c);
}
var fS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function vp(...t10) {
  const [e, n, i, s] = t10, r = kn();
  let o = kn();
  if (!pn(e))
    throw Fi(Ht.INVALID_ARGUMENT);
  const a = e;
  return ze(n) ? r.key = n : yt(n) && Object.keys(n).forEach((l) => {
    fS.includes(l) ? o[l] = n[l] : r[l] = n[l];
  }), ze(i) ? r.locale = i : yt(i) && (o = i), yt(s) && (o = s), [r.key || "", a, r, o];
}
function B1(t10, e, n) {
  const i = t10;
  for (const s in n) {
    const r = `${e}__${s}`;
    i.__numberFormatters.has(r) && i.__numberFormatters.delete(r);
  }
}
QJ();
var nQ = "9.14.3";
function iQ() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (go().__VUE_I18N_FULL_INSTALL__ = true), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (go().__VUE_I18N_LEGACY_API__ = true), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (go().__INTLIFY_JIT_COMPILATION__ = false), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (go().__INTLIFY_DROP_MESSAGE_COMPILER__ = false), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (go().__INTLIFY_PROD_DEVTOOLS__ = false);
}
var hS = fn.__EXTEND_POINT__;
var ns = B4(hS);
var En = {
  FALLBACK_TO_ROOT: hS,
  // 9
  NOT_SUPPORTED_PRESERVE: ns(),
  // 10
  NOT_SUPPORTED_FORMATTER: ns(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: ns(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: ns(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: ns(),
  // 14
  NOT_FOUND_PARENT_SCOPE: ns(),
  // 15
  IGNORE_OBJ_FLATTEN: ns(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: ns(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: ns()
  // 18
};
var sQ = {
  [En.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
  [En.NOT_SUPPORTED_PRESERVE]: "Not supported 'preserve'.",
  [En.NOT_SUPPORTED_FORMATTER]: "Not supported 'formatter'.",
  [En.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: "Not supported 'preserveDirectiveContent'.",
  [En.NOT_SUPPORTED_GET_CHOICE_INDEX]: "Not supported 'getChoiceIndex'.",
  [En.COMPONENT_NAME_LEGACY_COMPATIBLE]: "Component name legacy compatible: '{name}' -> 'i18n'",
  [En.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope.",
  [En.IGNORE_OBJ_FLATTEN]: "Ignore object flatten: '{key}' key has an string value",
  [En.NOTICE_DROP_ALLOW_COMPOSITION]: "'allowComposition' option will be dropped in the next major version. For more information, please see 👉 https://tinyurl.com/2p97mcze",
  [En.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: "'translateExistCompatible' option will be dropped in the next major version."
};
function Zu(t10, ...e) {
  return tJ(sQ[t10], ...e);
}
var pS = Ht.__EXTEND_POINT__;
var Cn = B4(pS);
var kt = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: pS,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: Cn(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: Cn(),
  // 26
  NOT_INSTALLED: Cn(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: Cn(),
  // 28
  // directive module errors
  REQUIRED_VALUE: Cn(),
  // 29
  INVALID_VALUE: Cn(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: Cn(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: Cn(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: Cn(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: Cn(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: Cn(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: Cn(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: Cn(),
  // 37
  // for enhancement
  __EXTEND_POINT__: Cn()
  // 38
};
function Js(t10, ...e) {
  return na(t10, null, true ? { messages: rQ, args: e } : void 0);
}
var rQ = {
  [kt.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [kt.INVALID_ARGUMENT]: "Invalid argument",
  [kt.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [kt.NOT_INSTALLED]: "Need to install with `app.use` function",
  [kt.UNEXPECTED_ERROR]: "Unexpected error",
  [kt.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [kt.REQUIRED_VALUE]: "Required in value: {0}",
  [kt.INVALID_VALUE]: "Invalid value",
  [kt.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
  [kt.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [kt.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [kt.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [kt.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode",
  [kt.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
};
var xp = Cs("__translateVNode");
var kp = Cs("__datetimeParts");
var Sp = Cs("__numberParts");
var wp = Cs("__enableEmitter");
var Cp = Cs("__disableEmitter");
var oQ = Cs("__setPluralRules");
var mS = Cs("__injectWithOption");
var Op = Cs("__dispose");
function Ml(t10) {
  if (!rn(t10))
    return t10;
  for (const e in t10)
    if (Ju(t10, e))
      if (!e.includes("."))
        rn(t10[e]) && Ml(t10[e]);
      else {
        const n = e.split("."), i = n.length - 1;
        let s = t10, r = false;
        for (let o = 0; o < i; o++) {
          if (n[o] === "__proto__")
            throw new Error(`unsafe key: ${n[o]}`);
          if (n[o] in s || (s[n[o]] = Ln()), !rn(s[n[o]])) {
            Wd(Zu(En.IGNORE_OBJ_FLATTEN, {
              key: n[o]
            })), r = true;
            break;
          }
          s = s[n[o]];
        }
        r || (s[n[i]] = t10[e], delete t10[e]), rn(s[n[i]]) && Ml(s[n[i]]);
      }
  return t10;
}
function ug(t10, e) {
  const { messages: n, __i18n: i, messageResolver: s, flatJson: r } = e, o = jn(n) ? n : Ri(i) ? Ln() : { [t10]: Ln() };
  if (Ri(i) && i.forEach((a) => {
    if ("locale" in a && "resource" in a) {
      const { locale: l, resource: c } = a;
      l ? (o[l] = o[l] || Ln(), Dc(c, o[l])) : Dc(c, o);
    } else
      Mt(a) && Dc(JSON.parse(a), o);
  }), s == null && r)
    for (const a in o)
      Ju(o, a) && Ml(o[a]);
  return o;
}
function gS(t10) {
  return t10.type;
}
function aQ(t10, e, n) {
  let i = rn(e.messages) ? e.messages : Ln();
  "__i18nGlobal" in n && (i = ug(t10.locale.value, {
    messages: i,
    __i18n: n.__i18nGlobal
  }));
  const s = Object.keys(i);
  s.length && s.forEach((r) => {
    t10.mergeLocaleMessage(r, i[r]);
  });
  {
    if (rn(e.datetimeFormats)) {
      const r = Object.keys(e.datetimeFormats);
      r.length && r.forEach((o) => {
        t10.mergeDateTimeFormat(o, e.datetimeFormats[o]);
      });
    }
    if (rn(e.numberFormats)) {
      const r = Object.keys(e.numberFormats);
      r.length && r.forEach((o) => {
        t10.mergeNumberFormat(o, e.numberFormats[o]);
      });
    }
  }
}
function z1(t10) {
  return createVNode(Text, null, t10, 0);
}
var H1 = () => [];
var lQ = () => false;
var W1 = 0;
function U1(t10) {
  return (e, n, i, s) => t10(n, i, getCurrentInstance() || void 0, s);
}
function uQ(t10 = {}, e) {
  const { __root: n, __injectWithOption: i } = t10, s = n === void 0, r = t10.flatJson, o = h1 ? ref : shallowRef, a = !!t10.translateExistCompatible;
  a && aJ(Zu(En.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
  let l = si(t10.inheritLocale) ? t10.inheritLocale : true;
  const c = o(
    // prettier-ignore
    n && l ? n.locale.value : Mt(t10.locale) ? t10.locale : Ol
  ), u = o(
    // prettier-ignore
    n && l ? n.fallbackLocale.value : Mt(t10.fallbackLocale) || Ri(t10.fallbackLocale) || jn(t10.fallbackLocale) || t10.fallbackLocale === false ? t10.fallbackLocale : c.value
  ), d = o(ug(c.value, t10)), f = o(jn(t10.datetimeFormats) ? t10.datetimeFormats : { [c.value]: {} }), h10 = o(jn(t10.numberFormats) ? t10.numberFormats : { [c.value]: {} });
  let p = n ? n.missingWarn : si(t10.missingWarn) || Gu(t10.missingWarn) ? t10.missingWarn : true, g = n ? n.fallbackWarn : si(t10.fallbackWarn) || Gu(t10.fallbackWarn) ? t10.fallbackWarn : true, m = n ? n.fallbackRoot : si(t10.fallbackRoot) ? t10.fallbackRoot : true, b = !!t10.fallbackFormat, x = ko(t10.missing) ? t10.missing : null, k = ko(t10.missing) ? U1(t10.missing) : null, v = ko(t10.postTranslation) ? t10.postTranslation : null, S = n ? n.warnHtmlMessage : si(t10.warnHtmlMessage) ? t10.warnHtmlMessage : true, w = !!t10.escapeParameter;
  const E = n ? n.modifiers : jn(t10.modifiers) ? t10.modifiers : {};
  let M = t10.pluralRules || n && n.pluralRules, N;
  N = (() => {
    s && N1(null);
    const Z = {
      version: nQ,
      locale: c.value,
      fallbackLocale: u.value,
      messages: d.value,
      modifiers: E,
      pluralRules: M,
      missing: k === null ? void 0 : k,
      missingWarn: p,
      fallbackWarn: g,
      fallbackFormat: b,
      unresolving: true,
      postTranslation: v === null ? void 0 : v,
      warnHtmlMessage: S,
      escapeParameter: w,
      messageResolver: t10.messageResolver,
      messageCompiler: t10.messageCompiler,
      __meta: { framework: "vue" }
    };
    Z.datetimeFormats = f.value, Z.numberFormats = h10.value, Z.__datetimeFormatters = jn(N) ? N.__datetimeFormatters : void 0, Z.__numberFormatters = jn(N) ? N.__numberFormatters : void 0, Z.__v_emitter = jn(N) ? N.__v_emitter : void 0;
    const ue = NX(Z);
    return s && N1(ue), ue;
  })(), pa(N, c.value, u.value);
  function Y() {
    return [
      c.value,
      u.value,
      d.value,
      f.value,
      h10.value
    ];
  }
  const F = computed({
    get: () => c.value,
    set: (Z) => {
      c.value = Z, N.locale = c.value;
    }
  }), re = computed({
    get: () => u.value,
    set: (Z) => {
      u.value = Z, N.fallbackLocale = u.value, pa(N, c.value, Z);
    }
  }), z = computed(() => d.value), W = computed(() => f.value), C = computed(() => h10.value);
  function O() {
    return ko(v) ? v : null;
  }
  function _(Z) {
    v = Z, N.postTranslation = Z;
  }
  function T() {
    return x;
  }
  function H(Z) {
    Z !== null && (k = U1(Z)), x = Z, N.missing = k;
  }
  function Q(Z, ue) {
    return Z !== "translate" || !ue.resolvedMessage;
  }
  const ae = (Z, ue, Xe, ht, U, q) => {
    Y();
    let se;
    try {
      true, s || (N.fallbackContext = n ? _X() : void 0), se = Z(N);
    } finally {
      true, s || (N.fallbackContext = void 0);
    }
    if (Xe !== "translate exists" && // for not `te` (e.g `t`)
    mp(se) && se === qd || Xe === "translate exists" && !se) {
      const [R, ie] = ue();
      if (n && Mt(R) && Q(Xe, ie) && (m && (Kd(g, R) || nS(p, R)) && Wd(Zu(En.FALLBACK_TO_ROOT, {
        key: R,
        type: Xe
      })), true)) {
        const { __v_emitter: de } = N;
        de && m && de.emit("fallback", {
          type: Xe,
          key: R,
          to: "global",
          groupId: `${Xe}:${R}`
        });
      }
      return n && m ? ht(n) : U(R);
    } else {
      if (q(se))
        return se;
      throw Js(kt.UNEXPECTED_RETURN_TYPE);
    }
  };
  function pe(...Z) {
    return ae((ue) => Reflect.apply(D1, null, [ue, ...Z]), () => bp(...Z), "translate", (ue) => Reflect.apply(ue.t, ue, [...Z]), (ue) => ue, (ue) => Mt(ue));
  }
  function xe(...Z) {
    const [ue, Xe, ht] = Z;
    if (ht && !rn(ht))
      throw Js(kt.INVALID_ARGUMENT);
    return pe(ue, Xe, Hi({ resolvedMessage: true }, ht || {}));
  }
  function Te(...Z) {
    return ae((ue) => Reflect.apply(R1, null, [ue, ...Z]), () => yp(...Z), "datetime format", (ue) => Reflect.apply(ue.d, ue, [...Z]), () => Qu, (ue) => Mt(ue));
  }
  function L(...Z) {
    return ae((ue) => Reflect.apply(V1, null, [ue, ...Z]), () => vp(...Z), "number format", (ue) => Reflect.apply(ue.n, ue, [...Z]), () => Qu, (ue) => Mt(ue));
  }
  function K(Z) {
    return Z.map((ue) => Mt(ue) || mp(ue) || si(ue) ? z1(String(ue)) : ue);
  }
  const X = {
    normalize: K,
    interpolate: (Z) => Z,
    type: "vnode"
  };
  function be(...Z) {
    return ae(
      (ue) => {
        let Xe;
        const ht = ue;
        try {
          ht.processor = X, Xe = Reflect.apply(D1, null, [ht, ...Z]);
        } finally {
          ht.processor = null;
        }
        return Xe;
      },
      () => bp(...Z),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (ue) => ue[xp](...Z),
      (ue) => [z1(ue)],
      (ue) => Ri(ue)
    );
  }
  function Ce(...Z) {
    return ae(
      (ue) => Reflect.apply(V1, null, [ue, ...Z]),
      () => vp(...Z),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (ue) => ue[Sp](...Z),
      H1,
      (ue) => Mt(ue) || Ri(ue)
    );
  }
  function Oe(...Z) {
    return ae(
      (ue) => Reflect.apply(R1, null, [ue, ...Z]),
      () => yp(...Z),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (ue) => ue[kp](...Z),
      H1,
      (ue) => Mt(ue) || Ri(ue)
    );
  }
  function Ue(Z) {
    M = Z, N.pluralRules = M;
  }
  function J(Z, ue) {
    return ae(() => {
      if (!Z)
        return false;
      const Xe = Mt(ue) ? ue : c.value, ht = Ct(Xe), U = N.messageResolver(ht, Z);
      return a ? U != null : no(U) || ri(U) || Mt(U);
    }, () => [Z], "translate exists", (Xe) => Reflect.apply(Xe.te, Xe, [Z, ue]), lQ, (Xe) => si(Xe));
  }
  function Fe(Z) {
    let ue = null;
    const Xe = J4(N, u.value, c.value);
    for (let ht = 0; ht < Xe.length; ht++) {
      const U = d.value[Xe[ht]] || {}, q = N.messageResolver(U, Z);
      if (q != null) {
        ue = q;
        break;
      }
    }
    return ue;
  }
  function xt(Z) {
    const ue = Fe(Z);
    return ue ?? (n ? n.tm(Z) || {} : {});
  }
  function Ct(Z) {
    return d.value[Z] || {};
  }
  function Pt(Z, ue) {
    if (r) {
      const Xe = { [Z]: ue };
      for (const ht in Xe)
        Ju(Xe, ht) && Ml(Xe[ht]);
      ue = Xe[Z];
    }
    d.value[Z] = ue, N.messages = d.value;
  }
  function un(Z, ue) {
    d.value[Z] = d.value[Z] || {};
    const Xe = { [Z]: ue };
    if (r)
      for (const ht in Xe)
        Ju(Xe, ht) && Ml(Xe[ht]);
    ue = Xe[Z], Dc(ue, d.value[Z]), N.messages = d.value;
  }
  function I(Z) {
    return f.value[Z] || {};
  }
  function $(Z, ue) {
    f.value[Z] = ue, N.datetimeFormats = f.value, F1(N, Z, ue);
  }
  function ne(Z, ue) {
    f.value[Z] = Hi(f.value[Z] || {}, ue), N.datetimeFormats = f.value, F1(N, Z, ue);
  }
  function Se(Z) {
    return h10.value[Z] || {};
  }
  function Ze(Z, ue) {
    h10.value[Z] = ue, N.numberFormats = h10.value, B1(N, Z, ue);
  }
  function Qe(Z, ue) {
    h10.value[Z] = Hi(h10.value[Z] || {}, ue), N.numberFormats = h10.value, B1(N, Z, ue);
  }
  W1++, n && h1 && (watch(n.locale, (Z) => {
    l && (c.value = Z, N.locale = Z, pa(N, c.value, u.value));
  }), watch(n.fallbackLocale, (Z) => {
    l && (u.value = Z, N.fallbackLocale = Z, pa(N, c.value, u.value));
  }));
  const Ye = {
    id: W1,
    locale: F,
    fallbackLocale: re,
    get inheritLocale() {
      return l;
    },
    set inheritLocale(Z) {
      l = Z, Z && n && (c.value = n.locale.value, u.value = n.fallbackLocale.value, pa(N, c.value, u.value));
    },
    get availableLocales() {
      return Object.keys(d.value).sort();
    },
    messages: z,
    get modifiers() {
      return E;
    },
    get pluralRules() {
      return M || {};
    },
    get isGlobal() {
      return s;
    },
    get missingWarn() {
      return p;
    },
    set missingWarn(Z) {
      p = Z, N.missingWarn = p;
    },
    get fallbackWarn() {
      return g;
    },
    set fallbackWarn(Z) {
      g = Z, N.fallbackWarn = g;
    },
    get fallbackRoot() {
      return m;
    },
    set fallbackRoot(Z) {
      m = Z;
    },
    get fallbackFormat() {
      return b;
    },
    set fallbackFormat(Z) {
      b = Z, N.fallbackFormat = b;
    },
    get warnHtmlMessage() {
      return S;
    },
    set warnHtmlMessage(Z) {
      S = Z, N.warnHtmlMessage = Z;
    },
    get escapeParameter() {
      return w;
    },
    set escapeParameter(Z) {
      w = Z, N.escapeParameter = Z;
    },
    t: pe,
    getLocaleMessage: Ct,
    setLocaleMessage: Pt,
    mergeLocaleMessage: un,
    getPostTranslationHandler: O,
    setPostTranslationHandler: _,
    getMissingHandler: T,
    setMissingHandler: H,
    [oQ]: Ue
  };
  return Ye.datetimeFormats = W, Ye.numberFormats = C, Ye.rt = xe, Ye.te = J, Ye.tm = xt, Ye.d = Te, Ye.n = L, Ye.getDateTimeFormat = I, Ye.setDateTimeFormat = $, Ye.mergeDateTimeFormat = ne, Ye.getNumberFormat = Se, Ye.setNumberFormat = Ze, Ye.mergeNumberFormat = Qe, Ye[mS] = i, Ye[xp] = be, Ye[kp] = Oe, Ye[Sp] = Ce, Ye[wp] = (Z) => {
    N.__v_emitter = Z;
  }, Ye[Cp] = () => {
    N.__v_emitter = void 0;
  }, Ye;
}
var dg = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (t10) => t10 === "parent" || t10 === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
Hi({
  keypath: {
    type: String,
    required: true
  },
  plural: {
    type: [Number, String],
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    validator: (t10) => mp(t10) || !isNaN(t10)
  }
}, dg);
Hi({
  value: {
    type: Number,
    required: true
  },
  format: {
    type: [String, Object]
  }
}, dg);
Hi({
  value: {
    type: [Number, Date],
    required: true
  },
  format: {
    type: [String, Object]
  }
}, dg);
function q1(t10, e) {
}
var hQ = Cs("global-vue-i18n");
function Yd(t10 = {}) {
  const e = getCurrentInstance();
  if (e == null)
    throw Js(kt.MUST_BE_CALL_SETUP_TOP);
  if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__)
    throw Js(kt.NOT_INSTALLED);
  const n = pQ(e), i = gQ(n), s = gS(e), r = mQ(t10, s);
  if (__VUE_I18N_LEGACY_API__ && n.mode === "legacy" && !t10.__useComponent) {
    if (!n.allowComposition)
      throw Js(kt.NOT_AVAILABLE_IN_LEGACY_MODE);
    return xQ(e, r, i, t10);
  }
  if (r === "global")
    return aQ(i, t10, s), i;
  if (r === "parent") {
    let l = bQ(n, e, t10.__useComponent);
    return l == null && (Wd(Zu(En.NOT_FOUND_PARENT_SCOPE)), l = i), l;
  }
  const o = n;
  let a = o.__getInstance(e);
  if (a == null) {
    const l = Hi({}, t10);
    "__i18n" in s && (l.__i18n = s.__i18n), i && (l.__root = i), a = uQ(l), o.__composerExtend && (a[Op] = o.__composerExtend(a)), vQ(o, e, a), o.__setInstance(e, a);
  }
  return a;
}
function pQ(t10) {
  {
    const e = inject(t10.isCE ? hQ : t10.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e)
      throw Js(t10.isCE ? kt.NOT_INSTALLED_WITH_PROVIDE : kt.UNEXPECTED_ERROR);
    return e;
  }
}
function mQ(t10, e) {
  return nJ(t10) ? "__i18n" in e ? "local" : "global" : t10.useScope ? t10.useScope : "local";
}
function gQ(t10) {
  return t10.mode === "composition" ? t10.global : t10.global.__composer;
}
function bQ(t10, e, n = false) {
  let i = null;
  const s = e.root;
  let r = yQ(e, n);
  for (; r != null; ) {
    const o = t10;
    if (t10.mode === "composition")
      i = o.__getInstance(r);
    else if (__VUE_I18N_LEGACY_API__) {
      const a = o.__getInstance(r);
      a != null && (i = a.__composer, n && i && !i[mS] && (i = null));
    }
    if (i != null || s === r)
      break;
    r = r.parent;
  }
  return i;
}
function yQ(t10, e = false) {
  return t10 == null ? null : e && t10.vnode.ctx || t10.parent;
}
function vQ(t10, e, n) {
  let i = null;
  onMounted(() => {
    if (e.vnode.el) {
      e.vnode.el.__VUE_I18N__ = n, i = lJ();
      const s = n;
      s[wp] && s[wp](i), i.on("*", q1);
    }
  }, e), onUnmounted(() => {
    const s = n;
    e.vnode.el && e.vnode.el.__VUE_I18N__ && (i && i.off("*", q1), s[Cp] && s[Cp](), delete e.vnode.el.__VUE_I18N__), t10.__deleteInstance(e);
    const r = s[Op];
    r && (r(), delete s[Op]);
  }, e);
}
function xQ(t10, e, n, i = {}) {
  const s = e === "local", r = shallowRef(null);
  if (s && t10.proxy && !(t10.proxy.$options.i18n || t10.proxy.$options.__i18n))
    throw Js(kt.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  const o = si(i.inheritLocale) ? i.inheritLocale : !Mt(i.locale), a = ref(
    // prettier-ignore
    !s || o ? n.locale.value : Mt(i.locale) ? i.locale : Ol
  ), l = ref(
    // prettier-ignore
    !s || o ? n.fallbackLocale.value : Mt(i.fallbackLocale) || Ri(i.fallbackLocale) || jn(i.fallbackLocale) || i.fallbackLocale === false ? i.fallbackLocale : a.value
  ), c = ref(ug(a.value, i)), u = ref(jn(i.datetimeFormats) ? i.datetimeFormats : { [a.value]: {} }), d = ref(jn(i.numberFormats) ? i.numberFormats : { [a.value]: {} }), f = s ? n.missingWarn : si(i.missingWarn) || Gu(i.missingWarn) ? i.missingWarn : true, h10 = s ? n.fallbackWarn : si(i.fallbackWarn) || Gu(i.fallbackWarn) ? i.fallbackWarn : true, p = s ? n.fallbackRoot : si(i.fallbackRoot) ? i.fallbackRoot : true, g = !!i.fallbackFormat, m = ko(i.missing) ? i.missing : null, b = ko(i.postTranslation) ? i.postTranslation : null, x = s ? n.warnHtmlMessage : si(i.warnHtmlMessage) ? i.warnHtmlMessage : true, k = !!i.escapeParameter, v = s ? n.modifiers : jn(i.modifiers) ? i.modifiers : {}, S = i.pluralRules || s && n.pluralRules;
  function w() {
    return [
      a.value,
      l.value,
      c.value,
      u.value,
      d.value
    ];
  }
  const E = computed({
    get: () => r.value ? r.value.locale.value : a.value,
    set: (J) => {
      r.value && (r.value.locale.value = J), a.value = J;
    }
  }), M = computed({
    get: () => r.value ? r.value.fallbackLocale.value : l.value,
    set: (J) => {
      r.value && (r.value.fallbackLocale.value = J), l.value = J;
    }
  }), N = computed(() => r.value ? r.value.messages.value : c.value), V = computed(() => u.value), Y = computed(() => d.value);
  function F() {
    return r.value ? r.value.getPostTranslationHandler() : b;
  }
  function re(J) {
    r.value && r.value.setPostTranslationHandler(J);
  }
  function z() {
    return r.value ? r.value.getMissingHandler() : m;
  }
  function W(J) {
    r.value && r.value.setMissingHandler(J);
  }
  function C(J) {
    return w(), J();
  }
  function O(...J) {
    return r.value ? C(() => Reflect.apply(r.value.t, null, [...J])) : C(() => "");
  }
  function _(...J) {
    return r.value ? Reflect.apply(r.value.rt, null, [...J]) : "";
  }
  function T(...J) {
    return r.value ? C(() => Reflect.apply(r.value.d, null, [...J])) : C(() => "");
  }
  function H(...J) {
    return r.value ? C(() => Reflect.apply(r.value.n, null, [...J])) : C(() => "");
  }
  function Q(J) {
    return r.value ? r.value.tm(J) : {};
  }
  function ae(J, Fe) {
    return r.value ? r.value.te(J, Fe) : false;
  }
  function pe(J) {
    return r.value ? r.value.getLocaleMessage(J) : {};
  }
  function xe(J, Fe) {
    r.value && (r.value.setLocaleMessage(J, Fe), c.value[J] = Fe);
  }
  function Te(J, Fe) {
    r.value && r.value.mergeLocaleMessage(J, Fe);
  }
  function L(J) {
    return r.value ? r.value.getDateTimeFormat(J) : {};
  }
  function K(J, Fe) {
    r.value && (r.value.setDateTimeFormat(J, Fe), u.value[J] = Fe);
  }
  function B(J, Fe) {
    r.value && r.value.mergeDateTimeFormat(J, Fe);
  }
  function X(J) {
    return r.value ? r.value.getNumberFormat(J) : {};
  }
  function be(J, Fe) {
    r.value && (r.value.setNumberFormat(J, Fe), d.value[J] = Fe);
  }
  function Ce(J, Fe) {
    r.value && r.value.mergeNumberFormat(J, Fe);
  }
  const Oe = {
    get id() {
      return r.value ? r.value.id : -1;
    },
    locale: E,
    fallbackLocale: M,
    messages: N,
    datetimeFormats: V,
    numberFormats: Y,
    get inheritLocale() {
      return r.value ? r.value.inheritLocale : o;
    },
    set inheritLocale(J) {
      r.value && (r.value.inheritLocale = J);
    },
    get availableLocales() {
      return r.value ? r.value.availableLocales : Object.keys(c.value);
    },
    get modifiers() {
      return r.value ? r.value.modifiers : v;
    },
    get pluralRules() {
      return r.value ? r.value.pluralRules : S;
    },
    get isGlobal() {
      return r.value ? r.value.isGlobal : false;
    },
    get missingWarn() {
      return r.value ? r.value.missingWarn : f;
    },
    set missingWarn(J) {
      r.value && (r.value.missingWarn = J);
    },
    get fallbackWarn() {
      return r.value ? r.value.fallbackWarn : h10;
    },
    set fallbackWarn(J) {
      r.value && (r.value.missingWarn = J);
    },
    get fallbackRoot() {
      return r.value ? r.value.fallbackRoot : p;
    },
    set fallbackRoot(J) {
      r.value && (r.value.fallbackRoot = J);
    },
    get fallbackFormat() {
      return r.value ? r.value.fallbackFormat : g;
    },
    set fallbackFormat(J) {
      r.value && (r.value.fallbackFormat = J);
    },
    get warnHtmlMessage() {
      return r.value ? r.value.warnHtmlMessage : x;
    },
    set warnHtmlMessage(J) {
      r.value && (r.value.warnHtmlMessage = J);
    },
    get escapeParameter() {
      return r.value ? r.value.escapeParameter : k;
    },
    set escapeParameter(J) {
      r.value && (r.value.escapeParameter = J);
    },
    t: O,
    getPostTranslationHandler: F,
    setPostTranslationHandler: re,
    getMissingHandler: z,
    setMissingHandler: W,
    rt: _,
    d: T,
    n: H,
    tm: Q,
    te: ae,
    getLocaleMessage: pe,
    setLocaleMessage: xe,
    mergeLocaleMessage: Te,
    getDateTimeFormat: L,
    setDateTimeFormat: K,
    mergeDateTimeFormat: B,
    getNumberFormat: X,
    setNumberFormat: be,
    mergeNumberFormat: Ce
  };
  function Ue(J) {
    J.locale.value = a.value, J.fallbackLocale.value = l.value, Object.keys(c.value).forEach((Fe) => {
      J.mergeLocaleMessage(Fe, c.value[Fe]);
    }), Object.keys(u.value).forEach((Fe) => {
      J.mergeDateTimeFormat(Fe, u.value[Fe]);
    }), Object.keys(d.value).forEach((Fe) => {
      J.mergeNumberFormat(Fe, d.value[Fe]);
    }), J.escapeParameter = k, J.fallbackFormat = g, J.fallbackRoot = p, J.fallbackWarn = h10, J.missingWarn = f, J.warnHtmlMessage = x;
  }
  return onBeforeMount(() => {
    if (t10.proxy == null || t10.proxy.$i18n == null)
      throw Js(kt.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    const J = r.value = t10.proxy.$i18n.__composer;
    e === "global" ? (a.value = J.locale.value, l.value = J.fallbackLocale.value, c.value = J.messages.value, u.value = J.datetimeFormats.value, d.value = J.numberFormats.value) : s && Ue(J);
  }), Oe;
}
iQ();
__INTLIFY_JIT_COMPILATION__ ? _1(JX) : _1(GX);
EX(oX);
MX(J4);
if (true) {
  const t10 = go();
  t10.__INTLIFY__ = true, mX(t10.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
var zZ = Object.assign({ name: "mn-app-locale" }, {
  __name: "app-locale",
  setup(t10) {
    const e = inject("minuit"), { locale: n, availableLocales: i } = Yd();
    function s(r) {
      e.value.locale = r, n.value = r;
    }
    return (r, o) => (openBlock(), createBlock(Yp, {
      label: unref(e).t("locale"),
      variant: "text",
      color: "neutral",
      icon: "far globe",
      labelless: ""
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(i), (a) => (openBlock(), createBlock(me, {
          key: a,
          class: "mn-app-locale",
          label: unref(e).t(a),
          variant: "text",
          color: a === unref(n) ? "accent" : "neutral",
          role: "menuitemradio",
          "aria-checked": a === unref(n),
          onClick: (l) => s(a)
        }, null, 8, ["label", "color", "aria-checked", "onClick"]))), 128))
      ]),
      _: 1
    }, 8, ["label"]));
  }
});
var jZ = Object.assign({ name: "mn-app-theme" }, {
  __name: "app-theme",
  setup(t10) {
    const e = inject("minuit");
    function n() {
      e.value.theme = e.value.theme === "light" ? "dark" : "light", e.value.theme === "dark" ? document.documentElement.classList.add("dark") : document.documentElement.classList.remove("dark");
    }
    return (i, s) => (openBlock(), createBlock(unref(me), {
      variant: "text",
      color: "neutral",
      label: unref(e).theme === "light" ? unref(e).t("toggleDark") : unref(e).t("toggleLight"),
      icon: unref(e).theme === "light" ? "far sun-bright" : "moon",
      labelless: "",
      onClick: n
    }, null, 8, ["label", "icon"]));
  }
});
var kQ = Object.assign({ name: "mn-banner" }, {
  __name: "banner",
  props: {
    color: {
      type: String,
      validator: (t10) => [
        "red",
        "orange",
        "amber",
        "yellow",
        "lime",
        "green",
        "emerald",
        "teal",
        "cyan",
        "sky",
        "blue",
        "indigo",
        "violet",
        "purple",
        "fuchsia",
        "pink",
        "rose"
      ].includes(String(t10))
    },
    closable: Boolean
  },
  setup(t10) {
    useCssVars((o) => ({
      "6f7f8496": s.value.light.background,
      68064218: s.value.light.text,
      d261b7d2: s.value.dark.background,
      "606e9254": s.value.dark.text
    }));
    const e = inject("minuit"), n = t10, i = ref(null), s = computed(() => ({
      light: {
        background: n.color ? `var(--${n.color}-200)` : "var(--bg-neutral-muted)",
        text: n.color ? "var(--text-neutral)" : "var(--text-neutral-muted)"
      },
      dark: {
        background: n.color ? `var(--${n.color}-800)` : "var(--bg-neutral-muted)",
        text: n.color ? "var(--text-neutral" : "var(--text-neutral-muted)"
      }
    }));
    function r() {
      i.value.remove();
    }
    return (o, a) => (openBlock(), createElementBlock("div", {
      ref_key: "bannerRef",
      ref: i,
      class: "mn-banner"
    }, [
      renderSlot(o.$slots, "default", {}, void 0, true),
      t10.closable ? (openBlock(), createBlock(me, {
        key: 0,
        class: "mn-banner-close-btn",
        label: unref(e).t("close"),
        variant: "text",
        color: "neutral",
        icon: "xmark",
        labelless: "",
        onClick: r
      }, null, 8, ["label"])) : createCommentVNode("", true)
    ], 512));
  }
});
var HZ = Me(kQ, [["__scopeId", "data-v-8925cb6a"]]);
var SQ = ["aria-labelledby"];
var wQ = ["id"];
var CQ = {
  key: 0,
  class: "mn-sidebar-header"
};
var OQ = { class: "mn-sidebar-header-links" };
var EQ = ["src", "alt"];
var MQ = {
  key: 2,
  class: "mn-sidebar-tooltip",
  "aria-hidden": "true"
};
var TQ = {
  key: 0,
  class: "mn-sidebar-tooltip",
  "aria-hidden": "true"
};
var AQ = { class: "mn-sidebar-content" };
var _Q = ["aria-labelledby"];
var NQ = ["id"];
var LQ = ["open", "onToggle"];
var IQ = { class: "mn-sidebar-summary" };
var PQ = {
  key: 0,
  class: "mn-sidebar-link-badge"
};
var DQ = {
  key: 0,
  class: "mn-sidebar-link-badge"
};
var $Q = {
  key: 1,
  class: "mn-sidebar-tooltip",
  "aria-hidden": "true"
};
var RQ = {
  key: 1,
  class: "mn-sidebar-footer"
};
var FQ = {
  key: 0,
  class: "mn-sidebar-footer-links"
};
var VQ = {
  key: 0,
  class: "mn-sidebar-tooltip",
  "aria-hidden": "true"
};
var BQ = {
  key: 0,
  class: "mn-sidebar-tooltip",
  "aria-hidden": "true"
};
var zQ = Object.assign({ name: "mn-sidebar" }, {
  __name: "sidebar",
  props: {
    label: {
      type: String,
      required: true
    },
    variant: {
      type: String,
      default: "full",
      validator: (t10) => ["full", "compact"].includes(String(t10))
    },
    home: Object,
    nav: Object,
    user: Object
  },
  emits: ["signout"],
  setup(t10, { emit: e }) {
    const n = inject("minuit"), i = useSlots(), s = e, r = t10, o = useId(), a = ref(null), l = ref(!!i.header || !!r.home || r.variant === "compact"), c = ref(!!i.footer || !!r.user), u = ref(false), d = computed(() => {
      var m;
      return !!((m = a.value) != null && m.closest(".mn-layout-sidebar-start"));
    });
    function f() {
      u.value = !u.value, localStorage.setItem(`${r.label}-collapsed`, u.value);
    }
    function h10(m, b) {
      m.target.open ? localStorage.removeItem(`mn-sidebar-${b.label}`) : localStorage.setItem(`mn-sidebar-${b.label}`, "closed");
    }
    function p(m) {
      return localStorage.getItem(`mn-sidebar-${m.label}`) !== "closed";
    }
    function g(m) {
      if (u.value) {
        const b = m.target.querySelector(".mn-sidebar-tooltip"), x = m.target.getBoundingClientRect();
        b.style.insetBlockStart = `${x.top}px`, b.closest(".mn-layout-sidebar-end") ? b.style.insetInlineEnd = "var(--size-14)" : b.style.insetInlineStart = "var(--size-14)";
      }
    }
    return onMounted(() => {
      r.variant === "compact" && (u.value = localStorage.getItem(`${r.label}-collapsed`) === "true");
    }), (m, b) => {
      var x;
      return openBlock(), createElementBlock("aside", {
        ref_key: "sidebarRef",
        ref: a,
        class: normalizeClass(["mn-sidebar", [{ "-collapsed": u.value }]]),
        "aria-labelledby": `${unref(o)}`
      }, [
        createBaseVNode("span", {
          id: `${unref(o)}`,
          hidden: ""
        }, toDisplayString(t10.label), 9, wQ),
        l.value ? (openBlock(), createElementBlock("header", CQ, [
          createBaseVNode("div", OQ, [
            createBaseVNode("div", {
              class: "mn-sidebar-tooltip-parent",
              onMouseenter: g
            }, [
              t10.home && t10.home.logo ? (openBlock(), createBlock(ds, {
                key: 0,
                class: "mn-sidebar-home",
                label: t10.home.label,
                path: t10.home.path
              }, {
                default: withCtx(() => [
                  t10.home.logo ? (openBlock(), createElementBlock("img", {
                    key: 0,
                    src: typeof t10.home.logo == "string" ? t10.home.logo : t10.home.logo[unref(n).theme],
                    alt: t10.home.label
                  }, null, 8, EQ)) : createCommentVNode("", true)
                ]),
                _: 1
              }, 8, ["label", "path"])) : t10.home ? (openBlock(), createBlock(ds, {
                key: 1,
                class: "mn-sidebar-home",
                color: "neutral",
                variant: "text",
                label: t10.home.label,
                path: t10.home.path,
                icon: u.value ? "home" : null,
                labelless: u.value
              }, null, 8, ["label", "path", "icon", "labelless"])) : createCommentVNode("", true),
              u.value ? (openBlock(), createElementBlock("span", MQ, toDisplayString(unref(Ie)((x = t10.home) == null ? void 0 : x.label)), 1)) : createCommentVNode("", true)
            ], 32),
            t10.variant === "compact" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "mn-sidebar-tooltip-parent",
              onMouseenter: g
            }, [
              createVNode(me, {
                class: "mn-sidebar-toggle",
                color: "neutral",
                variant: "text",
                label: u.value ? unref(n).t("expandSidebar") : unref(n).t("collapseSidebar"),
                icon: d.value ? "far sidebar" : "far sidebar-flip",
                labelless: "",
                mirror: "",
                onClick: f
              }, null, 8, ["label", "icon"]),
              u.value ? (openBlock(), createElementBlock("span", TQ, toDisplayString(unref(Ie)(u.value ? unref(n).t("expandSidebar") : unref(n).t("collapseSidebar"))), 1)) : createCommentVNode("", true)
            ], 32)) : createCommentVNode("", true)
          ]),
          renderSlot(m.$slots, "header", {}, void 0, true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", AQ, [
          t10.nav ? (openBlock(), createElementBlock("nav", {
            key: 0,
            class: "mn-sidebar-nav",
            "aria-labelledby": `${unref(o)}-nav`
          }, [
            createBaseVNode("span", {
              id: `${unref(o)}-nav`,
              hidden: ""
            }, toDisplayString(t10.nav.label), 9, NQ),
            createBaseVNode("ul", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(t10.nav.links, (k) => (openBlock(), createElementBlock("li", {
                key: `${unref(o)}-${JSON.stringify(k)}`,
                class: "mn-sidebar-group"
              }, [
                !u.value && k.collapsible ? (openBlock(), createElementBlock("details", {
                  key: 0,
                  class: "mn-sidebar-details",
                  open: p(k),
                  onToggle: (v) => h10(v, k)
                }, [
                  createBaseVNode("summary", IQ, [
                    createBaseVNode("span", null, toDisplayString(unref(Ie)(k.label)), 1),
                    createVNode(ft, {
                      icon: "angle-down",
                      color: "neutral"
                    })
                  ]),
                  createBaseVNode("ul", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(k.items, (v) => (openBlock(), createElementBlock("li", {
                      key: `${unref(o)}-${v.path}`
                    }, [
                      createVNode(ds, {
                        class: "mn-sidebar-link",
                        variant: "text",
                        color: "neutral",
                        label: v.label,
                        icon: v.icon,
                        labelless: u.value,
                        mirror: v.mirror || null,
                        path: v.path,
                        wide: !u.value
                      }, null, 8, ["label", "icon", "labelless", "mirror", "path", "wide"]),
                      !u.value && v.badge ? (openBlock(), createElementBlock("span", PQ, toDisplayString(v.badge), 1)) : createCommentVNode("", true)
                    ]))), 128))
                  ])
                ], 40, LQ)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  k.label ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(["mn-sidebar-group-label", { invisible: u.value }])
                  }, toDisplayString(unref(Ie)(k.label)), 3)) : createCommentVNode("", true),
                  createBaseVNode("ul", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(k.items, (v) => (openBlock(), createElementBlock("li", {
                      class: "mn-sidebar-tooltip-parent",
                      key: `${unref(o)}-${v.path}`,
                      onMouseenter: g
                    }, [
                      createVNode(ds, {
                        class: "mn-sidebar-link",
                        variant: "text",
                        color: "neutral",
                        label: v.label,
                        icon: v.icon,
                        labelless: u.value,
                        mirror: v.mirror || null,
                        path: v.path,
                        wide: !u.value
                      }, null, 8, ["label", "icon", "labelless", "mirror", "path", "wide"]),
                      !u.value && v.badge ? (openBlock(), createElementBlock("span", DQ, toDisplayString(v.badge), 1)) : createCommentVNode("", true),
                      u.value ? (openBlock(), createElementBlock("span", $Q, toDisplayString(unref(Ie)(v.label)) + toDisplayString(v.badge ? ` (${v.badge})` : null), 1)) : createCommentVNode("", true)
                    ], 32))), 128))
                  ])
                ], 64))
              ]))), 128))
            ])
          ], 8, _Q)) : createCommentVNode("", true),
          renderSlot(m.$slots, "content", {}, void 0, true)
        ]),
        c.value || t10.user ? (openBlock(), createElementBlock("footer", RQ, [
          renderSlot(m.$slots, "footer", {}, void 0, true),
          t10.user ? (openBlock(), createElementBlock("div", FQ, [
            createBaseVNode("div", {
              class: "mn-sidebar-tooltip-parent",
              onMouseenter: g
            }, [
              createVNode(ds, {
                class: "mn-sidebar-user",
                variant: "text",
                color: "neutral",
                label: t10.user.username || t10.user.name || t10.user.firstName || t10.user.email,
                path: t10.user.path || "/profile",
                labelless: u.value
              }, {
                start: withCtx(() => [
                  createVNode(KI, {
                    label: t10.user.username || t10.user.name || t10.user.firstName || t10.user.email,
                    src: t10.user.image || t10.user.avatar,
                    size: "small",
                    circle: ""
                  }, null, 8, ["label", "src"])
                ]),
                _: 1
              }, 8, ["label", "path", "labelless"]),
              u.value ? (openBlock(), createElementBlock("span", VQ, toDisplayString(t10.user.username || t10.user.name || t10.user.firstName || t10.user.email), 1)) : createCommentVNode("", true)
            ], 32),
            createBaseVNode("div", {
              class: "mn-sidebar-tooltip-parent",
              onMouseenter: g
            }, [
              createVNode(me, {
                variant: "text",
                color: "neutral",
                label: unref(n).t("signOut"),
                icon: "power-off",
                labelless: "",
                onClick: b[0] || (b[0] = (k) => s("signout"))
              }, null, 8, ["label"]),
              u.value ? (openBlock(), createElementBlock("span", BQ, toDisplayString(unref(Ie)(unref(n).t("signOut"))), 1)) : createCommentVNode("", true)
            ], 32)
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 10, SQ);
    };
  }
});
var WZ = Me(zQ, [["__scopeId", "data-v-c70909c3"]]);
var jQ = ["aria-label"];
var HQ = ["data-placement"];
var WQ = Object.assign({ name: "mn-toaster" }, {
  __name: "toaster",
  props: {
    placement: {
      type: String,
      default: "start-end",
      validator: (t10) => ["start-start", "start-center", "start-end", "end-start", "end-center", "end-end"].includes(String(t10))
    },
    shown: {
      type: Number,
      default: 5
    },
    duration: {
      type: Number,
      default: 5e3
    }
  },
  setup(t10) {
    const e = inject("minuit"), n = t10, i = ref(null), s = ref([]), r = ref([]), o = ref(false), a = ref(false), l = ref(false), c = ref(null), u = computed(() => {
      const g = s.value.filter((m) => m.placement).map((m) => m.placement);
      return g.length > 0 ? Array.from(new Set([n.placement].concat(g))) : [n.placement];
    });
    function d(g) {
      s.value = s.value.filter(({ id: m }) => m !== g.id);
    }
    function f(g) {
      g.target instanceof HTMLElement && g.target.dataset.dismissible === "false" || l.value || (l.value = true, c.value = g.relatedTarget);
    }
    function h10(g) {
      var m, b;
      l.value && !((b = (m = g.currentTarget) == null ? void 0 : m.contains) != null && b.call(m, g.relatedTarget)) && (l.value = false, c.value && (c.value.focus({ preventScroll: true }), c.value = null));
    }
    function p(g) {
      g.target && g.target instanceof HTMLElement && g.target.dataset.dismissible === "false" || (a.value = false);
    }
    return watch(
      () => i.value,
      () => {
        if (i.value)
          return () => {
            c.value && (c.value.focus({ preventScroll: true }), c.value = null, l.value = false);
          };
      }
    ), watchEffect(() => s.value.length <= 1 && (o.value = false)), watchEffect((g) => {
      const m = Ns.subscribe((b) => {
        if (b.dismiss) {
          s.value = s.value.map((x) => x.id === b.id ? { ...x, delete: true } : x);
          return;
        }
        nextTick(() => {
          const x = s.value.findIndex((k) => k.id === b.id);
          x !== -1 ? s.value.splice(x, 1, b) : s.value = [b, ...s.value];
        });
      });
      g(() => m());
    }), watchEffect((g) => {
      function m(b) {
        const x = ["altKey", "KeyN"].every((S) => b[S] || b.code === S), k = Array.isArray(i.value) ? i.value[0] : i.value;
        x && (o.value = true, k == null || k.focus());
        const v = document.activeElement === i.value || (k == null ? void 0 : k.contains(document.activeElement));
        b.code === "Escape" && v && (o.value = false);
      }
      document.addEventListener("keydown", m), g(() => document.removeEventListener("keydown", m));
    }), (g, m) => (openBlock(), createElementBlock("section", {
      class: "mn-toaster",
      "aria-label": unref(e).t("notifications"),
      tabIndex: "-1"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(u.value, (b, x) => (openBlock(), createElementBlock("ol", {
        key: b,
        ref_for: true,
        ref_key: "toasterRef",
        ref: i,
        class: "mn-toaster-list",
        tabIndex: "-1",
        "data-placement": b,
        onFocus: f,
        onBlur: h10,
        onMouseenter: m[1] || (m[1] = (k) => o.value = true),
        onMousemove: m[2] || (m[2] = (k) => o.value = true),
        onMouseleave: m[3] || (m[3] = (k) => !a.value && (o.value = false)),
        onPointerdown: p,
        onPointerup: m[4] || (m[4] = (k) => a.value = false)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(s.value.filter((k) => !k.placement && x === 0 || k.placement === b), (k, v) => (openBlock(), createBlock(HW, {
          key: k.id,
          modelValue: r.value,
          "onUpdate:modelValue": m[0] || (m[0] = (S) => r.value = S),
          index: v,
          notification: k,
          depth: s.value.length - v,
          visible: v + 1 <= t10.shown,
          placement: b,
          duration: (k == null ? void 0 : k.duration) || t10.duration,
          expanded: o.value,
          interacting: a.value,
          onRemoveNotification: d
        }, null, 8, ["modelValue", "index", "notification", "depth", "visible", "placement", "duration", "expanded", "interacting"]))), 128))
      ], 40, HQ))), 128))
    ], 8, jQ));
  }
});
var UQ = Me(WQ, [["__scopeId", "data-v-bd3bcd77"]]);
var qQ = ["aria-labelledby"];
var KQ = ["id"];
var YQ = {
  key: 0,
  class: "mn-layout-sidebar-start mn-layout-sidebar-desktop"
};
var GQ = ["aria-labelledby"];
var JQ = ["id"];
var XQ = { class: "mn-layout-page" };
var QQ = {
  key: 0,
  class: "mn-layout-header"
};
var ZQ = { class: "mn-layout-header-content-start" };
var eZ = { class: "mn-layout-header-content-center" };
var tZ = { class: "mn-layour-header-content-end" };
var nZ = {
  key: 1,
  class: "mn-layout-footer"
};
var iZ = {
  key: 1,
  class: "mn-layout-sidebar-end mn-layout-sidebar-desktop"
};
var sZ = ["aria-labelledby"];
var rZ = ["id"];
var oZ = Object.assign({ name: "mn-layout" }, {
  __name: "layout",
  props: {
    background: {
      type: [String, Object]
    },
    size: {
      type: String,
      validator: (t10) => ["small", "medium", "large"].includes(String(t10))
    },
    align: {
      type: String,
      default: "center",
      validator: (t10) => ["start", "center", "end"].includes(String(t10))
    },
    floating: Boolean,
    highlight: Boolean
  },
  setup(t10) {
    const e = inject("minuit"), n = useSlots(), i = t10, s = useId(), r = ip("(min-width: 1024px)"), o = ip("(min-width: 1280px)"), a = ref(!!n["sidebar-start"]), l = ref(!!n["sidebar-end"]), c = ref(!!n.header), u = ref(!!n.footer), d = ref(a.value || l.value), f = ref(null), h10 = ref(null), p = computed(() => typeof i.background == "string" ? `--url: url(${i.background})` : typeof i.background == "object" ? `--url: url(${i.background[e.value.theme]})` : null);
    function g(m) {
      var b, x, k, v;
      m.target === f.value ? (b = f.value) == null || b.close() : m.target === h10.value ? (x = h10.value) == null || x.close() : m.target.closest("a") && (m.target.closest(".mn-layout-sidebar-start") ? (k = f.value) == null || k.close() : m.target.closest(".mn-layout-sidebar-end") && ((v = h10.value) == null || v.close()));
    }
    return (m, b) => (openBlock(), createElementBlock("div", {
      class: "mn-layout",
      style: normalizeStyle(p.value)
    }, [
      createBaseVNode("section", {
        class: "mn-layout-shortcuts",
        "aria-labelledby": `${unref(s)}`
      }, [
        createBaseVNode("span", {
          id: `${unref(s)}`,
          hidden: ""
        }, toDisplayString(unref(e).t("shortcuts")), 9, KQ),
        createVNode(ds, {
          class: "mn-layout-shortcut",
          label: unref(e).t("mainContent"),
          path: "#main-content",
          variant: "text"
        }, null, 8, ["label"])
      ], 8, qQ),
      unref(r) && a.value ? (openBlock(), createElementBlock("div", YQ, [
        renderSlot(m.$slots, "sidebar-start")
      ])) : createCommentVNode("", true),
      createBaseVNode("dialog", {
        ref_key: "sidebarStartMobileRef",
        ref: f,
        class: "mn-layout-sidebar-start mn-layout-sidebar-mobile",
        "aria-labelledby": `${unref(s)}-sidebar-start`,
        onClick: g
      }, [
        createBaseVNode("span", {
          id: `${unref(s)}-sidebar-start`,
          class: "invisible"
        }, toDisplayString(unref(e).t("mainSidebar")), 9, JQ),
        createVNode(me, {
          class: "mn-layout-sidebar-close-btn",
          color: "neutral",
          label: unref(e).t("closeMainSidebar"),
          icon: "xmark",
          labelless: "",
          variant: "text",
          onClick: b[0] || (b[0] = (x) => {
            var k;
            return (k = f.value) == null ? void 0 : k.close();
          })
        }, null, 8, ["label"]),
        renderSlot(m.$slots, "sidebar-start")
      ], 8, GQ),
      createBaseVNode("div", XQ, [
        c.value || d.value ? (openBlock(), createElementBlock("header", QQ, [
          renderSlot(m.$slots, "banner"),
          createBaseVNode("div", {
            class: normalizeClass(["mn-layout-header-content", { "-sidebar": d.value }])
          }, [
            createBaseVNode("div", ZQ, [
              a.value && !unref(r) ? (openBlock(), createBlock(me, {
                key: 0,
                class: "mn-layout-sidebar-start-btn",
                label: unref(e).t("openMainSidebar"),
                icon: "bars",
                labelless: "",
                variant: "text",
                color: "neutral",
                onClick: b[1] || (b[1] = (x) => {
                  var k;
                  return (k = f.value) == null ? void 0 : k.showModal();
                })
              }, null, 8, ["label"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", eZ, [
              renderSlot(m.$slots, "header")
            ]),
            createBaseVNode("div", tZ, [
              l.value && !unref(o) ? (openBlock(), createBlock(me, {
                key: 0,
                class: "mn-layout-sidebar-end-btn",
                label: unref(e).t("openSecondarySidebar"),
                icon: "bars",
                labelless: "",
                variant: "text",
                color: "neutral",
                onClick: b[2] || (b[2] = (x) => {
                  var k;
                  return (k = h10.value) == null ? void 0 : k.showModal();
                })
              }, null, 8, ["label"])) : createCommentVNode("", true)
            ])
          ], 2)
        ])) : createCommentVNode("", true),
        createBaseVNode("main", {
          id: "main-content",
          class: normalizeClass(["mn-layout-content", [t10.size, t10.align, { "-floating": t10.floating, "-highlight": t10.highlight }]])
        }, [
          renderSlot(m.$slots, "default")
        ], 2),
        u.value ? (openBlock(), createElementBlock("footer", nZ, [
          renderSlot(m.$slots, "footer")
        ])) : createCommentVNode("", true)
      ]),
      unref(o) && l.value ? (openBlock(), createElementBlock("div", iZ, [
        renderSlot(m.$slots, "sidebar-end")
      ])) : createCommentVNode("", true),
      createBaseVNode("dialog", {
        ref_key: "sidebarEndMobileRef",
        ref: h10,
        class: "mn-layout-sidebar-end mn-layout-sidebar-mobile",
        "aria-labelledby": `${unref(s)}-sidebar-end`,
        onClick: g
      }, [
        createBaseVNode("span", {
          id: `${unref(s)}-sidebar-end`,
          class: "invisible"
        }, toDisplayString(unref(e).t("secondarySidebar")), 9, rZ),
        createVNode(me, {
          class: "mn-layout-sidebar-close-btn",
          color: "neutral",
          label: unref(e).t("closeSecondarySidebar"),
          icon: "xmark",
          labelless: "",
          variant: "text",
          onClick: b[3] || (b[3] = (x) => {
            var k;
            return (k = h10.value) == null ? void 0 : k.close();
          })
        }, null, 8, ["label"]),
        renderSlot(m.$slots, "sidebar-end")
      ], 8, sZ),
      createVNode(UQ)
    ], 4));
  }
});
var UZ = Me(oZ, [["__scopeId", "data-v-21a1a71e"]]);
var As = {
  neutral: "gray",
  accent: "indigo",
  font: "Inter",
  locale: "en",
  radius: "soft",
  theme: "light"
};
function K1(t10) {
  document.documentElement.style.setProperty("--app-neutral-50", `var(--${t10}-50)`), document.documentElement.style.setProperty("--app-neutral-100", `var(--${t10}-100)`), document.documentElement.style.setProperty("--app-neutral-200", `var(--${t10}-200)`), document.documentElement.style.setProperty("--app-neutral-300", `var(--${t10}-300)`), document.documentElement.style.setProperty("--app-neutral-400", `var(--${t10}-400)`), document.documentElement.style.setProperty("--app-neutral-500", `var(--${t10}-500)`), document.documentElement.style.setProperty("--app-neutral-600", `var(--${t10}-600)`), document.documentElement.style.setProperty("--app-neutral-700", `var(--${t10}-700)`), document.documentElement.style.setProperty("--app-neutral-800", `var(--${t10}-800)`), document.documentElement.style.setProperty("--app-neutral-900", `var(--${t10}-900)`), document.documentElement.style.setProperty("--app-neutral-950", `var(--${t10}-950)`), localStorage.setItem("minuit", JSON.stringify({ ...JSON.parse(localStorage.getItem("minuit")), neutral: t10 }));
}
function Y1(t10) {
  t10 === "neutral" ? (document.documentElement.style.setProperty("--app-accent-50", "var(--app-neutral-50)"), document.documentElement.style.setProperty("--app-accent-100", "var(--app-neutral-100)"), document.documentElement.style.setProperty("--app-accent-200", "var(--app-neutral-200)"), document.documentElement.style.setProperty("--app-accent-300", "var(--app-neutral-300)"), document.documentElement.style.setProperty("--app-accent-400", "var(--app-neutral-400)"), document.documentElement.style.setProperty("--app-accent-500", "var(--app-neutral-500)"), document.documentElement.style.setProperty("--app-accent-600", "var(--app-neutral-600)"), document.documentElement.style.setProperty("--app-accent-700", "var(--app-neutral-700)"), document.documentElement.style.setProperty("--app-accent-800", "var(--app-neutral-800)"), document.documentElement.style.setProperty("--app-accent-900", "var(--app-neutral-900)"), document.documentElement.style.setProperty("--app-accent-950", "var(--app-neutral-950)")) : (document.documentElement.style.setProperty("--app-accent-50", `var(--${t10}-50)`), document.documentElement.style.setProperty("--app-accent-100", `var(--${t10}-100)`), document.documentElement.style.setProperty("--app-accent-200", `var(--${t10}-200)`), document.documentElement.style.setProperty("--app-accent-300", `var(--${t10}-300)`), document.documentElement.style.setProperty("--app-accent-400", `var(--${t10}-400)`), document.documentElement.style.setProperty("--app-accent-500", `var(--${t10}-500)`), document.documentElement.style.setProperty("--app-accent-600", `var(--${t10}-600)`), document.documentElement.style.setProperty("--app-accent-700", `var(--${t10}-700)`), document.documentElement.style.setProperty("--app-accent-800", `var(--${t10}-800)`), document.documentElement.style.setProperty("--app-accent-900", `var(--${t10}-900)`), document.documentElement.style.setProperty("--app-accent-950", `var(--${t10}-950)`)), localStorage.setItem("minuit", JSON.stringify({ ...JSON.parse(localStorage.getItem("minuit")), accent: t10 }));
}
function G1(t10) {
  document.documentElement.style.setProperty("--app-font", t10), localStorage.setItem("minuit", JSON.stringify({ ...JSON.parse(localStorage.getItem("minuit")), font: t10 }));
}
function J1(t10) {
  document.documentElement.setAttribute("lang", t10), t10 === "ar" ? document.documentElement.setAttribute("dir", "rtl") : document.documentElement.setAttribute("dir", "ltr"), localStorage.setItem("minuit", JSON.stringify({ ...JSON.parse(localStorage.getItem("minuit")), locale: t10 }));
}
function X1(t10) {
  document.documentElement.style.setProperty("--app-radius", `var(--radius-${t10})`), localStorage.setItem("minuit", JSON.stringify({ ...JSON.parse(localStorage.getItem("minuit")), radius: t10 }));
}
function Q1(t10) {
  document.documentElement.setAttribute("data-theme", t10), localStorage.setItem("minuit", JSON.stringify({ ...JSON.parse(localStorage.getItem("minuit")), theme: t10 }));
}
var qZ = {
  install: (t10, e) => {
    var i, s, r, o, a, l, c, u, d;
    for (let f in (r = (s = (i = e == null ? void 0 : e.locale) == null ? void 0 : i.global) == null ? void 0 : s.messages) == null ? void 0 : r.value)
      e.locale.global.messages.value[f] = {
        ...at[f],
        ...e.locale.global.messages.value[f]
      };
    const n = JSON.parse(localStorage.getItem("minuit"));
    t10.config.globalProperties.$minuit = ref({
      neutral: (n == null ? void 0 : n.neutral) || (e == null ? void 0 : e.neutral) || As.neutral,
      accent: (n == null ? void 0 : n.accent) || (e == null ? void 0 : e.accent) || As.accent,
      font: (n == null ? void 0 : n.font) || (e == null ? void 0 : e.font) || As.font,
      locale: (n == null ? void 0 : n.locale) || ((l = (a = (o = e == null ? void 0 : e.locale) == null ? void 0 : o.global) == null ? void 0 : a.locale) == null ? void 0 : l.value) || (e == null ? void 0 : e.locale) || As.locale,
      radius: (n == null ? void 0 : n.radius) || (e == null ? void 0 : e.radius) || As.radius,
      theme: (n == null ? void 0 : n.theme) || (e == null ? void 0 : e.theme) || As.theme,
      t: (f) => {
        var h10, p;
        return (h10 = e == null ? void 0 : e.locale) != null && h10.global ? e.locale.global.t(f) : ((p = at[e == null ? void 0 : e.locale]) == null ? void 0 : p[f]) || at[As.locale][f];
      }
    }), K1(t10.config.globalProperties.$minuit.value.neutral), Y1(t10.config.globalProperties.$minuit.value.accent), G1(t10.config.globalProperties.$minuit.value.font), J1(((d = (u = (c = e == null ? void 0 : e.locale) == null ? void 0 : c.global) == null ? void 0 : u.locale) == null ? void 0 : d.value) || (e == null ? void 0 : e.locale) || As.locale), X1(t10.config.globalProperties.$minuit.value.radius), Q1(t10.config.globalProperties.$minuit.value.theme), watch(
      () => t10.config.globalProperties.$minuit.value.neutral,
      (f) => K1(f)
    ), watch(
      () => t10.config.globalProperties.$minuit.value.accent,
      (f) => Y1(f)
    ), watch(
      () => t10.config.globalProperties.$minuit.value.font,
      (f) => G1(f)
    ), watch(
      () => t10.config.globalProperties.$minuit.value.radius,
      (f) => X1(f)
    ), watch(
      () => t10.config.globalProperties.$minuit.value.theme,
      (f) => Q1(f)
    ), watch(
      () => {
        var f, h10, p;
        return (p = (h10 = (f = e == null ? void 0 : e.locale) == null ? void 0 : f.global) == null ? void 0 : h10.locale) == null ? void 0 : p.value;
      },
      (f) => J1(f)
    ), t10.provide("minuit", t10.config.globalProperties.$minuit);
  }
};
_w.add(nO);
export {
  zZ as AppLocale,
  BZ as AppStyle,
  jZ as AppTheme,
  dZ as Audio,
  KI as Avatar,
  HZ as Banner,
  $Z as Bar,
  fZ as Breadcrumbs,
  me as Button,
  _Z as Carousel,
  Jc as Checkbox,
  xZ as CheckboxGroup,
  hZ as Code,
  kZ as Color,
  nj as Container,
  $H as ContextMenu,
  NZ as Details,
  nc as Dialog,
  pZ as Divider,
  RZ as Doughnut,
  wZ as Editor,
  mZ as Empty,
  $n as Error,
  gZ as Feedback,
  CZ as File,
  _r as Form,
  LZ as Gallery,
  ln as Hint,
  ft as Icon,
  r0 as Image,
  Nr as Input,
  Ft as Label,
  UZ as Layout,
  qH as Lightbox,
  FZ as Line,
  ds as Link,
  Gk as List,
  bZ as Loader,
  Yp as Menu,
  HW as Notification,
  $P as Pagination,
  OZ as Phone,
  EZ as Picker,
  yZ as Progress,
  Xj as Quantity,
  VZ as Radar,
  MZ as RadioGroup,
  p2 as Range,
  TZ as Rating,
  Yb as Select,
  WZ as Sidebar,
  AZ as Sorter,
  IZ as Table,
  PZ as Tabs,
  HP as Tag,
  ui as Text,
  yj as Textarea,
  nD as Thumbnail,
  o0 as Title,
  UQ as Toaster,
  TI as Tooltip,
  vZ as Video,
  qZ as minuit,
  uZ as toast
};
/*! Bundled license information:

vue-router/dist/vue-router.mjs:
  (*!
    * vue-router v4.5.1
    * (c) 2025 Eduardo San Martin Morote
    * @license MIT
    *)

@owlabio/minuit/dist/minuit.js:
  (*!
   * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2024 Fonticons, Inc.
   *)
  (*!
   * Font Awesome Pro 6.7.2 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license (Commercial License)
   * Copyright 2024 Fonticons, Inc.
   *)
  (**
    * vee-validate v4.15.0
    * (c) 2024 Abdelrahman Awad
    * @license MIT
    *)
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)
  (*!
   * Chart.js v4.4.8
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)
  (*!
    * shared v9.14.3
    * (c) 2025 kazuya kawaguchi
    * Released under the MIT License.
    *)
  (*!
    * message-compiler v9.14.3
    * (c) 2025 kazuya kawaguchi
    * Released under the MIT License.
    *)

@owlabio/minuit/dist/minuit.js:
  (*!
    * core-base v9.14.3
    * (c) 2025 kazuya kawaguchi
    * Released under the MIT License.
    *)

@owlabio/minuit/dist/minuit.js:
  (*!
    * vue-i18n v9.14.3
    * (c) 2025 kazuya kawaguchi
    * Released under the MIT License.
    *)
*/
//# sourceMappingURL=@owlabio_minuit.js.map
